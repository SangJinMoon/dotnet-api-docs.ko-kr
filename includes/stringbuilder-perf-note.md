<span data-ttu-id="9e2a8-101">문자 기반 사용 하는 인덱싱을 사용 하는 <xref:System.Text.StringBuilder.Chars%2A> 속성은 다음과 같은 매우 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-101">Using character-based indexing with the <xref:System.Text.StringBuilder.Chars%2A> property can be extremely slow under the following conditions:</span></span>

- <span data-ttu-id="9e2a8-102"><xref:System.Text.StringBuilder> 인스턴스 큽니다 (예를 들어 이루어져 여러 수만 개의 문자)입니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-102">The <xref:System.Text.StringBuilder> instance is large (for example, it consists of several tens of thousands of characters).</span></span>
- <span data-ttu-id="9e2a8-103"><xref:System.Text.StringBuilder> 은 "규모가 큰"입니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-103">The <xref:System.Text.StringBuilder> is "chunky."</span></span> <span data-ttu-id="9e2a8-104">즉, 메서드 호출을와 같은 반복 <xref:System.Text.StringBuilder.Append%2A?displayProperty=nameWithType> 자동으로 개체의 확장 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> 속성 및 해당 메모리의 할당 된 새 청크 합니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-104">That is, repeated calls to methods such as <xref:System.Text.StringBuilder.Append%2A?displayProperty=nameWithType> have automatically expanded the object's <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> property and allocated new chunks of memory to it.</span></span>

<span data-ttu-id="9e2a8-105">각 문자 액세스에서는 연결 된 전체 목록은 청크 인덱싱할 올바른 버퍼를 찾을 수 때문에 성능이 저하 심각 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-105">Performance is severely impacted because each character access walks the entire linked list of chunks to find the correct buffer to index into.</span></span>

> [!NOTE]
>  <span data-ttu-id="9e2a8-106">큰 경우에 "규모가 큰" <xref:System.Text.StringBuilder> 개체를 사용 하는 <xref:System.Text.StringBuilder.Chars%2A> 속성 하나 또는 적은 수의 문자에 대 한 인덱스 기반 액세스에 대 한 영향은 미미 성능에 미치는 영향이; 일반적으로 **0(n)** 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-106">Even for a large "chunky" <xref:System.Text.StringBuilder> object, using the <xref:System.Text.StringBuilder.Chars%2A> property for index-based access to one or a small number of characters has a negligible performance impact; typically, it is an **0(n)** operation.</span></span> <span data-ttu-id="9e2a8-107">상당한 성능 저하의 문자를 반복할 때 발생는 <xref:System.Text.StringBuilder> 인 개체는 **O(n^2)** 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-107">The significant performance impact occurs when iterating the characters in the <xref:System.Text.StringBuilder> object, which is an **O(n^2)** operation.</span></span> 

<span data-ttu-id="9e2a8-108">문자 기반 사용 하는 인덱싱을 사용 하는 경우 성능 문제가 발생 한 경우 <xref:System.Text.StringBuilder> 개체의 경우 다음 방법 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-108">If you encounter performance issues when using character-based indexing with <xref:System.Text.StringBuilder> objects, you can use any of the following workarounds:</span></span>

- <span data-ttu-id="9e2a8-109">변환의 <xref:System.Text.StringBuilder> 인스턴스는 <xref:System.String> 호출 하 여는 <xref:System.Text.StringBuilder.ToString%2A> 메서드를 다음 문자열의 문자에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-109">Convert the <xref:System.Text.StringBuilder> instance to a <xref:System.String> by calling the <xref:System.Text.StringBuilder.ToString%2A> method, then access the characters in the string.</span></span>

- <span data-ttu-id="9e2a8-110">기존 내용을 복사 <xref:System.Text.StringBuilder> 새 개체 크기가 미리 지정 <xref:System.Text.StringBuilder> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-110">Copy the contents of the existing <xref:System.Text.StringBuilder> object to a new pre-sized <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="9e2a8-111">때문에 성능이 향상 됩니다 새 <xref:System.Text.StringBuilder> 대규모 개체가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-111">Performance improves because the new <xref:System.Text.StringBuilder> object is not chunky.</span></span> <span data-ttu-id="9e2a8-112">예:</span><span class="sxs-lookup"><span data-stu-id="9e2a8-112">For example:</span></span>

   ```csharp
   // sbOriginal is the existing StringBuilder object
   var sbNew = new StringBuilder(sbOriginal.ToString(), sbOriginal.Length);
   ```
   ```vb
   ' sbOriginal is the existing StringBuilder object
   Dim sbNew = New StringBuilder(sbOriginal.ToString(), sbOriginal.Length)
   ```
- <span data-ttu-id="9e2a8-113">초기 용량 설정는 <xref:System.Text.StringBuilder> 은 약 최대 예상된 크기를 호출 하 여 값으로 개체는 <xref:System.Text.StringBuilder.%23ctor(System.Int32)> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-113">Set the initial capacity of the <xref:System.Text.StringBuilder> object to a value that is approximately equal to its maximum expected size by calling the <xref:System.Text.StringBuilder.%23ctor(System.Int32)> constructor.</span></span> <span data-ttu-id="9e2a8-114">전체 블록의 경우에도 메모리를 할당이 참고는 <xref:System.Text.StringBuilder> 거의 최대 용량에 도달 합니다.</span><span class="sxs-lookup"><span data-stu-id="9e2a8-114">Note that this allocates the entire block of memory even if the <xref:System.Text.StringBuilder> rarely reaches its maximum capacity.</span></span>
