<Type Name="IMessageSink" FullName="System.Runtime.Remoting.Messaging.IMessageSink">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8b414cab42951a8dbae4b137382c350d328bc2fb" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30487307" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IMessageSink" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IMessageSink" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="VB.NET" Value="Public Interface IMessageSink" />
  <TypeSignature Language="C++ CLI" Value="public interface class IMessageSink" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>메시지 싱크에 대한 인터페이스를 정의합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프록시에 대 한 메서드 호출이 이루어지면 원격 인프라 원격 경계를 넘어 실제 개체에 인수를 전달 하기 위해 필요한 지원을 제공, 다시 메서드를 호출 하면 실제 개체는 인수를 사용 하 고 결과 반환 합니다. 프록시 개체의 클라이언트입니다.  
  
 원격 메서드를 호출 하는 클라이언트 쪽에서 서버 쪽으로 이동 하는 메시지 이며 다시 것 같습니다. 원격 메서드 호출의 체인을 통해 전달 방식에 원격 경계를 교차 하는 대로 `IMessageSink` 개체입니다. 각 싱크 체인에 있는 메시지 개체를 수신, 특정 작업을 수행 하면 및 체인의 다음 싱크에 위임 합니다. 첫 번째에 대 한 참조를 포함 하는 프록시 개체 `IMessageSink` 체인을 시작 하는 데 필요 합니다.  
  
 비동기 호출을 위임할 때 각 싱크 제공 회신 싱크 (다른 `IMessageSink`) 회신 돌아올 켜져 있을 때 다음 싱크에서 호출 될 합니다.  
  
 다른 형식의 싱크 받은 메시지 개체의 유형에 따라 다양 한 작업을 수행 합니다. 예를 들어 한 싱크에서 잠금을, 다른 호출 보안을 적용할 수, 다른 흐름 호출을 제어 하 여 안정적인 서비스를 수행할 수 및 아직 다른 호출을 전송할 수는 다른 <xref:System.AppDomain>, 프로세스 또는 컴퓨터. 두 개 이상의 메시지 싱크 체인에 있는 각각의 특정 동작과 관련 하 여 서로 작용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 구현을 보여 줍니다.는 <xref:System.Runtime.Remoting.Messaging.IMessageSink> 인터페이스입니다. 이 예에서는 형식 정의 및 어셈블리가 참조 하는 참고를 컴파일하려면 샘플에 대 한 제공 되어야 합니다.  
  
 [!code-cpp[IMessageSink_Client#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IMessageSink_Client/CPP/imessagesink_client.cpp#3)]
 [!code-csharp[IMessageSink_Client#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IMessageSink_Client/CS/imessagesink_client.cs#3)]
 [!code-vb[IMessageSink_Client#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IMessageSink_Client/VB/imessagesink_client.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>현재 인터페이스를 구현 하는 코드 둘 다에 대 한 구현을 제공 해야 합니다 해야 <see cref="M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" /> 및 <see cref="M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />이므로 비동기 호출으로 그리고 반대로 하는 동기 호출을 변환할 수 있습니다. 두 방법 모두 싱크 비동기 처리를 지원 하지 않는 경우에 구현 해야 합니다.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName="AsyncProcessMessage">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg, class System.Runtime.Remoting.Messaging.IMessageSink replySink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />
      <MemberSignature Language="VB.NET" Value="Public Function AsyncProcessMessage (msg As IMessage, replySink As IMessageSink) As IMessageCtrl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::Messaging::IMessageCtrl ^ AsyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg, System::Runtime::Remoting::Messaging::IMessageSink ^ replySink);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageCtrl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
        <Parameter Name="replySink" Type="System.Runtime.Remoting.Messaging.IMessageSink" />
      </Parameters>
      <Docs>
        <param name="msg">처리할 메시지입니다.</param>
        <param name="replySink">회신 메시지의 회신 싱크입니다.</param>
        <summary>받은 메시지를 비동기적으로 처리합니다.</summary>
        <returns>디스패치된 비동기 메시지를 제어할 수 있는 방법을 제공하는 <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> 인터페이스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 원격 인프라 또는 비동기 메시지에 대 한 이전 싱크가 메시지 싱크에서 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자가 인터페이스에 대한 참조를 통해 호출하며 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 인프라 코드와 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NextSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Remoting.Messaging.IMessageSink NextSink" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.IMessageSink.NextSink" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSink As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Remoting::Messaging::IMessageSink ^ NextSink { System::Runtime::Remoting::Messaging::IMessageSink ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>싱크 체인의 다음 메시지 싱크를 가져옵니다.</summary>
        <value>싱크 체인의 다음 메시지 싱크입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자가 인터페이스에 대한 참조를 통해 호출하며 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 인프라 코드와 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SyncProcessMessage">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Function SyncProcessMessage (msg As IMessage) As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::Messaging::IMessage ^ SyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
      </Parameters>
      <Docs>
        <param name="msg">처리할 메시지입니다.</param>
        <summary>받은 메시지를 동기적으로 처리합니다.</summary>
        <returns>요청에 대한 회신 메시지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage%2A> 원격 인프라 또는 동기 메시지에 대 한 이전 싱크가 메시지 싱크 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자가 인터페이스에 대한 참조를 통해 호출하며 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 인프라 코드와 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>