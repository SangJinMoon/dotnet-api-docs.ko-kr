<Type Name="RegistryAccessRule" FullName="System.Security.AccessControl.RegistryAccessRule">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a10fa2e1cc108c3aba7b66c04ae68f8616d9c2c3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36627839" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistryAccessRule : System.Security.AccessControl.AccessRule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistryAccessRule extends System.Security.AccessControl.AccessRule" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistryAccessRule" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryAccessRule&#xA;Inherits AccessRule" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryAccessRule sealed : System::Security::AccessControl::AccessRule" />
  <TypeSignature Language="F#" Value="type RegistryAccessRule = class&#xA;    inherit AccessRule" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.AccessRule</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a set of access rights allowed or denied for a user or group. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistryAccessRule> 클래스는 Windows 레지스트리 키에 액세스 제어 보안을 관리 하기 위한.NET Framework가 제공 하는 클래스 집합 중 하나입니다. 이러한 클래스와의 관계는 기본 Windows 액세스 제어 구조를의 개요를 참조 하십시오. <xref:System.Security.AccessControl.RegistrySecurity>합니다.  
  
> [!NOTE]
>  Windows 액세스 제어 보안 레지스트리 키에만 적용할 수 있습니다. 키에 저장 된 개별 키/값 쌍에 적용할 수 없습니다.  
  
 현재 레지스트리 키에 적용 된 규칙 목록이 사용는 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 가져올 메서드를 한 <xref:System.Security.AccessControl.RegistrySecurity> 개체를 사용 하 여 해당 <xref:System.Security.AccessControl.CommonObjectSecurity.GetAccessRules%2A> 메서드의 컬렉션을 가져옵니다 <xref:System.Security.AccessControl.RegistryAccessRule> 개체입니다.  
  
 <xref:System.Security.AccessControl.RegistryAccessRule> 개체가 내부 임의 제어 액세스 목록 (DACL)에서 액세스 제어 항목으로 일대일로 매핑되지 않습니다. 레지스트리 키에 대 한 모든 액세스 규칙 집합이 나타나면 집합은 현재 모든 액세스 제어 항목을 나타내는 데 필요한 규칙의 최소 수를 포함 합니다.  
  
> [!NOTE]
>  기본 액세스 제어 항목에 적용 하 고 규칙을 제거 하는 대로 변경 합니다. 규칙의 정보는 액세스 제어 항목의 가장 작은 수를 유지 하기 위해 가능 하면 병합 됩니다. 따라서 규칙의 현재 목록의 읽을 때 하지 같습니다 정확 하 게 사용자가 추가한 모든 규칙의 목록입니다.  
  
 사용 하 여 <xref:System.Security.AccessControl.RegistryAccessRule> 개체를 허용 하거나 거부할 사용자 또는 그룹에 대 한 액세스 권한을 지정 합니다. A <xref:System.Security.AccessControl.RegistryAccessRule> 개체는 항상 액세스를 허용 하거나 거부 된 액세스 권한 나타내며 하지 둘 다 합니다.  
  
 레지스트리 키에 규칙을 적용 하려면 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 가져올 메서드를는 <xref:System.Security.AccessControl.RegistrySecurity> 개체입니다. 수정 된 <xref:System.Security.AccessControl.RegistrySecurity> 추가 규칙을 사용 하 여 해당 메서드를 사용 하 여 개체는 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 메서드를 보안 개체를 다시 연결 합니다.  
  
> [!IMPORTANT]
>  변경 내용은 한 <xref:System.Security.AccessControl.RegistrySecurity> 개체를 호출 하기 전에 레지스트리 키의 액세스 수준을 적용 되지 않습니다는 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 레지스트리 키로 변경 된 보안 개체를 지정 하는 메서드.  
  
 <xref:System.Security.AccessControl.RegistryAccessRule> 개체는 변경할 수 없습니다. 레지스트리 키에 대 한 보안의 메서드를 사용 하 여 수정 되는 <xref:System.Security.AccessControl.RegistrySecurity> 규칙을 추가 하거나 제거 하는 클래스, 이렇게 하면 기본 액세스 제어 항목 수정 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 상속 및 전파 액세스 규칙을 보여 줍니다. 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체을 다음을 추가 하는 두 개의 규칙은 <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> 플래그입니다. 첫 번째 규칙에 없는 전파 플래그는 있지만 두 번째에 <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> 및 <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>합니다.  
  
 프로그램에 규칙을 표시는 <xref:System.Security.AccessControl.RegistrySecurity> 개체를 다음 개체를 사용 하 여 하위 키를 만듭니다. 자식 하위 키와 손자 하위 키를 만들고 각 하위 키에 대 한 보안을 표시 합니다. 마지막으로, 프로그램 테스트 키를 삭제 합니다.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.IdentityReference identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::Security::Principal::IdentityReference ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : System.Security.Principal.IdentityReference * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">The user or group the rule applies to. Must be of type <see cref="T:System.Security.Principal.SecurityIdentifier" /> or a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="registryRights">A bitwise combination of <see cref="T:System.Security.AccessControl.RegistryRights" /> values indicating the rights allowed or denied.</param>
        <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values indicating whether the rights are allowed or denied.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> class, specifying the user or group the rule applies to, the access rights, and whether the specified access rights are allowed or denied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 기본 전파 및 상속을 지정합니다. 즉, <xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> specifies an invalid value.  -or-  <paramref name="type" /> specifies an invalid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identity" /> is <see langword="null" />.  -or-  <paramref name="eventRights" /> is zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" /> nor of a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::String ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : string * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.String" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">The name of the user or group the rule applies to.</param>
        <param name="registryRights">A bitwise combination of <see cref="T:System.Security.AccessControl.RegistryRights" /> values indicating the rights allowed or denied.</param>
        <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values indicating whether the rights are allowed or denied.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> class, specifying the name of the user or group the rule applies to, the access rights, and whether the specified access rights are allowed or denied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 기본 전파 및 상속을 지정합니다. 즉, <xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType>합니다.  
  
 이 생성자는 만들기는 <xref:System.Security.Principal.NTAccount> 개체를 전달 하 여 `identity` 에 <xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType> 생성자 및 새로 만든 전달 <xref:System.Security.Principal.NTAccount> 개체를 <xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.AccessControlType%29> 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 레지스트리 액세스 규칙을 만들고에 추가 <xref:System.Security.AccessControl.RegistrySecurity> 을 보여 주는 개체 권한을 허용 및 거부 하는 규칙에 동일한의 호환 규칙 동안 별도로 유지 방법을 kind 병합 됩니다.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> specifies an invalid value.  -or-  <paramref name="type" /> specifies an invalid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="registryRights" /> is zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> is <see langword="null" />.  -or-  <paramref name="identity" /> is a zero-length string.  -or-  <paramref name="identity" /> is longer than 512 characters.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.IdentityReference identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::Security::Principal::IdentityReference ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : System.Security.Principal.IdentityReference * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">The user or group the rule applies to. Must be of type <see cref="T:System.Security.Principal.SecurityIdentifier" /> or a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="registryRights">A bitwise combination of <see cref="T:System.Security.AccessControl.RegistryRights" /> values specifying the rights allowed or denied.</param>
        <param name="inheritanceFlags">A bitwise combination of <see cref="T:System.Security.AccessControl.InheritanceFlags" /> flags specifying how access rights are inherited from other objects.</param>
        <param name="propagationFlags">A bitwise combination of <see cref="T:System.Security.AccessControl.PropagationFlags" /> flags specifying how access rights are propagated to other objects.</param>
        <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values specifying whether the rights are allowed or denied.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> class, specifying the user or group the rule applies to, the access rights, the inheritance flags, the propagation flags, and whether the specified access rights are allowed or denied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 레지스트리 키에 대 한 의미 있는 유일한 상속 플래그는 모든 레지스트리 키가 컨테이너는 <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType> 플래그입니다. 이 플래그를 지정 하지 않으면 전파 플래그 무시 되 고 직접 키만 영향을 받습니다. 플래그가 있는 경우에 다음 표에 나와 있는 것 처럼 규칙 전파 됩니다. 테이블 자식 하위 키가 CS 및 GS 손자 하위 키와 하위 키 S 가정 합니다. 즉, 손자 하위 키에 대 한 경로가 S\CS\GS입니다.  
  
|전파 플래그|S|CS|GS|  
|-----------------------|-------|--------|--------|  
|<xref:System.Security.AccessControl.PropagationFlags.None>|X|X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>|X|X||  
|<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>, <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X||  
  
 손자 하위 키에 대 한 패턴에 포함 된 모든 하위 키를 관리 합니다.  
  
 예를 들어 경우는 <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> 플래그가 지정 되어 `inheritanceFlags` 및 <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> 전파 플래그에 지정 된 `propagationFlags`,이 규칙이 직접 하위 키에 적용 되지 않습니다 되지만 모든 하위 키 및 모든 직계 자식 하위 키에 적용 하는 포함 됩니다.  
  
> [!NOTE]
>  지정할 수는 있지만 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> 플래그에 대 한 `inheritanceFlags`, 그렇게 하는 이유가 없습니다. 액세스 제어를 위해 하위 키에서 이름/값 쌍은 별개의 개체 되지 않습니다. 이름/값 쌍에 대 한 액세스 권한은 하위 키의 권한에 의해 제어 됩니다. 또한 모든 하위 키 컨테이너는 (즉, 이러한를 포함할 수는 다른 하위 키) 하 여 영향을 받지 않습니다는 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그입니다. 마지막으로 지정 하는 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그, 규칙의 유지 관리를 그렇지 않으면 호환 가능한 규칙의 조합을 사용 하 여 충돌 하므로 불필요 하 게 복잡해 집니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> specifies an invalid value.  -or-  <paramref name="type" /> specifies an invalid value.  -or-  <paramref name="inheritanceFlags" /> specifies an invalid value.  -or-  <paramref name="propagationFlags" /> specifies an invalid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identity" /> is <see langword="null" />.  -or-  <paramref name="registryRights" /> is zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" />, nor of a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::String ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : string * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.String" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">The name of the user or group the rule applies to.</param>
        <param name="registryRights">A bitwise combination of <see cref="T:System.Security.AccessControl.RegistryRights" /> values indicating the rights allowed or denied.</param>
        <param name="inheritanceFlags">A bitwise combination of <see cref="T:System.Security.AccessControl.InheritanceFlags" /> flags specifying how access rights are inherited from other objects.</param>
        <param name="propagationFlags">A bitwise combination of <see cref="T:System.Security.AccessControl.PropagationFlags" /> flags specifying how access rights are propagated to other objects.</param>
        <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values specifying whether the rights are allowed or denied.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> class, specifying the name of the user or group the rule applies to, the access rights, the inheritance flags, the propagation flags, and whether the specified access rights are allowed or denied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 레지스트리 키에 대 한 의미 있는 유일한 상속 플래그는 모든 레지스트리 키가 컨테이너는 <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType> 플래그입니다. 이 플래그를 지정 하지 않으면 전파 플래그 무시 되 고 직접 키만 영향을 받습니다. 플래그가 있는 경우에 다음 표에 나와 있는 것 처럼 규칙 전파 됩니다. 테이블 자식 하위 키가 CS 및 GS 손자 하위 키와 하위 키 S 가정 합니다. 즉, 손자 하위 키에 대 한 경로가 S\CS\GS입니다.  
  
|전파 플래그|S|CS|GS|  
|-----------------------|-------|--------|--------|  
|<xref:System.Security.AccessControl.PropagationFlags.None>|X|X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>|X|X||  
|<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>, <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X||  
  
 손자 하위 키에 대 한 패턴에 포함 된 모든 하위 키를 관리 합니다.  
  
 예를 들어 경우는 <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> 플래그가 지정 되어 `inheritanceFlags` 및 <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> 전파 플래그에 지정 된 `propagationFlags`,이 규칙이 직접 하위 키에 적용 되지 않습니다 되지만 모든 하위 키 및 모든 직계 자식 하위 키에 적용 하는 포함 됩니다.  
  
> [!NOTE]
>  지정할 수는 있지만 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> 플래그에 대 한 `inheritanceFlags`, 그렇게 하는 이유가 없습니다. 액세스 제어를 위해 하위 키에서 이름/값 쌍은 별개의 개체 되지 않습니다. 이름/값 쌍에 대 한 액세스 권한은 하위 키의 권한에 의해 제어 됩니다. 또한 모든 하위 키 컨테이너는 (즉, 이러한를 포함할 수는 다른 하위 키) 하 여 영향을 받지 않습니다는 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그입니다. 마지막으로 지정 하는 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그, 규칙의 유지 관리를 그렇지 않으면 호환 가능한 규칙의 조합을 사용 하 여 충돌 하므로 불필요 하 게 복잡해 집니다.  
  
 이 생성자는 만들기는 <xref:System.Security.Principal.NTAccount> 개체를 전달 하 여 `identity` 에 <xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType> 생성자 및 새로 만든 전달 <xref:System.Security.Principal.NTAccount> 개체를 <xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.InheritanceFlags%2CSystem.Security.AccessControl.PropagationFlags%2CSystem.Security.AccessControl.AccessControlType%29> 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 상속 및 전파 액세스 규칙을 보여 줍니다. 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체를 로컬 폴더를 만들고 있는 두 개의 규칙을 추가 <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> 플래그입니다. 첫 번째 규칙에 없는 전파 플래그는 있지만 두 번째에 <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> 및 <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>합니다.  
  
 프로그램에 규칙을 표시는 <xref:System.Security.AccessControl.RegistrySecurity> 개체, 한 다음 사용 하는 <xref:System.Security.AccessControl.RegistrySecurity> 하위 키를 만들 개체입니다. 자식 하위 키와 손자 하위 키를 만들고 각 하위 키에 대 한 규칙을 표시 합니다. 마지막으로, 프로그램 테스트 키를 삭제 합니다.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> specifies an invalid value.  -or-  <paramref name="type" /> specifies an invalid value.  -or-  <paramref name="inheritanceFlags" /> specifies an invalid value.  -or-  <paramref name="propagationFlags" /> specifies an invalid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventRights" /> is zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> is <see langword="null" />.  -or-  <paramref name="identity" /> is a zero-length string.  -or-  <paramref name="identity" /> is longer than 512 characters.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegistryRights">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistryRights RegistryRights { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.AccessControl.RegistryRights RegistryRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistryAccessRule.RegistryRights" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RegistryRights As RegistryRights" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::AccessControl::RegistryRights RegistryRights { System::Security::AccessControl::RegistryRights get(); };" />
      <MemberSignature Language="F#" Value="member this.RegistryRights : System.Security.AccessControl.RegistryRights" Usage="System.Security.AccessControl.RegistryAccessRule.RegistryRights" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistryRights</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the rights allowed or denied by the access rule.</summary>
        <value>비트 조합 <see cref="T:System.Security.AccessControl.RegistryRights" /> 값 된 권한을 나타내는 허용 또는 액세스 규칙에 의해 거부 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistryAccessRule> 개체는 변경할 수 없습니다. 다른 사용자, 서로 다른 권한을 또는 다른를 나타내는 새 액세스 규칙을 만들 수 있습니다 <xref:System.Security.AccessControl.AccessControlType>, 있지만 기존 액세스 규칙을 수정할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>