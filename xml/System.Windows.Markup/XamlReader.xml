<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XamlReader.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cb6251512dd75740e1b01a33ceb7e3470f3a68d1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb6251512dd75740e1b01a33ceb7e3470f3a68d1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</source>
          <target state="translated">WPF 기본 XAML 판독기 및 연결된 XAML 개체 기록기를 사용하여 XAML 입력을 읽고 개체 그래프를 만듭니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The synchronous <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> methods are static, but the asynchronous <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> methods are not static and require an instance of the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class to use.</source>
          <target state="translated">동기 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 메서드는 정적 이지만 비동기 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> 메서드는 정적 및의 인스턴스가 필요는 <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The output of the <ph id="ph1">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.</source>
          <target state="translated">출력은 <ph id="ph1">`Load`</ph> methods는 생성된 된 개체 트리 또는 개체 그래프의 루트 개체를 나타내는 단일 개체입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Object graphs that are created by <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> are typically added to the existing object tree of a WPF application at run time.</source>
          <target state="translated">개체 그래프에 의해 만들어진 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 일반적으로 런타임 시 WPF 응용 프로그램의 기존 개체 트리에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</source>
          <target state="translated">그렇지 않은 경우 새 개체 그래프는 WPF 응용 프로그램 모델의 목적에 대 한 연결이 끊어진 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</source>
          <target state="translated">즉, 렌더링 하지 않습니다 적용할 수 없습니다 액세스를 사용 하 여 개체 트리 기술을으로 WPF 응용 프로그램의 주 개체 트리 (예를 들어 Api <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information on object tree concepts, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">개체 트리 개념에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>In WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> supports the following primary scenarios:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 다음과 같은 기본 시나리오를 지원합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Cloning/object factory<ept id="p1">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</source>
          <target state="translated"><bpt id="p1">**</bpt>복제 개체 팩터리<ept id="p1">**</ept>: 참조 형식 일반적 추가적인 메커니즘 없이 WPF 개체 트리의에서 둘 이상의 위치에 포함 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, or support for commonly shareable objects such as <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> that are referenced as an item from a <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) One way to clone an object that is already in the object tree is to serialize the object using <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">(WPF에서 다시 사용할 또는 공유에 대 한 지원을 제공 하는 추가 메커니즘의 예로 기반으로 하는 개체 <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, 등의 일반적으로 공유할 수 있는 개체에 대 한 지원 또는 <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> 에서 항목으로 참조 되는 <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) 사용 하 여 개체를 직렬화가 이미 있는 개체를 복제 하는 한 가지 방법은 개체 트리는 <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You then use the serialized string as input for a call to <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, with a stream or <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> as an intermediary.</source>
          <target state="translated">그런 다음 직렬화 된 문자열 입력으로 사용할 있습니다에 대 한 호출에 대 한 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, 스트림 또는 <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> 중간자로 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Constructing objects based on just-in-time information<ept id="p1">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>적시에 정보를 기반으로 개체 생성<ept id="p1">**</ept>: 런타임에 바인딩 또는 사용자가 제공한 입력이 기존 개체의 상태를 변경 하는 다른 방법을 종종 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For example you could use the same value to set more than one property, or use data binding.</source>
          <target state="translated">예를 들어 둘 이상의 속성을 설정 하려면 동일한 값을 사용 하거나 데이터 바인딩을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> input is often a useful technique.</source>
          <target state="translated">여기서도 만들 개체의 형식이 결정할 수 있는 런타임 시 또는 사용자 상호 작용 하는 시나리오를 사용 하도록 설정한 경우 다음 만들어 이러한 개체에 대 한 문자열을 작성 하 여 하지만 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 입력은 종종 기술을 사용 하면 유용 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Using existing resource techniques<ept id="p1">**</ept>: The <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</source>
          <target state="translated"><bpt id="p1">**</bpt>기존 리소스 기술을 사용 하 여<ept id="p1">**</ept>:는 <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> 형식에서 자주 사용 되 다른 프레임 워크 또는 기술 응용 프로그램 경계 간의 데이터 나 개체를 전송에 대 한 또는 이와 유사한 상황에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can then use the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</source>
          <target state="translated">그런 다음 사용할 수는 <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> 저장 하거나 결국 응용 프로그램의 일부로 개체를 만드는 데 사용 하는 XAML 형식의 데이터를 얻을 수 있는 기술을 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Fixed documents:<ept id="p1">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</source>
          <target state="translated"><bpt id="p1">**</bpt>고정 문서:<ept id="p1">**</ept> 응용 프로그램에서 WPF 응용 프로그램 개체 트리의 UI에 대 한 로컬 또는 다운로드 한 XPS 문서를 로드할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This documentation sometimes describes an object graph, as opposed to an object tree.</source>
          <target state="translated">이 설명서에 경우에 따라 달리 개체 트리를 사용 하 여 개체 그래프를 설명합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</source>
          <target state="translated">엄격한 부모-자식 관계 항상 없으므로 런타임 WPF 응용 프로그램의 런타임 개체 관계에서 개체 그래프는 널리 적용 가능한 용어 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, because WPF also includes two different tree conceptualization APIs (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) the tree metaphor still applies adequately to most real-world cases in WPF.</source>
          <target state="translated">그러나 WPF에 두 개의 다른 트리 개념화 Api도 포함 되어 있으므로 (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) WPF에서 대부분의 실제 경우를 트리 메타포 적절 하 게 여전히 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</source>
          <target state="translated">그러나 XAML 언어 관점에서 개체 그래프는 종종 생각 XAML에서 개체 생성 방법에 대 한 XAML 언어 자체 반드시 지정 하지 않으므로 관계를 자세히 표시 하는 도우미 클래스 방법론 하는 최선의 방법에는 트리 구조 다시입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Code Access Security, Loose XAML, and XamlReader</source>
          <target state="translated">코드 액세스 보안, 느슨한 XAML 및 XamlReader</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>XAML is a markup language that directly represents object instantiation and execution.</source>
          <target state="translated">XAML은 개체 인스턴스화 및 실행을 직접적으로 나타내는 태그 언어입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</source>
          <target state="translated">따라서 XAML에서 만든 요소에는 생성된 해당 코드가 수행하는 것과 마찬가지로 시스템 리소스(예: 네트워크 액세스, 파일 시스템 IO)와 상호 작용하는 동일한 기능이 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 지원 된 <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> 보안 프레임 워크 <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.</source>
          <target state="translated">즉, 인터넷 영역에서 실행되는 <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 콘텐츠는 실행 권한이 줄어듭니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.</source>
          <target state="translated">이때 "느슨한 XAML"(컴파일되지 않은 XAML의 페이지가 로드 시 XAML 뷰어에 의해 해석됨) 및 <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph>는 일반적으로 이 인터넷 영역에서 실행되며 같은 권한 집합을 사용합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</source>
          <target state="translated">하지만 완전히 신뢰할 수 있는 응용 프로그램으로 로드된 XAML은 시스템 리소스에 대해 호스팅 응용 프로그램과 동일한 액세스 권한을 가집니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information, see <bpt id="p1">[</bpt>WPF Partial Trust Security<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>WPF 부분 신뢰 보안<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The implications of these statements for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is that your application design must make trust decisions about the XAML you decide to load.</source>
          <target state="translated">에 대 한 이러한 문 사항의 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 응용 프로그램 디자인 로드 하려는 경우 XAML에 대 한 신뢰 결정을 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</source>
          <target state="translated">신뢰할 수 없는 XAML을 로드 하는 경우에 결과 개체 그래프를 로드 하는 방법에 대 한 사용자 고유의 샌드 박싱 기술을 구현 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> can also be called by partial trust code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 부분 신뢰 코드에서 호출할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In this case, Internet security zone is applied for code access security.</source>
          <target state="translated">이 경우 인터넷 보안 영역의 코드 액세스 보안에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</source>
          <target state="translated">인터넷 보안 영역에서 유효 하지 않으면 로드 된 XAML에 아무 것도 XAML 구문 분석 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Under XBAP and other cases that are partial trust at the platform level, where <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</source>
          <target state="translated">XBAP 및 플랫폼 수준에서 일부 신뢰 된 다른 경우 여기서 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 일부의 실행 명시적 부분 신뢰 호출 된 대로 동일한 예외 동작 하 게 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF XAML, XAML Readers/Writers, and XAML Language Versioning</source>
          <target state="translated">WPF XAML, XAML 판독기/기록기 및 XAML 언어 버전 관리</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> includes language features such as  and .</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> 와 같은 언어 기능을 포함 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can use signatures of <ph id="ph1">`Load`</ph> or <ph id="ph2">`Parse`</ph> to load XAML that uses these features.</source>
          <target state="translated">시그니처를 사용할 수 있습니다 <ph id="ph1">`Load`</ph> 또는 <ph id="ph2">`Parse`</ph> 이러한 기능을 사용 하는 XAML을 로드 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</source>
          <target state="translated">그러나, 이러한 언어 기능은 태그를 컴파일해야 하는 XAML에 대 한 지원 되지 않습니다 (에 대 한 XAML 등의 <bpt id="p1">**</bpt>페이지<ept id="p1">**</ept> 에서 WPF 응용 프로그램 또는 빌드 작업에서 태그 컴파일 작업와 관련 된 모든 XAML 빌드 작업).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</source>
          <target state="translated">WPF 형식 및 WPF 기술은 일반적 WPF 내부에 대 한 액세스를 사용 하는 개념을 지원 합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</source>
          <target state="translated">예를 들어, WPF 종속성 속성을 구현 하는 방법을 효율적인 유형 멤버 조회에 대 한 내부 기술에 의존 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Access to these internals is enabled by the XAML reading and writing APIs provided in <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> from the <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> namespace and PresentationFramework assembly.</source>
          <target state="translated">이러한 내부 구조에 대 한 액세스는 XAML 읽기 및 쓰기에 제공 된 Api에 의해 사용 하도록 설정 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 에서 <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> 네임 스페이스 및 PresentationFramework 어셈블리입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) do not have access to the WPF internals.</source>
          <target state="translated">그러나 하위 XAML 판독기 및 XAML 작성기 System.Xaml 어셈블리에서 (클래스에 따라 <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) WPF 내부에 대 한 액세스 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>There is no dependency from System.Xaml to any WPF-specific assembly.</source>
          <target state="translated">System.Xaml에서 모든 WPF 관련 어셈블리에 종속성이 있습니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</source>
          <target state="translated">WPF 내부에 연결 되지 않은 System.Xaml 판독기와 작성기 올바르게 로드 하지 못했거나, 모든 WPF 저장 형식 또는 형식에 따라 WPF 형식입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</source>
          <target state="translated">특히 System.Xaml 판독기와 작성기 WPF 종속성 속성을 속성 저장소 및 WPF 스타일, 리소스 사전 및 템플릿을 사용 하는 방법의 모든 문의 지원 같은 개념을 이해 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore you have a choice to make:</source>
          <target state="translated">따라서 되도록 선택할을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</source>
          <target state="translated">WPF 형식을 로드 하는 경우 어떤 방식으로든에서 BAML 양식에서 XAML을 사용 하는, PresentationFramework XAML 판독기 및 XAML 작성기를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</source>
          <target state="translated">모든 WPF 형식 또는 BAML 형식의 XAML 사용 하지 않고도 다른 특정 기술 XAML 판독기 또는 XAML 작성기 구현 프레임 워크에 있는 관련 된 이유로 사용 하지 않는 경우 System.Xaml의 XAML 판독기 및 XAML 작성기를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>System.Xaml Backing Implementation in .NET 4</source>
          <target state="translated">System.Xaml 지원을.NET 4의 구현</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is the callable API surface for the WPF framework-level XAML parser.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> WPF 프레임 워크 수준 XAML 파서에 대 한 호출 가능 API 화면이입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>.</source>
          <target state="translated">같은 기본 XAML 파서가 성능도 런타임에 XAML을 로드 하 고 대상으로 하는 WPF 응용 프로그램에 대 한 구문 분석 <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> 및 <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</source>
          <target state="translated">대상으로 하는 경우 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, 외부 API는 같지만 구현 요소를 기반으로 만들어진는 <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 대부분 XAML을 구문 분석의 기술 및 보고 측면의 향상 되는 System.Xaml 어셈블리의 일반 XAML 구현 합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</source>
          <target state="translated">대상 지정 <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> 보고 예외는 System.Xaml에서 가져올 수 같은 구현 세부 정보는 참조로 System.Xaml를 포함 하는 포함 형식을 정의 하는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">다음 예제는 <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> 사용 하 여 문자열에는 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">문자열이 로드 되는 다음에 다시는 <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> 정적을 사용 하 여 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 에서 메서드는 <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source>Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</source>
          <target state="translated">현재 보류 중인 비동기 로드 작업이 있으면 중단합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> 비동기 작업입니다. 따라서 일부 로드에는 작업을 중단 하기 전에 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph>에 대한 WPF 스키마 컨텍스트 설정을 나타내는 <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph>에 대한 WPF 스키마 컨텍스트 설정을 나타내는 <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and returns the root of the corresponding object tree.</source>
          <target state="translated">XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The XAML to load, in stream form.</source>
          <target state="translated">스트림 형식으로 로드할 XAML입니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> that is the root of the corresponding object tree.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>에서 XAML 입력을 읽고 해당 개체 트리의 루트인 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The object at the root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트에 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The following example saves a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> using the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">다음 예제에서는 저장 한 <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> 에 <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> 를 사용 하는 <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The stream is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">스트림이에 다시 로드는 <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> 정적을 사용 하 여 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 에서 메서드는 <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is expected to be initialized with input XAML.</source>
          <target state="translated">입력 XAML을 사용하여 초기화되어야 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>Reads the XAML input through a provided <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">제공된 <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph>에서 XAML 입력을 읽고 해당 개체 트리의 루트인 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트인 개체입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The input <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> can be <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>.</source>
          <target state="translated">입력 <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> 수 <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is how you can load BAML at run time, or for localization tool purposes.</source>
          <target state="translated">실행 시 또는 지역화 도구에 BAML에 로드 하는 방법입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded the XAML input to load in XML form.</source>
          <target state="translated">XML 형식으로 로드하기 위해 이미 XAML 입력을 로드한 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>에서 XAML 입력을 읽고 해당 개체 트리의 루트인 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트인 개체입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">다음 예제는 <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> 사용 하 여 문자열에는 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">문자열이 로드 되는 다음에 다시는 <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> 정적을 사용 하 여 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 에서 메서드는 <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The stream that contains the XAML input to load.</source>
          <target state="translated">로드할 XAML 입력이 들어 있는 스트림입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">파서에서 사용하는 컨텍스트 정보입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>에서 XAML 입력을 읽고 해당 개체 트리의 루트인 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트인 개체입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML markup and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">XAML 태그를 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The stream containing the XAML input to load.</source>
          <target state="translated">로드할 XAML 입력이 들어 있는 스트림입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>에서 XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트인 개체입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">비동기 XAML 로드 작업에는 루트 개체는 순수 하 게 되는 개체가 반환 처음 됩니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">비동기적으로 계속 XAML 다음 구문 분석 하 고 루트 아래에 자식 개체가 채워집니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">이것이 일반적인 WPF XAML 처리 동작 및 개체 수명의 WPF 개념 상호 작용 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">일반적인 (비동기) 상호 작용에 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하는 개체의 모든 속성이 채워집니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">해당 동작 상향식 방법 사용 루트 개체인를 사용할 수 있을 마지막 개체 트리를 만드는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">하면 일반적으로 WPF 응용 프로그램의 개체 트리에 일부 위치로 반환 되는 개체를 할당 합니다, 콘텐츠 지식을 계속 채워지고 및 전체가 UI의 일부로 노출 되는 경우 증분 레이아웃 업데이트가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">이러한 이유로 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 응용 프로그램별 논리 또는 응용 프로그램 상태를 알릴 때 사용 하는 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">에 대 한 순서 대로 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> 입력을 비동기적으로 XAML을 로드 하려면 XAML 입력에서 루트 요소 특성 및 값 포함 해야 합니다 <ph id="ph2">`x:SynchronousMode="Async"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">값은 대/소문자입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If the XAML input root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</source>
          <target state="translated">XAML 입력된 루트가 포함 되어 있지 않으면 <ph id="ph1">`x:SynchronousMode="Async"`</ph>, 예외가 throw 되지 않으며 호출 동기 로드로 처리 됩니다 (참조 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">인스턴스당 하나의 비동기 로드 작업은 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스는 한 번에 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Multiple load operations are pending concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">여러 로드 조작은 동일한 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>로 동시에 보류됩니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An existing  <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded/read the XAML input.</source>
          <target state="translated">이미 XAML 입력을 로드한/읽은 기존 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>에서 XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">비동기 XAML 로드 작업에는 루트 개체는 순수 하 게 되는 개체가 반환 처음 됩니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">비동기적으로 계속 XAML 다음 구문 분석 하 고 루트 아래에 자식 개체가 채워집니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">이것이 일반적인 WPF XAML 처리 동작 및 개체 수명의 WPF 개념 상호 작용 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">일반적인 (비동기) 상호 작용에 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하는 개체의 모든 속성이 채워집니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">해당 동작 상향식 방법 사용 루트 개체인를 사용할 수 있을 마지막 개체 트리를 만드는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>You typically would assign the returned object from <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">일반적으로에서 반환된 된 개체를 할당할 때 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> 응용 프로그램의 개체 트리에 있는 위치로 일부 콘텐츠가 지식을 계속 채워지고 및 전체가의 일부로 노출 되는 경우 증분 레이아웃 업데이트가 발생할 수는 UI입니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">이러한 이유로 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 응용 프로그램별 논리 또는 응용 프로그램 상태를 알릴 때 사용 하는 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">에 대 한 순서 대로 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> 입력을 비동기적으로 XAML을 로드 하려면 XAML 태그의 루트 요소 특성 및 값 포함 해야 <ph id="ph2">`x:SynchronousMode="Async"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">값은 대/소문자입니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</source>
          <target state="translated">XAML 태그 루트가 포함 되어 있지 않으면 <ph id="ph1">`x:SynchronousMode="Async"`</ph>, 예외가 throw 되지 않으며 호출 동기 로드로 처리 대신 됩니다 (참조 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">인스턴스당 하나의 비동기 로드 작업은 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스는 한 번에 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">여러 로드 조작은 동일한 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>를 사용하여 동시에 수행됩니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>A stream containing the XAML input to load.</source>
          <target state="translated">로드할 XAML 입력이 들어 있는 스트림입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">파서에서 사용하는 컨텍스트 정보입니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>에서 XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">비동기 XAML 로드 작업에는 루트 개체는 순수 하 게 되는 개체가 반환 처음 됩니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">비동기적으로 계속 XAML 다음 구문 분석 하 고 루트 아래에 자식 개체가 채워집니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">이것이 일반적인 WPF XAML 처리 동작 및 개체 수명의 WPF 개념 상호 작용 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">일반적인 (비동기) 상호 작용에 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하는 개체의 모든 속성이 채워집니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">해당 동작 상향식 방법 사용 루트 개체인를 사용할 수 있을 마지막 개체 트리를 만드는 것과 같습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">하면 일반적으로 응용 프로그램의 개체 트리에 일부 위치로 반환 되는 개체를 할당 합니다, 콘텐츠 지식을 계속 채워지고 및 전체가 UI의 일부로 노출 되는 경우 증분 레이아웃 업데이트가 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">이러한 이유로 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 응용 프로그램별 논리 또는 응용 프로그램 상태를 알릴 때 사용 하는 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">에 대 한 순서 대로 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> 태그를 비동기적으로 로드 하는 XAML 태그의 루트 요소 특성 및 값 포함 해야 <ph id="ph2">`x:SynchronousMode="Async"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">값은 대/소문자입니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</source>
          <target state="translated">XAML 태그 루트가 포함 되어 있지 않으면 <ph id="ph1">`x:SynchronousMode="Async"`</ph>, 예외가 throw 되지 않으며 호출 동기 로드로 처리 됩니다 (참조 <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">인스턴스당 하나의 비동기 로드 작업은 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스는 한 번에 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 클래스는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">여러 로드 조작은 동일한 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>를 사용하여 동시에 수행됩니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source>Occurs when an asynchronous load operation completes.</source>
          <target state="translated">비동기 로드 작업이 완료되면 발생합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is also raised when an asynchronous load operation aborts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> 비동기 로드 작업을 중단 하는 경우에 발생 합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">지정된 텍스트 문자열에서 태그를 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">단일 텍스트 문자열인 입력 XAML입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">지정된 텍스트 문자열에서 XAML 입력을 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">구현 호출 하 여 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 문자열에서 스트림을 만든 후에 내부적으로 합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">참조 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 가능한 예외와 같은 추가 정보에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">단일 텍스트 문자열인 입력 XAML입니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">파서에서 사용하는 컨텍스트 정보입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML markup in the specified text string (using a specified <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>) and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>를 사용하여 지정된 텍스트 문자열에서 XAML 태그를 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">만든 개체 트리의 루트입니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">구현 호출 하 여 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 문자열에서 스트림을 만든 후에 내부적으로 합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">참조 <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> 가능한 예외와 같은 추가 정보에 대 한 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>