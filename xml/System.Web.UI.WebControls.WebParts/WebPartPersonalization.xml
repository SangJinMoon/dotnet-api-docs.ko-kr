<Type Name="WebPartPersonalization" FullName="System.Web.UI.WebControls.WebParts.WebPartPersonalization">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9225a4065a107241a4ecf7792267fabc5642a03" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30600517" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartPersonalization" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartPersonalization extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartPersonalization" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartPersonalization" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Web.UI.WebControls.EmptyStringExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>하위 수준 개인 설정 작업을 구현합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스는 하위 개인 설정 작업을 수행 하는 데 필요한 논리를 구현 합니다. 하지만 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개인 설정의 상위 수준 수명 주기 관리, 이기는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 실제로 특정 개인 설정 동작을 수행 하는 데 필요한 물리적 단계를 구현 하는 일을 담당 하는 클래스입니다. <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 클래스의 구현에 의존 하는데 <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> 개인 설정 정보에 대 한 기본 데이터 저장소와 통신할 수 있습니다.  
  
 기본 구현을 사용 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>의 인스턴스를 만듭니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 참조 하 여 사용할 수 있는 클래스는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성입니다. 예를 들어 액세스는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> 속성을 지정 하는 경우 `WebPartManager.Personalization.InitialScope`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 방법을 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 개인 설정 범위 개인 설정 된 속성의 결과 미치는 영향을 주는지 클래스를 사용 합니다. 이 예제에는 5 개의 파일에 있습니다.  
  
-   .Aspx 페이지를 선언적으로 두 개의 웹 파트 영역을 만듭니다는 컨트롤과 함께 각각.  
  
-   사용자 정의 컨트롤 호출 `Color.ascx` 사용자를 기반으로 사용자의 권한 부여 권한 상태 정보를 수정 하 고 공유 범위에 텍스트 상자 배경색을 적용 하는 개인 설정 된 속성을 변경할 수 있도록 합니다.  
  
-   사용자 정의 컨트롤 호출 `Persmode.ascx` 현재 페이지 범위 것을 표시 하 고 공유 범위를 입력 하거나, 데이터를 수정 하에 현재 사용자 권한을; 또한 두 개의 단추; 범위를 변경 하려면 하나 및 현재 사용자 개인 설정 정보를 다시 설정할 수를 제공 합니다.  
  
-   사용자 권한을 부여 하는 데 사용 되는 로그인 컨트롤입니다.  
  
-   사용자 개인 설정 상태를 수정 하 고 공유 범위에 액세스할 수 있도록 권한을 부여 하 여 예제를 제공 하는 섹션 된 Web.config 파일입니다.  
  
 다음 코드와 aspx 페이지를 만듭니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 두 웹 파트 영역을 표시 하 고는 `Color.ascx` 및 `Persmode.ascx` 컨트롤입니다. 페이지는 현재 사용자 정보를 얻는 데 사용 되는 로그인 페이지를 로드 합니다. 에 ASP.NET 웹 사이트 관리 도구를 사용 하 여 [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)] 페이지에 액세스 하는 사용자를 만들어야 합니다. 범위를 변경 하 고 상태 정보를 수정 하려면 구성 파일에서 권한 부여를 부여 받은 사용자의 예 Web.config 파일을 참조 하십시오.  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/Defaultcs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/Defaultvb.aspx#1)]  
  
 다음 코드 예제에서는 로그인 페이지를 만듭니다. 로그인에 성공한 후 기본 aspx 페이지를 리디렉션합니다.  
  
> [!IMPORTANT]
>  이 예제에는 사용자 입력을 허용하는 텍스트 상자가 있으므로 보안상 위험할 수 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#5](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/login.aspx#5)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/login.aspx#5)]  
  
 다음 예제 코드는이 응용 프로그램에 대 한 Web.config 파일의 일부입니다. 이 섹션에는이 경우 "user2"는 사용자에 대 한 권한 부여 설정 공유 개인 설정 범위를 입력 하 고 개인 설정 상태 정보를 수정 하는 방법을 보여 줍니다. 또한이 경우 "admin"는 공유 개인 설정 범위를 입력 하 고 개인 설정 상태 정보를 수정 하려면 "관리" 역할의 사용자가 허용 하는 데 사용할 수 있는 역할의 예를 보여줍니다.  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/web.config#2)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/web.config#2)]
  
 다음 코드 예제에서는 라는 사용자 컨트롤을 만듭니다 `Color.ascx`,이 경우 개인 설정 된 속성을 변경 하려면 사용자를 허용 하는 현재 개인 설정 범위 및 사용자의 권한 부여 권한에 따라 두 개의 입력란의 배경색 .  
  
> [!IMPORTANT]
>  이 예제에는 사용자 입력을 허용하는 텍스트 상자가 있으므로 보안상 위험할 수 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/color.ascx#3)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/color.ascx#3)]  
  
 다음 코드 예제에서는 라는 사용자 컨트롤을 만듭니다 `Persmode.ascx`,에서는 보여 주는 및 사용자 권한을 수정에 상태 및 공유 범위를 입력 합니다. 현재 개인 설정 상태를 다시 설정 하기 위해 다시 설정 단추를 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#4](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#4)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#4)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 클래스 긴밀히 협력 하 여 한 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 제어 및 개인 설정 인프라의 나머지 부분입니다. 개인 설정의 기본 구현은 프로그램 개인 설정 요구 사항을 충족 해야 하는 매우 강력한 하위 시스템을입니다. 대부분의 경우에서 개인 설정, 사용자 지정 하려는 경우 만들 수 있습니다 사용할 데이터 공급자에서 상속 되는 클래스를 만들어 사용 하 여 개인 설정 공급자 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />합니다.  
  
 개인 설정 하위 시스템을 비슷한에서 제공 하는 암호를 만들려고 한다고 하는 경우는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 및 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스, 사용자 지정 만들기 해야 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 구현을 파생 하 여 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 사용자 고유의 사용자 지정을 추가 하 고 논리입니다. 그런 다음 사용자 정의 만들 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 구현을 파생 하 여 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, 사용자 지정 논리를 추가 하 고 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> 메서드를 사용자 지정 반환 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 구현 합니다. 때문에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 에서는 요청을 통해 개인 설정 인프라를 제어는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤 않습니다 직접적와 상호 작용 하거나에 대 한 참조 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> 구현 합니다.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartPersonalization (System.Web.UI.WebControls.WebParts.WebPartManager owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.UI.WebControls.WebParts.WebPartManager owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.#ctor(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (owner As WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartPersonalization(System::Web::UI::WebControls::WebParts::WebPartManager ^ owner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="owner">개인 설정 정보를 관리하는 데 사용되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는이 클래스의 인스턴스를 초기화 하 고 사용 하 여 연결 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 인스턴스 개인 설정 작업을 수행 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyPersonalizationState">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>개인 설정 데이터를 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스에 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 컨트롤이나 특정 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 인스턴스에 적용합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ApplyPersonalizationState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ApplyPersonalizationState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ApplyPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ApplyPersonalizationState ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ApplyPersonalizationState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>개인 설정 데이터를 부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A> 속성이로 설정 되어 `true`,이 메서드를 호출는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ApplyWebPartPersonalization%2A> 메서드를는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> 인스턴스를 제공된 하는 웹 파트 컨트롤에 개인 설정 상태를 적용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">내부 데이터 저장소에서 로드하고 있는 상태에 개인 설정 상태를 적용하려 한 경우  
  
 \- 또는 -  
  
 데이터 저장소에서 반환된 개인 설정 상태가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ApplyPersonalizationState (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ApplyPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ApplyPersonalizationState(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ApplyPersonalizationState(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">개인 설정 데이터를 적용할 웹 파트 컨트롤입니다.</param>
        <summary>지정된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤에 개인 설정 데이터를 적용합니다. 이 작업은 부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 요청이 있을 때 수행됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개인 설정 데이터를 개별 적용 하려면이 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPart>-부모를 클래스를 파생 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A> 속성이로 설정 되어 `true`,이 메서드를 호출는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ApplyWebPartPersonalization%2A> 메서드를는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> 인스턴스를 제공된 하는 웹 파트 컨트롤에 개인 설정 상태를 적용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />가 관리하지 않는 웹 파트 컨트롤에 개인 설정 상태를 적용하려 한 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">내부 데이터 저장소에서 로드하고 있는 상태에 개인 설정 상태를 적용하려 한 경우  
  
 \- 또는 -  
  
 데이터 저장소에서 반환된 개인 설정 상태가 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 동일한 웹 파트 컨트롤에 개인 설정 데이터를 여러 차례 적용하려 한 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="CanEnterSharedScope">
      <MemberSignature Language="C#" Value="public bool CanEnterSharedScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnterSharedScope" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CanEnterSharedScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanEnterSharedScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanEnterSharedScope { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 범위에 진입하는 데 필요한 권한이 사용자에게 부여되어 있는지 나타내는 값을 반환합니다.</summary>
        <value>
          <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 범위에 진입하는 데 필요한 권한이 사용자에게 부여되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 `true` 사용자에 게 권한이 부여 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability> 입력 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 범위입니다.  
  
 처음으로 속성, 사용자의 오른쪽 입력에서 결정 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 범위가 지정 되 고 정보를 캐시 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.UserCapabilities%2A> 사전이 수정 된 후 처음으로이 속성이 호출 될,이 속성에 대 한 후속 호출에 변경 내용이 표시 되지 않습니다.  
  
   
  
## Examples  
 다음 코드에서는 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CanEnterSharedScope%2A> 속성입니다. 이 코드는에 큰 코드 샘플의 일부는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 클래스 설명 합니다.  
  
 [!code-csharp[WebParts_WebPartPersonalization#7](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#7)]
 [!code-vb[WebParts_WebPartPersonalization#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeScope">
      <MemberSignature Language="C#" Value="protected virtual void ChangeScope (System.Web.UI.WebControls.WebParts.PersonalizationScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ChangeScope(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ChangeScope(System.Web.UI.WebControls.WebParts.PersonalizationScope)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ChangeScope (scope As PersonalizationScope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ChangeScope(System::Web::UI::WebControls::WebParts::PersonalizationScope scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
      </Parameters>
      <Docs>
        <param name="scope">현재 페이지에 대한 새 개인 설정 범위입니다.</param>
        <summary>현재 페이지의 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 인스턴스를 지정된 범위로 변경합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 실행 중인 페이지의 개인 설정 범위를 지정 하는 새 범위를 변경는 `newScope` 매개 변수입니다. 이 메서드는 public에 의해 호출 되는 보호 된 도우미 메서드입니다 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 메서드. 이 보호 된 메서드를 전환 하려면 두 개 이상의 가능한 범위에 있는 경우 다음 버전의 확장을 처리할 수 있습니다.  
  
 하는 경우 현재 범위와 `newScope` 동일한 값은 다음이 메서드에서 아무런 작업도 수행 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 범위에서 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 범위로 전환하려 할 때 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 범위에 진입하기 위한 사용자 기능이 현재 사용자에게 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="scope" />가 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 열거형의 올바른 멤버가 아닌 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="CopyPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void CopyPersonalizationState (System.Web.UI.WebControls.WebParts.WebPart webPartA, System.Web.UI.WebControls.WebParts.WebPart webPartB);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CopyPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPart webPartA, class System.Web.UI.WebControls.WebParts.WebPart webPartB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CopyPersonalizationState (webPartA As WebPart, webPartB As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CopyPersonalizationState(System::Web::UI::WebControls::WebParts::WebPart ^ webPartA, System::Web::UI::WebControls::WebParts::WebPart ^ webPartB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartA" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="webPartB" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPartA">개인 설정 데이터를 적용하는 웹 파트 컨트롤입니다.</param>
        <param name="webPartB">개인 설정 데이터를 적용받는 웹 파트 컨트롤입니다.</param>
        <summary>웹 파트 컨트롤 하나에서 개인 설정 상태를 추출하고 이 상태를 두 번째 웹 파트 컨트롤에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 개인 설정 상태에서 추출 `webPartA` 에 적용 됩니다 `webPartB`합니다. 이 메서드는 가정 `webPartA` 및 `webPartB` 동일한 형식이 있습니다. 경우에 웹 파트 컨트롤 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤 메서드 개인 설정 상태에서 자식 컨트롤에 래핑된 복사 `webPartA` 자식 컨트롤에에 래핑된 `webPartB`합니다.  
  
 복사 작업의 일부로 `webPartB` "것"으로 표시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartA" /> 또는 <paramref name="webPartB" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartA" />와 <paramref name="webPartB" />의 <see cref="T:System.Type" />이 다른 경우  
  
 \- 또는 -  
  
 <paramref name="webPartA" />와 <paramref name="webPartB" />가 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤이지만 이 중 하나 또는 둘 다에 자식 컨트롤이 없는 경우  
  
 \- 또는 -  
  
 <paramref name="webPartA" />와 <paramref name="webPartB" />가 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤이지만 각 자식 컨트롤의 <see cref="T:System.Type" />이 다른 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public virtual bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 대해 개인 설정을 활성화하도록 요청했는지 나타내는 값을 반환합니다.</summary>
        <value>
          개인 설정이 활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 개인 설정 부모에 대해 사용 하도록 요청 되었는지 여부를 나타냅니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 이 중요 하지만 미묘한 차이가의 용도와 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsInitialized%2A>합니다.  
  
 이 속성의 완료 되기 전에 설정할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드. 실제로, 즉는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled%2A> 속성 해야에서 페이지 태그에서 설정할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 요소 개인 설정을 사용 하지 않도록 설정 해야 합니다. 하는 동안이 속성 또는 설정할 수는 `PreInit` 의 단계는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 메서드를 완료한 후에 이 속성 값을 설정하려 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureEnabled">
      <MemberSignature Language="C#" Value="public void EnsureEnabled (bool ensureModifiable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnsureEnabled(bool ensureModifiable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnsureEnabled(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnsureEnabled (ensureModifiable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnsureEnabled(bool ensureModifiable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ensureModifiable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ensureModifiable">수행할 검사 형식을 나타내는 부울 값입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스의 초기화가 완료되었는지 또는 개인 설정 상태를 수정하는 데 필요한 권한이 현재 사용자에게 있는지 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 몇 개에 사용 되는 도우미 메서드입니다 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 다음 두 가지 중 하나를 확인 하는 메서드:  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 인스턴스 초기화가 완료 (예를 들어는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> 메서드를 호출 하 고 성공적으로 완료 했습니다). 경우이 검사는 수행 된 `ensureModifiable` 매개 변수와 같으면 `false`합니다.  
  
     \- 또는 -  
  
-   현재 사용자에 게 개인 설정 상태를 수정할 권한이 있습니다. 경우에이 검사는 수행 `ensureModifiable` equals `true`합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 많은 경우에도이 메서드를 호출 합니다.  
  
-   표준 이외의 디스플레이 모드를 전환 합니다. 현재 사용자 개인 설정 상태를 수정할 권한이 있어야 합니다.  
  
-   추가, 삭제 또는 웹 파트 컨트롤을 이동 합니다. 현재 사용자 개인 설정 상태를 수정할 권한이 있어야 합니다.  
  
-   에 연결 하려면 연결을 해제 하 고 웹 파트 컨트롤을 편집 합니다. 현재 사용자 개인 설정 상태를 수정할 권한이 있어야 합니다.  
  
-   웹 파트를 내보내려면 페이지를 제어 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 인스턴스 초기화를 완료 해야 합니다.  
  
-   웹 파트를 가져올 제어 합니다. 현재 사용자 개인 설정 상태를 수정할 권한이 있어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">개인 설정 정보를 수정하는 데 필요한 권한이 현재 사용자에게 없거나 기타 검사에 실패한 경우  
  
 \- 또는 -  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled" />에서 <see langword="false" />을(를) 반환했습니다.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="EnterSharedScopeUserCapability">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartUserCapability EnterSharedScopeUserCapability;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartUserCapability EnterSharedScopeUserCapability" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EnterSharedScopeUserCapability As WebPartUserCapability " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartUserCapability ^ EnterSharedScopeUserCapability;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartUserCapability</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 범위에 진입하기 위한 사용자 권한의 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 인스턴스를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 권한을 "enterSharedScope" 문자열에 의해 표시 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability> 인스턴스.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ExtractPersonalizationState">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 개인 설정 데이터를 추출합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExtractPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ExtractPersonalizationState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ExtractPersonalizationState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ExtractPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ExtractPersonalizationState ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ExtractPersonalizationState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 개인 설정 데이터를 추출합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A> 속성이로 설정 되어 `true`, 페이지 요청 하는 동안 개인 설정 상태를 다시 설정 하지 않는 (예를 들어는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState%2A> 속성은 `false`),이 메서드는 부모 에서에서개인설정데이터를추출<xref:System.Web.UI.WebControls.WebParts.WebPartManager>제어 하는 동안 해당 <xref:System.Web.UI.Page.SaveStateComplete> 이벤트입니다.  
  
 이 메서드를 호출는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ExtractWebPartManagerPersonalization%2A> 에서 메서드는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> 부모에서 개인 설정 상태를 추출 하는 인스턴스 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">내부 데이터 저장소에서 로드하고 있는 상태에 개인 설정 상태를 추출하려 한 경우  
  
 \- 또는 -  
  
 개인 설정 상태가 아직 적용되지 않은 경우  
  
 \- 또는 -  
  
 개인 설정 데이터를 적용한 이후 <see cref="P:System.Web.UI.Control.ID" />의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />가 변경된 경우  
  
 \- 또는 -  
  
 데이터 저장소에서 반환된 개인 설정 상태가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="ExtractPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ExtractPersonalizationState (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ExtractPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ExtractPersonalizationState(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ExtractPersonalizationState(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">추출할 개인 설정 데이터가 들어 있는 웹 파트 컨트롤입니다.</param>
        <summary>웹 파트 컨트롤에서 개인 설정 데이터를 추출합니다. 이 작업은 부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 요청이 있을 때 수행됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A> 속성이 `true`, 페이지 요청 하는 동안 개인 설정 상태를 다시 설정 하지 않는 (예를 들어는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState%2A> 속성은 `false`),이 메서드는 웹 파트 컨트롤에서 개인 설정 데이터를 추출 합니다. 에 지정 된 `webPart`합니다. 이 메서드를 호출는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ExtractWebPartPersonalization%2A> 에서 메서드는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> 인스턴스는 제공 된 웹 파트 컨트롤에서 개인 설정 상태를 추출 하 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />가 관리하지 않는 웹 파트 컨트롤에서 개인 설정 상태를 추출하려 한 경우</exception>
        <exception cref="T:System.InvalidOperationException">내부 데이터 저장소에서 로드하고 있는 상태에 개인 설정 상태를 추출하려 한 경우  
  
 \- 또는 -  
  
 개인 설정 상태가 아직 적용되지 않은 경우  
  
 \- 또는 -  
  
 개인 설정 데이터를 적용한 이후 <see cref="P:System.Web.UI.Control.ID" />의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />가 변경된 경우  
  
 \- 또는 -  
  
 데이터 저장소에서 반환된 개인 설정 상태가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationFilter">
      <MemberSignature Language="C#" Value="protected internal virtual string GetAuthorizationFilter (string webPartID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetAuthorizationFilter(string webPartID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.GetAuthorizationFilter(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetAuthorizationFilter (webPartID As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetAuthorizationFilter(System::String ^ webPartID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartID">검색할 필터에 연결된 웹 파트 컨트롤의 ID입니다.</param>
        <summary>지정한 웹 파트 컨트롤에 연결된 권한 부여 필터가 있는 경우 이 필터를 검색합니다.</summary>
        <returns>지정한 웹 파트 컨트롤에 대한 권한 부여 필터입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 연결로 식별 되는 웹 파트 컨트롤 된 경우 권한 부여 필터를 검색 `webPartID`합니다. 직렬화 되 고 개인 설정 하 여 관리 되는 각 웹 파트 컨트롤 연관는 `webPartID` 매개 변수입니다. 런타임 시 페이지의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 각 웹 파트 컨트롤 수 있는 권한이 있는지 확인 하 여 페이지에 표시 되는 컨트롤을 필터링 할 수 있습니다. 이 인증 정보는 각 웹 파트 컨트롤에 연결 된 데이터에서를 문자열로 저장 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">페이지 주기에서 이 메서드를 너무 일찍 호출하여 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled" />가 <see langword="false" />인 상태에서 권한 부여 필터를 검색하려 한 경우  
  
 \- 또는 -  
  
 권한 부여 필터를 검색하려 했지만 개인 설정 상태가 로드되지 않은 경우  
  
 \- 또는  
  
 데이터 저장소에서 반환된 개인 설정 상태가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartID" />이 <see langword="null" /> 또는 빈 문자열("")인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="HasPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual bool HasPersonalizationState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasPersonalizationState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.HasPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasPersonalizationState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasPersonalizationState { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 페이지와 개인 설정 범위에 연결된 개인 설정 데이터가 있는지 나타내는 값을 반환합니다.</summary>
        <value>
          페이지에 연결된 개인 설정 데이터가 있는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이것이 현재 페이지와 범위의 조합에 연관 된 개인 설정 데이터가 있는지 여부를 확인 하기 위한 편리한 방법입니다. 메서드 호출을 내부적으로 <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState%2A> 공급자 데이터가 있는지 여부를 확인 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스와 연결된 개인 설정 공급자가 없는 경우. 이러한 상황은 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 메서드를 완료하기 전에 속성에 액세스한 경우에 발생할 수 있습니다.  
  
 \- 또는 -  
  
 연결된 <see cref="P:System.Web.UI.Control.Page" />의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 속성 값이 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 컨트롤의 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.Page" /> 속성의 값이 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="InitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope InitialScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope InitialScope" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property InitialScope As PersonalizationScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::PersonalizationScope InitialScope { System::Web::UI::WebControls::WebParts::PersonalizationScope get(); void set(System::Web::UI::WebControls::WebParts::PersonalizationScope value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>기본 개인 설정 범위를 가져오거나 설정합니다.</summary>
        <value>연결된 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />의 기본 개인 설정 범위를 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 부모에 사용 해야 하는 기본 개인 설정 범위 나타냅니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 적절 한 범위에 대 한 이전 지식이 없는 경우에는 제어 합니다. 이 속성을 명시적으로 설정 하지 기본값으로 반환 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 범위입니다.  
  
 이 속성의 완료 되기 전에 설정할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드. 즉, 사실상 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> 에 페이지 태그에서 설정할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 요소입니다. 하는 동안이 속성 또는 설정할 수는 `PreInit` 의 단계는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 메서드를 완료한 후에 현재 값이 아닌 다른 값으로 이 속성을 설정하려 한 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope" /> 열거형의 멤버가 아닌 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />의 값으로 설정하려 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개인 설정을 활성화하고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 클래스의 이 인스턴스에 대해 개인 설정 데이터를 성공적으로 로드했는지 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스에 대해 개인 설정을 활성화하고 개인 설정 데이터를 성공적으로 로드한 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 항상 개인 설정 데이터를 로드 하기 전에 반환 `false`합니다. 이 속성은 반환 하는 예를 들어 `false` 중의 `PreInit` 단계입니다. 연결 된 후 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드가 성공적으로 완료 (입니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> 메서드는),이 속성은 다음 반환 `true`합니다.  
  
 이 속성은 보호 된 항목에 대 한 공개적으로 액세스할 수 있는 별칭 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsInitialized%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="protected bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개인 설정을 활성화하고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 클래스의 이 인스턴스에 대해 개인 설정 데이터를 성공적으로 로드했는지 나타내는 값을 가져옵니다.</summary>
        <value>
          이 인스턴스에 대해 개인 설정이 초기화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개인 설정 기능이 활성화 된 경우 (하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled%2A> 속성이 `true`), <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 인스턴스는 연결 된 직후에 초기화 된 것으로 간주 됩니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드가 (성공적으로 완료 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> 메서드는). 개인 설정 데이터를 로드 하기 전에이 속성은 항상 반환 `false`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsModifiable">
      <MemberSignature Language="C#" Value="public bool IsModifiable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsModifiable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsModifiable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsModifiable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsModifiable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>상태 정보를 수정하는 데 필요한 권한이 현재 사용자에게 부여되어 있는지 나타내는 값을 가져옵니다.</summary>
        <value>
          상태 정보를 수정하는 데 필요한 권한이 사용자에게 부여되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 호출할 처음으로 개인 설정 상태를 수정 하는 사용자의 권한을 확인 한 결과가 캐시 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.UserCapabilities%2A> 사전 처음이 속성이이 호출 된 후 수정 되 면 변경 내용이 반영 되지 않습니다이 속성에 대 한 후속 호출 합니다.  
  
   
  
## Examples  
 다음 코드에서는 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsModifiable%2A> 속성입니다. 이 코드는에 큰 코드 샘플의 일부는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 클래스 설명 합니다.  
  
 [!code-csharp[WebParts_WebPartPersonalization#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#6)]
 [!code-vb[WebParts_WebPartPersonalization#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.PersonalizationScope Load ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Load () As PersonalizationScope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope Load();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>개인 설정을 초기화합니다.</summary>
        <returns>부모 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 부모를 대신 하 여 개인 설정 정보를 초기화 하기 위한 주 진입점 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 이 메서드는 부모 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드. 일반적으로 부모에서 해제 되어이 개인 설정 하는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤,이 메서드는 호출 되지 않습니다.  
  
 이 메서드는 동안 다음 초기화가 발생합니다.  
  
-   에 표시 된 기본 개인 설정 공급자 또는 사용자 지정 공급자에 대 한 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 페이지 태그 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName%2A> 속성을 가져옵니다.  
  
-   공급자 사용자 기능을 결정 하기 위해 호출 됩니다 (<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities%2A>) 현재 실행 중인 사용자에 대 한 합니다.  
  
-   현재 페이지/사용자/범위의 조합에 대 한 개인 설정 상태 공급자가 기본 데이터 저장소에서 로드 되 (<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A>) 내에 저장 된 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 인스턴스.  
  
-   현재 페이지/사용자/범위에 대 한 개인 설정 범위는 공급자에 의해 결정 됩니다 (<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope%2A>). 이 결정의 결과 수의 값 보다 다 수의 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> 속성입니다.  
  
 이 메서드에서 반환 되는 범위 값에 대 한 값으로 사용 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> 속성입니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 예외 개인 설정이 활성화 되지 않은 경우에 발생 합니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> 메서드는 직접 호출 합니다. ASP.NET 구현에서 로드를 수행 하는 내부 도우미 메서드가 실제로 호출 하 고이 도우미 메서드는 개인 설정 페이지에 대해 설정 되지 않은 경우 자동으로 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">개인 설정이 활성화되지 않은 상태 즉, <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled" />가 <see langword="false" />인 상태에서 이 메서드를 호출한 경우  
  
 \- 또는 -  
  
 연결된 <see cref="P:System.Web.UI.Control.Page" />의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 속성 값이 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 컨트롤의 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.Page" /> 속성의 값이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">페이지 태그나 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName" /> 속성에 공급자가 명시적으로 설정되어 있지만 공급자를 찾을 수 없는 경우  
  
 \- 또는 -  
  
 개인 설정 상태 데이터를 포함하는 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">데이터를 로드하고 deserialize하는 동안 문제가 발생한 경우  
  
 \- 또는 -  
  
 구성 파일에서 개인 설정 공급자의 정의에 오류가 발생한 경우</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">기본 공급자를 찾을 수 없거나 개인 설정 공급자를 초기화하는 동안 문제가 발생하여 내부 개인 설정 공급자를 초기화하지 못한 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="ModifyStateUserCapability">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartUserCapability ModifyStateUserCapability;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartUserCapability ModifyStateUserCapability" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ModifyStateUserCapability As WebPartUserCapability " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartUserCapability ^ ModifyStateUserCapability;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartUserCapability</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개인 설정 상태를 수정하기 위한 사용자 권한의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 인스턴스를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 권한을 "modifyState" 문자열에 의해 표시 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability> 인스턴스.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="ProviderName">
      <MemberSignature Language="C#" Value="public virtual string ProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개인 설정의 공급자 이름을 가져오거나 설정합니다.</summary>
        <value>개인 설정 공급자의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 페이지 선언에서이 속성에 설정 된 값을 반환 합니다. 반환 하는 경우에이 속성이 설정 되지 않은, <xref:System.String.Empty>합니다. 이 경우 페이지에서 구성 파일에 지정 된 기본 개인 설정 공급자를 사용 합니다.  
  
 이 속성의 완료 되기 전에 설정할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드. 즉,는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName%2A> 속성 페이지 선언에서에 설정 해야 합니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 요소입니다.  하는 동안이 속성 또는 설정할 수는 `PreInit` 단계입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 메서드를 완료한 후에 현재 값이 아닌 다른 값으로 이 속성을 설정하려 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ResetPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetPersonalizationState ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>내부 데이터 저장소에서 현재 페이지, 범위 및 사용자에 대한 개인 설정 데이터를 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 페이지, 범위 및 내부 데이터 저장소에서 사용자에 대 한 개인 설정 데이터를 다시 설정합니다. 재설정의 부작용을으로 현재 실행 중인 페이지는 다시 실행 하 여 한 <xref:System.Web.HttpServerUtility.Transfer%2A> 호출 합니다. 이 명령으로 현재 페이지를 다시 실행 한 `GET` 페이지 원래 요청 된 방식에 관계 없이 요청 합니다.  
  
 언제 든 지가이 메서드를 호출할 수 있습니다. 이 메서드를 호출 내부적으로 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ResetPersonalizationState%2A> 메서드는 공급자에 합니다. 데이터를 성공적으로 다시 설정는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState%2A> 속성이 `true`합니다. 이 속성은 다른 곳에서 사용 된 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 컨트롤 속성에서 개인 설정 데이터를 압축 해제 하지 않으려면 인스턴스 및 데이터 이미 다시 설정 하는 경우 저장 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스가 유효한 개인 설정 공급자를 참조할 수 없는 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="protected virtual void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Save" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Save();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 페이지, 범위 및 사용자에 대한 개인 설정 데이터를 내부 데이터 저장소에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 <xref:System.Web.UI.Page.SaveStateComplete> 이벤트입니다. 내부적으로 메서드 호출에서 <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState%2A> 메서드는 공급자에 있습니다.  
  
 현재 실행 중인 사용자가 호출 하는 기능이 없는 경우 개인 설정 데이터를 저장 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> (현재 <xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability> 인스턴스)의 결과 <xref:System.InvalidOperationException> 예외입니다. 이 것만 수 true 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 보호 된 라는 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Save%2A> 메서드를 직접 합니다. ASP.NET 구현에서 저장을 수행 하는 내부 도우미 메서드가 실제로 호출 되 고이 도우미 메서드는 현재 실행 중인 사용자에 게 데이터를 수정 하는 경우 권한이 자동으로 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 사용자에게 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability" />라는 기능이 없는 경우  
  
 \- 또는 -  
  
 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스가 유효한 개인 설정 공급자를 참조할 수 없는 경우  
  
 \- 또는 -  
  
 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스와 현재 연결된 개인 설정 공급자가 없는 경우. 이 상황은 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load" />를 호출하기 전에 이 메서드를 호출한 경우에 발생할 수 있습니다. 개인 설정 공급자 참조는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load" />에 대한 호출 과정에서 가져옵니다.  
  
 \- 또는 -  
  
 개인 설정 상태를 로드하지 않은 경우  
  
 \- 또는 -  
  
 연결된 <see cref="T:System.Web.UI.Page" />의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스가 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 컨트롤의 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.Page" /> 속성의 값이 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationScope Scope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope Scope" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scope As PersonalizationScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationScope Scope { System::Web::UI::WebControls::WebParts::PersonalizationScope get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 대한 현재 개인 설정 범위를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />의 범위를 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 값은 기반으로 초기 설정에서 반환 된 값은 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> 메서드. 호출 하 여이 값을 수정할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 메서드.  
  
 이 적용 하 고 개인 설정 정보를 추출에 사용 되는 범위는 note 합니다. 이 속성의 값에서 다를 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> 속성 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ChangeScope%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetDirty">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 변경된 개인 설정 데이터가 있는 것으로 표시합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetDirty">
      <MemberSignature Language="C#" Value="protected internal virtual void SetDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SetDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.SetDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SetDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SetDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 변경된 개인 설정 데이터가 있는 것으로 표시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A> 속성이 `true`,이 메서드는 부모 표시 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> "더티"로 제어 합니다. 구현 세부 정보에 따라는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 의 컨트롤의 인스턴스 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>,이 메서드 코드 액세스 보안 권한 검사 및 보안 검사를 호출할 수 있습니다. 이 메서드를 호출 내부적으로 <xref:System.Web.UI.WebControls.WebParts.PersonalizationState.SetWebPartManagerDirty%2A> 메서드.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 "더티" 상태를 내부적으로 추적을 통해 관리자의 "dirtiness"를 표시는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성 대신이 메서드를 통해 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">개인 설정 데이터를 로드하지 않은 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="SetDirty">
      <MemberSignature Language="C#" Value="protected internal virtual void SetDirty (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SetDirty(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.SetDirty(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SetDirty(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">변경된 것으로 표시할 웹 파트 컨트롤입니다.</param>
        <summary>지정된 웹 파트 컨트롤에 변경된 개인 설정 데이터가 있는 것으로 표시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A> 속성이 `true`,이 메서드는 지정 된 웹 파트 컨트롤 "더티"으로 표시 합니다. 구현 세부 정보에 따라는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 의 컨트롤의 인스턴스 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>,이 메서드 코드 액세스 보안 권한 검사 및 보안 검사를 호출할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />에서 관리하지 않는 웹 파트 컨트롤을 변경된 것으로 표시하려는 경우</exception>
        <exception cref="T:System.InvalidOperationException">개인 설정 데이터를 로드하지 않은 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="ShouldResetPersonalizationState">
      <MemberSignature Language="C#" Value="protected bool ShouldResetPersonalizationState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldResetPersonalizationState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Protected Property ShouldResetPersonalizationState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ShouldResetPersonalizationState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>내부 데이터 저장소에서 개인 설정 데이터를 삭제하도록 요청한 경우와 같이 현재 페이지의 개인 설정 데이터가 다시 설정되었는지 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          현재 페이지에 대한 개인 설정 상태가 다시 설정된 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 `true`, 현재 페이지에 대 한 개인 설정 상태를 다시 설정 하 고 개인 설정 데이터의 추출 컨트롤 및 이후의 저장 작업을 건너뛰도록 나타냅니다. 현재,이 속성이 자동으로 설정 되어 `true` 개인 설정 인프라에 의해 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ResetPersonalizationState%2A> 메서드를 호출 합니다.  
  
 이 속성을 설정할 수 있습니다에 제한이 없지만 속성 설정 해야 `true` 이전에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 <xref:System.Web.UI.Page.SaveStateComplete> 를 사용 하려면 이벤트입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleScope">
      <MemberSignature Language="C#" Value="public virtual void ToggleScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ToggleScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ToggleScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 페이지의 개인 설정 범위를 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />에서 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />로 또는 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />에서 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />로 전환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 실행 중인 페이지의 개인 설정 범위를 전환합니다. 결과 범위를 설정/해제는 <xref:System.Web.HttpServerUtility.Transfer%2A> 현재 실행 중인 페이지에 다시 합니다.  
  
 이 이렇게 하면 아무런 작업도 수행 발생 하는 웹 파트 컨트롤의 가져오기 또는 내보내기 하는 동안 호출 됩니다.  
  
 토글 범위 요청을 통해 제출 된 페이지에 대 한 발생 하는 경우는 `POST` 모든 쿼리 문자열 값 다음 요청을 전송 하는 동안 유지 됩니다; 쿼리 문자열 매개 변수 페이지를 통해 전송 된 경우 유지 되지 않습니다는 `GET` 요청 합니다.  
  
   
  
## Examples  
 다음 코드에서는 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 메서드. 이 코드는에 큰 코드 샘플의 일부는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 클래스 설명 합니다.  
  
 [!code-csharp[WebParts_WebPartPersonalization#7](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#7)]
 [!code-vb[WebParts_WebPartPersonalization#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 범위에서 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 범위로 전환하려 할 때 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 범위에 진입하기 위한 사용자 기능이 현재 사용자에게 없는 경우  
  
 \- 또는 -  
  
 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 인스턴스의 초기화가 완료되지 않은 경우  
  
 \- 또는 -  
  
 연결된 <see cref="T:System.Web.UI.Page" />의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스가 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 컨트롤의 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.Page" /> 속성의 값이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 열거형에 정의되지 않은 범위로 전환하려 한 경우. 기술적으로 이 상황은 발생하지 않습니다.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="UserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary UserCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary UserCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.UserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property UserCapabilities As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Collections::IDictionary ^ UserCapabilities { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 사용자에게 부여되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />의 사용자 기능을 가져오거나 설정합니다.</summary>
        <value>현재 사용자에게 부여된 사용자 기능 집합이 들어 있는 <see cref="T:System.Collections.IDictionary" />이거나, 사용자가 익명인 경우 빈 <see cref="T:System.Collections.Specialized.HybridDictionary" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재는 <xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability> 사용자의 기능을 나타내는 두 개의 값을 포함 하는 클래스: `modifyState` 및 `enterSharedScope`합니다. 경우 사용 편의성에 대 한 사전 내에 포함 된 기능으로 확인할 수 있습니다 도우미 속성 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsModifiable%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CanEnterSharedScope%2A>합니다. 이러한 속성에 액세스 한; 후 기능 변경에 대 한 제한 note 자세한 내용은 각 속성의 설명 섹션을 참조 하십시오.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="WebPartManager">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManager WebPartManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManager WebPartManager" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.WebPartManager" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WebPartManager As WebPartManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManager ^ WebPartManager { System::Web::UI::WebControls::WebParts::WebPartManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스에 연결된 현재 부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 컨트롤의 인스턴스를 가져옵니다.</summary>
        <value>현재 부모 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하 여 확인 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 의이 인스턴스와 연결 된 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
  </Members>
</Type>