<Type Name="IPersonalizable" FullName="System.Web.UI.WebControls.WebParts.IPersonalizable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c234e1e63b44473d91af87545b888d2b3930a23" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30590047" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>개인 설정 상태의 적용과 추출을 위한 추가 관리 기능을 정의합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 외에 `Personalizable` 특성 컨트롤 속성에 컨트롤을 구현할 수도 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 개인 설정 상태를 추출 하 고 응용 프로그램에 대 한 추가 관리 기능에 대 한 합니다. 예를 들어 개인 상태 정보를 관리 해야 하는 컨트롤은이 인터페이스를 구현 해야 합니다. 사용자 지정 캐시 솔루션, 메인프레임 또는 XML Web services를 데이터 지 속성 같은 복잡 한 메커니즘을 통해 개인 설정 된 데이터에 액세스 하는 컨트롤이이 인터페이스를 구현 해야 합니다.  
  
> [!IMPORTANT]
>  하지 App_Code 디렉터리에 정의 된 클래스에 기반 하는 형식을 추가 해야 하며 다음 기본 이진 serialization 메커니즘에 따라 달라 집니다. App_Code 기반 아티팩트 때문를 시간에 임의의 시점에 변경 된 어셈블리 이름을 보유할 수 있는 이진 직렬화 가능 일관 되 게 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 인터페이스입니다. 이 예제에서는 라는 웹 파트 컨트롤을 참조 하는.aspx 페이지 이루어져 `UrlListWebPart`합니다. 다음 코드는.aspx 파일 예제에 대 한 합니다.  
  
 [!code-aspx-csharp[WebParts_IPersonalizable_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/IPersonalizableCS.aspx#1)]
 [!code-aspx-vb[WebParts_IPersonalizable_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/IPersonalizableVB.aspx#1)]  
  
 다음 코드는 사용자 지정에 대 한 소스 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 이 파일을 App_Code 디렉터리에 저장 되어야 합니다.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 브라우저에서 페이지를 로드 합니다. 이름 입력 한 URL을 나타내는 다음 추가로 시작 하는 실제 URL `http://`를 클릭 하 고는 **추가** URL을 추가 하려면 단추입니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 관리하는 사용자 지정 데이터가 변경되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" /> 인터페이스로 관리되는 사용자 지정 데이터가 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에 의해 관리 되는 데이터 변경 될 때 컨트롤 것으로 간주 됩니다 "더티"입니다. 컨트롤은 반환 `true` 경우 사용자 지정 데이터 통해 관리 하는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 인터페이스가 변경 되었습니다. 컨트롤을 반환 하는 경우 `true` 에서이 속성을 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> 인터페이스 메서드 구현이 속성 값을 추출 하는 동안 호출 됩니다.  
  
> [!NOTE]
>  이 속성은 POST 요청을 처리 하는 두 번째 단계 동안 개인 설정 인프라에서 자동으로 검사 됩니다. 그러나 GET 요청에 대해 반환 되는 값에서는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성은 확인 되지 않습니다. 인해 발생 했을 관리 하는 데이터 뿐 아니라 제어 상태-"더티" 것으로 간주 되려면 컨트롤에 대 한 다른 이벤트 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable>-를 저장 합니다. GET 요청을 사용 하는 동안 컨트롤 자체 "변경"으로 표시 또는 조건에 따라 매우 구체적인 경계 개인 설정 인프라에서 컨트롤 "더티" GET 요청을 사용 하는 동안 다음 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> 가 항상 호출 됩니다.  
  
 컨트롤을 연결 된 참조할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하 고 확인는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> 속성을 현재 범위를 결정 합니다. 컨트롤의 사용자 지정 데이터의 "변경" 상태는 현재 범위에 대 한 적합 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 사용을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성입니다. 예제의 첫 번째 부분은 호스팅하는 웹 페이지는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
 [!code-aspx-csharp[WebParts_IPersonalizable_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/IPersonalizableCS.aspx#1)]
 [!code-aspx-vb[WebParts_IPersonalizable_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/IPersonalizableVB.aspx#1)]  
  
 예제의 두 번째 부분은 사용자 지정에 대 한 코드 <xref:System.Web.UI.WebControls.WebParts.WebPart> 이라는 컨트롤 `UrlListWebPart`합니다. 예를 실행 하려면 App_Code 디렉터리에이 파일을 저장 되어야 합니다. 소스 코드를 구현 하는 참고는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성입니다.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 브라우저에서 페이지를 로드 합니다. 이름 입력 한 URL을 나타내는 다음 추가로 시작 하는 실제 URL `http://`를 클릭 하 고는 **추가** URL을 추가 하려면 단추입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">내부 데이터 저장소에서 로드된 사용자 지정 범위의 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary>사용자 지정 데이터를 컨트롤로 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용자 지정 데이터 자체를 로드할 수 있도록 허용 하는 컨트롤에서 호출 됩니다. 내부 데이터 저장소 페이지에서 다른 개인 설정 데이터가 변경 되었는지 여부에 관계 없이 컨트롤의 사용자 지정 상태를 다시 써야 있는지 여부를 나타내는 값을 반환할 수 있습니다. 컨트롤 자체 사용자 지정 속성을 설정할 수 있으며 개인 설정 사전에 포함 된 값을 기반으로 하는 추가 내부 논리를 수행 합니다. 이 메서드는 웹 파트 컨트롤 컨트롤에 개인 설정 데이터를 적용 하는 동안 집합에서 호출 됩니다.  
  
 또한 병합 동작을 알고 있어야 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-대 범위 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>-범위에 포함 된 속성의 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 개체입니다. `state` 매개 변수는 내부 데이터 저장소에서 로드 된 사용자 지정 데이터의 병합 된 표시를 포함 합니다. <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 페이지 자체에 있을 때 이전에 추가 된 모든 값의 범위, <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 범위에서 확인할 수 있습니다. <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 범위에서는 관련 된 값 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 개인 설정 범위에 하나의 값에는 페이지는 추가 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 범위 및 페이지에 있을 때 다른 값을 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 개인 설정 인프라는 다음 범위 포함는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-범위 값 (반대인는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 값의 범위) 내에서 `state` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 구현을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> 메서드가 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 이 예제를 실행 하는 데 필요한 전체 코드는 예제 섹션을 참조는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 클래스 개요입니다.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">내부 데이터 저장소에서 로드된 사용자 지정 범위의 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary>사용자 지정 속성과 내부 상태 정보를 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> 개체에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서버 컨트롤 자체 사용자 지정 속성 및 내부 상태 정보를 저장할 수는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 에 지정 된는 `state` 매개 변수입니다. 정보를 일련의 이름/값 쌍으로 저장 됩니다. 통해 컨트롤에 대 한 다음 호출에서 인식할 수 있는 이름/값 쌍을 사용 하도록 컨트롤 작업은는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> 메서드.  
  
 컨트롤을 연결 된 참조할 수 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하 고 확인는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope> 현재 범위를 결정 하는 개체입니다. 사용자 지정 상태 정보는 현재 범위에 적절 해야 합니다. 각 <xref:System.Web.UI.WebControls.WebParts.PersonalizationEntry> 값에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 개인 설정 인프라를 병합할 때이에 따라 다르기 때문에 개체는 적절 한 범위 값에 연결 해야 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 및 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-사용자 지정 데이터 범위 지정 로 전달 하기 전에 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> 메서드.  
  
 웹 파트의 표준 ASP.NET 구현을 사용 하는 경우 컨트롤 ASP.NET에서 상태 사전에 저장 된 개체를 serialize 할 수 있는지 확인 해야 <xref:System.Web.UI.ObjectStateFormatter> 클래스입니다. 실제로, 다음으로 의미합니다.  
  
-   기본.NET Framework 형식, 문자열 및 배열, 배열, 해시 테이블 목록과 하이브리드 사전 같은 컬렉션 관련.NET Framework 형식을 자동으로 직렬화 됩니다.  
  
-   자신의 제공 사용자 지정 형식을 <xref:System.ComponentModel.TypeConverter> 클래스에 대 한 직렬화 하 고 문자열에서 역직렬화 할 수 있는 직렬화 가능한 것으로 간주 됩니다.  
  
-   사용자 지정 형식으로 serialize 할 수 있는 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 클래스 직렬화 가능한 것으로 간주 됩니다.  
  
> [!IMPORTANT]
>  하지 App_Code 디렉터리에 정의 된 클래스에 기반 하는 형식을 추가 해야 하며 다음 기본 이진 serialization 메커니즘에 따라 달라 집니다. App_Code 기반 아티팩트 때문를 시간에 임의의 시점에 변경 된 어셈블리 이름을 보유할 수 있는 이진 직렬화 가능 일관 되 게 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> 메서드가 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 이 예제를 실행 하는 데 필요한 전체 코드는 예제 섹션을 참조는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 클래스 개요입니다.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>