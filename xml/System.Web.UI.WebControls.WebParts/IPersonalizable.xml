<Type Name="IPersonalizable" FullName="System.Web.UI.WebControls.WebParts.IPersonalizable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3f16c2b1e76c9b648c236812e7491d0fd55179e0" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37595520" /></Metadata><TypeSignature Language="C#" Value="public interface IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPersonalizable" />
  <TypeSignature Language="F#" Value="type IPersonalizable = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="731eb-101">개인 설정 상태의 적용과 추출을 위한 추가 관리 기능을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-101">Defines additional management capabilities for the application and extraction of personalization state.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="731eb-102">사용 하는 것 외에도 합니다 `Personalizable` 특성 컨트롤 속성에 컨트롤을 구현할 수도 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 응용 프로그램 및 개인 설정 상태를 추출 하기 위한 추가 관리 기능에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-102">In addition to using the `Personalizable` attribute on control properties, a control can also implement <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> for additional management capabilities for the application and extraction of personalization state.</span></span> <span data-ttu-id="731eb-103">예를 들어 개인 상태 정보를 관리 해야 하는 컨트롤은이 인터페이스를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-103">For example, controls that need to manage private state information should implement this interface.</span></span> <span data-ttu-id="731eb-104">컨트롤 사용자 지정 캐시 솔루션, 메인프레임 또는 XML Web services에 데이터 지 속성 등의 복잡 한 메커니즘을 통해 개인 설정된 데이터에 액세스 하는이 인터페이스를 구현도 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-104">Controls that access personalized data through complex mechanisms, such as custom cache solutions, data persistence to mainframes, or XML Web services, should also implement this interface.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="731eb-105">하지 App_Code 디렉터리에 정의 된 클래스를 기반으로 하는 형식을 추가 해야 하며 그런 다음 기본 이진 serialization 메커니즘에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-105">You should not add types based on classes defined in the App_Code directory and then depend on the default binary serialization mechanism.</span></span> <span data-ttu-id="731eb-106">App_Code 기반 아티팩트가 하지 이진 직렬화 일관 되 게 때문에 시간에서 임의 지점에서 변경 어셈블리 이름을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-106">App_Code-based artifacts are not consistently binary-serializable due to the fact that they can have their assembly names changed at random points in time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="731eb-107">다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-107">The following code example demonstrates how to use the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> interface.</span></span> <span data-ttu-id="731eb-108">예제는 라는 웹 파트 컨트롤을 참조 하는.aspx 페이지로 구성 됩니다 `UrlListWebPart`합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-108">The example consists of an .aspx page that references a Web Part control named `UrlListWebPart`.</span></span> <span data-ttu-id="731eb-109">다음 코드는.aspx 파일의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-109">The following code is the .aspx file for the example.</span></span>  
  
 [!code-aspx-csharp[WebParts_IPersonalizable_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/IPersonalizableCS.aspx#1)]
 [!code-aspx-vb[WebParts_IPersonalizable_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/IPersonalizableVB.aspx#1)]  
  
 <span data-ttu-id="731eb-110">다음 코드는 사용자 지정 원본 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-110">The following code is the source for the custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control.</span></span> <span data-ttu-id="731eb-111">이 파일을 App_Code 디렉터리에 배치 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-111">This file should be placed in the App_Code directory.</span></span>  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 <span data-ttu-id="731eb-112">브라우저에서 페이지를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-112">Load the page in a browser.</span></span> <span data-ttu-id="731eb-113">로 시작 하는 실제 URL을 추가 하 고 URL을 나타내는 이름 입력 `http://`를 클릭 합니다 **추가** URL 추가 단추입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-113">Type in a name to represent a URL, then add an actual URL beginning with `http://`, and click the **Add** button to add the URL.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="731eb-114">컨트롤에서 관리하는 사용자 지정 데이터가 변경되었는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-114">Gets a value that indicates whether the custom data that a control manages has changed.</span></span></summary>
        <value><span data-ttu-id="731eb-115"><see cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" /> 인터페이스로 관리되는 사용자 지정 데이터가 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-115"><see langword="true" /> if the custom data managed with the <see cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" /> interface has changed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="731eb-116">컨트롤에서 관리 되는 데이터가 변경 된 경우 컨트롤 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-116">When data managed by a control has changed, the control is considered "dirty."</span></span> <span data-ttu-id="731eb-117">컨트롤을 반환할지 `true` 경우 사용자 지정 데이터를 통해 관리 하는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 인터페이스가 변경 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-117">A control should return `true` if the custom data that it manages through the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> interface has changed.</span></span> <span data-ttu-id="731eb-118">컨트롤을 반환 하는 경우 `true` 에서이 속성을 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> 인터페이스 메서드 구현 속성 값을 추출 하는 동안 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-118">If a control returns `true` from this property, the control's <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> interface method implementation is called during property value extraction.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="731eb-119">이 속성은 POST 요청을 처리 하는 두 번째 단계 동안 개인 설정 인프라에 의해 자동으로 검사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-119">This property is checked automatically by the personalization infrastructure during the latter phases of processing a POST request.</span></span> <span data-ttu-id="731eb-120">그러나 GET 요청에 대해 반환 되는 값에서는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성을 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-120">However, for GET requests, the value returned from the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> property is not checked.</span></span> <span data-ttu-id="731eb-121">일부 다른 이벤트에 "더티"에서 관리 하는 데이터 뿐 아니라 컨트롤 상태-간주 되기 위해 컨트롤을 유발한 것으로 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable>-저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-121">Some other event has to have caused the control to be considered "dirty" for any control state--not just data managed by <xref:System.Web.UI.WebControls.WebParts.IPersonalizable>--to be saved.</span></span> <span data-ttu-id="731eb-122">컨트롤을 표시할 수 자체적으로 "더티" GET 요청을 하는 동안 일부 매우 구체적인 경계 조건에서 개인 설정 인프라 고려 컨트롤 "더티" GET 요청을 하는 동안 다음 아니면 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> 가 항상 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-122">If a control can mark itself as "dirty" during a GET request, or if the personalization infrastructure under some very specific boundary conditions considers a control "dirty" during a GET request, then <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> will always be called.</span></span>  
  
 <span data-ttu-id="731eb-123">컨트롤 관련 참조할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하 고 확인을 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> 속성을 현재 범위를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-123">A control can reference its associated <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control and check the <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> property to determine the current scope.</span></span> <span data-ttu-id="731eb-124">컨트롤의 사용자 지정 데이터의 "더티" 상태는 현재 범위에 대 한 적합 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-124">The "dirty" state of a control's custom data should be appropriate for the current scope.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="731eb-125">다음 코드 예제에는 사용 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-125">The following code example demonstrates use of the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> property.</span></span> <span data-ttu-id="731eb-126">예제의 첫 번째 부분은 호스팅하는 웹 페이지를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-126">The first part of the example is the Web page that hosts a <xref:System.Web.UI.WebControls.WebParts.WebPart> control.</span></span>  
  
 [!code-aspx-csharp[WebParts_IPersonalizable_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/IPersonalizableCS.aspx#1)]
 [!code-aspx-vb[WebParts_IPersonalizable_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/IPersonalizableVB.aspx#1)]  
  
 <span data-ttu-id="731eb-127">예제의 두 번째 부분은 사용자 지정 코드 <xref:System.Web.UI.WebControls.WebParts.WebPart> 이라는 컨트롤 `UrlListWebPart`합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-127">The second part of the example is the code for the custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control called `UrlListWebPart`.</span></span> <span data-ttu-id="731eb-128">이 파일은 예제를 실행 하려면 App_Code 디렉터리에 배치 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-128">This file should be placed in the App_Code directory to run the example.</span></span> <span data-ttu-id="731eb-129">소스 코드를 구현 하는 참고를 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-129">Note that the source code implements the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> property.</span></span>  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 <span data-ttu-id="731eb-130">브라우저에서 페이지를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-130">Load the page in a browser.</span></span> <span data-ttu-id="731eb-131">로 시작 하는 실제 URL을 추가 하 고 URL을 나타내는 이름 입력 `http://`를 클릭 합니다 **추가** URL 추가 단추입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-131">Type in a name to represent a URL, then add an actual URL beginning with `http://`, and click the **Add** button to add the URL.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="iPersonalizable.Load state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="731eb-132">내부 데이터 저장소에서 로드된 사용자 지정 범위의 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-132">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> that contains custom scoped data that was loaded from the underlying data store.</span></span></param>
        <summary><span data-ttu-id="731eb-133">사용자 지정 데이터를 컨트롤로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-133">Loads custom data into a control.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="731eb-134">이 메서드는 그 자체에 사용자 지정 데이터를 로드할 수 있도록 하려면 컨트롤에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-134">This method is called on a control to allow it to load custom data into itself.</span></span> <span data-ttu-id="731eb-135">내부 데이터 저장소 페이지에서 다른 개인 설정 데이터가 변경 되었는지 여부에 관계 없이 컨트롤의 사용자 지정 상태를 다시 써야 하는지 여부를 나타내는 값을 반환할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-135">It can also return a value that indicates whether a control's custom state must be written back to the underlying data store, regardless of whether any other personalization data on the page has changed.</span></span> <span data-ttu-id="731eb-136">컨트롤은 고유한 사용자 지정 속성을 설정 하 고 개인 설정 사전에 포함 된 값을 기반으로 하는 추가 내부 논리를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-136">A control can set its own custom properties and carry out additional internal logic based on the values contained in the personalization dictionary.</span></span> <span data-ttu-id="731eb-137">이 메서드는 컨트롤에 개인 설정 데이터를 적용 하는 동안 설정 웹 파트 컨트롤에 의해 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-137">This method is called by the Web Parts control set while applying personalization data to a control.</span></span>  
  
 <span data-ttu-id="731eb-138">병합 동작을 알고 있어야 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-와 범위 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>-범위에 포함 된 속성을 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-138">You should also be aware of the merge behavior of <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-scoped versus <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>-scoped properties contained in the <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> object.</span></span> <span data-ttu-id="731eb-139">`state` 매개 변수는 내부 데이터 저장소에서 로드 된 사용자 지정 데이터의 병합 된 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-139">The `state` parameter contains a merged representation of custom data that was loaded from the underlying data store.</span></span> <span data-ttu-id="731eb-140"><xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 범위를 페이지 자체에 있을 때 이전에 추가한 모든 값 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 범위를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-140">In <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> scope, all the values that were previously added when the page itself was in <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> scope would be available.</span></span> <span data-ttu-id="731eb-141"><xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 범위를 사용 하 여 연결 된 값 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 개인 설정 범위 값인 하나의 페이지에 때 추가한 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 범위 및 페이지에 있을 때 다른 값을 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 개인 설정 인프라는 다음 범위 만 포함 합니다 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-값 범위 (아닌 사이트별로 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 값 범위) 내에서 `state` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="731eb-141">In <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> scope, if a value associated with <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> personalization scope had one value added when the page was in <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> scope, and a different value when the page was in <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> scope, then the personalization infrastructure would only include the <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-scoped value (as opposed to the <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> scope value) within the `state` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="731eb-142">다음 코드 예제에서는의 구현을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> 메서드는 사용자 지정에서 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-142">The following code example demonstrates an implementation of the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> method in a custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control.</span></span> <span data-ttu-id="731eb-143">이 예제를 실행 하는 데 필요한 전체 코드의 예제 섹션을 참조 하세요.를 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 클래스 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-143">For the full code required to run this example, see the Example section in the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> class overview.</span></span>  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="iPersonalizable.Save state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="731eb-144">내부 데이터 저장소에서 로드된 사용자 지정 범위의 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-144">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> that contains custom scoped data that was loaded from the underlying data store.</span></span></param>
        <summary><span data-ttu-id="731eb-145">사용자 지정 속성과 내부 상태 정보를 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> 개체에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-145">Saves custom properties and internal state information in the control's <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="731eb-146">서버 컨트롤 자체 사용자 지정 속성과 내부 상태 정보를 저장할 수는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 에 지정 된 된 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-146">A server control can store its own custom properties and internal state information the <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> specified in the `state` parameter.</span></span> <span data-ttu-id="731eb-147">정보를 일련의 이름/값 쌍으로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-147">The information is stored as a series of name/value pairs.</span></span> <span data-ttu-id="731eb-148">이 통해 해당 컨트롤에 대 한 다음 호출에서 인식할 수 있는 이름/값 쌍을 사용 하 여 컨트롤의 경우는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="731eb-148">It is the responsibility of the control to use name/value pairs that it can recognize during subsequent calls made to the control through the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> method.</span></span>  
  
 <span data-ttu-id="731eb-149">컨트롤을 연결 된 참조할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하 고 확인을 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope> 현재 범위를 결정 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-149">A control can reference its associated <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control and check the <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope> object to determine the current scope.</span></span> <span data-ttu-id="731eb-150">사용자 지정 상태 정보는 현재 범위에 적절 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-150">Custom state information should be appropriate for the current scope.</span></span> <span data-ttu-id="731eb-151">각 <xref:System.Web.UI.WebControls.WebParts.PersonalizationEntry> 에 추가 되는 값을 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 병합할 때 개인 설정 인프라가이에 따라 달라 지므로 개체는 적절 한 범위 값을 사용 하 여 연결 해야 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 및 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-사용자 지정 데이터 범위 전달 하기 전에 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="731eb-151">Note that each <xref:System.Web.UI.WebControls.WebParts.PersonalizationEntry> value that is added to the <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> object should be associated with the appropriate scope value, because the personalization infrastructure depends on this when merging <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> and <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-scoped custom data prior to passing it to the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> method.</span></span>  
  
 <span data-ttu-id="731eb-152">웹 파트의 표준 ASP.NET 구현을 사용 하는 경우 컨트롤 ASP.NET에서 상태 사전에 저장 된 개체를 serialize 할 수 유지 해야 <xref:System.Web.UI.ObjectStateFormatter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-152">When using the standard ASP.NET implementation of Web Parts, controls must ensure that objects placed in the state dictionary can be serialized by the ASP.NET <xref:System.Web.UI.ObjectStateFormatter> class.</span></span> <span data-ttu-id="731eb-153">실제로 다음으로 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-153">In practice, this means the following:</span></span>  
  
-   <span data-ttu-id="731eb-154">기본.NET Framework 형식, 문자열 및.NET Framework 형식 배열, 배열, 해시 테이블 목록과 하이브리드 사전 등 컬렉션 지향 자동으로 직렬화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-154">Primitive .NET Framework types, strings, and collection-oriented .NET Framework types such as arrays, array lists, hash tables, and hybrid dictionaries, are automatically serializable.</span></span>  
  
-   <span data-ttu-id="731eb-155">자체 제공 하는 사용자 지정 형식 <xref:System.ComponentModel.TypeConverter> 클래스를 직렬화 및 문자열에서 역직렬화 할 수 있는 직렬화 가능한 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-155">Custom types that supply their own <xref:System.ComponentModel.TypeConverter> classes capable of serializing to and deserializing from strings are considered serializable.</span></span>  
  
-   <span data-ttu-id="731eb-156">사용자 지정 형식으로 serialize 할 수 있는 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 클래스 직렬화 가능한 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-156">Custom types that can be serialized by the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class are considered serializable.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="731eb-157">하지 App_Code 디렉터리에 정의 된 클래스를 기반으로 하는 형식을 추가 해야 하며 그런 다음 기본 이진 serialization 메커니즘에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-157">You should not add types based on classes defined in the App_Code directory and then depend on the default binary serialization mechanism.</span></span> <span data-ttu-id="731eb-158">App_Code 기반 아티팩트가 하지 이진 직렬화 일관 되 게 때문에 시간에서 임의 지점에서 변경 어셈블리 이름을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-158">App_Code-based artifacts are not consistently binary-serializable due to the fact that they can have their assembly names changed at random points in time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="731eb-159">다음 코드 예제를 구현 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> 메서드는 사용자 지정에서 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-159">The following code example demonstrates implementing the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> method in a custom <xref:System.Web.UI.WebControls.WebParts.WebPart> control.</span></span> <span data-ttu-id="731eb-160">이 예제를 실행 하는 데 필요한 전체 코드의 예제 섹션을 참조 하세요.를 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 클래스 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="731eb-160">For the full code required to run this example, see the Example section in the <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> class overview.</span></span>  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>