<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39878b0a58d88077e3f60f42a8b9f566fd421748" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30601307" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>웹 페이지에서 발생하는 이벤트, 기능 및 모든 웹 파트 컨트롤을 관리하는 웹 파트 컨트롤 집합의 중앙 클래스로 사용됩니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 허브 또는 제어 센터의 웹 파트 응용 프로그램 역할입니다. -1 및-하나만 있어야<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 웹 파트 컨트롤을 사용 하는 모든 페이지에 있습니다. 웹 파트 응용 프로그램의 대부분의 측면에서와 마찬가지로 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인증 된 사용자만 작동 합니다. 또한의 기능은 거의 모두 사용할 서버 컨트롤에서 상속 하는 웹 파트 영역 내에 상주 하는 <xref:System.Web.UI.WebControls.WebParts.WebZone> 클래스입니다. 페이지에서 이러한 영역 외부에 상주 하는 서버 컨트롤은 아주 적은 웹 파트 기능이 나와 상호 작용 있을 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 페이지, 웹 파트 기능에 대 한 허브로는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 종류의 다음 표에 설명 된 작업을 수행 합니다.  
  
|작업 범주|컨트롤에서 수행 하는 작업|  
|-------------------|---------------------------|  
|웹 파트 컨트롤 추적|다양 한 종류의 응용 프로그램을 비롯 한 웹 파트 기능을 제공 하는 페이지에 있는 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 연결, 영역 및 다른 사용자입니다.|  
|웹 파트 컨트롤 추가 및 제거|메서드 추가, 삭제 및 닫기에 대 한 제공 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지에 있는 컨트롤입니다.|  
|연결 관리|컨트롤 간의 연결을 만들고 연결을 추가 하 고 제거 프로세스를 모니터링 합니다.|  
|개인 설정 컨트롤 및 페이지|사용자가 페이지에 다른 위치로 컨트롤을 이동할 수 있으며 특정 모양, 속성 및 컨트롤의 동작을 사용자가 편집할 수 있는 뷰를 실행 합니다. 각 페이지에는 사용자별 개인 설정을 유지합니다.|  
|다른 페이지 뷰 사이 설정/해제|사용자가 페이지 레이아웃 변경 또는 컨트롤을 편집 하는 등의 특정 태스크를 수행할 수 있도록 페이지는 페이지의 다른 특수 한 보기 사이 전환 합니다.|  
|웹 파트 수명 주기 이벤트 발생|컨트롤 추가 될 때, 이동, 연결 또는 삭제와 같은 웹 파트 컨트롤의 수명 주기 이벤트를 처리할 수 있도록 개발자 및 발생 시키고 정의 합니다.|  
|컨트롤의 가져오기와 내보내기를 사용 하도록 설정|속성의 상태를 포함 하는 XML 스트림을 내보내고 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자가 손쉽게 복잡 한 컨트롤에서 다른 페이지 또는 사이트를 개인 설정에 대 한 파일을 가져올 수 있도록 합니다.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스에는 다양 한 속성. 일치는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 다양 한 웹 파트 컨트롤 또는 다른 웹 파트는 특정 개체의 컬렉션을 참조 하는 속성이 있기 추적 다른 컨트롤의 역할을 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 속성을 사용 하는 모든 컬렉션은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 에서 추적 및 기타 컨트롤 관리 작업입니다.  
  
 다른 속성 그룹에는 웹 파트 응용 프로그램에서 발생 하는 특정 시나리오에 적용 되는 사용자 지정 가능한 경고가 포함 되어 있습니다. 여기에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 속성입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스는 대부분의 웹 서버 컨트롤에서 사용 되는 해당 기본 상속 된 속성 중 일부를 재정의 합니다. 여기에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성입니다.  
  
 마지막으로, 없는 속성 그룹을 응용 프로그램의 현재 상태에 액세스 하는 데 유용 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성 페이지에 있는 현재 표시 모드를 나타냅니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> 속성은 사용자가 될 수 있습니다 다른 기능을 사용 하는 브라우저 또는 스크립팅을 해제 되어 있는 경우 관련이 클라이언트 쪽 스크립트를 렌더링 하는 컨트롤 허용 되는지 여부를 나타냅니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성은 다양 한 확장성 사례에 사용 되는 중요 한 웹 파트 방법에 대 한 호출을 포함 하는 유틸리티 클래스를 참조 하는 데 유용 합니다. 이러한 메서드는 별도 클래스에 대 한 호출 숨기는 방식으로 (의 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 클래스), <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스의 API 간소화 됩니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성은 사용자의 개인 설정을 저장 하 고 해당 데이터를 영구 저장소를 유지 하는 개인 설정 개체에 대 한 액세스를 제공 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성 줍니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지 컨트롤에는 사용자 또는 응용 프로그램에서 현재 선택 되어 있습니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성 표시 여부를 사용자 지정 개인 설정 데이터를는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 변경 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에 포함 된 5 기본 제공 디스플레이 모드 또는 웹 페이지의 보기입니다. 개발자 확장할 수 있습니다이 기능을 사용자 지정 디스플레이 모드와 같은 형식을 확장 하 여 만드는 <xref:System.Web.UI.WebControls.WebParts.WebZone> 클래스 또는 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 클래스입니다. 사용자는 적절 한 종류의 지정된 된 디스플레이 모드에 해당 하는 컨트롤 요소가 페이지에 있는 페이지를 다양 한 디스플레이 모드를 전환할 수 있습니다.  
  
> [!NOTE]
>  사용자가 페이지에 해당 하는 영역 필요 없이 사용자 지정 디스플레이 모드를 전환할 수 있도록이 기능을 확장 하는 것이 불가능 합니다. 그러나 기본 동작은 디스플레이 모드 영역에 해당 합니다.  
  
 표준 디스플레이 모드의 필드를 공용으로 표시 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스입니다. 다음 표에서 필드 및를 참조 하는 디스플레이 모드 요약 되어 있습니다. 페이지의 현재 표시 모드 위에서 언급 했 듯이 항상 참조에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성과 페이지에 있는 영역 종류에 따라 해당 특정 페이지에서 사용할 수 있는 디스플레이 모드 집합에 포함 되어는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다.  
  
|필드|디스플레이 모드 정보|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|웹 페이지;의 일반 사용자 보기 기본 및 가장 일반적인 디스플레이 모드입니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|사용자를 다시 정렬할 수 또는 페이지 레이아웃을 변경 하는 컨트롤을 삭제 하는 뷰.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|편집 사용자 인터페이스 (UI)가 표시 되는 뷰로 사용자는 모양, 속성 및 표준 찾아보기 모드에서 표시 되는 컨트롤의 동작을 편집할 수 있습니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|카탈로그 UI가 표시 되는 뷰로 사용자가 사용할 수 있는 컨트롤의 카탈로그에서 페이지에 컨트롤을 추가할 수 있습니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|연결 UI가 표시 되는 뷰로 사용자 연결 수, 관리 또는 컨트롤 간의 연결을 끊습니다.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에도 다양 한 웹 파트 페이지 및 컨트롤의 수명 주기에서 중요 한 이벤트 포함 합니다. 이러한 이벤트는 웹 파트 컨트롤의 동작을 보다 정밀 하 게 프로그래밍 방식 제어를 제공합니다. 대부분의 메서드와 직접 관련 되어 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 다른 서버 또는 사용자 컨트롤에 배치 된 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 처럼 동작할 수 있도록 영역 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤). 그러나 몇 가지 이벤트 페이지 또는 페이지에는 연결의 상태와 관련이 있습니다. 다음 표에서 사용할 수 있는 이벤트를 나열 하 고 용도 요약 합니다.  
  
> [!NOTE]
>  모든 경우에는 다음 표에, "컨트롤" 라는 단어를 의미는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 또는 모든 서버 컨트롤 영역에 있는 사용 하 여 래핑는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임에 개체입니다.  
  
|이벤트(event)|설명|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|권한이 있는지 확인 하는 페이지에 컨트롤 추가 되는 바로 전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|페이지에 모든 연결이 활성화 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|페이지에서 모든 연결을 활성화 하는 과정 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|페이지의 현재 표시 모드 변경 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|페이지의 디스플레이 모드를 변경 하는 과정 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|컨트롤의 선택 취소 된 후에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|컨트롤의 선택이 취소 프로세스 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|컨트롤 영역에 추가한 후에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|프로세스 영역에 컨트롤을 추가 하기 바로 전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|컨트롤 (페이지에서 제거 됨) 종료 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|컨트롤을 닫는 프로세스 하기 바로 전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|(1 개를 프로그래밍 방식으로 만들거나 카탈로그에서 추가) 동적 컨트롤의 인스턴스를 영구적으로 삭제 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|동적 컨트롤을 삭제 하는 바로 전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|영역 내에서 또는 다른 영역으로 컨트롤이 이동 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|프로세스 컨트롤을 이동 하기 바로 전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|연결에 참여 하도록 선택 된 두 개의 연결을 설정한 후에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|두 컨트롤을 연결 하는 과정 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|두 개의 연결 된 컨트롤의 연결이 끊어진 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|두 개의 연결을 끊을 프로세스 직전에 발생 합니다.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에는 웹 파트 페이지를 관리 하기 위한 여러 메서드가 있습니다. 다양 한 메서드는 여기에 나열 되지 가지가 이름이 On의 형태를 취하*EventName*합니다. 이러한 메서드는 일반적으로 관련 된 이벤트를 발생 시키는 및 형식의 처리기와 이벤트를 제공 <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>합니다. 상속 하는 개발자도 대부분의 이러한 메서드를 재정의할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스입니다. 또한 페이지 개발자가 이러한 방법과 관련 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수 있습니다. 예를 들어의 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트 페이지 개발자 추가할 수는 `OnWebPartAdded` 특성을 `<asp:webpartmanager>` 사용자 지정 메서드 이벤트에 대 한 사용자 지정 처리를 제공할 수 있는 특성 이름을 웹 페이지 및 다음 할당의 태그 요소에에서 있습니다. 특성에 해당 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 메서드와이 기본 이벤트 처리 패턴을 대부분의 웹 파트 이벤트와 관련된 메서드에 대 한 작동 합니다.  
  
 또한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 메서드가 있습니다 관리 작업을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (사용 되는 서버 또는 사용자 컨트롤 및 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤). 이러한 방법 포함 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>합니다.  
  
 메서드의 다른 집합은 연결에 대 한 특수화 된 것입니다. 와 같은 메서드가 포함 됩니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>합니다.  
  
 마지막으로, 일부 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 메서드 개인 설정 하는 기능에 집중 합니다. 여기에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>합니다.  
  
 다른에 대 한 자세한 내용은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 통해 액세스할 수 있는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성에 대 한 설명서를 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 선언적 방법과 프로그래밍 방식으로 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 개의 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 사용자 정의 컨트롤 요소가 페이지에는 웹 파트 컨트롤에 따라 해당 페이지에서 가능한 표시 모드를 표시 하는 드롭다운 목록 컨트롤을 있습니다. 이 코드 예제에 대 한 웹 페이지에서이 사용자 정의 컨트롤 바로 아래 선언 된는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 페이지의 태그 요소에에서 있으면는 `Register` 컨트롤을 등록 하려면 웹 페이지의 맨 위 근처에 지시문입니다. 이 컨트롤의 모드 및 소스 코드에 대 한 설명을 표시 하는 대 한 세부 정보를 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 웹 페이지에 대 한 선언적 태그에 포함 된 `Register` 모두 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. 한 `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. 또한이 페이지에 대 한 연결 관련 이벤트를 처리 하는 인라인 코드도 포함는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 연결 하 고 컨트롤을 분리 하면서이 코드의 결과 볼 수 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 예의 세 번째 부분에는 컨트롤에 대 한 소스 코드입니다. 이라는 인터페이스는 `IZipCode`,이 인터페이스에서 구현 되 고는 `ZipCodeWebPart` 클래스입니다. 이 클래스에는 특수 콜백 메서드가 라는 `ProvideIZipCode` 하는 공급자 역할을 합니다. 다른 형식으로 명명 된 `WeatherWebPart`, 라는 특수 한 방법이 함께 구현 되어 `GetIZipCode`, 컨트롤이 다른 컨트롤의 소비자로 동작할 수 있습니다.  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제에서는 어셈블리로 소스 컴파일한 가정 및 `Register` 지시문 웹 페이지에서 어셈블리 이름을 참조 합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 브라우저에서 웹 페이지를 로드 하면 클릭는 **디스플레이 모드** 드롭 다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 합니다. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드 보고의 제목 표시줄에 있는 아래쪽 화살표를 클릭 하 고 **우편 번호** 활성화 동사 메뉴의 컨트롤을 클릭 한 다음 **연결**합니다. 연결 UI를 표시 한 다음 클릭는 **소비자에 대 한 연결을 만들** 링크 합니다. 셀에 드롭다운 목록 컨트롤이 나타납니다. 선택 **날씨 제어** 클릭 한 다음 확인 하 고 드롭다운 목록에서 **연결** 두 개의 연결을 완료 합니다. 클릭 **닫기**를 사용 하 여는 **디스플레이 모드** 드롭 다운 목록 페이지 표준 찾아보기 모드로 돌아갑니다. 우편 번호를 입력할 수 있으며 소비자 컨트롤을 입력 한 값으로 업데이트 됩니다. 때문에 `ZipCode` 속성으로 표시 되어 있으므로 `Personalizable` 소스 코드를이 속성 값에서 사용자가 입력 한 값을 저장 브라우저 세션 간에 유지 됩니다. 보다 복잡 한 소비자 컨트롤 우편 번호 정보를 가져올, 코드를 날씨 정보를 조회 및 사용자에 게 표시할 수 없습니다.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤은 확장 되도록 설계 되었습니다. 중앙 사이트와 웹 파트 응용 프로그램, 몇 가지 특정 형식을 확장 하거나 웹 파트 컨트롤 집합 대부분의 경우에서에서 제어 하려는 경우에 확장 되어야 하므로 이기 때문에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스, 속성 또는 메서드를 확인 하는 데 필요한 몇 가지 있을 수 있기 때문에  웹 파트 응용 프로그램의 컨텍스트에서 작동 하는 사용자 지정 형식입니다. 웹 파트 참조 설명서 (참조 <see cref="N:System.Web.UI.WebControls.WebParts" />) 자주 언급 되어 확장 하기 위해 필요한 입력 웹 파트를 확장 하는 방법에 논의 하는 경우, 고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 도 클래스 또는 코드 예제에서 확장 하는 방법을 보여 줍니다.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> 생성자에서 사용 하는 몇 가지 중요 한 변수는 초기화는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 모든 웹 파트 페이지에 직접적인 영향을 하나의 할당은 기본 페이지 디스플레이 모드 찾아보기 모드로 설정 되어 있다는 사실을 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 페이지에서 현재 비활성 상태인 모든 연결을 활성 상태로 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 간의 기존 연결을 활성화 하는 페이지에 각 요청에 메서드가 호출 됨 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 있는 기타 서버 컨트롤과 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역입니다. 경우에 따라 충돌 하는이 방법 활성화 되는 연결에 다시 경우 인스턴스가 호출에 대 한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드 문제가 있는 연결을 종료 합니다. 연결을 끊는 동안는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트가 발생 합니다. 일반적으로 개발자가이 이벤트를 취소할 수 있지만 경우에 때문에 이것이 취소할 수 없으며 연결 간에 충돌이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 연결을 활성화 하는 과정을 완료 하려면 충돌을 해결 해야 합니다. 자세한 내용은 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">웹 페이지에 추가하거나 페이지에서 열 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />(또는 서버 컨트롤이나 사용자 정의 컨트롤)입니다.</param>
        <param name="zone">
          <c>webPart</c>가 추가될 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />입니다.</param>
        <param name="zoneIndex">
          <c>zone</c>에서 <c>zone</c>의 다른 컨트롤을 기준으로 <c>webPart</c>가 나타나는 서수 위치를 나타내는 정수입니다.</param>
        <summary>웹 페이지에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 프로그래밍 방식으로 추가하기 위한 방법을 제공합니다.</summary>
        <returns>페이지에 추가된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드를 사용 새 동적 추가 둘 다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지에 및를 페이지에 이미 닫혀 있는 정적 또는 동적 컨트롤을 다시 열을 제어 합니다. 실제로에서 참조 된 컨트롤의 복사본을 만드는 새 컨트롤을 추가 하는 메서드를 호출 하는 경우는 `webPart` 매개 변수입니다. 새 ID를 컨트롤의 복사본에 대 한 생성 개발자 참조 해야 하므로 <xref:System.Web.UI.WebControls.WebParts.WebPart> 새 ID 값을 가져오는 방법에서 컨트롤이 반환 합니다. 이전에 닫힌된 컨트롤을 다시 열려면 메서드는 참조 하는 컨트롤에 대 한 직접 참조 반환은 `webPart` 매개 변수입니다.  
  
> [!IMPORTANT]
>  항상 사용 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드를 보다는 <xref:System.Web.UI.ControlCollection.Add%2A> 참조 하는 컨트롤의 컬렉션의 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> 추가할 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 사용 하 고 있으므로 페이지에 프로그래밍 방식으로 컨트롤의 <xref:System.Web.UI.ControlCollection.Add%2A> 메서드에서 예외가 throw 됩니다. 하지 않은 컨트롤을 추가 하려면는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (즉, 래핑 하는 서버 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임 시 컨트롤)를 먼저 호출 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 을 컨트롤을 만들려면 다음 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드를 추가 하려면 컨트롤입니다. 이 방법의 데모를 보려면 "예" 섹션을 참조 하십시오.  
  
   
  
## Examples  
 다음 코드 예제에서는의 사용을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드를 페이지에는 서버 컨트롤을 프로그래밍 방식으로 추가 합니다. 페이지 태그는 빈 포함 `<asp:webpartzone>` 요소 및 `<asp:webpartmanager>` 요소입니다. 처음으로 **추가 달력** 단추를 클릭 하면 코드 이벤트 처리기를 만듭니다는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤을로 영역에 추가 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체를 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <paramref name="zone" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" />이 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 영역 컬렉션에 등록되지 않은 경우  
  
 \- 또는 -  
  
 <paramref name="webPart" />가 이미 <paramref name="zone" />에 있는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> 값이 0보다 작은 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 또는 서버 컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하기 위해 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 메서드가 호출될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트가 발생할 때마다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 페이지에 추가 되 고 됩니다. 페이지에 컨트롤을 추가할 수 있는 일반적인 시나리오는 여러 가지가 있습니다. 에 대 한 전체 설명은 이러한에 대 한 설명 섹션을 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드. 컨트롤이 추가 되 면 체크 볼 수 있는지 여부를 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 설정 되었는지, 그렇다면 여부 컨트롤 하기 및 페이지에 추가 합니다.  
  
 개발자에 대 한 이벤트 처리기를 만들 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트를 컨트롤에 대 한 필터링을 제공 합니다. 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값 이벤트 처리기 코드에서 조건을 충족 하지 않는 컨트롤에 추가 되지 않습니다는 페이지입니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 사용자 지정 이벤트 처리기를 설정 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 자동으로 기본값을 재정의 하는 이벤트 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드.  
  
 코드는 `mgr1_AuthorizeWebPart` 메서드 각각의 해당 페이지에 컨트롤 가지는지 확인 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값으로 설정 `user` 하 고,이 경우 반환 `true`, 페이지에 추가할 수 있음을 나타내는 합니다. 이 가정 사용자 사용자 개인 설정 범위에서 페이지를 사용 하 여 컨트롤을 볼 수 있도록 하는 기본 방법입니다. 그러나 갖고 있음을 알게 컨트롤의 예제에서 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값으로 설정 `admin`합니다. 개발자는 관리 사용자가 볼 수만 설계 된 특수 컨트롤에이 필터를 적용할 수 있습니다. 이 컨트롤은 권한 부여 검사 중에 실패는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트를 표시 하지 것입니다. Note 속성이 설정 되지 않은 컨트롤;도 표시 됩니다 하지의 일부가 되도록 필터링 시나리오를 때문에 가정 됩니다 자신의 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 설정 되지 않은 합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤 간의 웹 파트 연결을 만드는 데 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 개체의 컬렉션을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 사용 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> 메서드 컬렉션을 만듭니다. 기본적으로 응용 프로그램 구성 파일에서 사용 가능한 변환기를 읽습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결이 설정되는 컨트롤입니다.</param>
        <summary>두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 연결하는 프로세스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> 메서드는 존재 하므로 개발자가 연결 프로세스를 더 많이 제어할 수 있도록 별도 단계에서 컨트롤 간의 연결을 설정 하는 과정을 수행할 수 있습니다. 메서드는 일련의 되도록 초기 검사 수행 `webPart` 에 대 한 연결을 합법적인 방식으로 설정할 수 있는 상태입니다. 경우 `webPart` 모든 검사를 통과 현재 선택 된 컨트롤로 설정 합니다 (참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성), 고 연결 프로세스를 계속할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">페이지의 현재 디스플레이 모드가 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" />가 닫혀 있습니다.  
  
 \- 또는 -  
  
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 포함되지 않은 경우  
  
 또는  
  
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 컨트롤과 같은 경우</exception>
        <block subset="none" type="overrides">
          <para>확장 하는 개발자는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤 파생된 클래스에서이 메서드를 재정의 하는 경우가 있습니다. 한 가지 방법은 기본 메서드를 호출 하 고 다음 몇 가지 추가 사용자 지정 처리;을 추가 하는 것 또는 컨트롤 간의 연결을 시작 하는 과정을 완전히 사용자 지정할 수 있습니다. 예를 들어 다음 연결을 만들기 전에 일부 데이터를 사용할 수 있는지 확인 하는 것이 좋습니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">편집할 컨트롤입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 편집하는 프로세스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 메서드는 존재 하므로 개발자가 프로세스를 더 많이 제어할 수 있도록 별도 단계에 편집 컨트롤의 프로세스를 수행할 수 있습니다. 메서드는 일련의 되도록 초기 검사 수행 `webPart` 편집할 수 있는 상태입니다. 경우 `webPart` 모든 검사를 통과 현재 선택 된 컨트롤로 설정 합니다 (참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성), 고 편집 프로세스를 계속할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">페이지의 현재 디스플레이 모드가 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" />가 닫혀 있습니다.  
  
 \- 또는 -  
  
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 포함되지 않은 경우  
  
 또는  
  
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 컨트롤과 같은 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 컨트롤이 들어 있는 페이지의 기본 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 필드 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고에 포함 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 정적 개체 이므로 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 웹 파트를 포함 하는 페이지를 처음 로드할을 제어 하는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (찾아보기 모드) 기본적으로 합니다. 일반적인 웹 페이지에서 사용자 찾아보기 단순히만 페이지 찾아보기 모드에 남아 있습니다. 페이지를 통해 사용할 수 있는 특수 디스플레이 모드 중 하나로 전환 해야 사용자가 페이지의 레이아웃, 컨트롤, 모양 또는 동작 개인 설정 하려고 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 필드를 프로그래밍 방식입니다. 코드는 찾아보기 및 디자인이 경우에 지원 되는 디스플레이 모드와 드롭 다운 목록을 채웁니다. `Page_PreRender` 메서드, 코드 검사 하는지 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>합니다. 이 경우 `Label1` 를 볼 수는 고 없는 경우, `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드 기본적으로 위치는입니다. 찾아보기 모드에 있는 나타내는 페이지의 레이블이 확인 합니다. 드롭다운 목록 컨트롤을 사용 하 여 페이지 디자인 모드를 전환 합니다. 코드 인해는 `Page_PreRender` , 레이블이 이제 숨겨집니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결에 참여할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 확인하여 해당 컨트롤을 연결할 수 있는지 여부를 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 두 지 여부를 결정 메서드를 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 연결할 수 있습니다. 메서드를 호출 하기 전에 조건부 검사로 일반적으로 사용 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 메서드는 두 개의 연결을 설정할 수 전에 충족 해야 하는 조건 수를 확인 합니다. 다음 목록에 대 한 연결을 만들기 위한 기본 조건을 요약 되어 있습니다. 메서드가 반환 하는 경우 이러한 모든 조건이 (및 몇 가지 추가적인 내부 조건을)이 충족 되 면 `true`, 컨트롤을 연결할 수 있음을 의미 합니다.  
  
-   공급자 및 소비자 컨트롤 수 없습니다 `null`, 및에서 참조 하는 컨트롤의 컬렉션에 포함 되어야 합니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
-   공급자 및 소비자에서 동일한 컨트롤 수 없습니다. 즉 한 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 자체에 연결할 수 없습니다.  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> (연결점) 공급자와 소비자에 대 한 개체 수 없으면 `null`합니다.  
  
-   공급자와 소비자를 닫을 수 없습니다 (컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> 속성 수 `true`).  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> 연결 지점 컨트롤의 속성에는 소비자 및 공급자의 컨트롤의 형식과 일치 해야 합니다.  
  
-   연결 지점을 모두 활성화 해야 합니다 (자신의 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> 메서드 모두 반환 해야 `true`).  
  
-   각 연결 지점 자체에 지정 된 것 보다 더 많은 연결을 구성 하기 위해 시도 하면 안 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> 속성입니다.  
  
-   경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체 (변환기)는 호환 되지 않는 컨트롤을 연결 하는 데 필요한, 않아야 `null`합니다. 그러나 컨트롤에 이미 호환 되는 변환기 이어야 합니다 `null`합니다.  
  
-   참조 해야 합니다 (사용 된 경우)는 변환기는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> 컬렉션입니다.  
  
-   Transformer (사용) 하는 경우에 두 컨트롤 간의 데이터를 변환할 수 있도록 공급자와 소비자와 호환 되는 인터페이스가 있어야 합니다. 보조 인터페이스를 소비자 및 공급자의 호환 되어야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">컨트롤이 연결될 때 <c>consumer</c>에 데이터를 제공하는 컨트롤입니다.</param>
        <param name="providerConnectionPoint">
          <c>provider</c>가 연결에 참여할 수 있게 해 주는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <param name="consumer">컨트롤이 연결될 때 <c>provider</c>에서 데이터를 받는 컨트롤입니다.</param>
        <param name="consumerConnectionPoint">
          <c>consumer</c>가 연결에 참여할 수 있도록 콜백 메서드 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <summary>공급자 및 소비자 컨트롤에 호환되는 인터페이스가 있고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 개체가 필요하지 않은 경우, 연결에 참여할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 컨트롤을 확인하여 해당 컨트롤을 연결할 수 있는지 여부를 확인합니다.</summary>
        <returns>
          <paramref name="provider" />와 <paramref name="consumer" />를 연결할 수 있는지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 연결에 사용 되 `provider` 및 `consumer` 두 컨트롤에 호환 되는 연결 지점 형식이 있으면 있도록는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체가 필요 하지 않습니다. 두 컨트롤을 호출 하기 전에 연결할 수 있는지 확인 하려면이 메서드를 사용 하려는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 프로그래밍 방식으로 연결을 만듭니다.  
  
 이 오버 로드와 동일한 구현 사용의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> 변환기가 오버이 로드는 필요 하지 않다는 것을 유일한 제외 된 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 메서드를 사용 하는 방법을 보여 줍니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 개의 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤은 `<asp:webpartmanager>` 요소 및 일부 이벤트 처리를 만드는 코드를 사용 하 여 연결 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 메서드.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 웹 페이지에 대 한 선언적 태그에 포함 된 `Register` 모두 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. 한 `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. 에 `Page_Load` 메서드를 코드 인지 확인 하는 연결 만들 수 있습니다,이 경우, 해당 연결 지점을, 소비자 및 공급자를 정의 하 고는 참조하는정적연결집합에새연결을추가합니다<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 예의 세 번째 부분에는 컨트롤에 대 한 소스 코드입니다. 인터페이스에서는 두 개의 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 하나는 공급자 및 소비자로 다른 역할을 제어 합니다. 호환 되는 연결 지점 했기 때문에 (두 인식는 `IZipCode` 인터페이스), 변환기가 연결을 만드는 데 필요 하지 않습니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 브라우저에서 웹 페이지를 로드 하면 클릭는 **디스플레이 모드** 드롭 다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 합니다. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드 보고의 제목 표시줄에 있는 아래쪽 화살표를 클릭 하 고 **우편 번호** 활성화 동사 메뉴의 컨트롤을 클릭 한 다음 **연결**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">컨트롤이 연결될 때 <c>consumer</c>에 데이터를 제공하는 컨트롤입니다.</param>
        <param name="providerConnectionPoint">
          <c>provider</c>가 연결에 참여할 수 있도록 콜백 메서드 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <param name="consumer">컨트롤이 연결될 때 <c>provider</c>에서 데이터를 받는 컨트롤입니다.</param>
        <param name="consumerConnectionPoint">
          <c>consumer</c>가 연결에 참여할 수 있도록 콜백 메서드 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <param name="transformer">연결할 호환되지 않는 <c>provider</c> 및 <c>consumer</c>를 활성화하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />입니다.</param>
        <summary>연결에 참여할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 검사하여 해당 컨트롤을 연결할 수 있는지 여부를 확인하고, <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 개체를 사용하여 호환되지 않는 소비자와 공급자 간의 연결을 만듭니다.</summary>
        <returns>
          <paramref name="provider" />와 <paramref name="consumer" />를 연결할 수 있는지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 연결에 사용 되 `provider` 및 `consumer` 두 컨트롤 있으면 지점 형식이 호환 되지 않는 연결 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체가 필요 합니다. 두 컨트롤을 호출 하기 전에 연결할 수 있는지 확인 하려면이 메서드를 사용 하려는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 프로그래밍 방식으로 연결을 만듭니다.  
  
 이 오버 로드와 동일한 구현 사용의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> 이 오버 로드는 변환기 필요 하다는 것을 유일한 제외 된 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 카탈로그의 서버 컨트롤을 웹 페이지에 추가하는 데 사용되는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> 필드 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고에 포함 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 정적 개체 이므로 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 사용자가 서버 컨트롤의 카탈로그를 사용할 수 있는 경우 페이지에 컨트롤을 추가 하려면 페이지를 전환할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (카탈로그 모드) 카탈로그 사용자 인터페이스 (UI) 나타납니다. 웹 파트 카탈로그에 대 한 UI에서 제공 되는 <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> 영역 컨트롤입니다. 개발자는 디자인 타임에이 영역 페이지에 추가 하 고 사용자는 런타임에 해당 컨트롤을 페이지에 추가할 수 있도록 서버 컨트롤 영역에 추가 합니다. 개발자가 이러한 컨트롤을 추가한 후 필요한 컨트롤 카탈로그 모드를 활성화 하는 때문에 카탈로그 모드로 페이지에서 지원 되는 디스플레이 모드를 됩니다.  
  
 사용자가 페이지를 모드, 영역 및 모든 서버 컨트롤에 표시 되므로 추가 된 카탈로그를 전환 하 고 사용자를 페이지에 추가 하 여 페이지에서 컨트롤을 제거 합니다. 카탈로그에서 컨트롤을 선택할 수 때 됩니다. 페이지에 컨트롤을 추가한 후 표준 찾아보기 모드에서 표시 되 고 페이지가 업데이트 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> 필드를 프로그래밍 방식입니다. 코드는 찾아보기, 디자인 및 카탈로그가 경우에 페이지에 대해 지원 되는 디스플레이 모드와 드롭 다운 목록을 채웁니다. 카탈로그 모드는 때문에 사용할 수는 `<asp:CatalogZone>` 요소와 웹 페이지에서 해당 자식 요소입니다. `Page_PreRender` 메서드, 코드 검사 하는지 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>합니다. 이 경우 `Label1` 를 볼 수는 고 없는 경우, `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드 기본적으로 위치는입니다. 페이지의 레이블이 숨겨지는지 확인 합니다. 페이지 카탈로그 모드로 전환 하려면 드롭다운 목록에서 컨트롤을 사용 합니다. 코드 인해는 `Page_PreRender` 메서드, 레이블이 표시 됩니다. 카탈로그에 컨트롤을 선택 하 고 페이지에서 두 개의 영역 중 하나를 추가할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>요청하는 브라우저의 기능과 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 속성 값을 확인하여 클라이언트 스크립트를 렌더링할지 여부를 결정합니다.</summary>
        <returns>클라이언트 스크립트를 렌더링할지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결에서 다른 컨트롤에 대해 공급자 역할을 하는 컨트롤을 사용자가 닫을 때 표시되는 경고를 가져오거나 설정합니다.</summary>
        <value>경고 메시지가 들어 있는 문자열입니다. 기본값은 .NET Framework에서 제공하는 문화권별 메시지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하면 사용자가을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어, 일반적으로 메시지가 표시 됩니다. 컨트롤을 의미 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드.  
  
 그러나 컨트롤이 다른 컨트롤에 연결 된 역할을 다른 컨트롤에 데이터 공급자를 사용자가 컨트롤을 닫고 하는 기본 경고 메시지가 표시 됩니다. 메시지는 공급자 컨트롤 인지를 닫으려고, 소비자가 사용할 데이터의 모든가 더 이상 처럼이 공급자에 연결 되는 방법을 제어 하는 사용자가 지시 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성을 사용 하면 개발자가 사용자에 게 표시 되는 경고 메시지를 사용자 지정할 수 있습니다.  
  
 페이지 개발자는이 속성에는 비어 있거나 null 문자열 값을 할당, 없음 경고 메시지 상자가 표시 됩니다는 사용자가 닫을 때는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 공급자에 있는 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성을 사용자에 게 사용자 지정 경고를 표시 합니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   두 개의 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 다음 코드 예제에서는의 웹 페이지 부분만 포함 되어 있습니다. 위에서 언급 한 사용자 지정 컨트롤에 대 한 소스 코드 및 사용자 정의 컨트롤을 필요할 수도 됩니다. 이러한 두 항목의 예제 단원에서 가져올는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다.  
  
 다음 웹 페이지 코드를 사용자 지정 경고 메시지를 할당 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성에 선언적 태그에는 `<asp:webpartmanager>` 요소입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 브라우저에서 웹 페이지를 로드 하면 클릭는 **디스플레이 모드** 드롭 다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 합니다. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드 보고의 제목 표시줄에 있는 아래쪽 화살표를 클릭 하 고 **우편 번호** 활성화 동사 메뉴의 컨트롤을 클릭 한 다음 **연결**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 클릭는 **소비자에 대 한 연결을 만들** 링크 합니다. 셀에 드롭다운 목록 컨트롤이 나타납니다. 선택 **날씨 제어** 클릭 고 드롭 다운 목록에서 **연결** 두 개의 연결을 완료 합니다. 클릭 **닫기**를 사용 하 여는 **디스플레이 모드** 드롭 다운 목록 페이지 표준 찾아보기 모드로 돌아갑니다. 마지막으로,에 대 한 동사 메뉴를 클릭는 **우편 번호** 제어할 (공급자 컨트롤이 경우) 및 선택 **닫기**합니다. 에 할당 한 사용자 지정 메시지가 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성이 표시 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />에서 닫을 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 서버 컨트롤입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 닫습니다. 닫힌 컨트롤은 웹 페이지에 렌더링되지 않지만 다시 열 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드 제거는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 다른 서버 제어 원래 포함 하는 웹 페이지에 렌더링 되지 않습니다. 닫힌된 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 닫힌된 컨트롤에 대 한 참조를 유지 관리 하 고 페이지를 복원 해야 하는 컨트롤에 대 한 가능 하 게 하는 개체입니다. 닫힌 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 참조 하는 컬렉션에 여전히 표시 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
 컨트롤을 닫는 하는 것은 삭제 다릅니다. 닫힌된 컨트롤은 페이지에 복원할 수 있습니다. 하지만 삭제 된 컨트롤 인스턴스는 영구적으로 제거 및 복원할 수 없습니다. 여부에 관계 없이 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 (페이지의 태그에 선언 됨) 정적 또는 동적 (페이지에 추가 사용자 또는 프로그래밍 방식으로 웹 파트 카탈로그에서) 서버 컨트롤은, 닫힌 후 페이지에는 다시 열 수 있습니다.  
  
 일반적으로 사용자가 닫을 수는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 동사 메뉴를 클릭 하 고 닫기 동사를 선택 하 여 제어 합니다. 컨트롤을 직접 호출 하 여 닫을 수도 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드와에 대 한 참조를 전달 `webPart`합니다.  
  
 페이지에 있는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 닫혔을, 개발자가 선언 된 경우는 `<asp:catalogzone>` 요소를 그 안에 추가 `<asp:pagecatalogpart>` 요소를 런타임 시 페이지로 닫힌된 컨트롤을 복원 하는 사용자에 대 한 간단한 사용자 인터페이스 (UI) 제공 합니다. 사용자가 페이지 카탈로그 디스플레이 모드를 전환할 수 있습니다 및 닫힌된 컨트롤 페이지 카탈로그 내에서 표시 됩니다. 사용자가 닫힌된 컨트롤을 선택 하 고 추가할 수 있어서 원하는 위치에 대 한 페이지에 다시 다음 하 고 선택 된 컨트롤은 페이지에 복원 일반적인 방식으로 렌더링 합니다.  
  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드가 호출 되 면 이벤트가 발생: <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (많은 경우 여러 개의 컨트롤), 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (있는 경우 연결 된 컨트롤). 취소할 수 것 특정 한 경우에만 일반적으로 개발자가 이러한 이벤트를 취소할 수 있습니다. 자세한 내용은 설명서를 참조 하십시오.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   페이지 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
-   웹 페이지입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 코드 예제에서는 두 번째 부분은 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예에서는 동적 컴파일 방법을 사용 합니다. 없기 때문에 없는 `Assembly` 특성에 `Register` 웹 페이지의 위쪽에이 컨트롤에 대 한 지시문입니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 페이지에는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역을으로 <`asp:pagecatalogpart>` 요소 내에서 선언 합니다. 이 닫힌 들어갑니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 하 고 사용자가을 페이지에 다시 추가할 수 있습니다. `Button1_Click` 메서드를 직접 호출 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 하 여 사용자 지정 메서드 <xref:System.Web.UI.WebControls.WebParts.WebPart> 사용자 동사 메뉴를 통해 컨트롤 닫을 수도 있지만 제어 합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 사용자 지정을 닫고 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 컨트롤의 헤더에 있는 동사 메뉴 (화살표 기호)를 클릭 하 여 **닫습니다**합니다. 이제 페이지를 선택 하 여 카탈로그 모드로 변경 **카탈로그** 에 **디스플레이 모드** 드롭 다운 목록 컨트롤입니다. 페이지 카탈로그 닫힌된 컨트롤과 함께 표시 됩니다. 닫힌된 컨트롤 옆에 있는 확인란을 클릭 하 여 **추가** 페이지에 추가 하 고 클릭 하 **닫기** 페이지 찾아보기 모드를 되돌립니다. 컨트롤이는 페이지에 복원 됩니다. 이제 닫습니다 다시 클릭 하 여이 시간은 **Close WebPart** 단추입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 없는 경우  
  
 \- 또는 -  
  
 <paramref name="webPart" />가 공유 컨트롤이고 다른 사용자에 의해 이미 닫힌 경우</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 간의 연결을 관리할 수 있도록 특수 UI(사용자 인터페이스)를 표시하는 데 사용되는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 필드 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고에 포함 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 정적 개체 이므로 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 사용자가 간의 연결을 관리 하려는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPart> 경우 웹 페이지에 제어는 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 영역이 페이지에 선언 된, 페이지를 전환할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드입니다. 연결 디스플레이 모드 컨트롤 연결 끊기 또는 연결 하 고 기존 연결의 세부 정보를 편집할 수 있는 기능을 포함 하는 연결을 관리 하기 위한 특별 한 UI를 표시 합니다.  
  
 웹 파트 컨트롤 집합에서 제공 하는 UI를 사용 하 여 연결을 관리 하는 기능 사용자에 게 제공 하려는 경우를 선언 해야는 `<asp:connectionszone>` 요소 페이지의 태그에 있습니다. 다른 유형의 요소와는 달리 <xref:System.Web.UI.WebControls.WebParts.WebZone> 영역,이 요소 내에서 다른 태그를 추가할 필요는 없습니다; 단독으로 요소를 간단히 선언 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 사용법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드입니다.  
  
 이 코드 예제는 세 부분으로 구성 합니다.  
  
-   인터페이스 및 사용자 지정을 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결을 설정할 수 있는 컨트롤입니다.  
  
-   연결 UI를 제공 하 고 작업을 보여 줍니다. 하는 웹 페이지는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드입니다.  
  
-   예를 실행 하는 방법에 대해 설명 합니다.  
  
 코드 예제에서는 첫 번째 부분은 인터페이스와 두 개의 사용자 지정을 포함 하는 소스 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있도록 디자인 된 컨트롤입니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제에서는 동적 컴파일 접근 방식을 사용 합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 예제의 두 번째 부분은 사용자 지정 컨트롤을 호스트 하는 웹 페이지입니다. 서버 내에서 `<script>` 태그 페이지에는 여러 가지가을 페이지에서 사용할 수 있는 디스플레이 모드 드롭 다운 목록을 채웁니다. 사용자는 페이지의 디스플레이 모드를 변경 하려면 드롭다운 목록에서 선택할 수 있습니다. 사용 가능한 표시 모드 중 하나 이므로 연결 디스플레이 모드는 `<asp:connectionszone>` 요소가 페이지의 태그에 선언 되어 있습니다. 이 요소에 다른 자식 요소가; 포함 되지 않습니다 사용자의 연결 관리 UI 설정에 존재 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드 두 위치에서이 예제에 표시 됩니다. 첫 번째는 `Page_Init` 메서드를 연결 디스플레이 모드도 추가 됩니다 디스플레이 모드의 드롭다운 목록에 코드에서 참조 하는 컬렉션을 반복는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다. 두 번째는 `Page_PreRender` 메서드는 페이지에 현재 표시 모드를 확인 하 고 현재 모드 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>에 메시지가 표시 됩니다는 <xref:System.Web.UI.WebControls.Label> 컨트롤입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 드롭다운 목록을 클릭 하 고 선택 **연결** 페이지 연결 디스플레이 모드를 전환 합니다. 페이지에 있는 연결할 디스플레이 모드 라는 메시지가 표시를 확인 합니다. 이제 중의 제목 표시줄에 있는 동사 메뉴 (화살표 기호)를 클릭는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤과 클릭 **연결** 동사 메뉴에 있습니다. UI가 표시를 연결 후 연결에 대 한 링크를 클릭 합니다. 연결 나타나는 UI 내에서 드롭 다운 목록을 사용 하 여, 다른 컨트롤은 연결에 참여 하 고을 클릭 선택 하는 **연결** 단추입니다. 연결 됩니다. 클릭는 **닫기** 단추를 클릭 한 다음 페이지 맨 위에 있는 드롭다운 목록을 사용 하 여 디스플레이 모드를 검색 하는 페이지를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 현재 연결이 모두 들어 있는 컬렉션에 대한 참조를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 속성은 현재 연결 집합을 한 페이지에 액세스 하는 방법을 제공 합니다. 컬렉션에서 특정 연결을 조작 하려는 개발자도 사용 해야 하 고 읽기 전용 컬렉션 자체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 와 같은 메서드 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 선언적 방법과 프로그래밍 방식으로 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 개의 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 다음 코드 예제에서는의 웹 페이지 부분만 포함 되어 있습니다. 위에서 언급 한 사용자 지정 컨트롤에 대 한 소스 코드 및 사용자 정의 컨트롤을 필요할 수도 됩니다. 이러한 두 항목의 예제 단원에서 가져올는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다.  
  
 다음 웹 페이지 코드에 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 속성 페이지에 현재 연결 수를 가져옵니다을 프로그래밍 방식으로 합니다. 에는 `<script>` 태그 섹션에 대 한 두 개의 이벤트를 처리 하는 코드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 액세스 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 을 얻을 수 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 브라우저에서 웹 페이지를 로드 하면 클릭는 **디스플레이 모드** 드롭 다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 합니다. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드 보고의 제목 표시줄에 있는 아래쪽 화살표를 클릭 하 고 **우편 번호** 활성화 동사 메뉴의 컨트롤을 클릭 한 다음 **연결**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 후 클릭는 **소비자에 대 한 연결을 만들** 링크 합니다. 셀에 드롭다운 목록 컨트롤이 나타납니다. 선택 **날씨 제어** 클릭 고 드롭 다운 목록에서 **연결** 두 개의 연결을 완료 합니다. 클릭 **닫기**를 사용 하 여는 **디스플레이 모드** 드롭 다운 목록 페이지 표준 찾아보기 모드로 돌아갑니다. 레이블을 연결 수와 수를 이제 표시 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 반환 하는 경우 이제 모드를 연결 하 고 두 분리할 컨트롤 찾아보기 모드로 돌아가면 레이블의 콘텐츠를 업데이트 해야 하며 더 연결 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지에 있는 현재 웹 파트 연결이 모두 연결되어 있을 뿐 아니라 각 연결에 관련된 소비자 및 공급자 컨트롤 간에 실제로 데이터가 공유되기 시작한 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결의 수명 주기에서이 이벤트는 페이지에 로드 프로세스가 완료 된 후 발생 합니다. 또한이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 를 나타내는 이벤트는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 서버 컨트롤의 특정 연결에 관련 된 연결 또는 합니다. 경우에는 페이지에 여러 연결이 있는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 메서드는 유효한 모든 웹 파트 연결 페이지에 활성 상태이 고 데이터를 공유할 수 이제 되는 것입니다. 활성 상태인 모든 연결이 알고 있으면 개발자가 수행할 수 등의 모든 연결의 상태는 사용자에 게 알림 태스크를 개수에 관계 없이 라고 소비자 컨트롤에 처리 하 고 해당 공급자의 데이터를 표시 하 고 등.  
  
 이 이벤트와 연결 된는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> 메서드를 개발자가 사용자 지정 이벤트 처리기를 만들 수 있도록 해 주는 이벤트를 발생 시킵니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 만들 수는 `OnConnectionsActivated` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 설정된 웹 파트 연결을 모두 활성화하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결의 수명 주기에서이 이벤트가 발생 한 페이지를 완료 하 고 로드 프로세스가 바로 앞의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 메서드를 호출 합니다. 와 다른는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 간에 특정 연결을 포함 하는 이벤트 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 기타 서버 컨트롤입니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 이벤트 페이지에서 가능한 모든 연결 연결 되어 있어야 하 고 활성화 하려고 때 발생 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 이벤트와 연결 된는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 메서드는 이벤트를 발생 시킵니다. 페이지에 추가할 수 있는 연결의 해당 형식을 확장 하는 컨트롤 개발자는 보호 된 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 메서드 하 고 다른 유형의 연결을 활성화 합니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 만들 수는 `OnConnectionsActivating` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 있는 두 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 컨트롤(또는 연결을 설정할 수 있는 다른 서버 컨트롤) 간의 연결을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드 간에 연결을 형성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤입니다. 연결을 만들려면이 메서드를 호출 하기 전에 수도 있습니다를 호출 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 컨트롤 연결을 설정 하기 위한 요구 사항을 충족 하는지 확인 하는 조건부 검사에서 메서드.  
  
> [!NOTE]
>  것도 가능 하지 않은 두 개의 서버 컨트롤 간의 연결을 만들려면 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 일반적으로 두 개의 존재 해야 사용자 지정 서버 컨트롤 (에서 상속 하는 컨트롤 예를 들어 <xref:System.Web.UI.WebControls.WebControl> 또는 기존 ASP.NET 서버 컨트롤) 필요한 멤버를 추가할 수 있도록 합니다. 컨트롤은 또한 아래에 지정 된 요구 사항을 충족 해야 합니다.  
  
 두 컨트롤 간의 연결 시나리오의 모든 형식에 연결 하려면 다음 요구 사항을 충족 해야 합니다.  
  
-   각 컨트롤에 있는 한 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역 (않습니다 하지 하는 것 같은 영역).  
  
-   연결에서 공급자 컨트롤은 공용 메서드는 공급자에 대 한 콜백을로 사용 되 고이으로 인터페이스를 구현 웹 파트 컨트롤 집합에 구현 된 대로 `ConnectionProvider` 공급자 연결으로 식별 방법에 대 한 메타 데이터 특성 점입니다. 때문에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 메서드 검색 공급자 연결 지점은 가상 메서드이므로 파생 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤가지고 동일한 메타 데이터 특성을 사용 하지 않습니다.  
  
-   웹 파트 컨트롤 집합에 구현 된 대로 소비자 컨트롤에 대 한 연결도 공급자의 콜백 메서드를 노출 된 인터페이스에 대 한 참조를 가져올 수 있도록 하는 특수 한 방법이 있으며 소비자는 `ConnectionConsumer` 에 메타 데이터 특성 소비자 연결으로 식별 하기가 가리킵니다. 때문에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 메서드 소비자 연결 지점을 검색은 가상 메서드이므로 파생 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤가지고 동일한 메타 데이터 특성을 사용 하지 않습니다.  
  
-   콜백 메서드는 호환 되어야, 공급자의 콜백 메서드 (소비자 및 공급자 공유할 수 있다는 데이터 직접 의미) 또는 개발자에 제공 된 인터페이스 사용 해야 소비자의 형식을 사용할 수 있다는 점에서 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체를 소비자가 사용할 수 있는 형식으로 공급자에서 데이터를 변환 합니다.  
  
    > [!IMPORTANT]
    >  변환기가 필요 없는 경우 사용 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> 메서드 오버 로드 합니다. 변환기가 필요한 경우 사용 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">연결된 다른 컨트롤에 데이터를 제공하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</param>
        <param name="providerConnectionPoint">연결에서 콜백 메서드로 사용되는 메서드입니다. 웹 파트 컨트롤 집합에서 구현될 때 이 메서드는 <c>provider</c>에서 <see langword="ConnectionProvider" /> 메타데이터 특성으로 표시되는 공용 메서드입니다.</param>
        <param name="consumer">
          <c>provider</c>로부터 데이터를 받아 이를 처리하거나 표시하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</param>
        <param name="consumerConnectionPoint">
          <c>providerConnectionPoint</c>와 연결하여 연결에 대한 데이터를 받는 메서드입니다. 웹 파트 컨트롤 집합에서 구현될 때 이 메서드는 <c>consumer</c>에서 <see langword="ConnectionConsumer" /> 메타데이터 특성으로 표시되는 공용 메서드입니다.</param>
        <summary>두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤에 대한 참조와 각 컨트롤의 지정된 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 개체만 사용하여 두 컨트롤 간의 연결을 만듭니다.</summary>
        <returns>연결에 필요한 공급자 및 소비자에 대한 다양한 정보가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 연결점을 사용 하지 않고 연결할 수 있는 호환 충분히 때 컨트롤을 연결에 사용 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체입니다. 메서드의이 오버 로드를 호출할 때 단순히 메서드의 다른 오버 로드 된 버전에 대 한 호출을 전달 하 고 전달 `null` 필요로 하는 매개 변수에 대 한 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체입니다.  
  
 두 컨트롤을 프로그래밍 방식으로 연결 하려고 하는 경우 사용할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 메서드에서 컨트롤을 직접 연결할 수 있는지 여부를 결정 하는 조건부 검사 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 한 연결을 만들려면이 메서드를 사용 하는 방법을 보여 줍니다. 예제를 실행 하는 데 필요한 전체 코드의 예 섹션을 참조 하십시오.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 해당 예제에서 페이지 디스플레이 모드를 변경할 수 있는 사용자 정의 컨트롤에 대 한 소스 코드와 소스 코드에 필요한 두 개의 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
 두를 호스팅하는 웹 페이지의 코드를 다음과 같이 제어 합니다. 페이지를 사용 하 여 `Register` 사용자 정의 컨트롤 및 사용자 지정 컨트롤을 선언 하는 맨 위에 있는 대리자입니다. 사용자 지정 컨트롤 내에 선언적으로 참조 한 `<asp:webpartzone>` 요소입니다. 처리 하는 코드는 `Button1_Click` 메서드를 사용 하 여 컨트롤 간의 연결을 만듭니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 클릭는 **웹 파트 컨트롤 연결** 단추는 연결을 설정할 수 있습니다. 그런 다음 텍스트 상자에 데이터를 입력 하 고 클릭 수는 **5 자리 우편 번호를 입력** 단추를 하면 컨트롤이 연결 되 고 두 번째에서 첫 번째 컨트롤에 입력 한 데이터가 업데이트 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 동적 연결 컬렉션이 읽기 전용인 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">연결된 다른 컨트롤에 데이터를 제공하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</param>
        <param name="providerConnectionPoint">
          <c>provider</c>의 공용 메서드로, <see langword="ConnectionProvider" /> 메타데이터 특성으로 표시되며 연결의 콜백 메서드로 사용됩니다.</param>
        <param name="consumer">
          <c>provider</c> 또는 <c>transformer</c>로부터 데이터를 받아 이를 처리하거나 표시하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</param>
        <param name="consumerConnectionPoint">
          <c>consumer</c>의 공용 메서드로, <see langword="ConnectionConsumer" /> 메타데이터 특성으로 표시되며 <c>providerConnectionPoint</c>와 연결되어 연결의 데이터를 받습니다.</param>
        <param name="transformer">
          <c>provider</c>의 데이터를 <c>consumer</c>가 처리할 수 있는 형식으로 변환하여 두 컨트롤 간을 연결할 수 있게 해 주는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />입니다.</param>
        <summary>두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤에 대한 참조와 각 컨트롤의 지정된 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 개체, 그리고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 개체를 사용하여 두 컨트롤 간의 연결을 만듭니다.</summary>
        <returns>연결에 필요한 공급자, 소비자 및 변환기에 대한 다양한 정보가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 연결점 호환 되지 않을 때 컨트롤을 연결 하는 데 사용 됩니다. 비 호환성이 발생 때 `consumer` 보다 다른 인터페이스를 구현 `provider` 으로 연결 합니다. 변환기에서 인식할 수 있는 형식으로 데이터를 변환 `consumer`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">연결이 이미 <see cref="E:System.Web.UI.Control.PreRender" />에서 활성화된 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 포함되고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 컨트롤이 관리하는 모든 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤, 서버 컨트롤 또는 사용자 정의 컨트롤의 컬렉션을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.ControlCollection" /> 컨트롤이 관리하는 모든 컨트롤이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> 속성에서 참조 되는 다른 컨트롤을 참조 하지 않습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 다양 한 영역 컨트롤와 같은 제어 <xref:System.Web.UI.WebControls.WebParts.EditorPart> 또는 <xref:System.Web.UI.WebControls.WebParts.CatalogPart> 컨트롤 및 다른 사용자입니다.  
  
 이 속성은 사용자 코드에서 호출할 수에 적합 하지 않습니다 대부분의 개발 환경에서 웹 파트 컨트롤 집합을 사용 합니다. 이러한 이유로 속성은 public 이지만 IntelliSense에서 표시 되지 합니다. 컬렉션에 액세스 하는 개발자 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 관리 하는 다른 서버 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 사용 해야 해당 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">복사할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤입니다.</param>
        <summary>웹 파트 컨트롤 집합에서 웹 페이지에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 추가하기 위해 해당 컨트롤의 복사본을 만드는 데 사용됩니다.</summary>
        <returns>페이지에 추가할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출할 수 없습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 사용자 코드에서 직접 메서드. 이 메서드는 내부적으로 호출 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 새 동적 추가 하는 과정의 일부로 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 페이지에는 서버 컨트롤입니다. 동적 컨트롤 페이지에 추가 되는 프로그래밍 방식이 나 웹 파트 사용자 인터페이스 (UI)를 통해 예를 들어 컨트롤 페이지의 태그에 직접 선언가 static 컨트롤의 반대 개념의 카탈로그에서 컨트롤을 추가 하는 사용자가 있습니다.  
  
> [!NOTE]
>  개발자가 추가 컨트롤 복사 시나리오를 처리할 메서드를 사용 하도록 설정 하려는 경우 파생된 클래스에서 메서드를 재정의할 수 있습니다. 자세한 내용은 상속자 참고 사항 섹션에 메모를 참조 하세요.  
  
 이 경우, 새로운 동적 컨트롤이 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 메서드 컨트롤의 새 인스턴스를 반환 합니다. 추가할 컨트롤이 이면 다른 유형의 서버 컨트롤 (예: 사용자 정의 컨트롤, 사용자 지정 컨트롤 또는 ASP.NET 컨트롤) 컨트롤은 이미 래핑으로 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 웹 파트 컨트롤 집합 개체입니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 발견 하면이 메서드는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤의 새 인스턴스를 반환는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 에 래핑된 자식 컨트롤의 새 인스턴스를 제어 합니다.  
  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 메서드 반환 하는 컨트롤의 새 복사본을 만들고, 또한 모든 속성의 값을 해당 기본값으로 다시 설정 합니다. 방법은 있고 개인 설정 가능한 속성의 값을 유지 하려는 경우 새 컨트롤 인스턴스에 복사 하는,를 호출 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> 메서드도 있습니다. 마지막 단계에서 수행 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 메서드를 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> 컨트롤에 대 한 새 ID를 얻는 메서드를 합니다.  
  
> [!NOTE]
>  메서드는 복사 된 컨트롤에 대 한 새 ID를 얻고 때문에 원래 ID 페이지에 추가 되는 동적 컨트롤을 참조 하 되지는지 않습니다. 대신, 메서드에 의해 반환 된 컨트롤의 새 인스턴스를 참조 해야 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>메서드 선언 <see langword="virtual" /> 개발자가에서 상속할 수 있도록는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 메서드를 재정의 하 고, 컨트롤의 복사본을 만들 수 없기 추가 시나리오에 대 한 합니다. 예를 들어 메서드 수 필요에 따라 입력 매개 변수로 받을 XML 파일에 serialize 하는 컨트롤입니다. 메서드 수 (있는 경우), XML을 deserialize 하 고 기존 사례를 처리 하 고의 새 인스턴스를 반환 하도록 기본 메서드를 호출 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 제어 합니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 사이트의 구성 파일에 지정된 변환기 집합을 만들고 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 속성에서 참조하는 변환기의 컬렉션에 이 변환기 집합을 추가합니다.</summary>
        <returns>웹 사이트의 구성 파일에 지정된 변환기 컬렉션입니다.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>응용 프로그램에서 사용할 수 있는 변환기를 추가 하려면이 메서드를 재정의할 수 있습니다. 예를 들어 웹 서비스에서 사용 가능한 변환기의 목록을 검색 하는 메서드를 작성할 수 있습니다.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 페이지의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 모든 컨트롤의 컬렉션을 반환합니다. 이 클래스는 상속될 수 없습니다.</summary>
        <returns>
          <see cref="T:System.Web.UI.ControlCollection" /> 컨트롤에서 관리하는 다양한 웹 파트 컨트롤이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>이 메서드는 보호 되 고 봉인 되므로 클래스에서 상속 하는 표시 되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스와 재정의할 수 없습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 파트 응용 프로그램에서 사용할 수 있는 모든 디스플레이 모드의 집합을 만듭니다.</summary>
        <returns>지원되는 디스플레이 모드가 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 특정 페이지에서 지원 되는 디스플레이 모드 뿐 아니라 모든 가능한 표시 모드 목록을 만듭니다. 지원 되는 디스플레이 모드에 대 한 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다.  
  
 기본적으로 웹 파트 컨트롤 집합 디스플레이 모드 웹 파트 페이지에 사용할 다음 집합을 만듭니다.  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 개발자가 사용 하거나 사용 하지 않고에서 파생 되는 사용자 지정 영역 지정 디스플레이 모드를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebZone> 또는 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 클래스입니다. 상속 해야 지정 디스플레이 모드를 만들려면는 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 클래스에서 상속 해야 디스플레이 모드는 페이지에서 지원 되는 모드를 추가 하 고는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스를 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 메서드.  
  
 디스플레이 모드를 사용 하 여 추가 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> 메서드를 추가 해야 해당 사용자 인터페이스 (UI) 컨트롤에 표시할 원하는 순서로 (같은 <xref:System.Web.UI.WebControls.ListBox> 컨트롤)를 제공 하는 사용자에 게 가능한 디스플레이 모드는 페이지.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 이 코드 예제는 다섯 부분으로 구성 합니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   다른 컨트롤을 호스팅하는 웹 페이지입니다.  
  
-   사용자 정의 컨트롤에 상주 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 웹 페이지의 영역에서 입력 하 고 텍스트 레이블을를 표시할 수 있습니다.  
  
-   두 컨트롤을 포함 하는 소스 코드 파일. 하나는 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 은 사용자 지정 컨트롤 및 다른 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 페이지의 기본 디스플레이 모드에 추가할 개체입니다.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 예제의 두 번째 부분은 웹 페이지입니다. 포함 된 두 개의 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 사용자 정의 컨트롤 및 사용자 지정 둘 다 제어 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 공지는 `Register` 페이지 맨 위에 있는 지시문 사용자 정의 컨트롤 및 컴파일된 컨트롤에 대 한 네임 스페이스를 참조 합니다.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 이 예제에서는 세 번째 부분에를 입력 하 고 텍스트를 표시 하기 위한 사용자 컨트롤입니다. 사용 하 여 한 <xref:System.Web.UI.WebControls.MultiView> 컨트롤 UI의 여러 뷰를 만듭니다. 뷰 하나에서 `Button1` 하지 않고 다른 단추입니다. 재정의 된 다음에 유의 `OnPreRender` 메서드를 코드 확인 하는 여부 페이지는 현재 사용자 지정 표시 모드 하며,이 경우 표시 단추가 포함 된 사용자 정의 컨트롤의 첫 번째 뷰입니다. 페이지는 페이지가 찾아보기 또는 디자인 모드에 있으면 예는 사용자 지정 표시 모드에 있지 단추가 숨겨집니다.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 예의 네 번째 부분에는 두 개의 사용자 지정 클래스에 대 한 소스 파일입니다. 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 메서드와 먼저 모든 기본 디스플레이 모드를 추가 하려면 기본 메서드를 호출 하 고 다음 사용자 지정 디스플레이 모드를 추가 합니다. 사용자 지정 표시 모드 클래스 `InLineEditDisplayMode`에서 상속 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, 생성자의 디스플레이 모드의 이름을 설정 하 고 다양 한 사용자 지정 표시 특성을 설정 하는 기본 속성을 재정의 합니다.  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 코드 예제를 실행 하려면 브라우저에서 페이지를 로드 합니다. 페이지는 현재 찾아보기 모드에서는 없는 단추가 표시 되는지 확인 합니다. 사용 하 여는 **디스플레이 모드** 드롭 다운 목록 컨트롤, 페이지를 변경 **인라인 편집 표시** 모드 및 표시 되는지 확인 하는 `Button1` 단추 아래쪽 사용자 정의 컨트롤에 표시 됩니다. 텍스트를 추가 하 고 컨트롤을 업데이트 하려면 단추를 클릭 합니다. 고 해당 데이터베이스 페이지 표시는 찾아보기 모드로 되돌아갑니다, 입력 한 텍스트가 표시, 단추는 페이지 사용자 지정 디스플레이 모드 중 더 이상 이므로 다시 숨겨집니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>동적 연결의 ID 역할을 하는 고유 값을 가져옵니다.</summary>
        <returns>연결의 고유 ID가 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> 메서드는 GUID 값을 생성 하 고 연결에 대 한 고유 ID로 사용할 문자열로 변환 합니다. 메서드는 동적 연결 생성 될 때마다 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드는 파생에서 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 는 고유 ID를 생성 하기 위한 구현을 변경 하는 클래스</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">ID를 생성할 컨트롤의 <see cref="T:System.Type" />입니다.</param>
        <summary>동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤의 고유 ID를 생성합니다.</summary>
        <returns>컨트롤의 고유 ID가 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Web.UI.WebControls.WebParts.WebPart> 웹 페이지에 컨트롤을 추가 하는 일 수 있습니다 (즉, 페이지 태그에서 컨트롤을 선언한) 정적 또는 동적 (즉, 프로그래밍 방식으로 추가 됩니다). 모든 시나리오에서 여기서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 고유한 ID를 생성 하려면이 메서드를 호출 하는 것은 페이지에 추가할 새 동적 컨트롤을 만들고  
  
 메서드는 개발자가 ID를 생성 하기 위한 사용자 지정 구현을 제공 하는 경우 해당 재정의할 수 있도록 가상  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">실패한 컨트롤의 ID를 나타내는 문자열입니다. <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />가 오류와 관련된 경우 이 ID는 자식 서버 컨트롤의 ID입니다.</param>
        <param name="originalTypeName">실패한 컨트롤의 <see cref="T:System.Type" /> 이름을 나타내는 문자열입니다. <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />가 오류와 관련된 경우 이 형식 이름은 자식 서버 컨트롤의 형식입니다.</param>
        <param name="originalPath">자식 사용자 정의 컨트롤이 포함된 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />가 오류와 관련된 경우, 사용자 정의 컨트롤의 경로가 들어 있는 문자열입니다.</param>
        <param name="genericWebPartID">
          <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />의 형식이 컨트롤 로드 또는 생성 오류와 관련된 경우 해당 컨트롤의 ID를 반환하는 문자열입니다.</param>
        <param name="errorMessage">페이지에 표시할 오류 메시지가 포함된 문자열입니다.</param>
        <summary>어떤 이유로 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 로드하거나 만드는 데 실패할 경우 페이지에 삽입되고 최종 사용자에게 표시되는 특수 컨트롤을 만듭니다.</summary>
        <returns>로드하거나 만드는 데 실패한 컨트롤 대신 페이지에 삽입되는 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> 웹 파트 컨트롤 집합을 로드 하거나 동적의 인스턴스를 만들 때 메서드를 호출 <xref:System.Web.UI.WebControls.WebParts.WebPart> 서버 컨트롤을 몇 가지 이유로 실패할 또는 합니다. 메서드는 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 개체, 오류 메시지를 할당 하 고 반환 합니다. <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 컨트롤 실패 했거나 컨트롤 대신 삽입 되 고 해당 오류 메시지는 페이지에 표시 됩니다.  
  
 호출할 수 없습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> 사용자 코드에서 직접 메서드. 그러나에서 상속할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 및 메서드를 확장 합니다. 자세한 내용은 상속자 참고 사항 섹션에 대 한 메모를 참조 하세요.  
  
 최종 사용자가 작업할 수는 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 제어 페이지에 매우 일반적인 경우 처럼 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 오류 메시지를 제거 하려면 지점을 컨트롤에 추가 됩니다 닫기 동사를 클릭 하 여 컨트롤을 닫을 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 다른 컨트롤 처럼의 개체입니다. 최종 사용자를 삭제 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 서버 컨트롤에 로드 하지 못한 컨트롤에도 페이지에서 삭제 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>반환 되는 정보를 사용자 지정 하려는 경우는 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> 컨트롤을 재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> 메서드를 기본 메서드를 호출, 기본 메서드에 전달 된 매개 변수에 다른 값을 할당한 다음 다시 돌아와 결과 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />제어 합니다. 예를 들어, 최종 사용자에 게 표시 하지 않을 경우는 <paramref name="originalPath" /> 값 (사용자 정의 컨트롤의 가상 디렉터리 경로 표시), 기본 메서드를 호출 하는 경우에 빈 문자열을 전달할 수 있습니다 ("") 해당 매개 변수에 대해 합니다.  
  
 동작을 사용자 지정할 수도 있습니다는 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> 여기에서 상속 하 여 자체를 제어 합니다. 재정의 하려는 하는 예를 들어 해당 <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> 또는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> 속성입니다.</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 웹 페이지에 대한 사용자의 개인 설정 데이터를 포함하는 개인 설정 개체를 반환합니다.</summary>
        <returns>사용자의 개인 설정 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> 메서드 포함 하 고 현재 페이지에 대 한 사용자의 개인 설정을 관리할 개체를 반환 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 이 개체를 관리 하는 컨트롤입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 아닌 서버 컨트롤입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 아닌 서버 컨트롤을 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 개체로 래핑하여 웹 파트 기능을 갖도록 합니다.</summary>
        <returns>
          <paramref name="control" />을 래핑하여 실제 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤처럼 동작할 수 있게 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드는 사용 되지 않는 서버 컨트롤을 위한 기본 메커니즘 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 동일한 기능을 수행할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 이므로 웹 파트 응용 프로그램에 완전히 참여 합니다. 크게 개발자가이 메서드를 사용 하 여 웹 파트 응용 프로그램에서 사용할 수 있는 서버 컨트롤의 수, 하므로 서버 거의 모든 형식의 표준 ASP.NET 컨트롤, 사용자 정의 컨트롤 및 사용자 지정 컨트롤-사용할 수 있습니다 클릭 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어도이 방법을 사용 하 여이 다른 두 가지 시나리오에서 사용 하 여 서버 컨트롤을 래핑하는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체입니다. 때 사용자가 서버 컨트롤을 추가 페이지를 사용 하 여는 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 없으면 가져온된 컨트롤 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드를 호출 합니다. 서버 컨트롤 내에서 일관 된 형식에서 선언 되는 경우에 또한는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역, 웹 페이지에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 없는 모든 컨트롤에 대 한 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
 일반적인 방법은 사용 하 여 영역에 서버 컨트롤을 프로그래밍 방식으로 추가 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드를 사용 하 여 컨트롤는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체를 다음 호출에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 컨트롤의 모든 컬렉션에 추가 하는 방법을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 참조 하는 페이지에 있는 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 사용을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드. 에 `Button2_Click method`, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드를 래핑하는 <xref:System.Web.UI.WebControls.Calendar> 보호로 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 영역에 추가 하기 전에 개체입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생을 사용 하도록이 메서드를 재정의할 수 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 클래스 대신 웹 파트와 함께 제공 되는 기본 클래스의 컨트롤 집합입니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최종 사용자가 컨트롤을 삭제할 때 해당 사용자에게 표시되는 사용자 지정 경고 메시지를 가져오거나 설정합니다.</summary>
        <value>경고 메시지의 텍스트가 포함된 문자열입니다. 기본값은 지역화된 경고 메시지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하면 사용자는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어, 일반적으로 기본 경고 메시지가 표시 됩니다. 컨트롤의이 인스턴스를 삭제 하면 삭제는 영구적 사용자 경고 합니다. 페이지 개발자 페이지에 컨트롤의 새 인스턴스를 추가 하는 방법을 사용자가 제공할 수 있습니다 (같은의 카탈로그를 통해 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 또는 몇 가지 프로그래밍 방법), 삭제 되는 컨트롤의 현재 인스턴스는 영구적으로 제거 하지만 합니다. 필요한 경우의 삭제를 취소 하려면 사용자에 대 한 단추를 포함 하는 경고를 표시 하는 대화 상자의 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 속성을 사용 하면 개발자가 사용자에 게 표시 되는 경고 메시지를 설정할 수 있습니다.  
  
 페이지 개발자 할당 빈 문자열 ("")를 삭제할 때 값이 속성에 경고 메시지 대화 상자가 표시 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 속성이 정적의 경우 표시 되지 않습니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤과 서버 컨트롤입니다. 정적 컨트롤 내에 선언 된 서버 컨트롤은 한 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역에 웹 페이지의 태그입니다. 이러한 컨트롤은 정적 이므로 삭제할 수 없습니다, 때문 delete 경고 메시지가 경우 표시 되지 않습니다. 사용자가 정적 컨트롤을 닫을 수 있지만 닫힌된 컨트롤이 있는 것 수로 다시 추가할 수는 페이지는 사용자가 반면 삭제 된 컨트롤을 복구할 수 없습니다 페이지 카탈로그에 추가 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 속성 선언적 방법과 프로그래밍 방식으로 합니다.  
  
 코드 예제에 네 부분으로 이루어져 있습니다.  
  
-   페이지 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
-   웹 페이지입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 코드 예제에서는 두 번째 부분은 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예에서는 동적 컴파일 방법을 사용 합니다. 없기 때문에 없는 `Assembly` 특성에 `Register` 웹 페이지의 위쪽에이 컨트롤에 대 한 지시문입니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 페이지에는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 를 사용자 지정 영역 <xref:System.Web.UI.WebControls.WebParts.WebPart> 사용자를 런타임 시 페이지로 것으로 추가할 수 있도록 영역에 컨트롤이 선언 합니다. Note 동적 컨트롤 (프로그래밍 방식으로 또는 이와 같은 카탈로그 페이지에 추가 된 컨트롤) 페이지에서 삭제할 수 있습니다. 정적 컨트롤 (내에서 선언 된 컨트롤에는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역 페이지의 태그에) 닫을 수 있지만 삭제 되지 않습니다. `<asp:webpartmanager>` 에 대 한 사용자 지정 값을 선언 하는 요소는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 사용 하 여 속성의 `DeleteWarning` 특성입니다. `Button1_Click` 을 다른 사용자 지정 값을 할당 하는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후에 추가 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 페이지입니다. 사용 하는 **디스플레이 모드** 드롭 다운 목록 컨트롤, 카탈로그 모드를 선택 합니다. 카탈로그에 표시 되 면 사용자 지정 컨트롤 옆의 확인란을 선택를 클릭 **추가** 페이지에 추가 하 고 클릭 한 다음에 **닫기** 페이지 찾아보기 모드를 되돌립니다. 이제는 컨트롤이 표시,이 삭제할 수 있습니다. 사용 하는 **디스플레이 모드** 다시 제어 하 고, 페이지 (삭제할 수 없습니다 컨트롤 페이지가 찾아보기 모드에 있을 때는) 디자인 모드를 전환 합니다. 동사 메뉴 (화살표 기호)의 헤더에는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 선택 **삭제**합니다. 에 설정 된 경고는 `DeleteWarning` 특성이 나타납니다. 클릭 **취소**합니다. 이제 단추를 클릭 **변경 삭제 경고**를 프로그래밍 방식으로 속성 값 변경 내용을 합니다. 컨트롤에 있는 동사 메뉴에서 선택 **삭제** 다시 및이 현재 다른 경고 메시지가 나타납니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">삭제할 서버 컨트롤입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤의 동적 인스턴스를 웹 페이지에서 영구적으로 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 메서드 나타내는 컨트롤을 영구적으로 제거는 `webPart` 페이지에서 매개 변수입니다. 닫힌 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 제어 하 고 삭제 된 컨트롤 인스턴스 페이지에 다시 추가할 수 없습니다는 페이지에 다시 추가할 수 있습니다.  
  
> [!NOTE]
>  웹 파트 컨트롤에 의해 구현 될 때 설정, 동적을 삭제 하려면 사용자를 위한 기능 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 사용자와 페이지에 컨트롤이 추가 된 개인 설정 범위에 따라 달라 집니다. 컨트롤 (권한이 있는 사용자)에 의해 페이지가 공유 범위에 있을 때 추가 되 면 다음 컨트롤 경우 삭제할 수 없습니다 개별 사용자가 페이지는 사용자 범위에 있습니다.  
  
 동적 컨트롤에만 삭제할 수 있습니다. 동적 컨트롤은 프로그래밍 방식으로 또는 카탈로그에서 컨트롤을 추가 하는 사용자가 페이지에 추가 됩니다. 정적 컨트롤 태그 또는 지 속성 형식에서 선언적으로 페이지에 추가 됩니다. 선언적 태그 인 태그에 영구적으로 존재 하기 때문에 정적 컨트롤을 삭제할 수 있습니다 하지만 닫은 후 다시 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 메서드를 사용하는 방법을 보여 줍니다. 처음으로 **추가 달력** 단추를 클릭 하면 코드 이벤트 처리기를 만듭니다는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤을으로 영역에 추가 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체입니다. 컨트롤은 프로그래밍 방식으로 추가 되므로, 동적 제어 되며 따라서 삭제할 수 있습니다. 사용자가 클릭할 때는 **일정 삭제** 단추, 코드 하면 컨트롤 존재 하 고 다음 호출 하 여 삭제는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 컨트롤이 들어 있는 웹 페이지의 레이아웃을 변경하는 데 사용되는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> 필드 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고에 포함 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 정적 개체 이므로 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 웹 파트를 포함 하는 페이지를 처음 로드할을 제어 하는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (찾아보기 모드) 기본적으로 합니다. 페이지를 사용자가을 다른 영역이 나 현재 영역 내에서 컨트롤을 이동 하 여 페이지의 레이아웃을 변경 하려면, 먼저 전환 해야 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (디자인 모드). 디자인 모드에서 다양 한 영역에 대 한 사용자 인터페이스 (UI) 나타나고 사용자 레이아웃을 변경 하는 컨트롤을 끌어 놓을 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> 필드를 프로그래밍 방식입니다. 코드는 찾아보기 및 디자인이 경우에 페이지에 대해 지원 되는 디스플레이 모드와 드롭 다운 목록을 채웁니다. `Page_PreRender` 메서드, 코드 검사 하는지 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>합니다. 이 경우 `Label1` 를 볼 수는 고 없는 경우, `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드 기본적으로 위치는입니다. 페이지의 레이블이 숨겨지는지 확인 합니다. 드롭다운 목록 컨트롤을 사용 하 여 페이지 디자인 모드를 전환 합니다. 코드 인해는 `Page_PreRender` 메서드, 레이블이 표시 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결을 끊을 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</param>
        <summary>닫거나 삭제할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 해당 컨트롤이 참여하는 연결에서 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드는 웹 파트 컨트롤 집합 컨트롤이 페이지에 종료 되거나 페이지에서 삭제할 때 내부적으로 호출 됩니다. 이러한 시나리오에서는 메서드 소비자 또는 공급자와 연관 된 모든 연결에서 컨트롤을 제거 하려면 호출 됩니다. 모든 연결에서 컨트롤이 제거 되 면 하는 경우이 메서드 호출의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 모든 연결을 종료 하는 메서드 `webPart` 복잡 합니다.  
  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드가 호출 되 면 발생는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트입니다. 일반적으로이 이벤트를 취소할 수 있지만 두 가지 경우에는 취소할 수 없습니다. 페이지에 요청 중 한 가지 경우에 발생 때는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 메서드를 호출 합니다. 기존 연결 간에 충돌 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 와이 인스턴스에 충돌 하는 연결 중 하나를 닫는 메서드를 호출 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 충돌을 해결할 수 있어야 하기 때문에 이벤트를 취소할 수 없습니다.  
  
 다른 사례 발생 때는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 현재 연결 된 서버 컨트롤 종료 하거나 삭제 합니다. 제어로 인해이 경우 종료 되 게도 따라서 취소 하는 것이 불가능 설계 연결 요구 사항이 해당 페이지에서 제거 되 고 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 종료 프로세스를 중단 하는 이벤트입니다. 자세한 내용은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드를 사용하는 방법을 보여 줍니다. 두 개의 사용자 지정을 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 웹 페이지에서는 다른 단추를 사용 하면 컨트롤을 분리 하는 동안에 단추를 클릭 하 여 컨트롤 간의 연결을 만들 수 있습니다. 페이지가 찾아보기 모드에서는 고, 연결 될 동안 닫은 컨트롤 중 하나의 경우 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드 닫힌된 컨트롤의 연결을 끊습니다 해당 연결을 종료 하 고 메시지를 표시 합니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다.  
  
-   사용자 지정을 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
-   해당 컨트롤을 호스팅하는 웹 페이지입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 두 번째 부분은 두 개의 사용자 지정에 대 한 소스 코드를 포함 하는 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결 될 컨트롤 및 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예에서는 동적 컴파일 하므로 `Register` 웹 페이지에서 이러한 구성 요소를 참조 하는 지시문이 적절 하 게 선언 된 웹 페이지의 위쪽에 있습니다. 컴파일 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 소스 코드에서 상속 된 컨트롤인 `MyWebPartManager` 재정의 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드. 이 메서드는 확인 닫히는 컨트롤 연결에 참여 하 고,이 경우 호출 하는 페이지의 각 연결에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드는 연결을 종료 합니다. 메서드의 기본 구현에서 동일는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 그런 다음 재정의 된 메서드가 사용자 페이지에 메시지를 기록 하 여 기본 구현을 정의 합니다.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 위쪽에 포함 되어 `Register` 지시문을 사용 하 고 사용자 정의 컨트롤을 사용 하 여 동적으로 컴파일된 어셈블리를 등록 하는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 페이지에는 두 가지 주요 방법입니다. `Button1_Click` 메서드는 컨트롤 간의 연결을 만들고 동안는 `Button2_Click` 메서드 컨트롤 연결을 끊습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 페이지를 로드 한 후을 클릭는 **연결** 단추 컨트롤을 연결 합니다. 그런 다음 동사 메뉴 컨트롤 (헤더 컨트롤의 아래쪽 화살표) 중 하나를 클릭 하 고 선택 **닫기** 동사 메뉴에서 합니다. 컨트롤을 닫을 하려고 할 때 재정의 된 메서드는, 연결이 종료 되 및 페이지에 메시지가 기록 됩니다. 닫힌된 컨트롤을 복원 하 고 다른 옵션을 사용해 클릭 하려면 페이지를 다시 설정 하려는 경우는 **Reset User State** 링크 개인 설정 데이터를 제거 하는 페이지의 원래 상태로 복원 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">서버 컨트롤 간의 연결을 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</param>
        <summary>웹 페이지에 있는 연결된 서버 컨트롤의 연결을 끊는 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드는 전체 프로세스 간의 연결을 종료를 수행 <xref:System.Web.UI.WebControls.WebParts.WebPart> 나 서버 컨트롤에 전달할 때의 `connection` 매개 변수입니다.  
  
 이 메서드는 컨트롤을 배치할 때 연결을 끊을 데는 `<asp:connectionszone>` 연결 관리에 대 한 사용자 인터페이스 (UI)를 제공 하는 웹 페이지의 요소입니다. 페이지에 있으면 연결 디스플레이 모드 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>), 및 현재 연결이 있는, 사용자가 호출 하는 단추를 클릭할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드는 연결을 종료 합니다.  
  
 호출할 수도 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 프로그래밍 방식으로 및 추가 하지 않고 컨트롤을 분리 하려는 경우 사용자 코드에서 직접 메서드는 `<asp:connectionszone>` 요소는 페이지입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드를 사용하는 방법을 보여 줍니다. 두 개의 사용자 지정을 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 웹 페이지에서는 다른 단추를 사용 하면 컨트롤을 분리 하는 동안에 단추를 클릭 하 여 컨트롤 간의 연결을 만들 수 있습니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다.  
  
-   사용자 지정을 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
-   해당 컨트롤을 호스팅하는 웹 페이지입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 두 번째 부분은 두 개의 사용자 지정에 대 한 소스 코드를 포함 하는 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결 될 컨트롤입니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예에서는 동적 컴파일 하므로 `Register` 웹 페이지에서 이러한 구성 요소를 참조 하는 지시문이 적절 하 게 선언 된 웹 페이지의 위쪽에 있습니다. 컴파일 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 위쪽에 포함 되어 `Register` 사용자 정의 컨트롤 및 사용 하 여 동적으로 컴파일된 어셈블리를 등록 하는 지시문은 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 페이지에는 두 가지 주요 방법입니다. `Button1_Click` 메서드는 컨트롤 간의 연결을 만들고 및 `Button2_Click` 메서드 컨트롤 연결을 끊습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 페이지를 로드 후 클릭할 수 있습니다는 **연결** 단추 컨트롤을 연결 합니다. 텍스트 상자 컨트롤에 텍스트를 입력 하 고 클릭 하는 경우는 **Enter** 단추 텍스트 (것 표시 되지 않는 컨트롤에 연결이 끊어진 경우) 연결 된 컨트롤에 표시 됩니다. 클릭는 **연결 끊기** 단추, 컨트롤 분리 됩니다. 사용 하 여 컨트롤의 연결 상태를 확인할 수 있습니다는 **디스플레이 모드** 드롭 다운 목록 컨트롤에 페이지 전환을 **연결** 모드입니다. 하는 작업을 수행한 후 컨트롤 중 하나의 제목 표시줄에 동사 메뉴 (화살표로 표시 됨)를 클릭 하 고 선택 된 **연결** 항목입니다. 연결 UI가 표시 됩니다. 있기 때문에 가능 하다는 `<asp:connectionszone>` 페이지에 요소를 선언 합니다. 연결 하 고이 UI에서 컨트롤을 연결을 끊을 수도 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" />이 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 또는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />에 포함되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />이(가) 읽기 전용입니다.  
  
 \- 또는 -  
  
 <paramref name="connection" />이 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />에서 이미 연결이 끊긴 경우  
  
 \- 또는 -  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />이(가) 읽기 전용입니다.  
  
 \- 또는 -  
  
 <paramref name="connection" />이 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />에서 이미 연결이 끊긴 경우</exception>
        <block subset="none" type="overrides">
          <para>재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> 메서드 연결 끊기에 대 한 기본 구현을 변경 하려는 경우 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다. 메서드를 재정의 하는 경우 단순히 기존 메서드 일부 구현을 추가 하려면 사용자 고유의 코드를 실행 하기 전에 기본 메서드를 호출할 수 있습니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 컨트롤이 들어 있는 웹 페이지의 활성 디스플레이 모드를 가져오거나 설정합니다.</summary>
        <value>페이지의 디스플레이 모드를 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 컨트롤을 포함 하는 페이지는 항상 여러 개의 가능한 디스플레이 모드 중 하나입니다. 디스플레이 모드에 대 한 세부 정보를 참조 하십시오. [웹 파트 페이지 디스플레이 모드](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스는 웹 페이지에 대 한 디스플레이 모드를 만듭니다. 기본을 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 클래스는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 웹 파트 컨트롤을 포함 하는 페이지에 사용할 수 있는 여러 가지 표준 디스플레이 모드 개체를 만듭니다. 에 설명 되어 이러한 표준 디스플레이 모드는 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 클래스 개요입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에 웹 파트 컨트롤을 사용 하는 페이지에 대 한 디스플레이 모드도 관리 합니다. 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 페이지에 현재 표시 모드에 대 한 참조를 유지 합니다. 사용할 수도 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성 페이지는 서로 다른 디스플레이 모드를 전환 합니다. 웹 파트 컨트롤을 사용 하는 페이지에서 디스플레이 모드 변경의 예제를 보려면 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 디스플레이 모드 관리의 일부로 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 이벤트 및 이벤트 처리기와 같은 디스플레이 모드와 관련 된 제공 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> 메서드. 이러한 메서드는 페이지의 동작을 사용자 지정 하 고 사용자 지정 디스플레이 모드를 추가 하는 데에 메커니즘을 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성입니다. 브라우저에서 페이지를 로드 한 후 디스플레이 모드를 전환 하려면 페이지의 아래쪽에 있는 단추를 사용할 수 있습니다. 페이지를 로드할 때 기본적으로 찾아보기 모드입니다. 디자인 모드로 전환 하면 다른 한 영역에서 서버 컨트롤을 끌어 올 수도 있고 하나의 영역 내에서 두 개의 컨트롤을 정렬할 수 있습니다. 편집 모드로 전환 하면 클릭할 수 있는 서버 컨트롤의 머리글에 있는 동사 메뉴 **편집**, 제공 된 편집 사용자 인터페이스 (UI)를 사용 하 여 컨트롤을 편집 합니다.  
  
> [!NOTE]
>  웹 파트 응용 프로그램에 대 한 디스플레이 모드를 전환 하는 것은 매우 일반적인 및 웹 파트 컨트롤을 포함 하는 모든 페이지에이 작업을 수행 하는 일관 되 고 다시 사용할 수 있는 방법을 제공 하는 것이 좋습니다. 여러 페이지에서 다시 사용할 수는 변경 내용이 있는 디스플레이 모드는 사용자 정의 컨트롤의 예에 대 한 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">속성에 할당되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">속성에 할당되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체가 지원되는 디스플레이 모드 중 하나가 아닌 경우  
  
 \- 또는 -  
  
 속성에 할당되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체를 사용할 수 없는 경우</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 페이지의 현재 디스플레이 모드가 변경된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 디스플레이 모드는 웹 파트 응용 프로그램의 필수적인 부분입니다. 사용자가 웹 페이지의 다른 디스플레이 모드를 전환 하는 경우 페이지는 매우 다른 모양의 새 디스플레이 모드의 목적에 따라을 자주 수행 합니다. 디스플레이 모드 변경 된 후에 선택한 UI 요소의 모양 변경 특정 컨트롤을 표시 하거나 숨길 같은 사용자 인터페이스 (UI)에 특정 변경 해야 할 수도 있으며 등 수 있습니다.  
  
> [!NOTE]
>  디스플레이 모드에 대 한 자세한 내용은 참조 하십시오. [웹 파트 페이지 디스플레이 모드](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)합니다. 이벤트 사용에 대 한 자세한 내용은 참조 하십시오. [하는 방법: Web Forms 응용 프로그램에](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 웹 페이지에서 디스플레이 모드 변경 프로세스를 시작하는 동사를 클릭한 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 디스플레이 모드는 웹 파트 응용 프로그램의 필수적인 부분입니다. 사용자가 웹 페이지의 다른 디스플레이 모드를 전환 하는 경우 페이지는 매우 다른 모양의 새 디스플레이 모드의 목적에 따라을 자주 수행 합니다. 특정 사용자 인터페이스 (UI)에서 사용 하 여 변경 하려는 사용자가 동사를 클릭 하 여 새 디스플레이 모드를 변경 하는 과정을 시작 후는 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> 다음 다양 한 UI 변경 및 새 디스플레이 모드는 것을 결정 하는 속성 요소 적절 하 게 합니다. 이 작업을 수행 하는 유용한 방법은 재정의 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> UI를 사용자 지정 하는 메서드.  
  
> [!NOTE]
>  디스플레이 모드에 대 한 자세한 내용은 참조 하십시오. [웹 파트 페이지 디스플레이 모드](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)합니다. 이벤트 사용에 대 한 자세한 내용은 참조 하십시오. [하는 방법: Web Forms 응용 프로그램에](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤과 관련된 모든 디스플레이 모드의 읽기 전용 컬렉션을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> 컨트롤과 관련된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 관련 된 모든 모드와 달리 디스플레이 속성 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 디스플레이 모드 사용할 수 있는 현재 페이지에서 (지원)를 참조 하는 속성입니다.  
  
 제공 된 디스플레이 모드, 찾아보기, 디자인, 두 가지는 페이지에 항상 지원 됩니다. 다른 세 가지 표시 모드, 편집, 카탈로그 및 연결을 페이지에는 해당 영역에서 실행 되도록 특정 디스플레이 모드에 필요한 형식이 있을 때만 지원 됩니다. 예를 들어, 페이지에 포함 되어 있지 않으면는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 영역 편집 디스플레이 모드에에서 표시 되는 참조 하는 컬렉션의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 속성을 참조 하는 컬렉션에 나타나지 않으므로 하지만 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 사용을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 속성입니다. 코드는이 속성을 사용 하 여 웹 파트 컨트롤 집합에서 사용할 수 있는 모든 디스플레이 모드를 사용 하 여 목록 채우기를 현재 페이지에서 지원 되지 않는 비롯 합니다. 이 경우 카탈로그 하 고 해당 하는 영역이 페이지에 없는 필요 하기 때문에 디스플레이 모드 지원 되지 않으며를 연결 합니다.  
  
 다른 세 개의 디스플레이 모드인 찾아보기, 디자인 및 편집-페이지에서 지원 됩니다. 편집 페이지 모드는 지원는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 찾아보기 영역 및 디자인 모드는 항상 지원 합니다.  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드에서 페이지의 디자인 모드를 전환 하려면 드롭다운 목록에서 컨트롤을 사용할 수 있습니다 다음 편집 모드를 합니다. 편집 모드에 서버 컨트롤 중 하나의 헤더에 있는 드롭 다운 동사 메뉴를 클릭 하 고 선택할 수 **편집** 컨트롤을 편집 합니다. 선택 사항에 유의 **카탈로그** 또는 **연결** 드롭 다운 목록에서 오류 페이지가 생성 됩니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 현재 있는 모든 동적 연결의 컬렉션을 가져옵니다.</summary>
        <value>페이지의 모든 동적 연결에 대한 참조가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 연결에 프로그래밍 방식으로 정적이 아니라 만들어진 연결이 있습니다. 정적 연결은 Web Forms 페이지의 태그에 선언 하 여 만듭니다. 동적 연결을 프로그래밍 방식으로 또는 연결 사용자 인터페이스 (UI)를 사용 하 여 연결을 만드는 사용자가을 구성 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> 컬렉션,이 기능은 읽기 전용 이며 해당 내용을 변경할 수 없습니다, 각 동적 연결 개체에 대 한 프로그래밍 방식의 액세스를 제공 하는 합니다.  
  
> [!NOTE]
>  연결 또는 연결 끊기 등의 일반적인 작업을 수행 하려면 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 개발자가에서 공용 메서드를 사용 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 같은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, 직접 연결을 수정 하는 대신 개체에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최종 사용자가 서버 컨트롤을 편집 및 수정할 수 있는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> 필드 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고에 포함 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 정적 개체 이므로 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 웹 파트를 포함 하는 페이지를 처음 로드할을 제어 하는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (찾아보기 모드) 기본적으로 합니다. 페이지를 사용자가 편집 하거나 서버 컨트롤을 수정 하려면, 먼저 전환 해야 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (편집 모드). 둘째, 특정 서버 컨트롤의 편집 동사 해당 컨트롤의 헤더에 있는 동사 메뉴를 클릭 하 여 편집을 선택 해야 합니다. 컨트롤이 편집 모드에 있으면 선택한 컨트롤을 편집 하기 위해 편집 사용자 인터페이스 (UI) 나타납니다.  
  
 페이지에서 편집 모드를 사용 하려면 페이지 해야 하나 이상 포함 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 와 같은 제공 되는 편집 중 하나 이상이 포함 된 영역 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> 컨트롤 또는 편집 컨트롤을 사용자 지정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> 필드를 프로그래밍 방식입니다. 코드는 찾아보기, 디자인 및 편집이 경우에 페이지에 대해 지원 되는 디스플레이 모드와 드롭 다운 목록을 채웁니다. 편집을 지원 하려면는 `<asp:EditorZone>` 요소는 페이지입니다. `Page_PreRender` 메서드, 코드 검사 하는지 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>합니다. 이 경우 `Label1` 를 볼 수는 고 없는 경우, `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드 기본적으로 위치는입니다. 페이지의 레이블은 숨겨져 있습니다. 페이지를 편집 모드로 전환 하려면 드롭다운 목록에서 컨트롤을 사용 합니다. 코드 인해는 `Page_PreRender` 메서드, 레이블이 표시 됩니다. 클릭는 **편집** 해당 특정 컨트롤을 편집할 수 있도록 컨트롤 중 하나에서 동사 메뉴에서 동사입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 들어 있는 웹 페이지에서 클라이언트 스크립트를 사용할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>페이지에서 클라이언트 스크립트를 실행할 수 있는지 여부를 나타내는 부울 값입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> 속성은 개발자가 클라이언트 스크립트를 사용 하지 않도록 설정할 수 있는 방법을 제공 합니다. 클라이언트 보안을 위해 스크립트를 사용 하지 않도록 설정 하거나 갖도록 하는 데는 페이지의 모든 사용자는 유사한 사용자 환경, 다양 한 브라우저를 사용 하는 경우에 할 수 있습니다.  
  
 클라이언트를 추가 하 여 스크립트를 사용 하지 않도록 설정할 수는 `EnableClientScript` 특성을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 선언적 코드의 다음 줄에서와 같이 웹 페이지에는 요소:  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 개발자가에서 상속 하 여이 속성을 제거할 수는 또한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 및 기본 설정 값을 `false`합니다.  
  
 웹 파트 컨트롤 집합에는 클라이언트는 클라이언트의 일부 UI (사용자 인터페이스) 및 개인 설정 기능을 제공 하는 데 스크립팅을 사용 합니다. 클라이언트를 사용 하지 않도록 설정 스크립팅, 웹 파트 컨트롤은 여전히 작동 하지만 일부 기능은 사용할 수 없습니다. 다른 영역으로 컨트롤을 끌어다 놓을 수 있는 기능 (동사는 대신 컨트롤의 제목 표시줄에서 링크로 표시 됨) 하는 컨트롤의 제목 표시줄에 있는 드롭 다운 동사 메뉴를 렌더링 하는 기능과 더불어 비활성화 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 테마를 사용할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>테마를 사용할 수 있는지 여부를 나타내는 부울 값입니다. 모든 경우에 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 기본 재정의 <xref:System.Web.UI.Control.EnableTheming%2A> 속성 값이 항상 반환 하는지 확인을 `true`합니다. 웹 파트 컨트롤 집합에서는 웹 파트를 렌더링 하는 테마를 사용 하는 컨트롤의 자식 컨트롤 때문에 이렇게는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 를 구성 하는 웹 페이지의 사용자 인터페이스 (UI). 예를 들어 테마는 다양 한 영역을 렌더링 하는 데 및 다양 한 유형의 비롯 하 여 해당 영역에 있는 컨트롤 파트 컨트롤 (에서 상속 하는 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.Part> 클래스), 사용자 정의 컨트롤, ASP.NET 서버 컨트롤 및 사용자 지정 서버 제어 합니다.  
  
 하지만 재정의 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> 속성은 기본 속성에 따라 읽기/쓰기 속성으로 구현 설계 해야 항상 반환 값이 속성을 설정할 수 없습니다, `true`합니다. 속성을 설정 하려고 하면 한 <xref:System.NotSupportedException> 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 속성에 값을 설정하려고 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 다른 컨트롤에 연결하는 프로세스를 완료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 메서드에 연결 하는 프로세스를 완료 한 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 다른 컨트롤입니다. 그는는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> 메서드.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 메서드를 사용 하면 참조 하는 개인 설정 개체가 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성은 수정할 수 있는 필요한 유형이 기 때문에 대 한 연결을 형성 자체는 개인 설정 합니다. 다음 메서드를를 사용 하면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 개체가 아닙니다 `null`, 마지막으로 호출 하 고는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 속성이 참조하는 컨트롤이 <see langword="null" />인 경우</exception>
        <block subset="none" type="overrides">
          <para>확장 하는 개발자는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤 파생된 클래스에서이 메서드를 재정의 하는 경우가 있습니다. 기본 메서드를 호출 하 고 몇 가지 추가 사용자 지정 처리를 추가 하는 한 가지 방법은 것 또는 완전히 컨트롤 간의 연결을 완료 하는 전체 과정을 사용자 지정할 수 있습니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 편집하는 프로세스를 완료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 메서드 편집 하는 프로세스를 완료 한 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 그는는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 메서드.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 메서드를 사용 하면 참조 하는 개인 설정 개체가 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성, 필요한 되는 것 이므로 편집 컨트롤에는 개인 설정 변경 해야 하는 프로세스입니다. 다음 메서드를를 사용 하면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 개체가 아닙니다 `null`되도록 현재 선택 된 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 변경 하 고 마지막를 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 속성이 참조하는 컨트롤이 <see langword="null" />인 경우</exception>
        <block subset="none" type="overrides">
          <para>확장 하는 개발자는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤 파생된 클래스에서이 메서드를 재정의 하는 경우가 있습니다. 기본 메서드를 호출 하 고 몇 가지 추가 사용자 지정 처리를 추가 하는 한 가지 방법은 것 또는 완전히 컨트롤의 편집을 완료 하는 전체 과정을 사용자 지정할 수 있습니다. 예를 들어 재정의 메서드에서 기본 메서드를 먼저 호출한 한 후 적용 된 편집 변경 내용을 결정 하는 코드와을 확인 하는 최종 사용자에 게 다시 하는 변경 내용 목록을 표시를 추가할 수 있습니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤에서 중요한 상태 데이터를 내보내려고 할 때 표시되는 경고 메시지 텍스트를 가져오거나 설정합니다.</summary>
        <value>경고 메시지가 들어 있는 문자열입니다. 기본 메시지는 .NET Framework에서 제공하는 문화권별 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 중요 한 상태 데이터를 내보낼 하려고 할 때는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어, 소스 코드의 중요 한 정보로 표시 된 멤버에서 가져온 데이터를 내보내고 하 라는 메시지 상자에 사용자에 게 경고 메시지가 표시 됩니다 중요 한 데이터를 내보내는 내보내기를 취소할 수를 제공 하 고 있습니다. 개발자가 설정 하 여 중요 한 특정 멤버의 데이터를 표시할 수는 `isSensitive` 의 매개 변수는 `[Personalizable]` 특성을 `true` 멤버입니다. 이 특성 및 매개 변수 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> 클래스입니다.  
  
> [!IMPORTANT]
>  웹 파트의 내보내기 기능을 사용 하는 경우 중요 한 데이터를 권한이 없는 사용자에 잠재적으로 내보낼 수도 있습니다. 이 위협 으로부터 보호 하는 방법에 대 한 세부 정보를 참조 하십시오. [보안 웹 파트 페이지](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 기본 메시지는 사용자가 내보내기를 시도할 때마다 표시 됩니다. 그러나 값을 할당 하 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 속성을 사용자 지정 경고 메시지를 제공할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 선언적으로 사용 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 속성입니다.  
  
 다음 웹 페이지에 대 한 코드는 표준을 사용 하 여 <xref:System.Web.UI.WebControls.BulletedList> 제어 하 고 영역에 배치 합니다. 컨트롤 래핑는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 실제 역할을 할 수 있는 런타임 시 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 컨트롤을 내보낼 수 있도록는 `ExportMode` 특성이 추가 되는 `<asp:bulletedlist>` 요소 및 특성 값은로 설정 되어 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, 즉, 중요 한 중요 하지 않은 데이터를 내보낼 수 있습니다. 에는 `<asp:webpartmanager>` 요소는 `ExportSensitiveDataWarning` 특성 사용자 지정 값이 할당 됩니다.  
  
 코드 예제가 작동 하려면, 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에 추가 해야 하는 설정을 나타냅니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내에서 `<system.web>` 섹션에서 없는지 확인 한 `<webParts>` 인 요소는 `enableExport` 특성이로 설정 `true`와 같이, 다음 태그입니다.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 링크를 포함 하는 컨트롤의 제목 표시줄에 동사 메뉴 (아래쪽 화살표로 표시 됨)를 클릭 합니다. 동사 메뉴에서 선택 **내보내기**, 및 사용자 지정 경고와 함께 메시지 상자가 나타납니다. 내보내기를 계속 하려면 클릭 **확인**를 사용 하면 컨트롤에 대 한 모든 데이터가 XML 설명 파일의 로컬 복사본을 저장 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">데이터를 내보낼 해당 컨트롤입니다.</param>
        <param name="writer">
          <c>webPart</c>에서 내보낸 데이터를 XML 설명 파일에 쓰는 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>서버 컨트롤의 상태 및 속성 데이터가 들어 있는 XML 설명 파일을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 에서 다양 한 상태 및 속성 데이터를 조합 하는 메서드 `webPart` XML 파일에 있습니다. 데이터에는 해당 어셈블리, 상태 데이터 및 속성 데이터를 포함 하 여 컨트롤 자체에 대 한 정보가 포함 됩니다. 내보내기를 시작 하는 사용자 로컬 컴퓨터 또는 네트워크의 디스크에 XML 파일을 저장할 수 있습니다. 다른 사용자가 다음 description 파일 다른 페이지 또는 웹 사이트를 가져오고 수 상태 및 속성 데이터의 다른 인스턴스에 적용 `webPart`합니다. 따라서 사용자가 공유 하 고 서버 컨트롤에서 해당 설정을 다시 사용할 수에 대 한 빠르고 편리한 메커니즘을 제공 하며 모양과 내보낸 / 가져온 컨트롤의 동작을 제어 하는 방법을 개발자를 제공 합니다.  
  
 속성에 `webPart` 기본적으로 내보내지 않습니다. 내보낼 속성을 사용 하려면 표시 해야 사용 하 여는 `[Personalizable]` 소스 코드에서. 내보낼 수 있는 속성을 설정 하 여 중요 한 데이터를 포함 하는 것도 선택적으로 표시할 수 있습니다는 `isSensitive` 의 매개 변수는 `[Personalizable]` 특성을 `true`합니다. 기본적으로 `isSensitive` 은 `false`합니다. 개발자는 매개 변수 설정할 수 있습니다 `true` 중요 한 데이터 임을 나타냅니다.  
  
 사용할 수 있도록 `webPart` 를 내보낼 수는 개발자는 다음과 같이 설정 됩니다. 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 속성 값을 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (개인 및 중요 한 속성을 모두 포함), 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, 중요 한 속성을 제외한 모든 내보냄 .  
  
> [!IMPORTANT]
>  사용자가 컨트롤에서 데이터를 내보내려면 및 다른 컨트롤에 데이터를 가져올 수 있도록 몇 가지 보안 위험을 수반 합니다. 중요 한 데이터를 보호 하기 위해 위에서 설명한 방법을 사용 해야 하며 이러한 데이터를 모두 노출의 위험을 방지 하는 경우에 내보내기를 허용 하지는 마십시오 `webPart` 전혀 합니다. 웹 파트 보안 문제에 대 한 세부 정보를 참조 하십시오. [보안 웹 파트 페이지](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <paramref name="writer" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />에서 참조되는 컨트롤의 컬렉션에 포함되지 않은 경우  
  
 \- 또는 -  
  
 <paramref name="webPart" />의 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 속성이 <paramref name="webPart" />에서 데이터를 내보낼 수 없음을 나타내는 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> 값으로 설정된 경우</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에는 UI(사용자 인터페이스)가 없으므로 이 컨트롤에 포커스를 설정하지 못하도록 재정의된 메서드입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> 메서드 재정의 기본 <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> 메서드를 호출자의 메서드를 호출 하는 경우 예외를 throw 합니다. 때문에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 포커스를 자체에서 설정할 수 없도록 수에 UI 컨트롤과 사용자에 게 표시 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출자가 UI가 없는 컨트롤에서 지원되지 않는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 메서드를 호출하려고 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결에서 소비자 역할을 하는 서버 컨트롤입니다.</param>
        <summary>웹 파트 연결의 소비자 역할을 하는 서버 컨트롤에서 연결 지점으로 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 개체의 컬렉션을 검색합니다.</summary>
        <returns>소비자의 연결 지점이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 연결에서 항상 정확히 두 개의 컨트롤의 데이터를 데이터 소비자 공급자 역할을 하나 포함 됩니다. 각 컨트롤에는 하나 이상의 정의 된 메서드는 연결 지점으로 있어야 합니다. 연결 지점은 소비자 컨트롤의 경우 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 개체입니다. 소비자 연결 지점 검색은 필요한 단계는 웹 파트 연결을 설정 합니다.  
  
 소비자는 항상 하나 이상의 연결점을 대 한 연결을 설정할 수 있어야 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 메서드 소비자 컨트롤을 확인 하 고 모든 연결 지점의 컬렉션을 검색 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 연결 요소가 없으면, 메서드가 빈 컬렉션을 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 개의 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 항목을 참조 하십시오. [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 웹 페이지에 대 한 선언적 태그에 포함 된 `Register` 모두 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. 한 `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. 에 `Page_Load` 코드 확인 여부 연결이 이미 존재 하며, 그렇지 않은 경우 공급자는 소비자, 해당 연결 지점을, 배열을 정의 하는 메서드와 참조 하는 정적 연결 집합에 새 연결을 추가 하는 다음의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다. <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> 를 사용 하 여 검색 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 메서드에 전달 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 두 컨트롤 간의 연결을 만들 수 있는지 여부를 결정 하는 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 예의 세 번째 부분에는 컨트롤에 대 한 소스 코드입니다. 이 코드와의 예 섹션에서 컴파일에 대 한 지침을 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다.  
  
 브라우저에서 웹 페이지를 로드 하면 클릭는 **디스플레이 모드** 드롭 다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 합니다. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드 보고의 제목 표시줄에 있는 아래쪽 화살표를 클릭 하 고 **우편 번호** 활성화 동사 메뉴의 컨트롤을 클릭 한 다음 **연결**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드. 이후 브라우저 세션의이 페이지를 반환 하는 경우 정적 연결이 이미 설정 되었으므로 및 페이지가 로드 될 때마다 다시 생성 하지 않아도 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />의 인스턴스가 들어 있는 웹 페이지입니다.</param>
        <summary>페이지에 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 현재 인스턴스에 대한 참조를 검색합니다.</summary>
        <returns>페이지에 있는 컨트롤의 현재 인스턴스를 참조하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 메서드는 현재에 대 한 참조를 검색 하려는 상황에서 유용 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 이런 문제가 발생 하는 일반적인 시나리오는의 ID 개발 하는 동안 알 수 없는 사용자 지정 컨트롤을 작성 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 해당 페이지에 컨트롤 됩니다.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 메서드는 정적의 인스턴스를 필요로 하지 않고 직접 호출할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 와 같은 일부 컨트롤에서 웹 파트 컨트롤 집합 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤는 <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> 현재에 대 한 참조를 검색할 수 있는 속성 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 따라서 이러한 컨트롤을 사용 하는 경우이 속성 대 한 참조를 사용 해야 합니다.  
  
 ID를 알고 있는 컨텍스트에서 코딩 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어는 웹 페이지 내에서 인라인 코드를 작성 하는 등 것을 간단 하 고 가장 효율적인을 직접 참조 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> ID를 사용 하 여 컨트롤  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 메서드를 사용하는 방법을 보여 줍니다. 이 예제는 두 부분으로 구성: 사용자 지정 서버 컨트롤 및 컨트롤을 호스트 하는 웹 페이지입니다.  
  
 사용자 지정 <xref:System.Web.UI.WebControls.Label> 컨트롤이 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 의 ID를 검색 하는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에 현재 페이지와 다음 ID 표시 합니다.  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 다음 코드 예제에서는 제공 웹 페이지에 컨트롤을 호스트 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 다음에 유의 현재 ID <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 사용자 지정에 표시 되는 컨트롤 <xref:System.Web.UI.WebControls.Label> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">메서드가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 값을 반환하는 컨트롤입니다.</param>
        <summary>
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 속성 값이 포함된 문자열을 가져옵니다.</summary>
        <returns>
          <paramref name="webPart" />에 대해 계산된 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 값이 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 계산 된 값을 가져옵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> 속성에 대 한 `webPart`합니다. 개발자에 값을 할당 하지 않는 경우는 <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> 속성은 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤,이 메서드는 제목으로 표시할 값을 생성 합니다. 현재 영역 내에서 컨트롤의 시퀀스를 나타내는 숫자와 문자열에 숫자가 제목 없는 컨트롤에 대 한 계산 된 값으로 구성 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 없는 경우</exception>
        <block subset="none" type="overrides">
          <para>기본 디스플레이 제목을 계산 하는 방식을 변경 하려면이 메서드를 재정의할 수 있습니다.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">내보낼 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</param>
        <summary>사용자가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 내보내려고 할 때 요청에 포함된 상대 가상 경로와 쿼리 문자열을 가져옵니다.</summary>
        <returns>컨트롤 내보내기 요청을 구성하는 상대 가상 경로와 쿼리 문자열이 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환한 값은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> 메서드는 컨트롤을 포함 하는 페이지의 서버 위치에 상대 가상 경로 및 내보내기 요청을 구성 하는 추가 된 쿼리 문자열 값이 서버에 제출 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> 메서드 전송할, 악의적인 스크립트가 공격 으로부터 보호 하기 위해 요청을 허용 하기 전에 문자열을 인코딩합니다.  
  
> [!NOTE]
>  웹 파트 응용 프로그램 보안에 대 한 자세한 내용은 참조 [보안 웹 파트 페이지](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />에 있으며 런타임에 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />의 자식 컨트롤로 래핑되는 서버 컨트롤입니다.</param>
        <summary>서버 컨트롤이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤의 인스턴스에 대한 참조를 가져옵니다.</summary>
        <returns>
          <paramref name="control" />을 자식 컨트롤로 래핑하는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />입니다. <paramref name="control" />이 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />에 포함되지 않은 경우 이 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 개발자에 배치 하는 컨트롤의 두 가지 범주가 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 웹 파트 응용 프로그램에 참여: <xref:System.Web.UI.WebControls.WebParts.WebPart> 에서 상속 되는 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 기본 클래스 및 표준 될 수 있는 기타 서버 컨트롤 ASP.NET 컨트롤, 사용자 지정 컨트롤 또는 사용자 정의 컨트롤입니다. 이러한 컨트롤 중 하나를 배치 하면는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 의 기능에 걸리는 영역은 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. A <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤에는이 기능이 기본적으로, 하지만 다른 종류의 서버 컨트롤은 그렇지 않습니다. 역할을 하도록 다른 서버 컨트롤을 사용 하도록 설정 하려면 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 저장 될 때 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 를 사용 하 여 영역, ASP.NET 래핑하는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 제어 합니다. 때문에 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤에서 직접 상속 된 <xref:System.Web.UI.WebControls.WebParts.WebPart> 클래스, 해당 자식 컨트롤에 제공 true 웹 파트 기능입니다.  
  
 런타임 시 종종 페이지 개발자에 대 한 참조를 얻으려고 경우가 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 영역에 서버 컨트롤 중 하나를 포함 하는 컨트롤입니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 메서드를 사용 하면에 대 한 참조를 검색 하는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 메서드. 코드 예제에는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤 내에서 선언는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역입니다. `Button1_Click` 의 ID를 처음 인쇄 하는 메서드는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤의 레이블을 사용 하 여 다음을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 에 대 한 참조를 검색 하는 메서드는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 달력을 래핑하는 컨트롤입니다. ID는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤과 해당 자식 컨트롤의 ID (되는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤), 두 번째 레이블의에 출력 됩니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결에서 공급자 역할을 하는 서버 컨트롤입니다.</param>
        <summary>웹 파트 연결의 공급자 역할을 하는 서버 컨트롤에서 연결 지점으로 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 개체의 컬렉션을 검색합니다.</summary>
        <returns>공급자의 연결 지점이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 연결에서 항상 정확히 두 개의 컨트롤의 데이터를 데이터 소비자 공급자 역할을 하나 포함 됩니다. 각 컨트롤에는 하나 이상의 정의 된 메서드는 연결 지점으로 있어야 합니다. 연결 지점은 공급자 컨트롤의 경우는 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 개체입니다.  
  
 공급자에는 항상 하나 이상의 연결점을 대 한 연결을 설정할 수 있어야 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 메서드 공급자 컨트롤을 확인 하 고 모든 연결 지점의 컬렉션을 검색 합니다. 공급자 연결 지점 검색은 필요한 단계는 웹 파트 연결을 설정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 예제는 네 부분으로 이루어져 있습니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 개의 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 웹 페이지에 대 한 선언적 태그에 포함 된 `Register` 모두 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. 한 `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. 에 `Page_Load` 코드 확인 여부 연결이 이미 존재 하며, 그렇지 않은 경우 공급자는 소비자, 해당 연결 지점을, 배열을 정의 하는 메서드와 참조 하는 정적 연결 집합에 새 연결을 추가 하는 다음의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다. <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> 를 사용 하 여 검색 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 메서드에 전달 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 두 컨트롤 간의 연결을 만들 수 있는지 여부를 결정 하는 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 예의 세 번째 부분에는 컨트롤에 대 한 소스 코드입니다. 이 코드와의 예 섹션에서 컴파일에 대 한 지침을 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다.  
  
 브라우저에서 웹 페이지를 로드 하면 클릭는 **디스플레이 모드** 드롭 다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 합니다. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드 보고의 제목 표시줄에 있는 아래쪽 화살표를 클릭 하 고 **우편 번호** 활성화 동사 메뉴의 컨트롤을 클릭 한 다음 **연결**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드. 이후 브라우저 세션의이 페이지를 반환 하는 경우 정적 연결이 이미 설정 되었으므로 및 페이지가 로드 될 때마다 다시 생성 하지 않아도 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">가져올 XML 설명 파일의 상태 및 속성 데이터를 읽는 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <param name="errorMessage">가져오는 중에 오류가 발생할 경우 사용자에게 표시되는 <see cref="T:System.String" />입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤에 대한 상태 및 속성 데이터가 들어 있는 XML 설명 파일을 가져온 다음 해당 데이터를 컨트롤에 적용합니다.</summary>
        <returns>가져온 XML 설명 파일에서 참조되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />(또는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />로 래핑되어 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />로 취급되는 서버 컨트롤)입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 메서드 가져오는 데 사용 하 여 만든 XML 설명 파일은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 서버 컨트롤에 대 한 메서드. 가져온 경우 실제 서버 컨트롤은 컨트롤에 대 한 상태 및 속성 데이터를 포함 하는 설명 파일만 아닙니다. 이미 제어 및 description 파일에 참조 된 어셈블리 설명 파일을 가져오려면는 사용자가 서버에서 사용할 수 여야 합니다.  
  
 가져오기는 컨트롤을 사용 하려면를 추가 해야 하는 개발자는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 가져오기를 사용할지 페이지에 컨트롤입니다. 영역 내는 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 컨트롤을 추가 해야 합니다. 이 컨트롤은 사용자가을 가져오는 설명 파일을 찾을 수 있는 파일 대화 상자.  
  
 Description 파일을 읽은 후 사용자 설명 파일을 찾거나 시작 가져오기는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 메서드. 오류가 없는 하 고 어셈블리 및 제어 발견 되 면 서버 컨트롤 내에서 카탈로그에 추가 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 컨트롤과 설명 파일에 지정 되는 다양 한 속성 및 상태 데이터를 컨트롤에 적용 됩니다. 다음 사용자 컨트롤을 선택 하 고 페이지에 추가할 수 있습니다.  
  
> [!IMPORTANT]
>  와 같은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 메서드 보안 위험에 대 한 몇 가지 가능성이 있습니다. 웹 사이트에 데이터를 가져올 해야 하기 때문에 악의적인 사용자 가져온 설명 파일에 잘못 된 데이터 또는 짝수 스크립트 코드를 삽입 하려고 할 수 있습니다. 잘못 된 데이터 또는 데이터베이스를 페이지에 표시 될 수 또는 삽입 된 스크립트를 실행할 수 있습니다. Description 파일 및 이러한 위험을 방지 방법을 가져오기와 관련 된 잠재적 위험의 개요를 참조 하십시오. [보안 웹 파트 페이지](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" />에서 파일을 읽지 못한 경우  
  
 \- 또는 -  
  
 가져오기 오류 메시지를 표시하는 데 필요한 <paramref name="reader" />를 파일에서 찾지 못한 경우  
  
 \- 또는 -  
  
 <paramref name="reader" />에서 내보낸 데이터가 들어 있는 XML 요소를 찾지 못하고 파일 끝에 도달한 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 클래스에서 실제로 구현되어 있지만 대개 컨트롤 개발자에게 유용한 여러 메서드를 조합 및 분리하는 데 사용되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에 대한 참조를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />로 분리된 다양한 메서드를 참조하는 데 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성 집합으로 호출 하는 Api를 제공 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 확장성 사례에서 주로 사용 되는 메서드입니다.  
  
 이러한 내부 메서드를 사용 하도록 디자인 된 방법은 통해 액세스 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성입니다. 가 속성을 보호 하기 때문에 액세스 하 고 수 있습니다의 인스턴스 내에서 메서드를 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 에서 상속 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스입니다.  
  
> [!NOTE]
>  IntelliSense에서이 속성은 [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]합니다. 그러나 파생에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스, 속성 및 해당 다양 한 멤버에 액세스할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 기능의 유연성의 일부 런타임 시 웹 페이지에 서버 컨트롤을 추가할 수 있다는 점입니다. 서버를 제어 하는 일반적인 시나리오의 여러 가지 (사용자 지정 될 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 사용자 지정 서버 컨트롤, 사용자 정의 컨트롤 또는 ASP.NET 컨트롤)를 추가할 수 있습니다.  
  
 다음과 같은 일반적인 시나리오에서 웹 파트 컨트롤 집합 페이지에 서버 컨트롤을 추가 하 고 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드 확인 하기 위해 호출 됩니다.  
  
-   내에서 웹 페이지의 태그에 선언 하 여 서버 컨트롤을 추가 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역입니다.  
  
-   서버 컨트롤에 추가 된 경우 프로그래밍 방식으로 영역입니다.  
  
-   때 사용자는 컨트롤의 웹 파트 카탈로그로 서버 컨트롤을 가져옵니다.  
  
-   기존 서버 컨트롤 개인 설정 데이터 저장소에서 로드 됩니다.  
  
-   서버 컨트롤에 추가 된 경우는 <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> 컨트롤 서버 컨트롤의 카탈로그에서 사용할 수 있도록 합니다.  
  
 컨트롤이 추가 되는 각 시나리오에서의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드를 호출 하는 컨트롤을 추가할 수 있도록 하는 모든 권한 부여 조건을 충족 했는지 확인 합니다. 컨트롤에 게 권한이 없는 필터링 시나리오 했습니다 것 처럼 정상적으로 추가 됩니다. 컨트롤 권한이 없는 경우 웹 파트 컨트롤 집합 컨텍스트에 따라 여러 가지 방법으로 응답할 수 있습니다. 컨트롤 집합 (사용자에 게 알릴 필요가 없는 경우) 권한이 없는 파트를 추가 하지 않을 수 있습니다, 오류 메시지를 표시할 수 또는 인스턴스를 추가할 수는 <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> 자리 표시자로 클래스입니다. 이 자리 표시자 개체의 페이지에 표시 되지 않으면 하지만 권한이 없는 컨트롤이 제외 된 나타내려면 페이지 소스 코드에 표시 됩니다.  
  
 컨트롤 수 있는 권한이 있는지 여부의 행렬식은 권한 부여 필터입니다. 권한 부여 필터는 개발자가 지정된 된 조건을 충족 하지 않는 모든 컨트롤 페이지에서 제외할 수 있는 웹 파트 컨트롤 집합의 기능입니다.  
  
 필터링 시나리오를 만들려면 개발자는 다음 두 가지를 수행 해야 합니다. 첫째, 문자열 값 (값은 임의의 수 있음)을 할당 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 각 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 시나리오에서 사용할 컨트롤입니다. 다른 유형의 없는 서버 컨트롤에 대 한이 속성에 값을 할당할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 하기 때문에에 배치 될 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역, 이러한 컨트롤 래핑됩니다는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임 시 컨트롤 및이 컨트롤에서 상속 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성입니다.  
  
 필터링 시나리오를 만드는 데 필요한 두 번째 단계는 재정의 하거나는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 메서드에 대 한 이벤트 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트입니다. 이러한 메서드는 개발자 있는지 확인할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성, 컨트롤 허가할 수 없는 해야 값 나타내면 개발자 되는지를 확인는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 의 값을 반환 하는 메서드 `false`합니다.  
  
> [!NOTE]
>  코드 예제 및 사용 하는 사용자 지정 된 필터링 시나리오를 설정 하는 방법에 대 한 설명을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드를 메서드의 오버 로드에 대 한 항목을 참조 하십시오.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">권한이 부여되었는지 확인할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤입니다.</param>
        <summary>컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하기 위한 초기 단계를 수행합니다.</summary>
        <returns>
          <paramref name="webPart" />가 페이지에 추가할 수 있는 컨트롤인지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 방법은 초기 방법에 대 한 권한 부여를 확인 하도록 설정 하는 웹 파트 컨트롤에 의해 호출 된 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 허용 `webPart` 를 매개 변수로 궁극적으로 컨트롤이 페이지에 추가할지를 결정 하는 프로세스를 시작 합니다. 제공 된 컨트롤의 허용 되는지 여부를 확인 해야 할 때 사용자 코드에서이 메서드를 직접 호출 합니다.  
  
 컨트롤에서 상속 되는지 여부를 결정 하는 초기 작업을 수행이 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 아니거나 클래스는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 제어 하 고 그렇다면 어떤 유형의 자식 제어 포함 합니다. 권한 부여 작업을 완료 하려면 호출는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 메서드를 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> 컨트롤이 페이지에 추가할 수 있는 권한이 있는지 확인 하는 코드에서 메서드.  
  
 이 코드 예제는 세 부분으로 구성 합니다.  
  
-   사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 를 재정의 하는 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드.  
  
-   필터를 만들고 웹 페이지는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
-   코드 예제를 실행 하는 방법에 대해 설명 합니다.  
  
 이 코드 예제에서는 사용자 지정을 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 를 재정의 하는 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 의 사용자 지정 처리를 제공 하는 메서드를 오버 로드는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성입니다. 이 컨트롤의 속성 값에 대 한 검사 `admin` 값이 있으면 컨트롤에 권한을 부여 합니다. 컨트롤에 다른 값을 권한이 없습니다. 속성 값을 사용 하지 않고 컨트롤 필터링 시나리오의 일부가 되려면 하지 가정 하는 대로 권한이 부여 됩니다.  
  
 이 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제 컴파일 동적 메서드를 사용합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 코드 예제에서는 두 번째 부분에는 컨트롤을 제외 시킬 수 있는 필터를 만듭니다. 다음 웹 페이지의 세 가지 ASP.NET 서버 컨트롤에는 `<asp:webpartzone>` 요소입니다. 첫 번째 및 두 번째 컨트롤에는 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 다른 값으로 설정 하 고 세 번째 속성을 할당 하지 않습니다. 런타임 시이 권한 부여 값을 검사할 수 있습니다 및 필터는 개발자가 설정 하는 조건과 일치 하는 경우 페이지에 컨트롤을 추가할 수 있습니다. 또한는 `Page_Load` 메서드를 호출 하 여 코드의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> 여부 각 컨트롤의 권한이 부여 되는 경우 설정 각 컨트롤의 및 확인 하 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 코드 예제가 작동 하려면 해야 설정을 추가 하면 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에서 note 합니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내에서 `<system.web>` 섹션에서 없는지 확인 한 `<webParts>` 인 요소는 `enableExport` 특성이로 설정 `true`와 같이, 다음 태그입니다.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 브라우저에서 페이지를 로드 한 후 재정의 된 메서드가의 조건과 일치 하기 때문에 첫 번째 컨트롤 표시 되도록 note 합니다. 필터에 의해 제외 되었으므로 두 번째 컨트롤은 페이지에 추가 되지 않습니다. 세 번째 컨트롤이 추가 않은 경우 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 집합입니다. 각 컨트롤의 제목 표시줄에 있는 동사 메뉴 아이콘을 클릭 하면 수 있다는 둘 다 공지 때문에 내보낼 수의 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 속성 값이 할당 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>이 메서드는 사용자 코드에서 직접 호출 됩니다. 프로그래밍 방식으로 보다 효율적으로 제어 권한 부여 프로세스 하려는 경우 재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> 메서드를 오버 로드 합니다.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">권한이 부여되었는지 확인할 컨트롤의 <see cref="T:System.Type" />입니다.</param>
        <param name="path">컨트롤이 사용자 정의 컨트롤인 경우 권한이 부여될 컨트롤의 소스 파일에 대한 상대 응용 프로그램 경로입니다.</param>
        <param name="authorizationFilter">컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하는 데 사용되는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 속성에 할당된 임의의 문자열 값입니다.</param>
        <param name="isShared">권한이 부여되었는지 확인할 컨트롤이 공유 컨트롤인지 여부를 나타냅니다. 즉, 컨트롤이 응용 프로그램의 다수 또는 모든 사용자에게 표시되고 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 속성 값이 <see langword="true" />로 설정되어 있습니다.</param>
        <summary>컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하기 위한 마지막 단계를 수행합니다.</summary>
        <returns>컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 오버 로드 메서드가 컨트롤이 페이지에 추가할 수 있는 권한이 있는지 확인 하는 마지막 단계를 수행 합니다. 메서드를 사용 하면 `type` 유효한 형식이 고 `path` 사용자 정의 컨트롤 경우에 값이 있습니다. 중요 한 호출 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 를 발생 시키는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 컨트롤이 페이지에 추가할 수 있는 권한이 있는지 확인 하는 메서드.  
  
 첫 번째 단계는 컨트롤을 제외 시킬 수 있는 필터를 만드는 것입니다. 다음 웹 페이지의 세 가지 ASP.NET 서버 컨트롤에는 `<asp:webpartzone>` 요소입니다. 첫 번째 및 두 번째 컨트롤에는 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 다른 값으로 설정 하 고 세 번째 속성을 할당 하지 않습니다. 런타임 시이 권한 부여 값을 검사할 수 있습니다 및 필터는 개발자가 설정 하는 조건과 일치 하는 경우 페이지에 컨트롤을 추가할 수 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 두 번째 단계는 무시 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 메서드를 사용자 지정 권한 부여 필터에 대 한 처리를 만듭니다. 참고 코드 있는지 먼저 확인 속성에 값이 있는지 여부를 하는 컨트롤을 할당 하지 않습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성은 자동으로 추가 됩니다. 코드를 반환 하는 경우 컨트롤에 있는 필터를 `true` 필터 값이 같은 경우에 `admin`합니다. 이 역할에 따라 특정 사용자에 게 특정 컨트롤을 표시 하기 위해 사용할 수 있는 간단한 메커니즘을 보여 줍니다. 이 항목의 범위를 벗어나는 역할을 사용 하는 전체 예제 이지만,으로 사용할 수 있습니다 같은 논리를이 코드 예제에서는 재정의 된 메서드가. 제외 하 고 현재 사용자가 권한 부여 필터 값과 일치 하는 역할에 있는지 여부를 확인할 수 있습니다. 을 추가한 다음 해당 사용자에 대해서만 컨트롤을 추가 합니다. 이렇게 하면 일부 사용자는 모든 컨트롤을 표시할 하 고 다른 사용자가 선택한 컨트롤에만 볼 수 있는 페이지를 만들 수 있습니다. 이 역할이 사용 된 필터를 확인 하는 논리 어떻게 표시 될 수 있습니다.  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제 컴파일 동적 메서드를 사용합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 브라우저에서 페이지를 로드 한 후 재정의 된 메서드가의 조건과 일치 하기 때문에 첫 번째 컨트롤 표시 되도록 note 합니다. 두 번째 컨트롤의 필터 값이 제외 되므로 페이지에 추가 되지 않습니다. 에 없기 때문에 세 번째 컨트롤이 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 집합입니다. 첫 번째 컨트롤 이름과 일치 하 고 다음 페이지를 다시 실행 하면 두 번째 컨트롤에서 속성 값을 변경 하는 경우 두 번째 컨트롤도 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />이 사용자 정의 컨트롤이고 <paramref name="path" />가 <see langword="null" />이거나 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="type" />이 사용자 정의 컨트롤이 아니고 <paramref name="path" />에 할당된 값이 있는 경우</exception>
        <block subset="none" type="overrides">
          <para>상속 하 여이 메서드를 재정의할 수는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스, 권한 부여를 확인할 때 추가 처리를 제공 하려는 경우. 특정 값을 확인 하는 메서드를 재정의 하는 것이 좋습니다는 <paramref name="authorizationFilter" /> 매개 변수 값에 따라 컨트롤이 페이지에 추가 될 지 여부를 확인 하는 부울 값을 반환 합니다.  
  
 권한 부여 필터에 대 한 확인 하 고 사용자 지정 처리를 제공 하려는 페이지는 개발자를 위한 모든 클래스에서 상속 하지 않고이 인라인으로.aspx 페이지 또는 코드 숨김 파일을 수행할 수가 있습니다. 에 대 한 페이지에서 대체 이벤트 처리기를 선언할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> 의 메서드는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 제어 합니다. 자세한 내용과 예제에 대 한 참조는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> 메서드.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 제어하는 페이지 수준 개인 설정 정보에 영향을 주는 개인 설정 변경 사항이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>개인 설정 변경 사항이 있는지 여부를 나타내는 부울 값입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 속성이 있는지 여부를 관리 하는 페이지 수준 개인 설정 데이터를 추적 하는 내부적으로 변경 합니다. 개인 설정 데이터가 변경 되는 사용자가 추가 또는 제거 등 페이지 수준에서 다양 한 개인 설정 동작을 수행할 때 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 연결 하거나 연결을 끊는 중 컨트롤, 컨트롤 및 기타 작업을 이동 하 여 페이지의 레이아웃을 변경 합니다.  
  
> [!NOTE]
>  사용자가 특정 컨트롤에 개인 설정 변경 내용을 확인 것 이므로, 제어 수준에서 개인 설정 수행할 수도 및 변경 내용이 해당 컨트롤에만 적용 합니다. 예제는 컨트롤을 편집 하 고 제목 텍스트 또는 해당 배경색 변경 게 됩니다. 제어 수준 개인 설정 하 여 추적 된 페이지 수준 개인 설정 데이터에는 영향을 주지는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 속성 값으로 변경 되지 않습니다 `true` 제어 수준 개인 설정이 발생 하는 경우.  
  
 하지만 메서드가 보호 되 고, 호출자가 직접 액세스할 수 없습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성 호출자가 직접 액세스할 수 있으며이 속성의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">로드하려는 저장된 상태 데이터가 들어 있습니다.</param>
        <summary>이전 페이지 요청에서 저장되었고 후속 요청에서 복원해야 하는 컨트롤 상태 데이터를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> 메서드는 페이지의 게시할을 유지 해야 하는 속성 데이터를 복원 하는 데 도움이 됩니다. 경우에는 <xref:System.Web.UI.Control.EnableViewState%2A> 속성이 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" />은 유효한 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />이 아닙니다.</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">로드할 상태 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary>나중에 초기화 프로세스 동안 사용될 수 있게 개인 설정 개체에 의해 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 전달된 사용자 지정 개인 설정 데이터를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> 형식으로 저장 된 상태 데이터를 제공 하는 메서드는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 개체입니다. 이 데이터는 웹 파트 컨트롤에 개인 설정 데이터를 로드 하 고 다른 초기화 작업을 수행 하기에 결국 사용 됩니다.  
  
> [!NOTE]
>  이 메서드는 때 시작 되는 일련의 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> 메서드를 처음 연결 된 요청 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 개인 설정 데이터를 제공 하는 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 사용자 코드에서 직접이 메서드를 호출할 수 없습니다. 그러나 직접 호출할 수, 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> 메서드 호출의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> 메서드와 개인 설정 데이터를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>개발자는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 파생 메서드 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 형식 역직렬화에 가져오는 동안이 속성에서 반환 되는 개체를 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 개체를 가져옵니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 형식 역직렬화 점을 제외 하 고 모든 항목에 대해 가져오는 동안이 속성에서 반환 하는 개체를 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">이동할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤입니다.</param>
        <param name="zone">
          <c>webPart</c>가 이동될 대상 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />입니다.</param>
        <param name="zoneIndex">
          <c>zone</c> 내의 다른 컨트롤에 상대적인 <c>webPart</c>의 인덱스를 나타내는 정수입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 한 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에서 다른 영역이나 동일한 영역 내의 새 위치로 이동합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 이동 하는 메서드 `webPart` 같은 영역에서 또는 다른 영역에 새 위치를 합니다. 코드에서 직접이 메서드를 호출할 수 및 다양 한 옵션을 사용 하 여 웹 파트 사용자 인터페이스 (UI)에서 새 위치로 컨트롤을 이동 하면 호출 됩니다.  
  
 다양 한 조건 충족 해야 `webPart` 이동할 수 있습니다 및 이들 중 대부분은이 항목의 예외 섹션에 나열 된 항목으로 표시 됩니다. 경우 `webPart` 에 포함 되지 않은 한 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역으로 시작 영역으로 이동할 수 없습니다.  
  
 이동 하는 다음과 같은 일련의 동작을 발생 조건을 만족 한 후에 `webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 이벤트를 발생시킵니다.  
  
2.  `webPart` (필요한 경우) 현재 영역에서 제거 되 고 새 영역이 나 현재 영역 내의 새 위치에 추가 합니다.  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 이벤트를 발생시킵니다.  
  
4.  `zoneIndex` 의 모든 <xref:System.Web.UI.WebControls.WebParts.WebPart> 원점과 대상 영역에는 제어 이동된 된 컨트롤을 반영 하도록 다시 설정 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 이동 하는 코드에서 직접 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 한 영역에서 컨트롤입니다.  
  
 이 코드 예제는 세 부분으로 구성 합니다.  
  
-   디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다.  
  
-   해당 컨트롤을 호스팅하는 웹 페이지입니다.  
  
-   코드 예제를 실행 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 예제의 두 번째 부분은 각각 포함 하는 두 개의 서버 컨트롤으로 두 개의 영역을 포함 하는 웹 페이지입니다. 사용자가 클릭할 때는 **Move WebPart** 의 코드 페이지에 단추는 `Button1_Click` 메서드 첫 번째 영역에서 컨트롤을 두 번째 영역에서 새 위치로 이동 합니다. 코드는 먼저 호출 해야 하는 통지는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 를 검색할 메서드는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 래핑하는 개체는 `list1` 컨트롤입니다. 때문에 이것이 필요의 첫 번째 매개 변수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 메서드를 사용 하려면 한 <xref:System.Web.UI.WebControls.WebParts.WebPart> 반면 제어 `list1` 는 ASP.NET 서버 컨트롤입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 페이지가 로드 된 후 클릭는 **Move WebPart** 단추 및 두 번째 영역의 가운데 위치로 이동 하는 링크를 포함 하는 컨트롤입니다. 컨트롤의이 이동이 호출 하 여 프로그래밍 방식으로 수행 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 메서드. 사용할 수도 있습니다는 **디스플레이 모드** 디자인 모드로 및 디자인 모드에서 페이지를 전환 하 고 드롭다운 목록 컨트롤을 다른 영역이 나 해당 영역의 다른 위치로 컨트롤을 끌 수 있습니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 도 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 사용자가 시작한를 처리 하는 컨트롤이 이동 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컬렉션에 없는 경우  
  
 \- 또는 -  
  
 <paramref name="zone" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컬렉션에 없는 경우  
  
 \- 또는 -  
  
 <paramref name="webPart" /> 컨트롤의 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 속성이 참조하는 영역이 <see langword="null" />인 경우, 즉 <paramref name="webPart" />가 현재 영역에 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 또는 <paramref name="zone" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" />가 0보다 작은 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 이벤트를 발생시키고 이벤트의 처리기가 있는 경우 이 처리기를 호출합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드 때는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 페이지에 추가할 수 있는 인증을 검사 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드가 호출 되 면 발생는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트, 이벤트에 대 한 처리기 메서드인 경우 처리기를 호출 하 고 있습니다.  
  
 권한 확인 프로세스 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어는 중요 한 웹 파트 기능입니다. 모든 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 서버 컨트롤에 의해 영역에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 컨트롤을 추가할 수 있는지 여부를 결정 하는 권한 부여 프로세스를 거칩니다. 기본적으로 웹 파트 컨트롤 집합에는 컨트롤 영역에 추가 되지 않도록 방지 하기 위해 필터링 조건을 제공 하지 않습니다. 하지만 컨트롤 집합에서는 개발자가 자신의 필터링 조건을 만드는 데 필요한 메커니즘을 제공 합니다. 이러한 메커니즘을 사용 하 여 사용자 지정 필터링 시나리오를 만들 수 있습니다. 예를 들어 페이지가 렌더링 되 고 사용자 역할에 사용자가을 하는 경우 해당 컨트롤이 추가 되지 특정 컨트롤 영역에 추가 관리자 역할에 사용자가을 하는 경우 되도록 필터를 만들 수 있습니다.  
  
 권한 부여 프로세스 중 컨트롤을 필터링 하기 위한 메커니즘은는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 필터링 시나리오를 만들려면는 기본적으로 두 가지 작업이 있습니다. 에 문자열을 할당 하는 먼저는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 각 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 필터링 할 컨트롤입니다. 이러한 문자열 값 임의적이 될 수 있지만 기준으로 필터링 할 조건이 포함 해야 합니다. 예를 들어 지정 된 컨트롤이 필요한 경우 사용자가 페이지에 추가할 경우에만 관리자가 보고 한 다음의 문자열 값을 할당할 수 있습니다 `admin` 속성에 있습니다. 다음 ASP.NET 역할 기능을 사용 하 여 하 고 사이트의 모든 사용자가 관리자, 관리자 및 사용자 등의 다양 한 역할에 추가할 수 없습니다. 필터링 코드 페이지가 로드 하는 경우 사용자 역할을 확인를 검사 중인에 권한 부여 필터 값과 비교 하 고 관리자 역할에 사용자가 예를 들면 고 컨트롤의 경우 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 값`admin`, 컨트롤을 추가할 수 없습니다.  
  
 필터링 시나리오를 만드는 두 번째 단계 검사 하는 코드를 작성 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값에 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤과 해당 영역에 추가 되기 전에 각 컨트롤 허용 되는지 여부를 확인 합니다. 필터링이 코드의 배치 위치는 두 가지 옵션이 있습니다. 첫 번째 옵션 페이지 개발자에 대 한 기본 옵션이입니다. 처리 하는 메서드를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 코드 분리 파일 또는 웹 페이지 서버 스크립트 코드에서 직접 이벤트입니다. 메서드를 추가 하 여 이벤트와 연결할는 `OnAuthorizeWebPart` 특성을 태그에 대 한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 다음 샘플 태그 코드에 표시 된 대로 페이지에서 제어 합니다.  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 각 확인은 작업을 수행 하 여 사용자 지정 메서드는이 <xref:System.Web.UI.WebControls.WebParts.WebPart> 필터링 조건에 대 한 제어 하 고 결과에 따라에 부울 값을 할당 하는 다음는 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> 속성의는 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> 를 나타내는 개체 여부는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 될 수 있습니다 추가 됩니다. "예" 섹션의 코드에는이 작업을 수행 하는 방법을 보여 줍니다.  
  
 상속 하는 어디에 배치할지 필터링 코드에 대 한 두 번째 옵션의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 하 고 필터 조건을 확인 하는 메서드를 재정의 합니다. 이 수행 하기 위해 재정의할 수는 두 가지 방법에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드. 두 방법 중 하나는 사용 되지만, 대부분의 경우에서 것이 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드를 제공 하므로 전체 권한 부여 프로세스를 통해 프로그래밍 방식 제어를 강화 반면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드는 하나의 특정 작업을 수행 합니다. 이벤트 및 처리기에 대 한 검사를 발생 시키는 것입니다. 사용자 지정의 코드 예제를 보려면 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 재정의 하는 클래스는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드를 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드의 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 사용자 지정 이벤트 처리기를 설정 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트 처리기에 대 한 필터링 사용자 지정 코드를 제공할 수 있도록는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드. 이 예에는 페이지 개발자 필터링 시나리오 및의 권한 부여를 제공 하는 일반적인 방법은 것 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 한 페이지에 추가 합니다.  
  
 웹 페이지를 알 수 있듯이 `<asp:webpartmanager>` 요소에는 `OnAuthorizeWebPart` 특성에 할당 된 이벤트 처리기의 이름으로 합니다. 메서드는 페이지에 컨트롤의 해당 되어 있는지 확인 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값으로 설정 `admin` 하 고,이 경우 반환 `true`를 페이지에 추가할 수 있음을 나타내는입니다.  
  
> [!NOTE]
>  컨트롤에 할당 된 모든 값을 포함 하지는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성도 비활성화 되어 있으므로 추가 가정 됩니다 필터링 시나리오의 일부가 될 수 없습니다. 필터링 시나리오에 일반적인 접근 방식은 것: 일부 컨트롤 필터링 하 고 다른 되지 않습니다, 모든 사용자에 대해 사용할 수 있도록 것으로 가정 됩니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 사용자 역할에이 항목의 범위를 벗어나는 이기 때문에이 코드 예제는 필터링의 사용자 역할을 검사 하지 않습니다. 그러나 필터링 사용자 역할에 따라 컨트롤의 시나리오는이 필터링 기능을 사용 하는 가장 일반적인 중 하나일 수 있습니다. 사이트 역할이 있고이 메서드에 컨트롤을 필터링 할 사용자 역할을 확인 하려는 경우 메서드는 다음 코드 블록 (역할을 사용 하지 않는 이전 코드 예제에는 간단한 방법)와 유사 합니다.  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>페이지와 해당 페이지의 컨트롤이 로드되고 페이지의 연결이 데이터 공유를 시작할 수 있도록 활성화되었음을 나타내는 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> 메서드 발생은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 페이지 로드 프로세스를 완료 된 후 이벤트입니다. 메서드는 이벤트에 대 한 처리기를 추가 하는 방법을 제공 합니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnConnectionsActivated` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>개발자는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> 파생 메서드 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>페이지와 해당 페이지의 컨트롤이 로드되었으며 연결을 활성화하는 프로세스를 시작할 수 있음을 나타내는 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 발생 시키는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 개발자에 게 연결을 활성화 하는 과정을 프로그래밍 방식으로 사용자 지정 하기 위한 메커니즘을 제공 하는 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnConnectionsActivating` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>개발자는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> 파생 메서드 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">변경된 디스플레이 모드와 관련된 이벤트 데이터가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 컨트롤이 웹 페이지에서 특정 디스플레이 모드를 다른 모드로 전환하는 프로세스를 완료했음을 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> 메서드 바탕에만 발생 시킵니다 형성는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> 메서드. 예를 들어 후 디스플레이 모드의 변경을 제공할 수 있습니다를 디스플레이 따라 모드에 포함 된 사용자 인터페이스 (UI)의 모양을 변경는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> 속성입니다. 또는 특정 콘텐츠를 숨기 거 나 특정 컨트롤을 표시할 수 있습니다.  
  
 메서드를 재정의 하는 경우 정상적으로 호출 해야 기본 메서드 재정의 된 메서드의 마지막 단계로 사용자 지정 코드를 먼저 실행 되 고이 이벤트는 마지막으로 발생 모드 변경을 완료 되었음을 나타내는입니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">변경되는 디스플레이 모드와 관련된 이벤트 데이터가 들어 있는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 컨트롤이 웹 페이지에서 특정 디스플레이 모드를 다른 디스플레이 모드로 전환하는 프로세스를 진행 중임을 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> 메서드 바탕에만 발생 시킵니다 형성는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> 메서드. 예를 들어 디스플레이 모드를 변경 하려는 새 디스플레이 모드는 것을 확인 (사용 하 여는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> 속성) 될 새 디스플레이 모드에 따라 사용자 인터페이스 (UI)를 변경 하 고 있습니다. 사용자 지정 디스플레이 모드를 설치한 경우에 특정 컨트롤 표시 되도록 사용자 지정 모드에서 새 디스플레이 모드를 사용할 경우는 것이 좋습니다.  
  
 이 메서드를 재정의 하는 경우 일반적으로 메서드를 호출 해야는 기본 재정의 된 메서드의 첫 번째 단계로 이벤트가 디스플레이 모드를 변경 하려면 시작 중임을 나타내기 위해 있도록 합니다. 그런 다음 사용자 지정 코드는 사용자 인터페이스 (UI)에서 하기 전에 변경할 수도 새 디스플레이 모드는 실제로 표시 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Init" /> 컨트롤 주기 중 첫 번째 이벤트인 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드를 발생 시키는 기본 메서드를 호출 하는 <xref:System.Web.UI.Control.Init> 컨트롤을 선택한 다음의 인스턴스 하나만 있는지 확인 하는 등 몇 가지 준비 단계를 수행 하는 이벤트는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 페이지, 제어 및 로드 개인 설정 데이터입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">페이지에 다른 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 있는 경우</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.Control.PreRender" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 웹 페이지에 렌더링되기 직전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> 메서드를 발생 시키는 기본 메서드를 호출 하는 <xref:System.Web.UI.Control.PreRender> 컨트롤을 선택한 다음 레지스터 이벤트 웹 파트를 포함 하는 페이지에 필요한 여러 가지 클라이언트 스크립트를 제어 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 새로 선택되었거나 선택이 취소된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 이벤트는 일반적으로 지점 개발자 사용자 인터페이스 (UI)의 모양을 변경 해야 할 수는 위치입니다. 예를 들어, 새 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 선택 하면 웹 파트 컨트롤 설정 변경 내용을 새로 선택 된 컨트롤의 렌더링 합니다. 컨트롤의 선택이 취소 후 렌더링 정상적으로 반환 됩니다.  
  
 사용자가 특정을 선택한 후 <xref:System.Web.UI.WebControls.WebParts.WebPart> 편집을 위해 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드를 호출 합니다. 사용자 컨트롤 편집을 완료 하 고 컨트롤의 선택 항목의 선택이 취소 결과 함께 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드가 다시 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>여러 가지 방법으로 관련 된는 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 이벤트 개발자가 선택한 컨트롤 변경 된 후 발생 하는 렌더링을 사용자 지정할 수 있도록 합니다. 선언적 코드에서 내에서 <see langword="&lt;asp:webpartmanager&gt;" /> 요소를 설정할 수 있습니다는 <see langword="OnSelectedWebPartChanged" /> 특성을 사용자 지정 메서드의 이름을 할당 합니다. 사용자 지정 하는 메서드의 이벤트가 발생할 때 선택한 컨트롤의 렌더링을 수정할 수 있습니다. 상속 하는 또 다른 옵션은 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 및 메서드를 재정의 합니다. 세 번째 방법은 영역 수준;에서 렌더링을 사용자 지정 예를 들어에서 상속할 수 있습니다는 <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> 클래스를 재정의 하 고 해당 <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> 메서드를 선택 하 고 편집 과정의 선택을 취소 하는 컨트롤의 렌더링을 사용자 지정 합니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 이벤트를 발생시킵니다. 이 이벤트는 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 변경하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 이벤트를 변경 하는 프로세스 중 발생 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤에서 현재 선택 되어 있습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 메서드와 연결된 된 이벤트를 사용 하 여 선택한 컨트롤 변경 되는 프로세스를 취소할 수 있도록 합니다. 내에서 메서드가 호출 예를 들어는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 메서드를 및 내 에서도 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 방법에서 프로세스를 취소 하는 방법을 제공 합니다. 사용자가 편집 되는 컨트롤에 취소 동사를 클릭 하면 컨트롤을 더 이상 선택 하 고 모든 편집 내용이 저장 되지 않습니다, 때문에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드를 사용 하면 편집 내용이 취소할 수 없습니다.  
  
> [!NOTE]
>  시작 되 고 연결 하는 프로세스를 종료 하는 메서드에서도 메서드는 비슷하게는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 해당 프로세스를 취소할 수 있도록 다른 컨트롤을 제어 합니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 추가 하 여 이벤트는 `OnSelectedWebPartChanging` 특성을 `<asp:webpartmanager>` 선언적 페이지 태그 요소와 특성에는 사용자 지정 메서드의 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">컨트롤 제거와 관련된 이벤트 데이터입니다.</param>
        <summary>기본 <see cref="E:System.Web.UI.Control.Unload" /> 이벤트를 발생시키고 웹 페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스를 제거합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 페이지에 추가된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 메서드 추가 과정 동안 호출 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 다른 서버 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역) 페이지에 있습니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 추가 하 여 이벤트는 `OnWebPartAdded` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤)을 추가하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 이벤트 중 추가 되는 컨트롤 임을 나타냅니다. 메서드는 또한 추가 프로세스를 취소 하는 옵션을 제공 합니다. 컨트롤 성공적으로 추가 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트가 발생 합니다.  
  
 페이지 개발자가 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartAdding` 특성을 `<asp:webpartmanager>` 요소에는 웹 페이지 및 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 만드는 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> 메서드를 이벤트 처리를 사용자 지정 합니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary>컨트롤이 페이지에서 제거되었음을 알리는 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 임을 나타내는 이벤트는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 다른 서버 또는 사용자 정의 컨트롤) 성공적으로 닫힌 페이지에 있습니다.  
  
 닫으려면는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 렌더링 되지 않습니다 및 특별 한에 저장 개체 라고도 페이지 카탈로그 않도록 페이지에서 제거할 것을 의미 합니다. 에 해당 하는 페이지 카탈로그는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 제어 하 고, 닫힌에 대 한 참조를 유지 관리 <xref:System.Web.UI.WebControls.WebParts.WebPart> 각 페이지에 대 한 제어 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 내에 있는 페이지에 컨트롤을 선언한는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역을 사용자가 페이지 카탈로그 디스플레이 모드를 전환 하 고 이전에 닫힌 모든 컨트롤을 페이지에 다시 추가할 수 있습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 메서드를 사용에 대 한 사용자 지정 처리기를 만드는 개발자를 위한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트입니다. 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartClosed` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다. 하나 이상의 유용한 태스크 개발자는이 방법에서는 수행할 수 한 자리 표시 자가 닫힌된 컨트롤 대신, 페이지로 컨트롤을 추가 하는 방법을 사용자에 게 알려 주는 도구 설명이를 완료 하는 것입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 페이지에서 제거하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 을 나타내는 하는 컨트롤을 닫거나 페이지에서 제거 하는 이벤트입니다. 메서드는 또한 닫는 프로세스를 취소 하는 옵션을 제공 합니다. 컨트롤의 페이지에서 제거 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트가 발생 합니다.  
  
 페이지 개발자가 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartClosinging` 특성을 `<asp:webpartmanager>` 요소에는 웹 페이지 및 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 만드는 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 메서드를 이벤트 처리를 사용자 지정 합니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 페이지에서 영구적으로 삭제된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> 메서드가 삭제 하는 동안에 호출을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 다른 서버 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역) 페이지에서 합니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 추가 하 여 이벤트는 `OnWebPartDeleted` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 이벤트를 발생시킵니다. 이 이벤트는 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 포함된 서버 컨트롤이나 사용자 정의 컨트롤)이 삭제 프로세스를 진행 중임을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 <xref:System.Web.UI.WebControls.WebParts.WebPart> 및 컨트롤을 삭제할 수 있습니다, 컨트롤이 삭제 됩니다 컨트롤 인스턴스 페이지에서 영구적으로 제거 되 고 복원할 수 없습니다. 동적 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤은 프로그래밍 방식으로 추가 된 또는 웹 파트 카탈로그에서 정적 컨트롤의 반대 개념에 선언 된 웹 페이지의 태그입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 발생 시키는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> 컨트롤은 해당 영역에서 영구적으로 삭제 되 고 있음을 나타내는 이벤트를 합니다. 메서드는 또한 삭제 프로세스를 취소할 수 있는 기회를 제공 합니다. 컨트롤이 페이지에서 성공적으로 삭제 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 이벤트가 발생 합니다.  
  
 페이지 개발자가 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartDeleting` 특성을 `<asp:webpartmanager>` 요소에는 웹 페이지 및 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 만드는 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 메서드를 이벤트 처리를 사용자 지정 합니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 페이지의 다른 위치로 이동된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 의 거의 마지막 이벤트는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 메서드 하 여 모든 코드가 이벤트 처리기가 실행 되기 전에 컨트롤을 이동 하는 프로세스 완료 되었음을 보장 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 현재 영역 내에서 또는 다른 영역으로 컨트롤 이동 되 고 프로그래밍 방식으로 또는 사용자 컨트롤을 끌어 이동을 수행 됩니다 여부는 중요 하지 않습니다 때 이벤트가 발생 합니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 추가 하 여 이벤트는 `OnWebPartMoved` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이나 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 있는 서버 컨트롤 또는 사용자 정의 컨트롤이 이동 프로세스를 진행 중임을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 이벤트를 발생 때는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 다른 서버 컨트롤 영역 내에서 또는 다른 영역으로 이동 됩니다. 메서드는 또한 이동 하는 프로세스를 취소할 수 있는 기회를 제공 합니다. 이동이 성공적으로 완료 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 이벤트가 발생 합니다.  
  
 페이지 개발자가 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartMoving` 특성을 `<asp:webpartmanager>` 요소에는 웹 페이지 및 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 만드는 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> 메서드를 이벤트 처리를 사용자 지정 합니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 간의 연결이 설정된 이후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> 메서드 맨 끝에서 해당 이벤트를 발생 시킵니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드를 이벤트 처리기의 코드를 실행 하기 전에 두 컨트롤을 연결 하는 데 필요한 단계는 완료 되도록 합니다.  
  
 메서드 연결을 만드는 과정을 제어 하며, 관련된 이벤트를 적절 한 시기에 사용자 인터페이스 (UI)를 업데이트 하거나 연결 된 사용자에 게 알리려면.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 추가 하 여 이벤트는 `OnWebPartsConnected` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 이벤트를 발생시킵니다. 이 이벤트는 두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이나 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 포함된 서버 컨트롤 또는 사용자 정의 컨트롤 간의 연결을 설정하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 발생 시키는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 이벤트를 두 개의 연결을 설정 하려고 할 때 발생 합니다. 메서드는 연결 시도 취소할 수 있는 기회를 제공 합니다. 연결이 성공 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 이벤트가 발생 합니다.  
  
 페이지 개발자가 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartsConnecting` 특성을 `<asp:webpartmanager>` 요소에는 웹 페이지 및 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 만드는 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 메서드를 이벤트 처리를 사용자 지정 합니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 간의 연결이 종료된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> 메서드 맨 끝에서 해당 이벤트를 발생 시킵니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 두 컨트롤 간의 연결을 종료 프로세스를 수행 하는 메서드.  
  
 연결을 종료 하는 과정을 통해 프로그래밍 방식 제어를 제공 하는 메서드, 개발자가 사용자에 게 알려 줄 수를 있도록 사용자 인터페이스 (UI)를 변경 하 또는 응용 프로그램에 다른 변경을 수행 합니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 추가 하 여 이벤트는 `OnWebPartsDisconnected` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 이벤트를 발생시킵니다. 이 이벤트는 두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이나 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 있는 서버 컨트롤 또는 사용자 정의 컨트롤이 편집 프로세스를 진행 중임을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 메서드 발생은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 두 컨트롤은 연결을 종료 되었을 때 발생 하는 이벤트입니다. 메서드는 연결 끊기 프로세스를 취소할 수 있는 기회를 제공 합니다. 연결이 성공적으로 제거 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 이벤트가 발생 합니다.  
  
 페이지 개발자가 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartsDisconnecting` 특성을 `<asp:webpartmanager>` 요소에는 웹 페이지 및 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 만드는 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 메서드를 이벤트 처리를 사용자 지정 합니다.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 개인 설정 데이터가 들어 있는 개체에 대한 참조를 가져옵니다.</summary>
        <value>개인 설정 데이터가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성에 액세스 하는 방법을 제공는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 통해 페이지와 연관 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 이 속성을 사용 하 여 개인 설정 개체의 다양 한 멤버를 액세스할 수 있습니다. 예를 들어, 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 메서드는 페이지의 개인 설정 범위에서 전환할 사용자 범위 또는 그 반대로 공유 합니다. 개인 설정 데이터 등에 사용 되는 공급자 페이지에서 개인 설정도 사용 여부를 페이지의 현재 개인 설정 범위 아웃 찾을 수 있습니다.  
  
 데이터에서 참조 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성은 페이지 수준 개인 설정 데이터에서 추적 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 컨트롤별 개인 설정 데이터에 개인 설정 가능한 속성의 값과 같은 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어은의 일부가 아닌는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성입니다.  
  
> [!NOTE]
>  웹 파트 개인 설정에 대 한 자세한 내용은 참조 하십시오. [웹 파트 개인 설정 개요](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성 프로그래밍 방식으로 합니다.  
  
 다음 웹 페이지를 사용 하면 사용자의 특정 측면을 편집할 편집 모드를 입력할 수는 <xref:System.Web.UI.WebControls.Calendar> 제어 합니다. **토글 범위** 단추 사용자 또는 공유 개인 설정 범위에 페이지를 전환 합니다. **편집 모드** 및 **찾아보기 모드** 단추는 각 페이지의 적절 한 디스플레이 모드를 전환 합니다. 에 `<script>` 태그를 사용 하 여 이벤트를 처리 하는 메서드의 두 파일의 섹션에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성을 내부 개체의 유용한 멤버에 액세스 합니다. 특히, 이러한 방법을 사용 하 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> 속성을 통해 액세스 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 코드 예제를 실행 하려면도 활성화 해야 사용자 또는 사용자가 공유 범위에서 페이지를 개인 설정. Web.config 파일에 항목을 내 추가 `<system.web>` 섹션에 다음 태그과 같은 형식입니다.  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 브라우저에서 페이지를 로드 한 후 클릭는 **토글 범위** 단추 및를 페이지 범위를 공유 합니다. 클릭 **편집 모드** 디스플레이 모드를 변경 하려면 표시 된 컨트롤에 있는 동사 메뉴를 클릭 하 고 선택 **편집** 메뉴에서 합니다. 편집 컨트롤이 모두에 대 한 사용자 인터페이스 (UI) 나타나는지 확인 합니다. 클릭 하 여 지금 **찾아보기 모드** 일반 검색으로 돌아갑니다. 페이지 라고 공유 범위에 표시 되 면 클릭 **토글 범위** 사용자 범위에가 페이지를 다시 합니다. 다음을 다시 컨트롤을 편집 하지만 다음에 유의 이제 편집 UI에서 동일한 단계에 따라는 <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> 컨트롤이 표시 되지 않습니다. 이 컨트롤의 페이지는 공유 개인 설정 범위에서 하는 경우에 작동 때문입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 웹 페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 끌기와 같은 다양한 개인 설정 기능에 사용되는 클라이언트측 스크립트를 내보낼 수 있도록 합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">페이지에 쓸 컨트롤의 내용을 받는 <see cref="T:System.Web.UI.HtmlTextWriter" />입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 내용을 렌더링하지 못하도록 재정의된 메서드입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 상태 데이터를 저장하여 해당 컨트롤이 들어 있는 웹 페이지에 대한 후속 요청에서 복원할 수 있도록 합니다.</summary>
        <returns>컨트롤의 저장된 상태 데이터가 들어 있는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> 메서드 페이지 포스트백 동안 유지 해야 하는 속성에 대 한 상태 데이터를 저장 합니다. 경우에는 <xref:System.Web.UI.Control.EnableViewState%2A> 속성이로 설정 된 `false`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">로드할 상태 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 사용자 지정 개인 설정 상태 데이터를 페이지가 다시 로드될 때마다 다시 로드할 수 있도록 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> 방법은 개인 설정, 프로세스에서 중요 한 때문에 개인 설정 된 사용자 설정을 이후 브라우저 세션 동안 저장 해야 하 고 페이지를 방문 합니다. 개인 설정 사용자 지정 상태 데이터를 저장 하는 메서드: 동적 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 페이지에 추가 되거나 페이지; 페이지에서 이동 된 컨트롤 및 있는 동적 연결에서 삭제 된 서버 컨트롤 작성 또는 삭제 되었습니다.  
  
 사용자 코드에서 직접이 메서드를 호출할 수 없습니다. 그러나 호출할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 메서드는 자체 개인 설정 데이터를 저장 하려면이 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>이 메서드는 파생에서 개발자 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 개인 설정 데이터를 저장 하는 과정을 사용자 지정 하는 클래스입니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>다른 컨트롤과의 연결을 편집하거나 만들기 위해 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤에 대한 참조를 가져옵니다.</summary>
        <value>연결을 편집하거나 설정하기 위해 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성에 대 한 참조를 반환 합니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 편집을 위해 또는 다른 컨트롤과 연결을 만들기 위한 현재 선택 되어 있는 기타 서버 컨트롤입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 컨트롤을 선택 하는 과정을 처리 하기 위한 몇 가지 유용한 메서드 및 이벤트를 제공 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 이벤트는 컨트롤을 선택한 후에 바로 전에 발생 모든 변경 내용이 있습니다. 선택 된 후에 컨트롤에서 작업을 수행 하려면 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드. 예를 들어 다음 하는 컨트롤의 선택 되어 있지만 아직 변경 되지 않은 시각적으로 강조 하는 컨트롤을 선택 모양을 변경 하는 것이 좋습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 방금 선택한 컨트롤 변경 된 후에 이벤트가 발생 합니다. 변경 된 후에 컨트롤에 대해 일부 작업을 수행 하려면 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>한 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤의 선택 상태가 변경되고 웹 페이지의 다른 컨트롤로 이동된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트와 함께에서 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 선택 된 컨트롤의 사용자 인터페이스 (UI)를 변경 하려면 메서드. 예를 들어, 사용자가 페이지 디자인 모드로 전환 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>), 한 다음를 선택는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 새 위치로 끌어 목적으로는 것이 일반적의 색을 변경 하 여 예를 들어 선택한 컨트롤의 렌더링을 변경 하려면 해당 테두리 또는 배경 선택 되어 있습니다.  
  
> [!NOTE]
>  이벤트 사용에 대 한 자세한 내용은 참조 하십시오. [하는 방법: Web Forms 응용 프로그램에](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에서 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 변경하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트와 함께에서 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드. 페이지 개발자가 코드에 추가 하 여에 이벤트 처리기를 만들 수 있습니다는 `OnSelectedWebPartChanging` 특성을 `<asp:webpartmanager>` 이벤트를 처리할 요소에는 페이지 및 사용자 지정 메서드의 이름으로 특성의 값을 설정 합니다.  
  
 이 이벤트는 시작 및 끝 컨트롤을 편집 하는 때와 컨트롤 간의 연결을 종료 또는 시작 프로세스 중 발생 합니다. 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드.  
  
 일반적으로,는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 선택한 컨트롤을 변경 하는 사용자의 동작의 직접적인 결과로 이벤트가 발생 하면 이벤트를 취소할 수 있습니다. 그러나 이벤트를 취소할 수 없는 시나리오가 있습니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 컨트롤이 삭제 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 분리는 그렇지 않은 경우, 포함 된 컨트롤 모두 닫아야 합니다. 이 경우에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 닫히는 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 사용자 및가 아닌 것과 결정 해야 컨트롤에서 현재 선택 된 중단 될 가능성 없이 선택 영역을 변경 하는 경우의 정리 프로세스를 완료할 수 있도록 모든 컨트롤입니다. 따라서 의도적으로 설계 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 메서드는이 시나리오에서 취소할 수 없습니다. 취소할 수 있는 관련된 이벤트에 대 한 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 사용자 지정 개인 설정 데이터가 변경되었음을 나타내는 플래그를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> 메서드 궁극적으로 업데이트 된 개인 설정 데이터를 저장 하도록 설정 하는 웹 파트 컨트롤에 개인 설정 구성 요소를 설정 하는 플래그를 설정 합니다. 추적 개인 설정 데이터를 변경 시킬 수 있는 시나리오에 대 한 자세한 내용은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어, 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> 메서드 사용자 코드에서 직접 호출할 수 없습니다 및 개인 설정 기능이 웹 파트의 일부로 설정 하는 웹 파트 컨트롤에 의해 내부적으로 사용 되기 때문에 재정의할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>메서드를 호출할 수는 파생에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다. 이 개인 설정 하는 웹 파트 컨트롤의 구성 요소를 설정 하 고 따라서 개인 설정 데이터에 대 한 플래그를 설정 하는 과정을 제어 해야 할 사용자 지정 하려는 경우에 유용 합니다.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤입니다.</param>
        <summary>
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 속성 값을 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤과 같게 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> 메서드 프로세스 시작 또는 끝에서 지정 된 컨트롤의 편집 하는 동안 호출 됩니다는 `webPart` 을 시작 하거나 포함 된 연결을 종료 하 고 매개 변수를 `webPart`합니다.  
  
 편집 및 연결 프로세스의 시작 부분에서 `webPart` 편집 하거나 연결에 참여 하려면 선택 된 컨트롤입니다.  
  
 편집 및 연결 프로세스가 끝날 때 `null` 에 전달 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> 메서드 종료 될 때는 현재 선택 된 컨트롤에 생성 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 스킨을 적용할 수 없도록 빈 문자열("")을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 스킨이 할당되지 않도록 하는 빈 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> 상속 된 속성을 재정의 <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> 를 방지 하려면 속성에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 스킨을 사용 하 여에서 보이지 않는 컨트롤입니다. 항상 빈 문자열을 반환 하 여 할당 되지 스킨을 방지 하는 속성의 구현을 `get` 값을 설정 하는 시도 하는 경우 항상 예외를 throw 하 고, 접근자는 `set` 접근자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 속성에 값을 설정하려고 한 경우</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 정적 연결로 정의된 모든 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 개체의 컬렉션에 대한 참조를 가져옵니다.</summary>
        <value>페이지의 정적 연결이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성은 사용 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤을 추적 하 고 페이지의 모든 정적 연결을 관리 합니다. 동적 연결과 달리 정적 연결 될 때마다 페이지가 렌더링 되는 페이지에 추가할 필요는 없습니다.  
  
 프로그래밍 방식으로 만든 또는 지정 된 페이지에 있는 모든 정적 연결을 포함 하는이 속성에서 참조 하는 컬렉션 한 `<asp:webpartconnection>` 페이지의 태그에는 요소입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   웹 파트 페이지에서 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 개의 사용자 지정을 포함 하는 소스 코드 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   두 개의 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   이 예제에서는 브라우저에서 작동 하는 방식에 대해 설명 합니다.  
  
 다음 코드 예제에서는의 웹 페이지 부분만 포함 되어 있습니다. 예제 단원에서 예제--사용자 지정 사용자 정의 컨트롤 및 사용자 지정 컨트롤 및 인터페이스에 대 한 소스 코드의 처음 두 개의 부분을 가져올 해야 합니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 해당 항목을 컴파일하기 위해 옵션도 설명는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 페이지에 대 한 선언적 태그에 포함 된 `Register` 모두 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. 한 `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. 에 `Page_Load` 코드 확인 여부 연결이 이미 존재 하며, 그렇지 않은 경우 공급자는 소비자, 해당 연결 지점을, 배열을 정의 하는 메서드와 참조 하는 정적 연결 집합에 새 연결을 추가 하는 다음의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 브라우저에서 웹 페이지를 로드 하면 클릭는 **디스플레이 모드** 드롭 다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 합니다. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드 보고의 제목 표시줄에 있는 아래쪽 화살표를 클릭 하 고 **우편 번호** 활성화 동사 메뉴의 컨트롤을 클릭 한 다음 **연결**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드. 이후 브라우저 세션의이 페이지를 반환 하는 경우 정적 연결이 이미 설정 되었으므로 및 페이지가 로드 될 때마다 다시 생성 하지 않아도 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>특정 웹 페이지에서 사용할 수 있는 모든 디스플레이 모드의 읽기 전용 컬렉션을 가져옵니다.</summary>
        <value>특정 웹 페이지에서 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성 페이지에 있는 영역 컨트롤의 종류에 따라 해당 페이지에서 실제로 사용할 수 있는 디스플레이 모드를 포함 합니다.  
  
> [!NOTE]
>  디스플레이 모드를 해제할 수 있습니다 및에 추가 되지 않은 디스플레이 모드를 사용 하지 않도록 설정 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 컬렉션, 해당 형식의 해당 디스플레이 모드를 지 원하는 영역 페이지에 있는 경우에 합니다.  
  
 찾아보기 모드와 디자인 모드는 항상 지원 됩니다. 다를 수 있는 디스플레이 모드는 편집, 카탈로그 및 모드를 연결 합니다. 이러한 각 디스플레이 모드의 특정 형식과 연결 된 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 제어 합니다. 참조 하는 컬렉션에 추가할 특정 디스플레이 모드를 발생 시키는 웹 페이지에 해당 특정 형식의 영역이 있는지는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다. 예를 들어, 웹 페이지에는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 되지 않은 영역을 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역을 편집 디스플레이 모드를 사용 하면 해당 페이지에서 지원 되는 모드 중 하나인 되지만 카탈로그 디스플레이 모드 지원 되지 않습니다.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 에서 다른 속성은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 현재 사용할 수 있는 모든 디스플레이 모드를 포함 하는 컬렉션을 참조 하는 속성 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 붙지 않은 특정 페이지에서 지원 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 사용을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다. 코드가이 속성을 사용 하 여 현재 웹 페이지에서 사용할 수 있는 디스플레이 모드만 목록을 채웁니다.  
  
 이 페이지에서 디스플레이 모드 지원 되는: 찾아보기, 디자인 및 편집 합니다. 처음 두 항상 있으며 편집 모드는 페이지에 포함 하기 때문에이 코드 예제에서 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 제어 합니다. 카탈로그를이 페이지에 해당 하는 영역이 없기 때문에 디스플레이 모드 표시 되지 않습니다를 연결 합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드에서 페이지의 디자인 모드를 전환 하려면 드롭다운 목록에서 컨트롤을 사용할 수 있습니다 다음 편집 모드를 합니다. 편집 모드에 서버 컨트롤 중 하나의 헤더에 있는 드롭 다운 동사 메뉴를 클릭 하 고 선택할 수 **편집** 컨트롤을 편집 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 사용자 지정 개인 설정 상태 데이터가 웹 페이지에서 변경되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>개인 설정 상태 데이터가 변경되었는지 여부를 나타내는 부울 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성은 호출자가 확인할 수 있는 방법을 제공 상태에서 관리 되는 데이터를 개인 설정 여부는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 변경 되었습니다. 때 사용자 개인 설정 페이지 수준 세부 정보, 예를 들어 페이지 레이아웃 변경, 생성 또는 연결을 삭제 하 여 컨트롤 추가 및 삭제를 개인 설정 데이터에서 및 관리 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 변경 내용을 제어 합니다. 이 호출자에 게 보호 된 값을 반환 하는 통과 방법 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 속성으로, 호출자가 직접 액세스할 수 없습니다.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성 나타내지 않습니다 여부를 개인 설정할 수 있는 속성 값 또는 개인의 모양에 영향을 주는 개별 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 변경 합니다. 개인 설정 컨트롤 수준 각 컨트롤에 대해 개별적으로 추적 됩니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성만 여부 나타내고 개인 설정 데이터는 페이지 수준에서에서 관리 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 변경 되었습니다.  
  
 다음 목록에는 설명 해야 하는 개인 설정의 몇 가지 일반적인 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성의 값을 반환 `true`한다는 표시 이므로 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에 변경 된 개인 설정 데이터가 일부:  
  
-   정적 닫는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지에 컨트롤 (또는 서버 또는 사용자 정의 컨트롤).  
  
-   닫힌된 정적 복원 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지로 다시 페이지 카탈로그에서 제어 합니다.  
  
-   영역 내에서 또는 다른 영역에 모든 컨트롤을 이동 합니다.  
  
-   컨트롤의 카탈로그에서 추가 <xref:System.Web.UI.WebControls.WebParts.WebPart> 서버 컨트롤 또는 컨트롤을 프로그래밍 방식으로 추가 합니다.  
  
-   두 연결을 만들면 <xref:System.Web.UI.WebControls.WebParts.WebPart> 프로그래밍 방식으로 또는 연결 사용자 인터페이스 (UI)를 사용 하 여 제어 합니다.  
  
-   두 연결을 삭제 해도 <xref:System.Web.UI.WebControls.WebParts.WebPart> 프로그래밍 방식으로 또는 연결 UI를 사용 하 여 제어 합니다.  
  
 이 속성 값에 액세스 하려면 캐스팅 해야 합니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 인스턴스는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 인터페이스; 다음 읽기는 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성 값입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 간단한 사용법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 을 나타내는 속성을 몇 가지 일반적인 페이지 개인 설정 야기 하는 인스턴스는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 개인 설정 데이터를 변경 합니다.  
  
 이 코드 예제는 4 개의 구성 됩니다.  
  
-   웹 파트 컨트롤을 포함 하는 페이지에 대 한 디스플레이 모드를 변경할 수 있는 사용자 정의 컨트롤을 반환 합니다.  
  
-   두 개의 사용자 지정에 대 한 코드를 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 인터페이스입니다.  
  
-   모든 컨트롤을 호스팅하는 웹 페이지입니다.  
  
-   코드 예제에서는 작동 하는 방식에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하기 위한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드와 사용자 정의 컨트롤의 작동 방식에 대 한 정보를 참조 하십시오. [연습: 웹 파트 페이지에](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 예제의 두 번째 부분은 사용자 지정 컨트롤 및 인터페이스를 소스 파일입니다. 다음에 유의 `IZipCode` 인터페이스 하나의 메서드를 노출 하 고 사용자 지정에서이 메서드를 구현 하는 `ZipCodeWebPart` 사용할 수 있도록 콜백 메서드로 제어 사용 `ZipCodeWebPart` 연결 시나리오에서 공급자 역할을 합니다. 다른 컨트롤과 `WeatherWebPart`, 소비자의 역할에 대 한 연결 제어할;에서 제공 하는 특정 인터페이스를 사용할 수 있는 `ZipCodeWebPart`합니다. 실제 응용 프로그램에서 `WeatherWebPart` 개인 설정 된 우편 번호 값 공급자에서 사용 하 고 사용자에 게 그래픽 날씨 정보를 제공할 수 없습니다.  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 여기서 것 동적으로 컴파일되는 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 동적 컴파일;을 사용 하 여이 코드 예제 따라서 알 수 있듯이 `Register` 웹 페이지의 위쪽에이 구성 요소에 대 한 지시문만 포함 `TagPrefix` 및 `Namespace` 특성만 있고는 `Assembly` 특성입니다. 컴파일하는 방법을 보여 주는 연습을 참조 하십시오. [연습: 개발 및 사용자 지정 웹 서버 컨트롤을 사용 하 여](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 두 개의 들어 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 와 두 개의 사용자 지정을 포함 하는 첫 번째 영역 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 또한 한 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 표준을 포함 하는 영역 <xref:System.Web.UI.WebControls.Calendar> 사용자 페이지에 추가할 수 있는 컨트롤입니다. `<asp:connectionszone>` 요소 UI 컨트롤 간의 연결을 만드는 사용자에 대 한 연결을 제공 합니다. 에 `Page_PreRender` 의 텍스트를 업데이트 하는 메서드를 확인 하는 개인 설정 데이터가 변경 되었는지 여부 그리고 있다면 사라졌는지 `Label1`합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 개인 설정 데이터를 변경 하는이 항목의 설명 섹션에 나열 된 시나리오 중 일부를 만들려고 시도 합니다. 변경에 의해 추적 되는 개인 설정 시나리오 중 하나를 포함 되어 있을 경우 다양 한 변경이 수행 하면서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 텍스트는 `Label1` 개인 설정 데이터가 변경 되었음을 나타내도록 컨트롤이 표시 됩니다. 예를 들어 다음 작업을 할 수 있습니다.  
  
-   클릭 하 여 컨트롤 간의 연결을 만듭니다는 **웹 파트 컨트롤 연결** 단추입니다.  
  
-   사용 하 여는 **디스플레이 모드** 드롭 다운 목록 컨트롤을 페이지 카탈로그 모드를 전환 하 고 추가 된 **내 달력** 컨트롤을 두 번째 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역입니다.  
  
-   페이지를 뒤로 찾아보기 모드로 클릭 (제목 표시줄의 화살표 기호로 표시) 하는 동사 메뉴에 대 한 변경의 **내 달력** 컨트롤을 선택 **닫습니다** 을 닫고 페이지 카탈로그에 추가 합니다.  
  
-   카탈로그 모드에 페이지를 반환 하 고 추가 **내 달력** 페이지로 다시 제어 합니다.  
  
-   사용 하 여는 **디스플레이 모드** 페이지 디자인 모드를 전환 컨트롤을 다른 영역에 또는 동일한 영역에 다른 위치로 끌어서 하나 이상의 컨트롤의 레이아웃을 다시 정렬 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">로드할 상태 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 로드되어야 하는 이전에 저장된 사용자 지정 개인 설정 상태 데이터를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는의 구현에서 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> 집합에 대 한 웹 파트 컨트롤 직접 액세스로 보호 되는 방법을 제공 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> 메서드. 관리 되는 개인 설정 된 사용자 지정 데이터를 저장이 메서드가 호출 될 때는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤과 이전에 초기화 프로세스의 뒷부분에 나오는 사용 하기 위해 영구 데이터 저장소에 저장 된 합니다.  
  
> [!NOTE]
>  대부분의 경우에서 페이지 및 컨트롤에 해당 하는 개발자의 코드 하지 않아도이 메서드를 호출 하는 주로 웹 파트 컨트롤 집합 개인 설정 데이터를 검색 하기 위한 메커니즘으로 사용 하기 때문에 있습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>개발자는이 방법을 사용 하는 시나리오 중 하나를 대신 사용할 사용자 지정 개인 설정 프레임 워크를 개발 하려는 경우 웹 파트 컨트롤 집합에서 제공 됩니다. 이 경우 개발자가에서 상속 된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스를 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> 의 사용자 지정 구현을 반환 하는 메서드는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체입니다. 사용자 지정 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체 구현을 호출 하 여의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 메서드 적절 한 때 사용자 지정 개인 설정 데이터를 로드 합니다.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">저장될 상태 데이터가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 사용자 지정 개인 설정 상태 데이터를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 메서드는의 구현에서 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> 집합에 대 한 웹 파트 컨트롤 직접 액세스로 보호 되는 방법을 제공 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> 메서드. 관리 되는 모든 개인 설정된 데이터가 저장이 메서드가 호출 될 때는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 웹 파트 응용 프로그램에 대해 구성 된 영구 데이터 저장소를 제어 합니다.  
  
> [!NOTE]
>  대부분의 경우에서 페이지 및 컨트롤에 해당 하는 개발자의 코드 하지 않아도이 메서드를 호출 하는 주로 웹 파트 컨트롤 집합 개인 설정 데이터를 저장 하기 위한 메커니즘으로 사용 하기 때문에 있습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>한 가지 시나리오는 개발자는이 방법으로 작동할 것 대신 사용 하는 사용자 지정 개인 설정 프레임 워크를 개발 하려는 경우 웹 파트 컨트롤 집합에서 제공 됩니다. 이 경우 개발자가에서 상속 된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스를 재정의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> 의 사용자 지정 구현을 반환 하는 메서드는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체입니다. 사용자 지정 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체 구현을 호출 하 여의 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 지정 개인 설정 데이터를 저장 하려면 적절 한 시기 메서드.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 개인 설정 상태 데이터를 적용하고 기본 메서드를 호출하여 컨트롤의 뷰 상태 데이터에 대한 변경 내용을 추적할 수 있도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 뷰 상태 데이터는 변경 내용이 저장 되는 <xref:System.Web.UI.StateBag> 개체를 컨트롤의를 통해 액세스할 수 <xref:System.Web.UI.Control.ViewState%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>자식 컨트롤이 표시되도록 하는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤과 해당 자식 컨트롤이 표시되는지 여부를 나타내는 부울 값입니다. 모든 경우에 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 기본 재정의 <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> 속성의 값을 항상 반환을 `true` 에 대 한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성입니다. 경우에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 자체 표시 되지 않으면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성 설정 해야 합니다. `true` 모든 해당 자식 컨트롤이 기본적으로 볼 수 있도록 합니다.  
  
 값을 설정 하려고 하면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성 때문에 항상 오류가 생성는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 기준 속성 동작을 재정의 하 고 속성에 값을 할당 하지 못하도록 합니다.  
  
 이 속성 비주얼 디자이너에서 바인딩 가능한 않으며 런타임에 바인딩할 수입니다. 자세한 내용은 <xref:System.ComponentModel.BindableAttribute>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 속성에 값을 할당하려고 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤이 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 추가된 후에 컨트롤이 성공적으로 추가되었음을 나타내기 위해 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트는 동적 컨트롤 (페이지 태그에서 선언 되는 대신 프로그래밍 방식으로 추가 하는 컨트롤)는 영역에 추가한 성공적으로 나타내는 경우에 유용 합니다. 와 함께에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 메서드를 이벤트 사용자 인터페이스 (UI)를 업데이트 하거나 컨트롤을 성공적으로 추가 된 사용자에 게 알릴 방법을 개발자에 게 제공 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 다른 서버 컨트롤을 추가하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 이벤트에 의해 발생 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 메서드 영역에는 컨트롤을 추가 하는 프로세스가 시작 된 후입니다. 이 이벤트는 완료 되기 전에 프로세스를 취소 하는 기회를 제공 합니다. 이 이벤트 다음 추가 프로세스에 성공한 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartAdding` 특성을 `<asp:webpartmanager>` 의 요소는 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤)이 페이지에서 제거되었을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트 컨트롤 닫 혔 음 성공적으로, 사용자가 또는 프로그래밍 방식으로 나타냅니다. 닫으려면는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 렌더링 되지 않습니다 및 특별 한에 저장 개체 라고도 페이지 카탈로그 않도록 페이지에서 제거할 것을 의미 합니다. 에 해당 하는 페이지 카탈로그는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 제어 하 고, 닫힌에 대 한 참조를 유지 관리 <xref:System.Web.UI.WebControls.WebParts.WebPart> 각 페이지에 대 한 제어 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 내에 있는 페이지에 컨트롤을 선언한는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역을 사용자가 한 페이지 카탈로그 디스플레이 모드를 전환 하 고 이전에 닫힌 모든 컨트롤을 페이지에 다시 추가할 수 있습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트와 연결 된는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 메서드를 이벤트를 발생 하 고 그에 대 한 처리기를 제공 합니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartClosed` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤)을 제거하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트에 의해 발생 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 메서드 때는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하는 컨트롤을 닫는 중입니다. 컨트롤의 제거 되 면이 이벤트가 다음는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartClosed` 특성을 <`asp:webpartmanager>` 의 요소는 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 일반적으로,는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트는 닫는 사용자의 직접적인 결과로 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 이벤트를 취소할 수 있습니다. 그러나 이벤트를 취소할 수 없는 시나리오가 있습니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 컨트롤이 삭제 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 분리는 그렇지 않은 경우, 포함 된 컨트롤 모두 닫아야 합니다. 이 경우에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 닫히는 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 사용자 아니라를 제어 합니다. 시기는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤을 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 각 컨트롤을 닫을 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트가 발생 하기 때문에 디자인에 따라 이벤트를 취소할 수 없는는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 의 정리 작업을 완료 해야 하는 경우 모든 영역 컨트롤입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤이 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에서 삭제된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 이벤트는 동적 컨트롤 (페이지 태그에서 선언 되는 대신 프로그래밍 방식으로 추가 하는 컨트롤) 영역에서 삭제 되었습니다 있는지를 나타내는 경우에 유용 합니다. 와 함께에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> 메서드를 이벤트 사용자 인터페이스 (UI)를 업데이트 하거나 컨트롤을 성공적으로 삭제 된 사용자에 게 알릴 방법을 개발자에 게 제공 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에서 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 다른 서버 컨트롤의 인스턴스를 삭제하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> 이벤트에 의해 발생 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 메서드 (사용자 웹 파트 사용자 인터페이스를 통해 또는 프로그래밍 방식으로 추가 된 하나) 동적 컨트롤을 삭제 하는 과정입니다. 이벤트 완료 되기 전에 프로세스를 취소 하는 기회를 제공 합니다. 삭제 프로세스가 완료 되 면이 이벤트가 다음는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartDeleting` 특성을 `<asp:webpartmanager>` 의 요소는 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤이 웹 페이지의 다른 위치로 이동된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 static (웹 페이지의 태그에 선언 됨) 및 동적 컨트롤에 적용 됩니다. 과 연관 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 메서드. 이동이 완료 한 후 이벤트 발생 하기 때문에 개발자가 사용자, 일부 유효성 검사 또는 기타 작업에 몇 가지 알림을 제공 하는 이벤트 처리기를 포함할 수 있습니다. 이벤트 처리기를 추가 하려면 추가할 수 있습니다는 `OnWebPartMoved` 특성을 `<asp:webpartmanager>` 요소에는 페이지 및 특성에는 사용자 지정 메서드 이름 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 포함된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 다른 서버 컨트롤을 이동하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 이벤트가 발생할 때는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 자체 영역 내에서 또는 다른 영역으로 이동 되 고 다른 서버 컨트롤 또는 합니다. 이 사용자 컨트롤을 끌 때와 프로그래밍 방식으로 이동할 때 발생할 수 있습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 이벤트에 의해 발생 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 메서드를 완료 되기 전에 이동 프로세스를 취소할 수 있는 기회를 제공 합니다. 이동이 완료 되 고이 이벤트에서 다음 컨트롤을 새 위치에 배치 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 만들 수는 `OnWebPartMoving` 특성을 `<asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 관리하는 모든 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 대한 참조를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> 컨트롤 집합에 대한 참조가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성은 사용는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 모든 추적을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 내에 포함 된 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 페이지의 영역에 있습니다. 컬렉션이 읽기 전용으로 설정 되지만 개별 액세스할 수 <xref:System.Web.UI.WebControls.WebParts.WebPart> 방식으로 컬렉션 변경할을 통해 프로그래밍 방식으로 제어 합니다.  
  
> [!NOTE]
>  있을 수는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 외부의 페이지에 컨트롤 배치는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역에서 추적 되지 않는 컨트롤에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하거나에서 참조 된 해당 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 컬렉션입니다. 그러나는 거의 사용 하는 이유는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 그런 다음 웹 파트 기능을 손실 하 고 일반적인 서버 컨트롤의 역할을 하기 때문에 영역을 외부에서 제어 합니다.  
  
 모든 형식의 사용자 지정 영역에 배치할 수 있는 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 표준 ASP.NET 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 서버 컨트롤으로 처리 될 수는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 런타임 시 컨트롤입니다. 때 되지 않는 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 놓입니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ASP.NET으로 컨트롤을 래핑하는 실행 시 영역은 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체 컨트롤은 진정한 처럼 동작할 수 있도록 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 따라서 사용 하 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 서버 컨트롤에서 파생 되었는지 여부에 관계 없이 모든 유형의 추적할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 클래스.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성 액세스 개별을 프로그래밍 방식으로 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 다음에 유의에서 웹 페이지에 대 한 선언적 태그 내에서 `<asp:webpartzone>` 요소는 두 개의 표준 ASP.NET 서버 컨트롤입니다. 상속 하지 않는 있지만 <xref:System.Web.UI.WebControls.WebParts.WebPart> 와 래핑 영역에 있기 때문에 클래스는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임 시 개체 이며 따라서 참조 하는 컬렉션에 포함 될 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성 합니다. 사용자 지정을 추가할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 이 영역에 있는 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 서버 제어 하 고 동일한 방식으로 처리 될 것 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 코드 예제가 작동 하려면 해야 설정을 추가 하면 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에서 note 합니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내에서 `<system.web>` 섹션에서 없는지 확인 한 `<webParts>` 인 요소는 `enableExport` 특성이로 설정 `true`와 같이, 다음 태그입니다.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 클릭 하면 페이지는 브라우저에 로드 한 후의 **WebPart Count** 단추는 코드를 사용는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 컬렉션에 있는 컨트롤의 수를 반환 하는 속성입니다. 클릭는 **달력 제목 숨기기** 만 테두리와 제목이 아닌 있는 렌더링 되도록 단추를 코드에서 달력을 변경 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤) 간에 특정 연결이 설정된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 이벤트와 연결 된는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> 메서드. 연결이 완료 되었음을 확인 했으면 하려는 경우도 팩트를 사용자에 게 알리는 또는 페이지의 사용자 인터페이스 (UI)를 변경할 수도 있으므로 이벤트 유용 합니다. 예를 들어 두 컨트롤 간에 성공적으로 연결을 제안 하는 몇 가지 그래픽 이미지를 표시 하려는 경우 간단한 메시지를 표시 한 후 변경 페이지 디스플레이 모드를 또는 찾아보기 모드입니다.  
  
 페이지 개발자가 추가 하 여이 이벤트와 사용자 지정 이벤트 처리기에 연결할 수는 `OnWebPartsConnected` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 있는 서버 컨트롤이나 사용자 정의 컨트롤) 간의 연결을 만드는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 이벤트에 의해 발생 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 메서드를 고는 연결 작업이 시작 신호를 보냅니다 (예를 들어 사용자가 컨트롤을 선택 하 고 연결 동사를 클릭), 아직 완료 되지 합니다. 이벤트 완료 되기 전에 연결을 취소할 수를 제공 합니다. 연결이 성공적으로 완료 되 면이 이벤트가 다음는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartsConnecting` 특성을 `<asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>두 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤 간의 연결이 종료된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 이벤트와 연결 된는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> 메서드. 이 이벤트는 연결이 종료 되었음을 확인 했으면 하려는 사용자에 게 알립니다를 코드에서 일부 정리 작업을 수행 하거나 사용자 인터페이스 (UI)에 대 한 다른 변경 때문에 유용 합니다.  
  
 페이지 개발자가 추가 하 여이 이벤트와 사용자 지정 이벤트 처리기에 연결할 수는 `OnWebPartsDisConnected` 특성을 `<asp:webpartmanager>` 페이지에서 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이전에 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤 간의 연결을 종료하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트에 의해 발생 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 메서드를 알립니다 사용자가 연결 끊기 동사를 클릭 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드를 호출 했음을 합니다. 이벤트 완료 되기 전에 연결을 종료 하는 과정을 취소할 수를 제공 합니다. 연결이 성공적으로 종료 되 면이 이벤트가 다음는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartsDisconnecting` 특성을 `<asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 일반적으로,는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트가 발생 한 연결을 종료 하는 사용자의 작업의 직접적인 결과로, 이벤트를 취소할 수 있습니다. 그러나 이벤트를 취소할 수 없는 몇 가지 시나리오가 있습니다. 첫 번째 시나리오는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 컨트롤이 삭제 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 분리는 그렇지 않은 경우, 포함 된 컨트롤 모두 닫아야 합니다. 이 경우에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 닫히는 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 사용자 및가 아닌 것도 할 수 있어야 중단 될 가능성 없이 연결 된 컨트롤의 연결을 종료를 정리 하 고 닫는의 프로세스를 완료할 수 있도록 모든 컨트롤입니다. 따라서 의도적으로 설계 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 메서드는이 시나리오에서 취소할 수 없습니다. 취소할 수 있는 관련된 이벤트에 대 한 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트입니다.  
  
 두 번째 시나리오는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트를 취소할 수 없는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> (이 예를 들어 페이지에 각 요청 하는 동안 호출) 메서드가 호출 되 고 일부 유형의 페이지에는 기존 연결에 충돌 합니다. 예를 들어 한 사용자 제어 y로 제어 x가 하지만 공유 사용자가 컨트롤 제어 z, x와 아직 x 컨트롤은 여러 연결을 구성할 수 없습니다. 이 경우 연결에 대 한 개별 사용자의 설정을, 우선 순위가 높은 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 호출 하 여 충돌을 해결 하는 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드 간의 연결을 종료 하 고 x 및 z는 특정 사용자에 대 한 합니다. 이 연결을이 끊는 디자인 하 여 충돌을 해결 하는 데 필수적 이므로 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이 시나리오에서는 이벤트를 취소할 수 없습니다.  
  
 세 번째 시나리오는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 메서드를 취소할 수 없는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 현재 연결 된 서버 컨트롤 삭제 되거나 닫힙니다. 컨트롤이 페이지에서 제거 하려는 확실 하 게 되므로 연결을 제거 하는 논리적으로 필수적입니다. 따라서,는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 호출는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 차례로 발생 시키는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 디자인 이벤트, 이벤트를 취소 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역이 모두 들어 있는 컬렉션에 대한 참조를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> 영역 집합을 참조하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 속성은 사용는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤을 추적 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 웹 페이지의 영역입니다. 참고 속성이 모든 형식의 영역을 참조 하지 않습니다 파생 되는 영역만 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 클래스를 포함 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역입니다.  
  
 속성에서 참조 하는 컬렉션이 읽기 전용 이지만, 개별 개체 컬렉션에 액세스 하 고 프로그래밍 방식으로 작업을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 속성 액세스 개별을 프로그래밍 방식으로 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역 컨트롤입니다. 웹 페이지에 대 한 선언적 태그에서 되 두 `<asp:webpartzone>` 요소, 서버 컨트롤이 들어 있습니다. 에 `<script>` 코드에서는 페이지의 섹션은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 액세스 개별 영역 모든 영역 Id를 표시 하 고 다음 두 번째 영역에서 배경 색을 변경 하는 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 코드 예제가 작동 하려면 해야 설정을 추가 하면 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에서 note 합니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내에서 `<system.web>` 섹션에서 없는지 확인 한 `<webParts>` 인 요소는 `enableExport` 특성이로 설정 `true`와 같이, 다음 태그입니다.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 클릭 하면 페이지는 브라우저에 로드 한 후에 **목록 영역 Id** 단추는 코드를 사용는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 컬렉션의 모든 영역에 대 한 Id를 나열 하는 속성입니다. 클릭는 **변경 영역 BackColor** 단추를 코드의 두 번째 영역의 배경색을 변경 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>