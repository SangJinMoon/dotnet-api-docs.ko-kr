<Type Name="CanExecuteRoutedEventHandler" FullName="System.Windows.Input.CanExecuteRoutedEventHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a252bc967121eea51fe378caf080a9b7c5a519bc" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37505121" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CanExecuteRoutedEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.CanExecuteRoutedEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub CanExecuteRoutedEventHandler(sender As Object, e As CanExecuteRoutedEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void CanExecuteRoutedEventHandler(System::Object ^ sender, CanExecuteRoutedEventArgs ^ e);" />
  <TypeSignature Language="F#" Value="type CanExecuteRoutedEventHandler = delegate of obj * CanExecuteRoutedEventArgs -&gt; unit" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.Input.CanExecuteRoutedEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender">
      <span data-ttu-id="8c893-101">처리기를 호출하고 있는 명령 대상입니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8c893-101">The command target that is invoking the handler.</span>
      </span>
    </param>
    <param name="e">
      <span data-ttu-id="8c893-102">이벤트 데이터입니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8c893-102">The event data.</span>
      </span>
    </param>
    <summary>
      <span data-ttu-id="8c893-103">
        <see cref="E:System.Windows.Input.CommandBinding.CanExecute" /> 이벤트를 처리할 메서드를 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8c893-103">Represents the method that will handle the <see cref="E:System.Windows.Input.CommandBinding.CanExecute" /> event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c893-104"><xref:System.Windows.Input.CanExecuteRoutedEventHandler> 이벤트 소스에 연결 된 명령을 명령 대상에서 실행할 수 있는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c893-104">The <xref:System.Windows.Input.CanExecuteRoutedEventHandler> determines if the command associated with the event source is able to execute on the command target.</span></span> <span data-ttu-id="8c893-105">명령에 명령 소스를 대상으로 지정 하는 경우 대상 정보를 통해 얻을 수 있습니다 `sender`합니다.</span><span class="sxs-lookup"><span data-stu-id="8c893-105">If the command has a command source that specifies a target, then the target information can be obtained through `sender`.</span></span> <span data-ttu-id="8c893-106">경우는 <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> 를 설정 하지 않으면 키보드 포커스가 있는 요소가 대상 이며 통해 얻을 수 있습니다 `sender`합니다.</span><span class="sxs-lookup"><span data-stu-id="8c893-106">If the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> is not set, the element with keyboard focus is the target, and can also be obtained through `sender`.</span></span>  <span data-ttu-id="8c893-107">대상에서 명령을 실행할 수 있는지 판단 되 면 해당 <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType> 속성에 설정할 `true`이 고, 그렇지 않으면로 설정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="8c893-107">If it is determined that the command can execute on the target, then the <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType> property should be set to `true`; otherwise, set it to `false`.</span></span>  
  
 <span data-ttu-id="8c893-108">명령, 원본 및 대상 확인 하기 위해 이벤트 데이터에 의존할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8c893-108">You do not need to rely on event data to determine the command, source, and target.</span></span> <span data-ttu-id="8c893-109">이 훨씬 어렵습니다 명령 구조는 이벤트의 연속 잠재적인 대상에서 동일한 명령을 실행 하려면 명령 라우팅에 광범위 하 게 의존 하는 경우 알려진된 가능한 명령 호출 처리기의 사용을 제한할 수 있습니다. 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="8c893-109">You can limit the usage of the handler to known possible command invocations, although this is more difficult to accomplish if your command structure relies extensively on the command routing to execute the same command on successive potential targets in an event route.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8c893-110">에서는 다음 예제는 <xref:System.Windows.Input.CanExecuteRoutedEventHandler> 설정 하는 <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> 에 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="8c893-110">The following example shows a <xref:System.Windows.Input.CanExecuteRoutedEventHandler> that sets <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> to `true`.</span></span>  
  
 [!code-csharp[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlercanexecutehandler)]
 [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlercanexecutehandler)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.ExecutedRoutedEventHandler" />
  </Docs>
</Type>