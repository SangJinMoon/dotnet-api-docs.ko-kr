<Type Name="INormalizeForIsolatedStorage" FullName="System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7980afb71abfe7eb7616996e3dcc638f708a8b0a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36562173" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INormalizeForIsolatedStorage" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" />
  <TypeSignature Language="VB.NET" Value="Public Interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="C++ CLI" Value="public interface class INormalizeForIsolatedStorage" />
  <TypeSignature Language="F#" Value="type INormalizeForIsolatedStorage = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="c207f-101">격리된 저장소와 응용 프로그램 도메인, 어셈블리의 증명 정보를 비교할 수 있게 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c207f-101">Enables comparisons between an isolated store and an application domain and assembly's evidence.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c207f-102">격리 된 저장소 식별 하 고 고유한 파일 저장소 위치와 함께 제공 하기 위해 어셈블리에 대 한 증거를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c207f-102">Isolated storage uses evidence about an assembly in order to identify it and provide it with a unique file storage location.</span></span> <span data-ttu-id="c207f-103">저장소를 요청 하는 어셈블리 (로드 하는 호스트에 의해 제시)으로 증명 정보를 처리 하 고 기존 저장소를 만드는 데 사용한 증거와 비교 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c207f-103">When an assembly requests a store, its evidence (as presented by the host that loaded it) is processed and compared with the evidence used to create the existing stores.</span></span> <span data-ttu-id="c207f-104">새 저장소를 만드는 데 필요 하거나 해당 어셈블리에 대해 이미 존재 하는 경우를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c207f-104">This determines if you need to create a new store or if one already exists for the assembly in question.</span></span> <span data-ttu-id="c207f-105">증명 정보는 기능적으로 동일 조각을 사용 하는 비교 방법으로 인해 하지 serialize 된 형식이 동일 하지 않은 경우에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c207f-105">Due to the comparison technique used, pieces of evidence that are functionally equivalent might not result in a true comparison if the serialized forms are not identical.</span></span> <span data-ttu-id="c207f-106">사용자 지정 증거를 구현할 때 증거 클래스의 경우 이것이 여부와 그럴 경우를 고려해, 구현 <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage>합니다.</span><span class="sxs-lookup"><span data-stu-id="c207f-106">When implementing custom evidence, consider whether this is the case for your evidence class and, if so, implement <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage>.</span></span> <span data-ttu-id="c207f-107">이 인터페이스를 구현 하는 증명 정보에 대 한는 <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A> 메서드가 호출 되 고 해당 메서드에 의해 반환 되는 개체의 정규화 된 복사본 비교는 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="c207f-107">For evidence that implements this interface, the <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A> method is called and comparisons are based on the normalized copy of the object returned by that method.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="c207f-108">
        <para>사용자 지정 증거를 구현 하 고 저장소를 이미 있는지 확인 해야 할 때이 인터페이스를 구현 합니다. 직렬화 된 개체를 비교는 대/소문자 구분 문자열 등의 일부 인스턴스에서에 쓰일 수 없습니다. 예를 들어 www.MSN.com WWW.msn.com 고는 반환 된 <see langword="true" /> 비교 했을 때. 만들려는 <see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /> 개체를 구현 해야는 <see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /> 메서드.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="c207f-108">
          <para>Implement this interface when you are implementing custom evidence and need to determine if a store already exists. Serialized objects should not be used for comparisons in some instances, such as that of case sensitive strings. For example, www.MSN.com is equal to WWW.msn.com and will return a <see langword="true" /> when compared. To create an <see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /> object, you need to implement the <see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /> method.</para>
        </span>
      </span>
    </block>
    <block subset="none" type="usage">
      <span data-ttu-id="c207f-109">
        <para>인스턴스를 정규화 격리 된 저장소 어셈블리의 증명 정보 및 현재 사용 중인 기존 비교 하기 전에이 인터페이스의 메서드를 호출 합니다.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="c207f-109">
          <para>Call the methods of this interface to normalize the instance before making comparisons between an assembly's evidence and currently existing isolated stores.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public object Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Normalize();" />
      <MemberSignature Language="F#" Value="abstract member Normalize : unit -&gt; obj" Usage="iNormalizeForIsolatedStorage.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c207f-110">파생 클래스에서 재정의할 경우 이 메서드를 호출한 개체의 정규화된 복사본을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c207f-110">When overridden in a derived class, returns a normalized copy of the object on which it is called.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c207f-111">이 메서드를 호출한 인스턴스를 나타내는 정규화된 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c207f-111">A normalized object that represents the instance on which this method was called.</span>
          </span>
          <span data-ttu-id="c207f-112">이 인스턴스는 문자열, 스트림 또는 serialize할 수 있는 모든 개체일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c207f-112">This instance can be a string, stream, or any serializable object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="c207f-113">
            <para>이 메서드를 재정의 하 고 스트림이 반환 된 개체를 serialize 할 것으로 간주 하 고 기존 저장소를 만드는 데 사용한 증거의 serialize 된 형식에 직접 비교 됩니다. 반환 되는 개체는 문자열, 격리 된 저장소의 이름으로 간주 되며 기존 저장소 이름과 비교 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="c207f-113">
              <para>When you override this method and the object returned is a stream, it is assumed to be serialized and is compared directly to the serialized form of the evidence used to create existing stores. If the object returned is a string, it is considered the name of an isolated store and compared to the names of the existing stores.</para>
            </span>
          </span>
        </block>
        <block subset="none" type="usage">
          <span data-ttu-id="c207f-114">
            <para>격리 된 저장소에서 파생 된 클래스를 작성 하 고 현재 어셈블리에 대 한 격리 된 저장소 이미 있는지 확인 해야 하는 경우 일반적으로이 메서드를 호출 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="c207f-114">
              <para>You typically call this method if you are writing a class derived from isolated storage and you need to check to see if isolated storage already exists for the current assembly.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>