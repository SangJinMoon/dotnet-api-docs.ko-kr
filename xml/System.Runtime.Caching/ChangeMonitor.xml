<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ChangeMonitor.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ef439688d7b98a238cf8640eb07e63804432a3ba.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef439688d7b98a238cf8640eb07e63804432a3ba</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Provides a base class for a derived custom type that monitors changes in the state of the data which a cache item depends on.</source>
          <target state="translated">캐시 항목이 종속된 데이터의 상태 변경을 모니터링하는 파생된 사용자 지정 형식에 대한 기본 클래스를 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class is used as the base class for derived monitor classes that are specialized for particular cache implementations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 클래스는 특정 캐시 구현에 대해 특수화 된 파생된 모니터링 클래스에 대 한 기본 클래스로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance monitors changes in the state of data which a cache item depends on.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스 데이터에 따라 캐시 항목의 상태 변경을 모니터링 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the item can be a file or data entity whose contents are cached.</source>
          <target state="translated">예를 들어 항목 내용이 캐시 된 파일 또는 데이터 엔터티를 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the file or data entity is updated, the associated cache entry must be changed also.</source>
          <target state="translated">파일 또는 데이터 엔터티가 업데이트 되는 경우 연결 된 캐시 항목 수 변경 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Common items that can be monitored include data entities (such as database fields, values, rows, or tables), another cache entry, and files and file attributes.</source>
          <target state="translated">모니터링할 수 있는 공통 항목 데이터 엔터티 (예: 데이터베이스 필드, 값, 행 또는 테이블), 다른 캐시 항목 및 파일 및 파일 특성을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A dependency change is a change in the state of a dependency.</source>
          <target state="translated">종속성 변경 종속성의 상태 변경이입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>In a typical cache implementation, after a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance notifies the cache that a dependency has changed, the cache performs the required action, such as invalidating the inserted cache entry.</source>
          <target state="translated">일반적인 캐시 구현에서 후 한 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스 종속성이 변경 되는 캐시에 게 알리는, 캐시 삽입 된 캐시 항목을 무효화 같은 필요한 동작을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classes can be customized to monitor dependency changes for specific different data stores.</source>
          <target state="translated">파생 된 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 특정 다른 데이터 저장소에 대 한 종속성 변경을 모니터링 하려면 클래스를 사용자 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, there are cache implementations for a file system, physical memory, or a database.</source>
          <target state="translated">예를 들어 파일 시스템, 실제 메모리 또는 데이터베이스에 대 한 캐시 구현이 있습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class examines changes that occur outside the cache, and then alerts the cache that changes have occurred.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 캐시 외부에서 발생 하는 변경 내용을 검사 하 고 다음 변경 내용이 발생 한 캐시를 경고 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> includes the following classes that derive from <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class:</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> 에서 파생 되는 다음 클래스가 포함 됩니다 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 클래스:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Each of these classes works with different types of dependencies.</source>
          <target state="translated">각이 클래스는 다른 종류의 종속성 작동합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the derived <ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph> class monitors changes to a cache for file system data (files and folders) that the cache item depends on.</source>
          <target state="translated">예를 들어 파생 <ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph> 클래스에는 캐시 항목에 종속 된 파일 시스템 데이터 (파일 및 폴더)에 대 한 캐시의 변경 내용을 모니터링 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This type is thread safe.</source>
          <target state="translated">이 형식은 스레드로부터 안전합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If you create a custom cache implementation or a derived change monitor type, you must follow certain guidelines.</source>
          <target state="translated">사용자 지정을 만드는 경우 캐시 구현 또는 모니터 유형, 파생 된 변경 특정 지침을 따라야 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The following list summarizes these guidelines.</source>
          <target state="translated">다음 목록에는 다음이 지침을 요약합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the documentation for individual methods or properties.</source>
          <target state="translated">자세한 내용은 개별 메서드나 속성에 대 한 설명서를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the method returns.</source>
          <target state="translated">파생된 클래스의 생성자에서 설정 해야 합니다는 <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> 속성을 모니터링을 시작 하 고 호출 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 메서드는 메서드가 반환 되기 전에 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a constructor encounters an error during constructions and must have to dispose of resources, the constructor can only call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called because the <ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload will throw an <ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> exception if initialization is not completed.</source>
          <target state="translated">생성자를 생성 하는 동안 오류가 발생 하 고 리소스를 삭제 하는 데 필요한, 생성자만 호출할 수 있습니다는 <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 후 오버 로드는 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 때문에 메서드는 <ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 를 throw 한 <ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> 초기화가 완료 되지 않은 경우 예외입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If changes occur in the data that is being monitored before initialization is complete, the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before calling the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">변경이 발생 하는 경우 초기화 되기 전에 모니터링 되는 데이터 완료, 생성자 호출 해야 합니다는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드 호출 하기 전에 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> type is instantiated, you must insert the monitor into a custom <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation.</source>
          <target state="translated">파생 된 후 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 형식이 인스턴스화된, 사용자 지정 모니터를 삽입 해야 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 구현 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Or if you are finished using the change monitor, call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">변경 모니터를 사용 하 여 작업을 완료 하는 경우 호출 또는 <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance is inserted into a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation, the <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance require that the change monitor is disposed.</source>
          <target state="translated">후는 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스에 삽입 되는 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 구현은 <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 인스턴스에 변경 모니터가 삭제 되도록 해야 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Even if the insertion is invalid and causes an exception, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">삽입 잘못 되었으며 예외를 발생 시키는 경우에는 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 구현을 호출 해야 합니다는 <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived change monitor is inserted into a cache, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>, by passing a <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object.</source>
          <target state="translated">파생된 된 변경 모니터 캐시에 삽입 한 이후에 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 구현을 호출 해야 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>, 전달 하 여는 <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method can be called only one time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 메서드는 한 번만 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called immediately when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">종속성 변경 문제가 이미 발생 했다면는 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 즉시 인스턴스를 호출할 예정 때 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 라고 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called only one time.</source>
          <target state="translated">그렇지 않은 경우는 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 인스턴스는 한 번만 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This one time call occurs either when the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called because the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance detected a change, or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called on the <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, whichever occurs first.</source>
          <target state="translated">이 한 번 호출이 발생 하며 때는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 때문에 메서드는 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스가 검색으로 변경 되거나는 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드가 호출 되는 <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, 중 먼저 발생 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance that is provided by an <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation should remove the associated cache entry and specify a reason by using the <ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 에서 제공 되는 인스턴스는 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 구현 관련된 캐시 항목을 제거 하 고 사용 하 여 이유를 지정 해야는 <ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph> 열거형입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance can call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method either before a cache implementation has called <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or after.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스를 호출할 수는 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드는 캐시 구현이 호출 전에 하나 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 메서드 후 또는 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called before <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called, the base <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> implementation will notify the cache that this has occurred and will trigger the callback to be passed to <ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> immediately when <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is invoked.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 전에 메서드가 호출 되 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 호출 되는 기본 <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 구현에서이 문제가 발생 하는 캐시 알림 메시지를 및로 전달할 콜백 트리거할 <ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 즉시 <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Any state data that is passed to the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is saved by the change monitor and subsequently passed to the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method is invoked.</source>
          <target state="translated">에 전달 되는 모든 상태 데이터는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드 변경 모니터에 의해 저장 되 고 나중에 전달 되는 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 메서드 때는 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 메서드가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method.</source>
          <target state="translated">변경 모니터를 구현 해야 합니다는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method documentation.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 메서드 설명서를 참조하세요.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload must be called to dispose of the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드 오버 로드를 삭제 하기 위해 호출 해야 합니다는 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The rules for calling Dispose are as follows:</source>
          <target state="translated">Dispose를 호출 하기 위한 규칙은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Before an item is inserted into the cache, it is the responsibility of caller to dispose of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">삭제 하기 위해 호출자에 게 작업은 캐시에 항목이 삽입 되 면 전에 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Once cache item and the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer must make sure that that the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, even if the insert fails.</source>
          <target state="translated">한 번 캐시 항목 및 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 캐시에 연결 된 인스턴스는 전달, 캐시 구현 자가 있는지 확인 해야 하는 <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 삽입이 실패 하는 경우에 메서드가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After an item and its associated <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">항목 및 연결 된 후 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스가 캐시에 전달 된, 때문에 호출자에 게가 종속성을 삭제 해야 때는 <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드가 호출 되 면 호출이 종속성이 변경 된 것 처럼 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>As a result, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is automatically invoked.</source>
          <target state="translated">결과적으로 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드는 자동으로 호출 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">이러한 규칙 고려는 <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 다음 방법 중 하나에서 메서드를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Users must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">사용자가 호출 해야 합니다는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 파생된 변경 모니터 인스턴스를 캐시에 삽입 하지 않도록 결정은 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the implementation tries to insert the change-monitor instance into an object cache but the insertion fails, the cache implementation is responsible for calling the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">구현 변경 모니터 인스턴스 개체 캐시에 삽입 하려고 하는 경우 삽입이 실패 하면 캐시 구현이 호출을 담당는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose of any associated dependencies.</source>
          <target state="translated">삽입 시도가 예외를 발생 시키는 캐시 구현 관련 된 모든 종속성을 삭제 해야 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the cache entry is removed, the cache implementation must also dispose of the dependency.</source>
          <target state="translated">캐시 엔트리가 제거 되 면 종속성의 캐시 구현도 삭제 해야 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The internal implementation of the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method automatically calls the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method after it calls a callback that is registered through <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>.</source>
          <target state="translated">내부 구현은 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드를 자동으로 호출 된 <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 후 하는 콜백을 호출할 메서드를 통해 등록 된 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This automatic call to the dispose method during the event firing only occurs if the initialization of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance was previously completed.</source>
          <target state="translated">경우에이 자동 메서드 호출에서 dispose 이벤트 발생 하는 동안 발생의 초기화는 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스가 이전에 완료 되었습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored already changed when the constructor was still active) then the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method will automatically dispose of the change monitor.</source>
          <target state="translated">파생 된 변경 모니터의 생성자가 호출 하는 경우는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 메서드를 변경 모니터의 상태가 이미 변경 하는 경우 (즉, 생성자가 여전히 활성화 하는 경우 이미 변경 된 모니터링 되는 상태) 경우 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 방법은 변경 모니터의 자동으로 삭제 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph> property is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph> after the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called by the derived change-monitor instance, regardless of whether a <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object has been set by a call to the <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or not.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph> 속성이로 설정 되어 <ph id="ph2">&lt;see langword="true" /&gt;</ph> 후는 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 파생된 변경 모니터 인스턴스 여부에 관계 없이 메서드는 한 <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 개체를 호출 하 여 설정에 <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 메서드 여부.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>This constructor is called from constructors in derived classes to initialize the base class.</source>
          <target state="translated">이 생성자는 파생 클래스의 생성자에서 호출되어 기본 클래스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class has a default constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 클래스에 기본 생성자입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>However, classes that inherit from the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class and define custom change-monitoring behavior must perform initialization in the constructor.</source>
          <target state="translated">그러나에서 상속 하는 기본 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 클래스 및 사용자 지정 변경 모니터링 정의 동작은 생성자에서 초기화를 수행 해야 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>For more information, see the Notes for Inheritors section.</source>
          <target state="translated">자세한 내용은 상속자 참고 사항 섹션에 대 한 메모를 참조 하세요.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> class before it returns.</source>
          <target state="translated">파생된 클래스의 생성자에서 설정 해야 합니다는 <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> 속성을 모니터링을 시작 하 고 호출에서 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 반환 하기 전에 클래스입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>If a dependency changes before initialization is complete (for example, if a dependent cache key is not found in the cache), the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before it calls the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">초기화 하기 전에 종속성이 변경 (예: 캐시에 종속 된 캐시 키가 없는 경우) 완료 되 면 생성자 호출 해야 합니다는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드 호출 하기 전에 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>In this case, constructor can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">이 경우를 호출 하려면는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드 후에는 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 메서드를 호출 하기 때문에 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 초기화가 완료 되지 않은 경우 메서드는 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is used to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance and related resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드 릴리스를 사용 하 여 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스 및 관련된 리소스입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The public <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is invoked to coordinate the disposal process with key life-cycle events of derived change-monitor classes (such as initialization), and to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance so that the instance can be garbage collected.</source>
          <target state="translated">공용 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드 (예: 초기화) 변경 모니터 파생된 클래스의 키 수명 주기 이벤트가 사용 하 여 삭제 프로세스를 조정 하 고 해제 하는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스 인스턴스가 가비지 수집 될 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is implemented by derived change-monitor classes to dispose of their managed and unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드 해당 스레드와 관리 되지 않는 리소스를 삭제 하기 위해 변경 모니터 파생된 클래스에서 구현 됩니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Releases all resources that are used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method invokes the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method of derived classes only one time, the first time it is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드가 호출 하는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 한 번만 호출 되는 처음으로 파생 된 클래스의 메서드.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Subsequent calls to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method have no effect.</source>
          <target state="translated">에 대 한 후속 호출에서 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드 아무런 효과가 없습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After the method has been called, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">메서드가 호출 된 후의 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph> 속성이 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload must be called to dispose of a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 삭제 하기 위해 오버 로드를 호출 해야 합니다는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The following are the rules for calling the dispose method:</source>
          <target state="translated">다음은 dispose 메서드를 호출 하는 것에 대 한 규칙입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Before an item is inserted into the cache, it is the caller's responsibility to dispose of a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">항목이 캐시에 삽입 되 면 전에 호출자의 삭제는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Once cache item and the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer that must make sure that <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> is called, even if the insert fails.</source>
          <target state="translated">한 번 캐시 항목 및 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 연결 된 인스턴스를 캐시 되었는지 확인 해야 하는 캐시 구현자에 전달 되 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 삽입이 실패 하는 경우에 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After an item and its associated <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">항목 및 연결 된 후 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스가 캐시에 전달 된, 때문에 호출자에 게가 종속성을 삭제 해야 때는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드가 호출 되 면 호출이 종속성이 변경 된 것 처럼 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>As a result, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is automatically invoked.</source>
          <target state="translated">결과적으로 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드는 자동으로 호출 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">이러한 규칙 고려는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 다음 방법 중 하나에서 메서드를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users must call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">사용자가 호출 해야 합니다는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 파생된 변경 모니터 인스턴스를 캐시에 삽입 하지 않도록 결정은 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The cache implementation is responsible for calling the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload if the implementation tries to insert the change-monitor instance into an object cache but the insertion fails.</source>
          <target state="translated">캐시를 구현 하는 호출에 대 한 책임이 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 구현 변경 모니터 인스턴스 개체 캐시에 삽입 하려고 시도 하지만 삽입이 실패 한 경우 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose any associated dependencies.</source>
          <target state="translated">삽입 시도가 예외를 발생 시키는 캐시 구현 관련 된 모든 종속성을 삭제 해야 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>If the cache entry is removed, the cache implementation must also dispose the dependency.</source>
          <target state="translated">캐시 엔트리가 제거 되 면 캐시 구현 종속성도 삭제 해야 합니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The internal implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically calls the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method after it calls a callback that is registered through the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">내부 구현은 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드를 자동으로 호출 된 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 후 하는 콜백을 호출할 메서드를 통해 등록 된는 <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>This automatic dispose during the event firing only occurs if the initialization of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance previously completed.</source>
          <target state="translated">경우에 이벤트 발생 하는 동안이 자동 dispose 발생의 초기화는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스가 이전에 완료 되었습니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored has already changed when the constructor was still active) then <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method will automatically dispose the change monitor.</source>
          <target state="translated">파생 된 변경 모니터의 생성자가 호출 하는 경우는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> 메서드를 변경 모니터의 상태가 이미 변경 하는 경우 (즉, 상태가 모니터링 되는 이미 변경 생성자가 여전히 활성화 하는 경우) 다음 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> 방법은 변경 모니터를 자동으로 삭제 합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users should not call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">사용자가 호출 하지 않아야는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>However, you cannot prevent users from calling the method.</source>
          <target state="translated">그러나 메서드를 호출에서 사용자를 방지할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Therefore, if they do, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">따라서, 그럴 경우는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>In that case, the cache entry is notified as if the dependency has changed.</source>
          <target state="translated">이 경우 캐시 항목에는 종속성이 변경 하는 경우 알림이 전송 됩니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>To prevent derived classes from overriding <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method, the method is not an explicit interface implementation.</source>
          <target state="translated">파생된 클래스를 재정의 하지 않도록 하려면 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드, 메서드는 명시적 인터페이스 구현 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Initialization is not complete in the derived change-monitor class that called the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">기본 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드를 호출한 파생된 변경 모니터 클래스에서 초기화가 완료되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release managed and unmanaged resources and any references to a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">관리되는 리소스 및 관리되지 않는 리소스와 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스에 대한 모든 참조를 해제하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 관리되지 않는 리소스만 해제하려면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed, the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method is called by a <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph> thread and any external managed references are likely no longer valid because they have already been garbage collected.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>가 전달되면 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 메서드가 <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph> 스레드에 의해 호출되고, 모든 외부 관리 참조가 이미 가비지 수집되었기 때문에 더 이상 유효하지 않습니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Releases all managed and unmanaged resources and any references to the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">모든 관리되는 리소스 및 관리되지 않는 리소스와 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스에 대한 모든 참조를 해제합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>This overload must be implemented by derived change-monitor classes.</source>
          <target state="translated">이 오버로드는 파생된 변경 모니터 클래스에 의해 구현되어야 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When the value of <ph id="ph1">`disposing`</ph> value is <ph id="ph2">`true`</ph>, all managed and unmanaged resources are disposed and any references to this object are released so that the derived change-monitor instance can be garbage collected.</source>
          <target state="translated">때의 값 <ph id="ph1">`disposing`</ph> 값은 <ph id="ph2">`true`</ph>, 스레드와 관리 되지 않는 리소스를 모두 삭제 되 고 파생된 변경 모니터 인스턴스 가비지 수집 될 수 있도록이 개체에 대 한 참조가 해제 됩니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>It is guaranteed that the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method will invoke the implemented <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method only one time.</source>
          <target state="translated">변수는 기본 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드는 구현 된 호출 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드에 한 번만 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload to release all managed and unmanaged resources when the value of <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">변경 모니터를 구현 해야 합니다는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 오버 로드를 모두 해제 코드와 비관리 리소스 때의 값 <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> 은 <ph id="ph3">&lt;see langword="true" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method overload that has a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="true" /&gt;</ph> is called only one time, namely, when the instance is disposed for the first time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 변수가 있는 메서드 오버 로드는 <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> 값 <ph id="ph3">&lt;see langword="true" /&gt;</ph> 은 한 번만 호출, 즉, 인스턴스가 처음으로 삭제 될 때입니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must not call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload directly.</source>
          <target state="translated">변경 모니터를 호출 해서는 안 된 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 오버 로드를 직접 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A derived change monitor can call the public parameter-less <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method on the base <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">파생된 된 변경 모니터 공용 매개 변수가 없는 호출 수 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 자료 메서드 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Alternatively, a change monitor can implement a finalizer method.</source>
          <target state="translated">또는 변경 모니터 종료자 메서드를 구현할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>In that case, the finalizer can invoke the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method and pass it a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 경우 종료자를 호출할 수 있습니다는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 메서드 전달는 <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> 값 <ph id="ph3">&lt;see langword="false" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>However, this is usually unnecessary.</source>
          <target state="translated">그러나이 작업이 일반적으로 필요 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Monitoring for dependency changes is typically performed by a service that maintains a reference to the change-monitor instance.</source>
          <target state="translated">종속성 변경에 대 한 모니터링은 일반적으로 변경 모니터 인스턴스에 대 한 참조를 유지 관리 하는 서비스에서 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The reference prevents the instance from being garbage collected, and therefore makes a finalizer method unnecessary.</source>
          <target state="translated">가비지 수집 되지 않도록 인스턴스 되지 않으며가 불필요 한 종료자 메서드에 대 한 참조 합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>To avoid memory leaks, when a dependency changes, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method disposes the change-monitor instance (unless initialization has not finished).</source>
          <target state="translated">종속성이 변경 될 때 메모리 누수를 방지 하는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드 (하지 않는 한 초기화가 완료 되지 않았으며) 변경 모니터 인스턴스를 삭제 합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Gets a value that indicates that the state that is monitored by the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class has changed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 클래스에서 모니터링하는 상태가 변경되었음을 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the state that is monitored by the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance has changed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 인스턴스에서 모니터링하는 상태가 변경되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>You can check the value of this property in a derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class to see whether a dependency has changed.</source>
          <target state="translated">파생 된이 속성의 값을 확인할 수 있습니다 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 클래스 종속성이 변경 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>The value is set to <ph id="ph1">`true`</ph> when a dependency change occurs (that is, when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called).</source>
          <target state="translated">값으로 설정 됩니다 <ph id="ph1">`true`</ph> 종속성 변경이 발생할 경우 (즉는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드는).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>After the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called by the derived class, the value of the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property will be <ph id="ph3">`true`</ph>, regardless of whether a <ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> instance has been notified by a call to the <ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">후의 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드는 파생된 클래스의 값에서는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> 속성이 <ph id="ph3">`true`</ph>여부에 관계 없이 <ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> 를 호출 하 여 인스턴스 अ ध는 <ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Callers can check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property to see whether a dependency has changed.</source>
          <target state="translated">호출자를 확인할 수는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> 속성을 종속성 변경 되었는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>However, in a multi-threaded environment, a simpler and more maintainable approach is to insert data into a cache implementation without checking the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property.</source>
          <target state="translated">그러나 다중 스레드 환경에서 간단 하 고 더 쉽게 유지 관리할 방법은 하는 확인 하지 않고 데이터를 캐시 구현에 삽입 된 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Cache implementations must check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property for you and must not perform an insert or set operation if one or more associated dependencies have already changed.</source>
          <target state="translated">캐시 구현 확인 해야 합니다는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> 있습니다에 대 한 속성 및 삽입 수행 하거나 안 하나 이상의 연결 된 종속성 이미 변경 된 경우 작업을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>Called from the constructor of derived classes to indicate that initialization is finished.</source>
          <target state="translated">파생 클래스의 생성자에서 호출되어 초기화가 완료되었음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If a dependency changes before initialization is complete in a derived class, the constructor of the derived class must invoke the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">종속성이 파생된 클래스에서 초기화가 완료 되기 전에 변경 하는 경우 파생된 클래스의 생성자를 호출 해야 합니다는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>When the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked, the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is automatically set to <ph id="ph3">`true`</ph> by the change monitor.</source>
          <target state="translated">때는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드가 호출 되는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> 자동으로 속성이 <ph id="ph3">`true`</ph> 변경 모니터에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>As a result, when the change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, the base class will automatically call the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">결과적으로, 변경 모니터 생성자 호출 하는 경우는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> 메서드를 기본 클래스를 자동으로 호출 된 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If initialization is complete, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically disposes the derived change-monitor instance.</source>
          <target state="translated">초기화가 완료 되 면 하는 경우는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드는 파생된 변경 모니터 인스턴스를 자동으로 삭제 합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class must call the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the constructor returns.</source>
          <target state="translated">파생된 클래스의 생성자는 기본 호출 해야 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 생성자는 반환 되기 전에 메서드.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">파생된 클래스의 생성자를 호출할 수는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드 후에 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> 때문에 호출 됩니다는 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 초기화가 완료 되지 않은 경우 메서드는 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>Gets a value that indicates that the derived instance of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class is disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 클래스의 파생 인스턴스가 삭제되었는지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the instance is disposed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">인스턴스가 삭제되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>The property is set to <ph id="ph1">`true`</ph> after the base <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method in a derived class to dispose of the instance.</source>
          <target state="translated">속성이로 설정 되어 <ph id="ph1">`true`</ph> 기본 후 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 메서드 호출에서 <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> 인스턴스를 삭제 하려면 파생된 클래스에서 메서드.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A reference to a method that is invoked when a dependency has changed.</source>
          <target state="translated">종속성이 변경되었을 때 호출되는 메서드에 대한 참조입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Called by Cache implementers to register a callback and notify an <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance through the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> delegate when a dependency has changed.</source>
          <target state="translated">종속성이 변경되었을 때 콜백을 등록하고 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 대리자를 통해 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 인스턴스를 알리기 위해 캐시 구현자에 의해 호출됩니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Cache implementers use this method to wire themselves up to a change monitor.</source>
          <target state="translated">캐시 구현자 변경 모니터 자신을 연결 하려면이 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If you associate one or more change monitors with the cache item, you pass a <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph> instance with a populated change monitors property to the cache item.</source>
          <target state="translated">통과 연결 하나 이상의 캐시 항목을 사용 하 여 모니터를 변경,는 <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph> 캐시 항목 채워진된 변경 모니터 속성을 사용 하 여 인스턴스.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A cache implementer that supports change monitors is responsible for iterating over the <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph> property and register the <ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegates with each change monitor that it finds.</source>
          <target state="translated">반복에 대 한 지원 변경 모니터 캐시 구현자는는 <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph> 속성과 레지스터는 <ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> 각 대리자 발견 하는 모니터를 변경 합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegate includes an optional state parameter, a concrete change monitor implementation can pass optional state information.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> 구체적인 변경 모니터 구현은 선택적 상태 정보를 전달할 수, 대리자는 선택적 상태 매개 변수를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The cache implementer determines whether an explicit dependency on the type of state that a custom change monitor passes as part of the callback can be taken.</source>
          <target state="translated">캐시 구현자 명시적 종속성 상태 사용자 지정 변경 모니터 콜백의 일부로 전달 하는 유형의을 수행할 수 있는지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The base cache extensibility API has no requirement for explicit dependency on the type of state.</source>
          <target state="translated">기본 캐시 확장성 API에는 상태 형식에 명시적인 종속성에 대 한 요구 사항이 있습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method automatically determines whether the state of the monitor has already changed at the time <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called.</source>
          <target state="translated">구현에서 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> 메서드를 자동으로 모니터의 상태가 이미 시간에 변경 되었는지 여부를 결정 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, then the method automatically calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> event handler, that was registered, through the <ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> 속성은 <ph id="ph2">`true`</ph>, 메서드를 자동으로 호출 합니다는 <ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> 통해 등록 된 이벤트 처리기는 <ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>This occurs because it is possible that from the time a cache implementation creates a change monitor, to the time a cache implementation gets the monitor and wires itself up to it, the underlying monitored state has changed.</source>
          <target state="translated">이 캐시 구현 캐시를 구현 하는 모니터를 가져오고, 최대 연결 시간으로 변경 모니터를 만들면 시간에서 기본 모니터링된 상태가 변경 되었을 수 있기 때문에 발생 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the state has already changed then the object that is passed to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">경우 상태가 이미 변경 후에 전달 되는 개체는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 방법은 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method can be invoked only one time, and will throw an exception on subsequent calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> 메서드를 한 번만 호출할 수 있으며 후속 호출에서 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The callback method has already been invoked.</source>
          <target state="translated">콜백 메서드가 이미 호출되었습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method to be notified of any dependency changes.</source>
          <target state="translated">호출 해야 합니다는 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 메서드 종속성 변경을 알림을 받을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">종속성 변경 문제가 이미 발생 했다면는 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 인스턴스 될 때 호출할 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> 라고 합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called one time, either when the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, whichever occurs first.</source>
          <target state="translated">그렇지 않은 경우는 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 인스턴스는 한 번 호출 됩니다 때는 <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> 메서드는 시기는 <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 메서드 중 먼저 발생 합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance provided by the cache implementation should remove the cache entry and if it is requested by the cache caller, raise the necessary change or update event back to the original cache caller.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 캐시 구현에 의해 제공 된 인스턴스와 캐시 엔트리를 제거 되 고 캐시 호출자가 요청 되는 경우 필요한 변경 또는 원래 캐시 호출자로 다시 업데이트 이벤트를 발생 시킵니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The object cache implementation must remove the cache entry that is associated with a dependency change.</source>
          <target state="translated">개체 캐시 구현 종속성 변경 내용과 연결 된 캐시 항목을 제거 해야 합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The data for the change event.</source>
          <target state="translated">변경 이벤트에 대한 데이터입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>This value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 값은 <ph id="ph1">&lt;see langword="null" /&gt;</ph>일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Called by derived classes to raise the event when a dependency changes.</source>
          <target state="translated">종속성이 변경될 때 이벤트를 발생시킬 수 있도록 파생 클래스에서 호출됩니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called when dependency changes occur.</source>
          <target state="translated">일반적으로 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드 종속성이 변경 될 때 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is also invoked when a change-monitor instance is disposed but the disposal occurs only if the callback has not already been invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 변경 모니터 인스턴스가 삭제 되지만 콜백을 호출 하지 않으면 이미 있는 경우에 삭제 작업이 수행 되는 경우에 메서드가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called before the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called, the state data from the call to the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is saved by the cache implementation.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 전에 메서드가 호출 되는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> 메서드가 호출 되 면를 호출 하 여 상태 데이터는 <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> 메서드는 캐시 구현에 의해 저장 됩니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Also, the callback to the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> method is invoked immediately when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">또한 하는 콜백에 <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> 즉시 메서드 때는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> 메서드가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>Gets a value that represents the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 클래스 인스턴스를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The identifier for a change-monitor instance.</source>
          <target state="translated">변경 모니터 인스턴스의 식별자입니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property value typically consists of dependency names combined string data that uniquely identifiers the data that is being monitored by a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> 속성 값 일반적으로 구성 됩니다 종속성 연결 이름의 문자열 데이터의 고유 하 게 식별자에서 모니터링 하는 데이터는 <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property is a string.</source>
          <target state="translated">값은 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> 속성은 문자열입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the string is used to assign the unique ID of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">고유 ID를 할당 하는 문자열의 값이 사용 된 <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>By overriding the property, you can define a custom implementation for the string value of the property in order to assign it a unique ID.</source>
          <target state="translated">속성을 재정의 하 여 속성의 문자열 값에 대 한 사용자 지정 구현을 고유 ID를 할당 하기 위해 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>In derived classes, you must set the value of the property in the constructor.</source>
          <target state="translated">파생된 클래스에서 생성자에서 속성의 값을 설정 해야 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>