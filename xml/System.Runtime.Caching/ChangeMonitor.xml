<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ef439688d7b98a238cf8640eb07e63804432a3ba" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480497" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>캐시 항목이 종속된 데이터의 상태 변경을 모니터링하는 파생된 사용자 지정 형식에 대한 기본 클래스를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> 클래스는 특정 캐시 구현에 대해 특수화 된 파생된 모니터링 클래스에 대 한 기본 클래스로 사용 됩니다. A <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스 데이터에 따라 캐시 항목의 상태 변경을 모니터링 합니다. 예를 들어 항목 내용이 캐시 된 파일 또는 데이터 엔터티를 수 있습니다. 파일 또는 데이터 엔터티가 업데이트 되는 경우 연결 된 캐시 항목 수 변경 합니다. 모니터링할 수 있는 공통 항목 데이터 엔터티 (예: 데이터베이스 필드, 값, 행 또는 테이블), 다른 캐시 항목 및 파일 및 파일 특성을 포함 합니다.  
  
 종속성 변경 종속성의 상태 변경이입니다. 일반적인 캐시 구현에서 후 한 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스 종속성이 변경 되는 캐시에 게 알리는, 캐시 삽입 된 캐시 항목을 무효화 같은 필요한 동작을 수행 합니다.  
  
 파생 된 <xref:System.Runtime.Caching.ChangeMonitor> 특정 다른 데이터 저장소에 대 한 종속성 변경을 모니터링 하려면 클래스를 사용자 지정할 수 있습니다. 예를 들어 파일 시스템, 실제 메모리 또는 데이터베이스에 대 한 캐시 구현이 있습니다. <xref:System.Runtime.Caching.ChangeMonitor> 캐시 외부에서 발생 하는 변경 내용을 검사 하 고 다음 변경 내용이 발생 한 캐시를 경고 하는 클래스입니다.  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 에서 파생 되는 다음 클래스가 포함 됩니다 <xref:System.Runtime.Caching.ChangeMonitor> 클래스:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 각이 클래스는 다른 종류의 종속성 작동합니다. 예를 들어 파생 <xref:System.Runtime.Caching.FileChangeMonitor> 클래스에는 캐시 항목에 종속 된 파일 시스템 데이터 (파일 및 폴더)에 대 한 캐시의 변경 내용을 모니터링 합니다.  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <block subset="none" type="overrides">
      <para>사용자 지정을 만드는 경우 캐시 구현 또는 모니터 유형, 파생 된 변경 특정 지침을 따라야 합니다. 다음 목록에는 다음이 지침을 요약합니다. 자세한 내용은 개별 메서드나 속성에 대 한 설명서를 참조 합니다.  
  
-   파생된 클래스의 생성자에서 설정 해야 합니다는 <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> 속성을 모니터링을 시작 하 고 호출 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 메서드는 메서드가 반환 되기 전에 합니다. 생성자를 생성 하는 동안 오류가 발생 하 고 리소스를 삭제 하는 데 필요한, 생성자만 호출할 수 있습니다는 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 후 오버 로드는 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 때문에 메서드는 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 를 throw 한 <see cref="T:System.InvalidOperationException" /> 초기화가 완료 되지 않은 경우 예외입니다.  
  
-   변경이 발생 하는 경우 초기화 되기 전에 모니터링 되는 데이터 완료, 생성자 호출 해야 합니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드 호출 하기 전에 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 메서드.  
  
-   파생 된 후 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 형식이 인스턴스화된, 사용자 지정 모니터를 삽입 해야 <see cref="T:System.Runtime.Caching.ObjectCache" /> 구현 합니다. 변경 모니터를 사용 하 여 작업을 완료 하는 경우 호출 또는 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드.  
  
-   후는 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스에 삽입 되는 <see cref="T:System.Runtime.Caching.ObjectCache" /> 구현은 <see cref="T:System.Runtime.Caching.ObjectCache" /> 인스턴스에 변경 모니터가 삭제 되도록 해야 합니다. 삽입 잘못 되었으며 예외를 발생 시키는 경우에는 <see cref="T:System.Runtime.Caching.ObjectCache" /> 구현을 호출 해야 합니다는 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 오버 로드 합니다.  
  
-   파생된 된 변경 모니터 캐시에 삽입 한 이후에 <see cref="T:System.Runtime.Caching.ObjectCache" /> 구현을 호출 해야 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, 전달 하 여는 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 개체입니다. <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 메서드는 한 번만 호출할 수 있습니다. 종속성 변경 문제가 이미 발생 했다면는 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 즉시 인스턴스를 호출할 예정 때 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 라고 합니다. 그렇지 않은 경우는 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 인스턴스는 한 번만 호출 됩니다. 이 한 번 호출이 발생 하며 때는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 때문에 메서드는 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스가 검색으로 변경 되거나는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드가 호출 되는 <see cref="T:System.Runtime.Caching.ChangeMonitor" />, 중 먼저 발생 합니다.  
  
-   <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 에서 제공 되는 인스턴스는 <see cref="T:System.Runtime.Caching.ObjectCache" /> 구현 관련된 캐시 항목을 제거 하 고 사용 하 여 이유를 지정 해야는 <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> 열거형입니다.  
  
-   A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스를 호출할 수는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드는 캐시 구현이 호출 전에 하나 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 메서드 후 또는 합니다. 경우는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 전에 메서드가 호출 되 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 호출 되는 기본 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 구현에서이 문제가 발생 하는 캐시 알림 메시지를 및로 전달할 콜백 트리거할 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 즉시 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 가 호출 됩니다. 에 전달 되는 모든 상태 데이터는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드 변경 모니터에 의해 저장 되 고 나중에 전달 되는 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 메서드 때는 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 메서드가 호출 됩니다.  
  
-   변경 모니터를 구현 해야 합니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 메서드. 자세한 내용은 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 메서드 설명서를 참조하세요.  
  
-   <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드 오버 로드를 삭제 하기 위해 호출 해야 합니다는 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스. Dispose를 호출 하기 위한 규칙은 다음과 같습니다.  
  
    -   삭제 하기 위해 호출자에 게 작업은 캐시에 항목이 삽입 되 면 전에 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스.  
  
    -   한 번 캐시 항목 및 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 캐시에 연결 된 인스턴스는 전달, 캐시 구현 자가 있는지 확인 해야 하는 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 삽입이 실패 하는 경우에 메서드가 호출 됩니다.  
  
    -   항목 및 연결 된 후 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스가 캐시에 전달 된, 때문에 호출자에 게가 종속성을 삭제 해야 때는 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드가 호출 되 면 호출이 종속성이 변경 된 것 처럼 처리 됩니다. 결과적으로 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드는 자동으로 호출 합니다.  
  
-   이러한 규칙 고려는 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 다음 방법 중 하나에서 메서드를 호출 해야 합니다.  
  
    -   사용자가 호출 해야 합니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 파생된 변경 모니터 인스턴스를 캐시에 삽입 하지 않도록 결정은 메서드 오버 로드 합니다.  
  
    -   구현 변경 모니터 인스턴스 개체 캐시에 삽입 하려고 하는 경우 삽입이 실패 하면 캐시 구현이 호출을 담당는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 오버 로드 합니다. 삽입 시도가 예외를 발생 시키는 캐시 구현 관련 된 모든 종속성을 삭제 해야 합니다.  
  
    -   캐시 엔트리가 제거 되 면 종속성의 캐시 구현도 삭제 해야 합니다.  
  
    -   내부 구현은 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드를 자동으로 호출 된 <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> 후 하는 콜백을 호출할 메서드를 통해 등록 된 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />합니다.  
  
 <block subset="none" type="note"><para>  
 경우에이 자동 메서드 호출에서 dispose 이벤트 발생 하는 동안 발생의 초기화는 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스가 이전에 완료 되었습니다.  
  
</para></block>  
  
 파생 된 변경 모니터의 생성자가 호출 하는 경우는 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 메서드를 변경 모니터의 상태가 이미 변경 하는 경우 (즉, 생성자가 여전히 활성화 하는 경우 이미 변경 된 모니터링 되는 상태) 경우 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 방법은 변경 모니터의 자동으로 삭제 합니다.  
  
-   <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> 속성이로 설정 되어 <see langword="true" /> 후는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 파생된 변경 모니터 인스턴스 여부에 관계 없이 메서드는 한 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 개체를 호출 하 여 설정에 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 메서드 여부.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 클래스의 새 인스턴스를 초기화합니다. 이 생성자는 파생 클래스의 생성자에서 호출되어 기본 클래스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor> 클래스에 기본 생성자입니다. 그러나에서 상속 하는 기본 <xref:System.Runtime.Caching.ChangeMonitor> 클래스 및 사용자 지정 변경 모니터링 정의 동작은 생성자에서 초기화를 수행 해야 합니다. 자세한 내용은 상속자 참고 사항 섹션에 대 한 메모를 참조 하세요.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스의 생성자에서 설정 해야 합니다는 <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> 속성을 모니터링을 시작 하 고 호출에서 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 반환 하기 전에 클래스입니다. 초기화 하기 전에 종속성이 변경 (예: 캐시에 종속 된 캐시 키가 없는 경우) 완료 되 면 생성자 호출 해야 합니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드 호출 하기 전에 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 메서드. 이 경우를 호출 하려면는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드 후에는 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 메서드를 호출 하기 때문에 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 초기화가 완료 되지 않은 경우 메서드는 예외를 throw 합니다.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드 릴리스를 사용 하 여 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스 및 관련된 리소스입니다. 공용 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드 (예: 초기화) 변경 모니터 파생된 클래스의 키 수명 주기 이벤트가 사용 하 여 삭제 프로세스를 조정 하 고 해제 하는 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스 인스턴스가 가비지 수집 될 수 있도록 합니다. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드 해당 스레드와 관리 되지 않는 리소스를 삭제 하기 위해 변경 모니터 파생된 클래스에서 구현 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드가 호출 하는 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 한 번만 호출 되는 처음으로 파생 된 클래스의 메서드. 에 대 한 후속 호출에서 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드 아무런 효과가 없습니다. 메서드가 호출 된 후의 <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> 속성이 `true`합니다.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 삭제 하기 위해 오버 로드를 호출 해야 합니다는 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스. 다음은 dispose 메서드를 호출 하는 것에 대 한 규칙입니다.  
  
-   항목이 캐시에 삽입 되 면 전에 호출자의 삭제는 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스.  
  
-   한 번 캐시 항목 및 <xref:System.Runtime.Caching.ChangeMonitor> 연결 된 인스턴스를 캐시 되었는지 확인 해야 하는 캐시 구현자에 전달 되 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 삽입이 실패 하는 경우에 호출 됩니다.  
  
-   항목 및 연결 된 후 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스가 캐시에 전달 된, 때문에 호출자에 게가 종속성을 삭제 해야 때는 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드가 호출 되 면 호출이 종속성이 변경 된 것 처럼 처리 됩니다. 결과적으로 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드는 자동으로 호출 합니다.  
  
-   이러한 규칙 고려는 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 다음 방법 중 하나에서 메서드를 호출 해야 합니다.  
  
    -   사용자가 호출 해야 합니다는 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 파생된 변경 모니터 인스턴스를 캐시에 삽입 하지 않도록 결정은 메서드 오버 로드 합니다.  
  
    -   캐시를 구현 하는 호출에 대 한 책임이 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 구현 변경 모니터 인스턴스 개체 캐시에 삽입 하려고 시도 하지만 삽입이 실패 한 경우 재정의 합니다. 삽입 시도가 예외를 발생 시키는 캐시 구현 관련 된 모든 종속성을 삭제 해야 합니다.  
  
    -   캐시 엔트리가 제거 되 면 캐시 구현 종속성도 삭제 해야 합니다.  
  
 내부 구현은 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드를 자동으로 호출 된 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 후 하는 콜백을 호출할 메서드를 통해 등록 된는 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> 메서드.  
  
> [!NOTE]
>  경우에 이벤트 발생 하는 동안이 자동 dispose 발생의 초기화는 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스가 이전에 완료 되었습니다.  
  
 파생 된 변경 모니터의 생성자가 호출 하는 경우는 <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> 메서드를 변경 모니터의 상태가 이미 변경 하는 경우 (즉, 상태가 모니터링 되는 이미 변경 생성자가 여전히 활성화 하는 경우) 다음 <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> 방법은 변경 모니터를 자동으로 삭제 합니다.  
  
> [!NOTE]
>  사용자가 호출 하지 않아야는 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드. 그러나 메서드를 호출에서 사용자를 방지할 수 없습니다. 따라서, 그럴 경우는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드가 호출 됩니다. 이 경우 캐시 항목에는 종속성이 변경 하는 경우 알림이 전송 됩니다.  
  
 파생된 클래스를 재정의 하지 않도록 하려면 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드, 메서드는 명시적 인터페이스 구현 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">기본 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드를 호출한 파생된 변경 모니터 클래스에서 초기화가 완료되지 않았습니다.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스 및 관리되지 않는 리소스와 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스에 대한 모든 참조를 해제하려면 <see langword="true" />이고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />입니다. <see langword="false" />가 전달되면 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 메서드가 <see langword="finalizer" /> 스레드에 의해 호출되고, 모든 외부 관리 참조가 이미 가비지 수집되었기 때문에 더 이상 유효하지 않습니다.</param>
        <summary>모든 관리되는 리소스 및 관리되지 않는 리소스와 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스에 대한 모든 참조를 해제합니다. 이 오버로드는 파생된 변경 모니터 클래스에 의해 구현되어야 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때의 값 `disposing` 값은 `true`, 스레드와 관리 되지 않는 리소스를 모두 삭제 되 고 파생된 변경 모니터 인스턴스 가비지 수집 될 수 있도록이 개체에 대 한 참조가 해제 됩니다. 변수는 기본 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드는 구현 된 호출 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드에 한 번만 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>변경 모니터를 구현 해야 합니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 오버 로드를 모두 해제 코드와 비관리 리소스 때의 값 <paramref name="disposing" /> 은 <see langword="true" />합니다. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 변수가 있는 메서드 오버 로드는 <paramref name="disposing" /> 값 <see langword="true" /> 은 한 번만 호출, 즉, 인스턴스가 처음으로 삭제 될 때입니다. 변경 모니터를 호출 해서는 안 된 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 오버 로드를 직접 합니다. 파생된 된 변경 모니터 공용 매개 변수가 없는 호출 수 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 자료 메서드 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 클래스입니다.  
  
 또는 변경 모니터 종료자 메서드를 구현할 수 있습니다. 이 경우 종료자를 호출할 수 있습니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 메서드 전달는 <paramref name="disposing" /> 값 <see langword="false" />합니다. 그러나이 작업이 일반적으로 필요 하지 않습니다. 종속성 변경에 대 한 모니터링은 일반적으로 변경 모니터 인스턴스에 대 한 참조를 유지 관리 하는 서비스에서 수행 됩니다. 가비지 수집 되지 않도록 인스턴스 되지 않으며가 불필요 한 종료자 메서드에 대 한 참조 합니다. 종속성이 변경 될 때 메모리 누수를 방지 하는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드 (하지 않는 한 초기화가 완료 되지 않았으며) 변경 모니터 인스턴스를 삭제 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 클래스에서 모니터링하는 상태가 변경되었음을 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 인스턴스에서 모니터링하는 상태가 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된이 속성의 값을 확인할 수 있습니다 <xref:System.Runtime.Caching.ChangeMonitor> 클래스 종속성이 변경 여부를 확인 합니다.  
  
 값으로 설정 됩니다 `true` 종속성 변경이 발생할 경우 (즉는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드는). 후의 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드는 파생된 클래스의 값에서는 <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> 속성이 `true`여부에 관계 없이 <xref:System.Runtime.Caching.OnChangedCallback> 를 호출 하 여 인스턴스 अ ध는 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> 메서드.  
  
> [!NOTE]
>  호출자를 확인할 수는 <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> 속성을 종속성 변경 되었는지 여부를 확인 합니다. 그러나 다중 스레드 환경에서 간단 하 고 더 쉽게 유지 관리할 방법은 하는 확인 하지 않고 데이터를 캐시 구현에 삽입 된 <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> 속성입니다. 캐시 구현 확인 해야 합니다는 <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> 있습니다에 대 한 속성 및 삽입 수행 하거나 안 하나 이상의 연결 된 종속성 이미 변경 된 경우 작업을 설정 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스의 생성자에서 호출되어 초기화가 완료되었음을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성이 파생된 클래스에서 초기화가 완료 되기 전에 변경 하는 경우 파생된 클래스의 생성자를 호출 해야 합니다는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드.  
  
 때는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드가 호출 되는 <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> 자동으로 속성이 `true` 변경 모니터에 의해 합니다. 결과적으로, 변경 모니터 생성자 호출 하는 경우는 <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> 메서드를 기본 클래스를 자동으로 호출 된 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드. 초기화가 완료 되 면 하는 경우는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드는 파생된 변경 모니터 인스턴스를 자동으로 삭제 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생된 클래스의 생성자는 기본 호출 해야 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 생성자는 반환 되기 전에 메서드. 파생된 클래스의 생성자를 호출할 수는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드 후에 <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> 때문에 호출 됩니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 초기화가 완료 되지 않은 경우 메서드는 예외를 throw 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 클래스의 파생 인스턴스가 삭제되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          인스턴스가 삭제되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성이로 설정 되어 `true` 기본 후 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 메서드 호출에서 <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 인스턴스를 삭제 하려면 파생된 클래스에서 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">종속성이 변경되었을 때 호출되는 메서드에 대한 참조입니다.</param>
        <summary>종속성이 변경되었을 때 콜백을 등록하고 <see cref="T:System.Runtime.Caching.ObjectCache" /> 대리자를 통해 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 인스턴스를 알리기 위해 캐시 구현자에 의해 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐시 구현자 변경 모니터 자신을 연결 하려면이 메서드를 사용 합니다. 통과 연결 하나 이상의 캐시 항목을 사용 하 여 모니터를 변경,는 <xref:System.Runtime.Caching.CacheItemPolicy> 캐시 항목 채워진된 변경 모니터 속성을 사용 하 여 인스턴스. 반복에 대 한 지원 변경 모니터 캐시 구현자는는 <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> 속성과 레지스터는 <xref:System.Runtime.Caching.OnChangedCallback> 각 대리자 발견 하는 모니터를 변경 합니다.  
  
 때문에 <xref:System.Runtime.Caching.OnChangedCallback> 구체적인 변경 모니터 구현은 선택적 상태 정보를 전달할 수, 대리자는 선택적 상태 매개 변수를 포함 합니다. 캐시 구현자 명시적 종속성 상태 사용자 지정 변경 모니터 콜백의 일부로 전달 하는 유형의을 수행할 수 있는지 여부를 결정 합니다.  
  
> [!NOTE]
>  기본 캐시 확장성 API에는 상태 형식에 명시적인 종속성에 대 한 요구 사항이 있습니다.  
  
 구현에서 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> 메서드를 자동으로 모니터의 상태가 이미 시간에 변경 되었는지 여부를 결정 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> 메서드를 호출 합니다. 경우는 <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> 속성은 `true`, 메서드를 자동으로 호출 합니다는 <xref:System.Runtime.Caching.OnChangedCallback> 통해 등록 된 이벤트 처리기는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드. 이 캐시 구현 캐시를 구현 하는 모니터를 가져오고, 최대 연결 시간으로 변경 모니터를 만들면 시간에서 기본 모니터링된 상태가 변경 되었을 수 있기 때문에 발생 합니다. 경우 상태가 이미 변경 후에 전달 되는 개체는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 방법은 `null`합니다.  
  
 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> 메서드를 한 번만 호출할 수 있으며 후속 호출에서 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">콜백 메서드가 이미 호출되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="overrides">
          <para>1.  호출 해야 합니다는 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 메서드 종속성 변경을 알림을 받을 수 있습니다. 종속성 변경 문제가 이미 발생 했다면는 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 인스턴스 될 때 호출할 <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> 라고 합니다. 그렇지 않은 경우는 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 인스턴스는 한 번 호출 됩니다 때는 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> 메서드는 시기는 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 메서드 중 먼저 발생 합니다. <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 캐시 구현에 의해 제공 된 인스턴스와 캐시 엔트리를 제거 되 고 캐시 호출자가 요청 되는 경우 필요한 변경 또는 원래 캐시 호출자로 다시 업데이트 이벤트를 발생 시킵니다.  
  
2.  개체 캐시 구현 종속성 변경 내용과 연결 된 캐시 항목을 제거 해야 합니다.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">변경 이벤트에 대한 데이터입니다. 이 값은 <see langword="null" />일 수 있습니다.</param>
        <summary>종속성이 변경될 때 이벤트를 발생시킬 수 있도록 파생 클래스에서 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드 종속성이 변경 될 때 호출 됩니다. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 변경 모니터 인스턴스가 삭제 되지만 콜백을 호출 하지 않으면 이미 있는 경우에 삭제 작업이 수행 되는 경우에 메서드가 호출 됩니다.  
  
 경우는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 전에 메서드가 호출 되는 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> 메서드가 호출 되 면를 호출 하 여 상태 데이터는 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 메서드는 캐시 구현에 의해 저장 됩니다. 또한 하는 콜백에 <xref:System.Runtime.Caching.OnChangedCallback> 즉시 메서드 때는 <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 클래스 인스턴스를 나타내는 값을 가져옵니다.</summary>
        <value>변경 모니터 인스턴스의 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> 속성 값 일반적으로 구성 됩니다 종속성 연결 이름의 문자열 데이터의 고유 하 게 식별자에서 모니터링 하는 데이터는 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스. 값은 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> 속성은 문자열입니다. 고유 ID를 할당 하는 문자열의 값이 사용 된 <xref:System.Runtime.Caching.ChangeMonitor> 인스턴스.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>속성을 재정의 하 여 속성의 문자열 값에 대 한 사용자 지정 구현을 고유 ID를 할당 하기 위해 정의할 수 있습니다.</para>
        </block>
        <block subset="none" type="overrides">
          <para>파생된 클래스에서 생성자에서 속성의 값을 설정 해야 합니다.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>