<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731517" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>클래스 형식, 인터페이스 형식, 배열 형식, 값 형식, 열거형 형식, 형식 매개 변수, 제네릭 형식 정의 및 개방형 생성 제네릭 형식이나 폐쇄형 생성 제네릭 형식에 대한 형식 선언을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` 루트는 <xref:System.Reflection> 기능 및 메타 데이터에 액세스 하는 기본 방법입니다. 멤버를 사용 하 여 <xref:System.Type> 뿐만 아니라 모듈 및 어셈블리 클래스가 배포 되는 형식 (예: 생성자, 메서드, 필드, 속성 및 클래스의 이벤트), 멤버에 대 한 형식 선언에 대 한 정보를 얻을 수 있습니다.  
  
 리플렉션을 사용 하는 액세스 수준에 관계 없이 형식 및 해당 멤버에 대 한 정보를 얻을 수 있는 코드에 필요한 권한은 없습니다. 리플렉션을 사용 하 여 public 멤버 또는 액세스 수준을 볼 수 있도록 설정 하는 동안 일반 컴파일을 다른 멤버에 액세스 하는 코드에 필요한 권한은 없습니다. 그러나 일반적으로 액세스할 수 없다고, private 또는 internal 메서드, 또는 형식의 필드를 보호 하는 멤버에 액세스 하기 위해 리플렉션을 사용 하 여 코드에 대 한 클래스를 상속 하지 않습니다, 코드 있어야 <xref:System.Security.Permissions.ReflectionPermission>합니다. 참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.  
  
 `Type` 여러 구현을 허용 하는 추상 기본 클래스가입니다. 파생된 클래스는 시스템 제공 항상 `RuntimeType`합니다. 리플렉션에서 런타임 라는 단어로 시작 하는 모든 클래스는 시스템 및 지원 비교 연산에 개체당 한 번만 생성 됩니다.  
  
> [!NOTE]
>  다중 스레드 시나리오에서는 잠그지 마십시오 <xref:System.Type> 개체에 대 한 액세스를 동기화 하기 위해 `static` 데이터입니다. 컨트롤이 없는 수 없는 다른 코드 클래스 형식이 개발자 잠글 수도 있습니다. 이 인해 교착 상태가 발생할 수 있습니다. 대신, 개인 잠금을 설정 하면 정적 데이터에 대 한 액세스를 동기화 `static` 개체입니다.  
  
> [!NOTE]
>  파생된 클래스 호출 코드의 기본 클래스의 보호 된 멤버에 액세스할 수 있습니다. 또한 호출 코드 어셈블리의 어셈블리 구성원에 게 액세스가 허용 됩니다. 일반적으로 초기 바인딩 코드에 액세스할 수 있는 경우 다음 사용자도 액세스할 수 런타임에 바인딩된 코드에서.  
  
> [!NOTE]
>  다른 인터페이스를 확장 하는 인터페이스에서 확장된 된 인터페이스에 정의 된 메서드를 상속 하지 않습니다.  
  
 섹션 내용  
  
 [유형 형식 개체 나타냅니까?](#WhatTypes)   
 [형식 개체를 검색합니다.](#Retrieve)   
 [같음에 대 한 형식 개체를 비교](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>유형 형식 개체 나타냅니까?  
 이 클래스는 스레드로부터 안전 합니다. 여러 스레드에서이 유형의 인스턴스에서 동시에 읽을 수 있습니다. 인스턴스는 <xref:System.Type> 클래스 다음 유형 중 하나를 나타낼 수 있습니다.  
  
-   클래스  
  
-   값 형식  
  
-   배열  
  
-   인터페이스  
  
-   열거형  
  
-   대리자  
  
-   생성 된 제네릭 형식과 제네릭 형식 정의  
  
-   인수를 입력 하 고 생성 된 제네릭 형식, 제네릭 형식 정 및 제네릭 메서드 정의의 매개 변수를 입력 합니다.  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>형식 개체를 검색합니다.  
 <xref:System.Type> 특정 형식과 관련 된 개체는 다음과 같은 방법으로 얻을 수 있습니다.  
  
-   인스턴스 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 메서드가 반환 되는 <xref:System.Type> 인스턴스 형식을 나타내는 개체입니다. 모든 관리 되는 형식에서 파생 되므로 <xref:System.Object>, <xref:System.Object.GetType%2A> 모든 종류의 인스턴스에서 메서드를 호출할 수 있습니다.  
  
     다음 예제에서는 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 개체 배열에 있는 각 개체의 런타임 형식을 확인할 수 있습니다.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   정적 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 메서드는 반환 된 <xref:System.Type> 정규화 된 이름을 사용 하 여 지정 된 형식을 나타내는 개체입니다.  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, 및 <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> 메서드 반환 `Type` 모듈에 정의 된 형식을 나타내는 개체입니다. 첫 번째 방법은 배열을 가져오는 데 사용할 수 있습니다 <xref:System.Type> 모듈에 정의 된 모든 공용 및 개인 형식에 대 한 개체입니다. (의 인스턴스를 가져올 수 `Module` 통해는 <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> 메서드를 통해 또는 <xref:System.Type.Module%2A?displayProperty=nameWithType> 속성입니다.)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType> 다양 한를 비롯 한 어셈블리에 정의 된 클래스를 검색 하는 메서드를 포함 하는 개체 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, 및 <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>합니다.  
  
-   <xref:System.Type.FindInterfaces%2A> 메서드는 형식에서 지 원하는 인터페이스 형식의 필터링 된 목록을 반환 합니다.  
  
-   <xref:System.Type.GetElementType%2A> 메서드가 반환 되는 `Type` 요소를 나타내는 개체입니다.  
  
-   <xref:System.Type.GetInterfaces%2A> 및 <xref:System.Type.GetInterface%2A> 메서드 반환 <xref:System.Type> 형식에서 지 원하는 인터페이스 형식을 나타내는 개체입니다.  
  
-   <xref:System.Type.GetTypeArray%2A> 메서드 배열을 반환 <xref:System.Type> 임의의 개체 집합에 지정 된 형식을 나타내는 개체입니다. 개체 형식의 배열을 사용 하 여 지정 된 <xref:System.Object>합니다.  
  
-   <xref:System.Type.GetTypeFromProgID%2A> 및 <xref:System.Type.GetTypeFromCLSID%2A> 메서드가 COM 상호 운용성을 위해 제공 됩니다. 반환 되는 <xref:System.Type> 로 지정 된 형식을 나타내는 개체는 `ProgID` 또는 `CLSID`합니다.  
  
-   <xref:System.Type.GetTypeFromHandle%2A> 메서드는 상호 운용성을 위해 제공 됩니다. 반환 된 `Type` 클래스 핸들로 지정 된 형식을 나타내는 개체입니다.  
  
-   C# `typeof` 연산자는 c + + `typeid` 연산자 및 Visual Basic `GetType` 연산자 가져올는 `Type` 유형에 대 한 개체입니다.  
  
-   <xref:System.Type.MakeGenericType%2A> 메서드가 반환 되는 <xref:System.Type> 은 개방형 생성된 형식이 생성 된 제네릭 형식을 나타내는 개체의 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`, 닫힌 생성 된 형식 그렇지 않은 경우 및 합니다. 닫혀 있는 경우에 제네릭 형식을 인스턴스화할 수 있습니다.  
  
-   <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, 및 <xref:System.Type.MakeByRefType%2A> 메서드 반환 <xref:System.Type> 를 나타내는 개체를 각각 지정된 된 형식, 지정된 된 형식 및 참조 매개 변수의 형식에 대 한 포인터의 배열 (`ref` C#에서는 `ByRef`Visual basic에서).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>같음에 대 한 형식 개체를 비교  
 A <xref:System.Type> 나타내는 되지 않은 고유 개체, 즉 두 개의 <xref:System.Type> 동일한 형식을 나타내는 경우에 개체 참조가 동일한 개체를 참조 합니다. 이 비교를 통해 <xref:System.Type> 참조 일치를 사용 하 여 개체입니다. 다음 예제에서는 비교는 <xref:System.Type> 동일한 형식 인지 확인 하는 정수 값의 수를 나타내는 개체입니다.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 다음 예제에서는의 대표 몇 가지 기능 <xref:System.Type>합니다. C# `typeof` 연산자 (`GetType` Visual Basic의 연산자 `typeid` Visual c + +에서 연산자) 얻는 데 사용 되는 <xref:System.Type> 개체를 나타내는 <xref:System.String>합니다. 이 <xref:System.Type> 개체는 <xref:System.Type.GetMethod%2A> 메서드 가져오는 데 사용 됩니다는 <xref:System.Reflection.MethodInfo> 나타내는 <xref:System.String.Substring%2A> 시작 위치와 길이 사용 하는 오버 로드 합니다.  
  
 오버 로드 시그니처를 식별 하려면 코드 예제는 두 개를 포함 하는 임시 배열을 만듭니다 <xref:System.Type> 나타내는 `int` (`Integer` Visual basic에서).  
  
> [!NOTE]
>  배열에 정확 하 게 두 개의 참조의 인스턴스를 포함 <xref:System.Type> 나타내는 `int` 은 현재 어플리케이션 도메인에 있습니다. 모든 형식에 대해은의 인스턴스 하나만 <xref:System.Type> 응용 프로그램 도메인입니다.  
  
 사용 하 여 코드 예제는 <xref:System.Reflection.MethodInfo> 를 호출 하는 <xref:System.String.Substring%2A> "Hello, World!", 문자열에서 메서드 결과 표시 합니다.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <block subset="none" type="overrides">
      <para>상속 하는 경우 <see langword="Type" />, 멤버를 재정의 해야 합니다.  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Type" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Type 개체의 생성 하는 동안이 생성자는 파생된 클래스에서 호출 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식이 선언되는 <see cref="T:System.Reflection.Assembly" />를 가져옵니다. 제네릭 형식의 경우 제네릭 형식이 정의되는 <see cref="T:System.Reflection.Assembly" />를 가져옵니다.</summary>
        <value>현재 형식이 포함된 어셈블리를 설명하는 <see cref="T:System.Reflection.Assembly" /> 인스턴스입니다. 제네릭 형식의 경우 인스턴스는 특정한 생성된 형식을 만들고 사용하는 어셈블리가 아니라 제네릭 형식 정의가 포함된 어셈블리를 설명합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 개체가 생성 된 제네릭 형식을 나타내면,이 속성은 제네릭 형식 정의 포함 하는 어셈블리를 반환 합니다. 예를 들어, 제네릭 형식 정의 포함 하는 MyGenerics.dll 이라는 어셈블리를 만들 `MyGenericStack<T>` (`MyGenericStack(Of T)` Visual Basic의 `generic<T> ref class MyGenericStack` c + +에서). 인스턴스를 만들 경우 `MyGenericStack<int>` (`MyGenericStack(Of Integer)` Visual basic에서) 다른 어셈블리에는 <xref:System.Type.Assembly%2A> 는 생성 된 형식에 대 한 속성을 반환는 <xref:System.Reflection.Assembly> MyGenerics.dll를 나타내는 개체입니다.  
  
 마찬가지로, 하는 경우 현재 <xref:System.Type> 개체는 할당 되지 않은 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식을 포함 하는 어셈블리 반환 `T`합니다.  
  
 경우는 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 속성을 사용할 수 없는.NET Core 또는 유니버설 Windows 플랫폼 같은 특정.NET 구현에 사용 된 <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> 속성 대신 합니다.      
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스와 연결 된 어셈블리 이름 및 형식의 정규화 된 이름을 표시 합니다.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Type" /> 개체가 로드된 어셈블리의 이름을 비롯하여 형식의 어셈블리 한정 이름을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" />이 로드된 어셈블리의 이름을 비롯한 <see cref="T:System.Type" />의 어셈블리 한정 이름입니다. 현재 인스턴스가 제네릭 형식 매개 변수를 나타낼 경우에는 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식의 어셈블리 정규화 된 이름을 형식 이름, 쉼표, 어셈블리의 표시 이름으로 다음 네임 스페이스를 포함 하 여 구성 됩니다. 어셈블리의 표시 이름을 사용 하 여 가져온는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성입니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0의에서 프로세서 아키텍처 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어 "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에 포함 되지 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
 공용 언어 런타임을 지 원하는 모든 컴파일러는 중첩 된 클래스의 단순한 이름을 내보내고 리플렉션에서 다음 규칙에 따라 쿼리 시 형식 표시 이름을 생성 합니다.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|대괄호 ()|유형 이름 다음 해당 형식의 배열을 나타냅니다.<br /><br /> 또는<br /><br /> 제네릭 형식에 대 한 제네릭 형식 인수 목록을 포함합니다.<br /><br /> 또는<br /><br /> 형식 인수 목록 내에서 정규화 된 어셈블리 형식을 포함합니다.|  
  
 예를 들어, 클래스에 대 한 정규화 된 어셈블리 이름을 다음과 같을 수 있습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 네임 스페이스 예를 들어 TopNamespace.Sub+Namespace 더하기 기호를 포함 된 경우 다음 더하기 기호 (+)는 뒤에 야 이스케이프 문자 (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션이이 문자열을 다음과 같이 내보내기 합니다.  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A "+ +"가 "\\+\\+", 및 "\\"가 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데 사용 된 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리의 정규화 된 형식 이름으로 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식으로 이름을 찾을 것은 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서 합니다. <xref:System.Type.GetType%2A> 어셈블리와 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름에는 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자가 포함 될 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공백은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 연결 합니다. 어셈블리 이름에 ',' 구분 기호 앞에 공백이 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 제네릭 인수 자체 어셈블리 이름으로 한정 됩니다. 에 대 한 정규화 된 어셈블리 형식 이름에 예를 들어 `MyGenericClass<int>` (`MyGenericClass(Of Integer)` Visual basic에서), `int` 에 대 한 정규화 된 어셈블리 형식 이름으로 확장 됩니다 <xref:System.Int32>합니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 개체를이 속성은 반환 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스와 연결 된 어셈블리 이름 및 형식의 정규화 된 이름을 표시 합니다.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 반환 된 문자열을 비교 하는 다음 예제는 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성입니다.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />과 관련된 특성을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Reflection.TypeAttributes" />이 값이 지정되어 있지 않은 제네릭 형식 매개 변수를 나타내지 않는 경우 <see cref="T:System.Type" />의 특성 집합을 나타내는 <see cref="T:System.Type" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 멤버는 <xref:System.Reflection.TypeAttributes> 열거형 값의 그룹을 나타내는 마스크 됩니다. 각 그룹에는 기본 값이 0 인 멤버 하나 포함 되어 있습니다. 내부 값 예를 들어는 <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> 의 멤버는 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 그룹은 0을 그대로 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 의 멤버는 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 그룹입니다. 이 때문에 이러한 값을 테스트 하기 전에 / / 마스크를 사용 해야 합니다. 예제에서는 그림을 제공합니다.  
  
> [!TIP]
>  같은 속성 대부분의 용도 대 한 <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, 및 <xref:System.Type.IsSpecialName%2A> 형식 특성 보다 사용 하기가 더 쉽습니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 생성된 된 제네릭 형식,이 속성은 제네릭 형식 정의의 특성을 반환 합니다. 에 대 한 반환 하는 특성은 예를 들어 `MyGenericClass<int>` (`MyGenericClass(Of Integer)` Visual basic에서) 특성 `MyGenericClass<T>` (`MyGenericClass(Of T)` Visual basic에서).  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수-즉, 하는 경우는 <xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `true` -는 <xref:System.Reflection.TypeAttributes> 이 속성에서 반환 된 값이 지정 되지 않았습니다.  
  
   
  
## Examples  
 다음 예제에서는 용도 <xref:System.Type.Attributes%2A> 속성입니다.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 직접 상속된 형식을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />이 직접 상속하는 <see cref="T:System.Type" />이거나, 현재 <see langword="null" />이 <see langword="Type" /> 클래스나 인터페이스를 나타내면 <see cref="T:System.Object" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 형식은 현재 형식을 직접 상속 되는 형식이입니다. <xref:System.Object> 하지 않은 기본 형식, 따라서 모니터링 유형만 `null` 의 기본 형식으로 반환 됩니다 <xref:System.Object>합니다.  
  
 인터페이스; 0 개 이상의 기본 인터페이스에서 상속 따라서이 속성은 반환 `null` 경우는 `Type` 개체는 인터페이스를 나타냅니다. 기본 인터페이스는 하 게 결정할 수 <xref:System.Type.GetInterfaces%2A> 또는 <xref:System.Type.FindInterfaces%2A>합니다.  
  
 하는 경우 현재 <xref:System.Type> 생성 된 제네릭 형식을 나타내며, 제네릭 인수를 반영 하는 기본 형식입니다. 예를 들어 다음 선언을 살펴보세요.  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 생성 된 형식에 대 한 `C<int>` (`C(Of Integer)` Visual basic에서)에서는 <xref:System.Type.BaseType%2A> 속성에서 반환 `B<int>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 정의의 형식 매개 변수 <xref:System.Type.BaseType%2A> 형식 매개 변수에서 상속 해야 하는 클래스 즉, 클래스 제약 조건을 반환 합니다. 클래스 제약 조건이 없는 경우 <xref:System.Type.BaseType%2A> 반환 <xref:System.Object?displayProperty=nameWithType>합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Type.BaseType%2A> 속성입니다.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 다음 예제에서는 재귀를 사용 하 여 어셈블리에 각 클래스의 완전 한 상속 계층 구조를 나열 합니다. 이 예제에서는 클래스를 정의 `C` 라는 클래스에서 파생 된 `B`이며 차례로 라는 클래스에서 파생 `A`합니다.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" /> 개체에 특정 형식으로 바뀌지 않은 형식 매개 변수가 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" /> 개체 자체가 제네릭 형식 매개 변수이거나 특정 형식이 적용되지 않은 형식 매개 변수이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식의 인스턴스를 만들도록 없는 제네릭 형식 정의 또는 형식 자체의 모든 바깥쪽 제네릭 형식 또는 모든 요소는 형식의 형식 인수에서 개방형 생성된 형식 이어야 합니다. 또 다른 방법은 말하면 재귀적으로 검사 하는 경우, 형식에 제네릭 형식 매개 변수가 없는 있어야 합니다.  
  
 형식 하는 임의의 복잡 한 있으므로 이러한 결정은 어렵습니다. 오류를 줄일 수는 <xref:System.Type.ContainsGenericParameters%2A> 속성을 인스턴스화할 수 닫힌된 생성 된 형식을 구분 하기 위해 표준 방법을 제공 및 개방형 생성 형식 수 없습니다. 경우는 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`, 형식을 인스턴스화할 수 없습니다.  
  
 <xref:System.Type.ContainsGenericParameters%2A> 속성 형식 매개 변수를 재귀적으로 검색 합니다. 예를 들어 반환 `true` 형식 요소가 배열인 배열에 대 한 `A<T>` (`A(Of T)` Visual basic에서) 때 배열의 제네릭 자체 하지 않은 경우에 합니다. 이와 반대로의 동작에서 <xref:System.Type.IsGenericType%2A> 반환 하는 속성 `false` 배열에 대 한 합니다.  
  
 일련의 예제에서는 클래스와 값을 보여 주는 테이블에 대 한는 <xref:System.Type.ContainsGenericParameters%2A> 속성 참조 <xref:System.Type.IsGenericType%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 형식 매개 변수가 있는 제네릭 클래스를 정의 하 고 첫 번째 클래스에서 파생 되는 두 번째 제네릭 클래스를 정의 합니다. 파생된 클래스의 기본 클래스에 두 개의 형식 인수가: 첫 번째는 <xref:System.Int32> 두 번째는 파생 된 형식의 형식 매개 변수입니다. 보고 된 위치를 포함 하 여이 예제에서는 이러한 제네릭 클래스에 대 한 정보를 표시는 <xref:System.Type.GenericParameterPosition%2A> 속성입니다.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Reflection.MethodBase" />가 제네릭 메서드의 형식 매개 변수를 나타내는 경우 선언 메서드를 나타내는 <see cref="T:System.Type" />를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />이 제네릭 메서드의 형식 매개 변수를 나타내면 선언하는 메서드를 나타내는 <see cref="T:System.Reflection.MethodBase" />이고, 그렇지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 선언 방법은 제네릭 메서드 정의 합니다. 즉, 경우 <xref:System.Type.DeclaringMethod%2A> 반환 하지 않는 `null`, 다음 `DeclaringMethod.IsGenericMethodDefinition` 반환 `true`합니다.  
  
 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 제네릭 형식 정의 나 제네릭 메서드 정의 원래에 제네릭 형식 매개 변수에 정의 된 속성을 식별 합니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성 반환 하지 않습니다는 <xref:System.Reflection.MethodInfo>, 해당 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체 해당 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성에서 반환 `null`, 하면 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환는 <xref:System.Type> 현재 제네릭 형식 정의 나타내는 개체 <xref:System.Type> 개체 제네릭 형식의 형식 매개 변수를 나타냅니다. 정의 합니다.  
  
-   가져오기는 <xref:System.Type.DeclaringMethod%2A> 형식 속성에 해당 <xref:System.Type.IsGenericParameter%2A> 속성은 `false` throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Reflection.MethodBase> 에서 반환 하는 <xref:System.Type.DeclaringMethod%2A> 속성이 <xref:System.Reflection.MethodInfo> 제네릭 메서드의 또는 <xref:System.Reflection.ConstructorInfo> 제네릭 생성자의 경우.  
  
> [!NOTE]
>  제네릭 생성자는.NET Framework 버전 2.0에서에서 지원 되지 않습니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 메서드가 형식 인수는 메서드를 할당 하 고 생성된 된 제네릭 메서드를 호출 하는 클래스를 정의 합니다. 또한 생성된 된 메서드 및 제네릭 메서드 정의 대 한 정보를 표시 합니다. 제네릭 메서드 정의의 형식 매개 변수에 대 한 정보를 표시 하는 경우는 `DisplayGenericMethodInfo` 메서드, 예제 코드의 값을 표시는 <xref:System.Type.DeclaringMethod%2A> 메서드의 제네릭 형식 매개 변수에 대 한 속성입니다.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 중첩 형식 또는 제네릭 형식 매개 변수를 선언하는 형식을 가져옵니다.</summary>
        <value>현재 형식이 중첩 형식이면 바깥쪽 형식을 나타내고 현재 형식이 제네릭 형식의 형식 매개 변수이면 제네릭 형식 정의를 나타내며 현재 형식이 제네릭 메서드의 형식 매개 변수이면 제네릭 메서드를 선언하는 형식을 나타내는 <see cref="T:System.Type" /> 개체이고, 그렇지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 개체가 나타내는 제네릭 형식의 형식 매개 변수, 제네릭 형식 정의이 속성을 반환 합니다.  
  
 하는 경우 현재 <xref:System.Type> 개체 제네릭 메서드의 형식 매개 변수를 나타내는 경우이 속성에는 제네릭 메서드 정의 포함 하는 형식을 반환 합니다. 형식이 제네릭 경우 제네릭 형식 정의가 반환 됩니다. 다음 코드의 제네릭 형식 정의 반환 하는, 즉는 <xref:System.Collections.Generic.List%601> 들어 있는 제네릭 클래스는 <xref:System.Collections.Generic.List%601.ConvertAll%2A> 제네릭 메서드.  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 속성 제네릭 형식 매개 변수는 제네릭 형식 정의 나 제네릭 메서드 정의 식별 합니다. 원래 정의 된:  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성 반환 하지 않습니다는 <xref:System.Reflection.MethodInfo>, 해당 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체 해당 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성에서 반환 `null`, 하면 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환는 <xref:System.Type> 현재 제네릭 형식 정의 나타내는 개체 <xref:System.Type> 개체 제네릭 형식의 형식 매개 변수를 나타냅니다. 정의 합니다.  
  
-   가져오기는 <xref:System.Type.DeclaringType%2A> 형식 속성에 해당 <xref:System.Type.IsGenericParameter%2A> 속성은 `false` throw는 <xref:System.InvalidOperationException>합니다.  
  
   
  
## Examples  
 이 예제에서는 파생된 클래스에서 메서드의 선언 형식이 표시 됩니다.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />에서 호출하는 적절한 멤버를 선택하기 위해 내부 규칙을 구현하는 기본 바인더에 대한 참조를 가져옵니다.</summary>
        <value>시스템에서 사용되는 기본 바인더에 대한 참조입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공용 언어 런타임와 함께 제공 되는 기본 바인더는 가장 특수화 된 환경 제외한 모든 메시지에 적용 됩니다. 파생 된 형식 제공 되는 기본 바인더의 다른 다음과 규칙을 정의 하는 바인더 해야 할 경우는 <xref:System.Reflection.Binder> 클래스를 사용 하 여 해당 형식의 인스턴스를 전달 된 `binder` 중 하나의 매개 변수는 <xref:System.Type.InvokeMember%2A> 오버 로드 합니다.  
  
 리플렉션 공용 형식 시스템의 액세스 가능성 규칙을 모델링합니다. 예를 들어 호출자에 게 동일한 어셈블리에 포함 된 경우 호출자에 게 필요는 없습니다 특별 한 권한이 내부 멤버에 대 한. 그렇지 않은 경우 호출자가 <xref:System.Security.Permissions.ReflectionPermission>합니다. 이것은 보호 되는 멤버 조회 일치, private, 및 등입니다.  
  
 일반적으로 <xref:System.Reflection.Binder.ChangeType%2A> 확대 데이터 손실이 없는 변환을 수행 해야 합니다. 확대 변환의 예로는 32 비트 부호 있는 정수는 64 비트 부호 있는 정수 값으로 하는 값을 변환 합니다. 이 데이터가 손실 될 수 있는 축소 변환에서 구분 됩니다. 축소 변환의 예로 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 하는 것입니다.  
  
 다음 표에서 기본 바인더에서 지 원하는 변환 합니다.  
  
|원본 유형|대상 유형|  
|-----------------|-----------------|  
|모든 형식|해당 기본 형식입니다.|  
|모든 형식|구현 하는 인터페이스입니다.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|비참조 형식|참조로 전달 합니다.|  
  
   
  
## Examples  
 다음 예제에서 기본 바인더를 가져옵니다는 `DefaultBinder` 속성을 전달 하 여 MyClass의 멤버를 호출 하 고는 `DefaultBinder` 값에 대 한 매개 변수로 <xref:System.Type.InvokeMember%2A>합니다.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />의 네임스페이스에 있는 이름을 구분합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> 형식의 빈 배열을 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제는 `EmptyTypes` 중 하나에 사용 된 필드는 `GetConstructor` 메서드 매개 변수가 없는 생성자를 가져오기.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 내부 시스템 형식이 지정된 <see cref="T:System.Object" /> 또는 <see cref="T:System.Type" />의 내부 시스템 형식과 동일한지 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">현재 <see cref="T:System.Type" />의 내부 시스템 형식과 비교할 내부 시스템 형식이 있는 개체입니다. 성공적인 비교를 위해 <c>o</c>는 캐스팅되거나 <see cref="T:System.Type" /> 형식의 개체로 변환될 수 있어야 합니다.</param>
        <summary>현재 <see cref="T:System.Type" /> 개체의 내부 시스템 형식이 지정된 <see cref="T:System.Object" />의 내부 시스템 형식과 동일한지 확인합니다.</summary>
        <returns>
          <paramref name="o" />의 내부 시스템 형식이 현재 <see cref="T:System.Type" />의 내부 시스템 형식과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 다음 경우에도 이 메서드는 <see langword="false" />를 반환합니다.  
  
-   <paramref name="o" />가 <see langword="null" />인 경우  
  
-   <paramref name="o" />는 캐스팅되거나 <see cref="T:System.Type" /> 개체로 변환될 수 없습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Object.Equals%2A?displayProperty=nameWithType>를 재정의합니다. 캐스팅 `o` 유형의 개체로 <xref:System.Type> 호출는 <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.Equals%28System.Object%29> 다양 한 비교할 <xref:System.Type> 개체 다양 한 인스턴스 <xref:System.Object> 인스턴스.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 이 예제에 대 한 주목할 만한 특히 두 가지 사항은 다음과 같습니다.  
  
-   비교는 <xref:System.Type> 까지의 정수를 나타내는 개체는 <xref:System.Reflection.TypeInfo> 반환 하는 정수를 나타내는 개체 `true` 때문에 <xref:System.Reflection.TypeInfo> 에서 파생 됩니다 <xref:System.Type>합니다.  
  
-   비교는 <xref:System.Type> 을 나타내는 개체는 <xref:System.Collections.Generic.IList%601> 개체 (개방형 제네릭 형식)는 `List(Of String)` 개체 (폐쇄형된 제네릭 형식)를 반환 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">현재 <see cref="T:System.Type" />의 내부 시스템 형식과 비교할 내부 시스템 형식이 있는 개체입니다.</param>
        <summary>현재 <see cref="T:System.Type" />의 내부 시스템 형식이 지정된 <see cref="T:System.Type" />의 내부 시스템 형식과 동일한지 확인합니다.</summary>
        <returns>
          <paramref name="o" />의 내부 시스템 형식이 현재 <see cref="T:System.Type" />의 내부 시스템 형식과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 `Equals` 두 형식을 비교 하려면.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>특성에 사용되는 멤버 필터를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 되는 대리자에 대 한 참조를 보유 하는이 필드는 <xref:System.Type.FindMembers%2A> 메서드. 이 대리자에 의해 캡슐화 된 메서드는 두 개의 매개 변수: 첫 번째는는 <xref:System.Reflection.MemberInfo> 개체가 고 두 번째가는 `Object`합니다. 메서드를 확인 여부는 `MemberInfo` 로 지정 된 기준과 일치 하는 개체는 `Object`합니다. `Object` 클래스에 필드 중 하나의 값을 할당할 수 있습니다 <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, 또는 <xref:System.Reflection.MethodImplAttributes>합니다.  
  
 예를 들어는 `Object` 에서 필드의 값을 할당 `FieldAttributes` 공용입니다. 이 경우,는 `FilterAttribute` 대리자를 호출 반환 `true` 메서드가 표현 하는 경우에는 `MemberInfo` 개체 메타 데이터에 공용 필드가 특성으로 데코레이팅되 어 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 가져옵니다는 `FilterAttribute` 대리자를 매개 변수로 전달는 <xref:System.Type.FindMembers%2A> 메서드를 지정 된 멤버와 해당 특성을 표시 합니다.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이름에 사용되는 멤버 필터(대/소문자 구분)를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 되는 대리자에 대 한 참조를 보유 하는이 필드는 <xref:System.Type.FindMembers%2A> 메서드. 이 대리자에 의해 캡슐화 된 메서드는 두 개의 매개 변수: 첫 번째는는 <xref:System.Reflection.MemberInfo> 개체가 고 두 번째가는 `Object`합니다. 메서드를 확인 여부는 `MemberInfo` 로 지정 된 기준과 일치 하는 개체는 `Object`합니다. `Object` 후행 포함 될 수 있는 문자열 값이 할당은 "*" 와일드 카드 문자입니다. 유일한 와일드 카드 최종 문자열 일치가 지원 됩니다.  
  
 예를 들어는 `Object` "바이트 *" 값이 할당 될 수 있습니다. 이 경우,는 `FilterName` 대리자를 호출 반환 `true` 메서드가 표현 하는 경우에는 `MemberInfo` 개체에 이름이 "바이트"로 시작 하 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 연결 된 사용자 정의 메서드를 가져옵니다 `Application` 유형입니다.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이름에 사용되는 멤버 필터(대/소문자를 구분하지 않음)를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 되는 대리자에 대 한 참조를 보유 하는이 필드는 <xref:System.Type.FindMembers%2A> 메서드. 이 대리자에 의해 캡슐화 된 메서드는 두 개의 매개 변수: 첫 번째는는 <xref:System.Reflection.MemberInfo> 개체가 고 두 번째가는 `Object`합니다. 메서드를 확인 여부는 `MemberInfo` 로 지정 된 기준과 일치 하는 개체는 `Object`합니다. `Object` 후행 포함 될 수 있는 문자열 값이 할당은 "*" 와일드 카드 문자입니다. 유일한 와일드 카드 최종 문자열 일치가 지원 됩니다.  
  
 예를 들어는 `Object` "바이트 *" 값이 할당 될 수 있습니다. 이 경우 때는 `FilterName` 대리자 호출 되 면 true를 반환 합니다만가 나타내는 메서드가 `MemberInfo` 개체 이름이 지정 된 대/소문자 무시 "바이트"로 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 가져옵니다는 `MemberFilter` 대리자를 매개 변수로 전달는 <xref:System.Type.FindMembers%2A> 메서드, 메서드 및 해당 특성의 표시는 `String` 대/소문자를 무시 하 고 문자 "c"로 시작 하는 클래스입니다.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">인터페이스를 <c>filterCriteria</c>에 대해 비교하는 대리자입니다.</param>
        <param name="filterCriteria">반환되는 배열에 인터페이스가 포함되어야 하는지를 결정하는 검색 조건입니다.</param>
        <summary>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 인터페이스의 필터링된 목록을 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속된 인터페이스의 필터링된 목록을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 해당 필터와 일치하는 인터페이스 중에서 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속된 인터페이스가 없는 경우에는 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> 및 <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> 대리자 제공한는 <xref:System.Reflection.Module?displayProperty=nameWithType> 클래스 사용할 수도 있습니다를의 법률는 <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> 위임 합니다.  
  
 이 클래스에서 구현 된 인터페이스의 모든 값은이 클래스 자체 또는 기본 클래스에서 선언 하는지 여부를 검색 하는 동안 간주 됩니다.  
  
 이 메서드는 반환 인터페이스가 구현 하는 각 인터페이스에서 일치 하는 모든 뿐만 아니라 각 클래스를 구현 하는 일치 하는 인터페이스의 각 기본 클래스 계층 구조, 검색 (즉, 일치 하는 인터페이스의 전이적 closure 값이 반환). 중복 된 인터페이스가 없는 반환 됩니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <xref:System.Type.FindInterfaces%2A> 형식 매개 변수에 제약 조건에 선언 된 모든 인터페이스를 검색 하 고 모든 인터페이스는 인터페이스를 통해 상속 제약 조건에서 선언 되었습니다. 하는 경우 현재 <xref:System.Type> 제네릭 형식의 형식 인수를 나타내는 <xref:System.Type.FindInterfaces%2A> 제약 조건과 일치 하는지 여부는 형식에서 구현 된 모든 인터페이스를 검색 합니다.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> 제네릭 하지 않은 형식에도 제네릭 인터페이스를 반환할 수 있습니다. 예를 들어 제네릭이 아닌 형식 구현할 수 있습니다 `IEnumerable<int>` (`IEnumerable(Of Integer)` Visual basic에서).  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 인터페이스 구현 또는 지정 된 형식에서 상속 및 인터페이스 이름을 표시 한 다음를 찾습니다.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">정적 이니셜라이저가 호출되고 예외를 발생합니다.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">검색할 멤버 형식을 나타내는 개체입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="filter">비교를 수행하여 현재 검사 중인 멤버가 <c>filterCriteria</c>와 일치하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />를 반환하는 대리자입니다. 이 클래스에서 제공하는 <see langword="FilterAttribute" />, <see langword="FilterName" /> 및 <see langword="FilterNameIgnoreCase" /> 대리자를 사용할 수 있습니다. 첫 번째 대리자는 <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> 및 <see langword="MethodImplAttributes" />의 필드를 검색 조건으로 사용하고 다른 두 대리자는 <see langword="String" /> 개체를 검색 조건으로 사용합니다.</param>
        <param name="filterCriteria">
          <see langword="MemberInfo" /> 개체의 배열에 멤버가 반환되는지를 결정하는 검색 조건입니다.  
  
 <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> 및 <see langword="MethodImplAttributes" />의 필드는 이 클래스에서 제공하는 <see langword="FilterAttribute" /> 대리자와 함께 사용할 수 있습니다.</param>
        <summary>지정된 멤버 형식의 <see cref="T:System.Reflection.MemberInfo" /> 개체에 대한 필터링된 배열을 반환합니다.</summary>
        <returns>지정된 멤버 형식의 <see cref="T:System.Reflection.MemberInfo" /> 개체에 대한 필터링된 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.MemberInfo" />에 필터 조건과 일치하는 <see cref="T:System.Type" /> 형식의 멤버가 없으면 <paramref name="memberType" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 구성원 속성, 메서드, 필드, 이벤트 및 등을 포함합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 멤버를 정의 하는 검색에 포함할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Instance` 검색에 인스턴스 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.Static` 검색에 정적 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 멤버 (즉, 전용, 내부 및 보호 된 멤버)를 포함 하도록 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하는 <xref:System.Type>, 상속 된 멤버가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 유효한 값에 대 한 <xref:System.Type.MemberType%2A> 에 정의 된 <xref:System.Reflection.MemberInfo>합니다. 이러한 멤버가 없으면 빈 배열이 반환 됩니다.  
  
 지정 해야이 메서드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 형식 매개 변수를 나타내는 <xref:System.Type.FindMembers%2A> 클래스 제약 조건 및 인터페이스 제약 조건 형식 매개 변수의 선언 된 모든 멤버를 처리 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 검색 조건과 일치 하는 클래스에서 모든 멤버를 찾아서 다음 일치 하는 멤버를 표시 합니다.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 네임스페이스는 포함하지만 어셈블리는 포함하지 않는 형식의 정규화된 이름을 가져옵니다.</summary>
        <value>해당 네임스페이스는 포함하지만 어셈블리는 포함하지 않는 형식의 정규화된 이름이거나 현재 인스턴스가 제네릭 형식 매개 변수, 배열 형식, 포인터 형식, 형식 매개 변수에 기초한 <see langword="null" /> 형식 또는 제네릭 형식 정의가 아니지만 확인되지 않은 형식 매개 변수가 들어 있는 제네릭 형식인 경우에는 <see langword="byref" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규화 된 이름 예를 들어는 <xref:System.String> 형식이 `System.String`합니다. 이와 반대로 반환 하는 어셈블리의 정규화 된 이름은 <xref:System.Type.AssemblyQualifiedName%2A> 전체 이름과 함께 전체 어셈블리 이름으로 구성 되는 속성입니다.  
  
 문자열에 형식 인수에서 반환 된 현재 형식의 폐쇄형된 제네릭 형식을 나타내면는 <xref:System.Type.FullName%2A> 속성을 제네릭 형식 자체의 문자열 표현을 해당 전체에서 정규화 되지 않은 경우에 전체 어셈블리 이름으로 정규화 됩니다 어셈블리 이름입니다. 다음 예제에서는 하나에 대 한 제네릭 형식 정의 나타내는 형식의 폐쇄형된 제네릭 형식을 나타내는 FullName 속성의 차이점을 보여 줍니다.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 이 속성은 반환 `null` 경우:  
  
-   현재 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다.  
  
     다음 예제에서는 검색의 형식 매개 변수는 <xref:System.Nullable%601> 유형 및 표시 하는 시도 해당 <xref:System.Type.FullName%2A> 속성입니다.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   현재 <xref:System.Type> 개체 포인터 형식, 배열 형식, 나타냅니다 또는 `byref` 제네릭 형식 매개 변수를 기반으로 하는 형식입니다.  
  
     다음 예제에서는 제네릭 형식 정의 `Generictype1<T>`, 세 가지 방법으로: `Display(T[])`, T; 형식의 배열을 전달 되는 `HandleT(T)`, T 개체; 전달 되 고 `ChangeValue(ref T)`, T 개체 참조로 전달 되는 합니다. C# 및 Visual Basic 허용 하지 않으므로 T에 대 한 포인터로 정의할 수는 `HandleT` 메서드를 호출을 해야는 <xref:System.Type.MakePointerType%2A> 에서 메서드는 <xref:System.Type> 를 제네릭 형식에 대 한 포인터를 만드는 메서드의 매개 변수 형식을 나타내는 개체입니다. 이 예제에서 출력 하는 세 가지 경우 모두 보여 줍니다는 <xref:System.Type.FullName%2A> 속성은 `null`합니다.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   현재 형식이 제네릭 형식 매개 변수를 특정 형식으로 바뀌지 않은 포함 (즉,는 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`), 하지만 형식이 제네릭 형식 정의 되지 않습니다 (즉,는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성 반환 `false`  
  
     다음 예에서 `Derived<T>` 에서 상속 `Base<T>`합니다. <xref:System.Type.BaseType%2A> 속성 가져옵니다는 <xref:System.Type> 의 기본 형식을 나타내는 개체 `Derived<T>`, 및 해당 <xref:System.Type.FullName%2A> 속성에서 반환 `null`합니다.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     가져오려는 <xref:System.Type.FullName%2A> 없는 `null`를 사용할 수 있습니다는 <xref:System.Type.GetGenericTypeDefinition%2A> 예제와 같이 제네릭 형식 정의 가져올 메서드를 합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 형식의 전체 이름을 표시합니다.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 반환 된 문자열을 비교 하는 다음 예제는 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성입니다.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 제네릭 형식 매개 변수의 공 분산과 특수 제약 조건을 설명하는 <see cref="T:System.Reflection.GenericParameterAttributes" /> 플래그의 조합을 가져옵니다.</summary>
        <value>현재 제네릭 형식 매개 변수의 공 분산 및 특수 제약 조건을 설명하는 <see cref="T:System.Reflection.GenericParameterAttributes" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값 현재 제네릭 형식 매개 변수는 공변, 여부를 설명 하는 플래그 및 특수 제약 조건을 설명 하는 플래그를 포함 합니다. 사용 하 여는 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> 값을 공 분산 플래그를 선택 하 고 사용 된 <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> 제약 조건 플래그를 선택 하는 값입니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 형식 정의 `Test` 제약 조건이 서로 다른 두 개의 형식 매개 변수를 사용 합니다. 제약 조건을 사용 하 여 검사 프로그램을 실행 하는 경우는 <xref:System.Type.GenericParameterAttributes%2A> 속성 및 <xref:System.Type.GetGenericParameterConstraints%2A> 메서드.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Type" /> 개체가 제네릭 형식 매개 변수가 아닌 경우. 즉, <see cref="P:System.Type.IsGenericParameter" /> 속성이 <see langword="false" />를 반환합니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> 개체가 제네릭 형식이나 제네릭 메서드의 형식 매개 변수를 나타내는 경우, 해당 매개 변수가 선언된 제네릭 형식 또는 메서드의 형식 매개 변수 목록에서 해당 형식 매개 변수가 있는 위치를 가져옵니다.</summary>
        <value>형식 매개 변수가 정의된 제네릭 형식 또는 메서드의 형식 매개 변수 목록에서 해당 형식 매개 변수가 있는 위치입니다. 위치 번호는 0부터 시작합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> 속성의 위치를 반환 형식 매개 변수는 제네릭 형식 정의 나 제네릭 메서드 정의의 매개 변수 목록에서 형식 매개 변수가 원래 정의 된 합니다. <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 제네릭 형식 또는 메서드 정의 식별 하는 속성:  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성 반환 하지 않습니다는 <xref:System.Reflection.MethodInfo>, 해당 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체 해당 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성에서 반환 `null`, 하면 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환는 <xref:System.Type> 현재 제네릭 형식 정의 나타내는 개체 <xref:System.Type> 개체 제네릭 형식의 형식 매개 변수를 나타냅니다. 정의 합니다.  
  
 값에 대 한 올바른 컨텍스트를 제공 하는 <xref:System.Type.GenericParameterPosition%2A> 속성을 해야 하는 제네릭 형식 또는 형식 매개 변수가 속한 메서드를 식별 합니다. 예를 들어 제네릭 메서드의 반환 값 `GetSomething` 다음 코드에서:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 반환한 형식이 `GetSomething` 클래스에 제공 된 형식 인수에 따라 달라 집니다 `A` 및 `GetSomething` 자체입니다. 가져올 수는 <xref:System.Reflection.MethodInfo> 에 대 한 `GetSomething`는 반환 형식을 가져올 수 있습니다. 반환 형식의 형식 매개 변수를 검사 하는 경우 <xref:System.Type.GenericParameterPosition%2A> 둘 다에 대해 0을 반환 합니다. 위치 `V` 은 0 이므로 `V` 클래스에 대 한 형식 매개 변수 목록에서 첫 번째 형식 매개 변수인 `A`합니다. 위치 `X` 은 0 이므로 `X` 에 대 한 형식 매개 변수 목록에서 첫 번째 형식 매개 변수인 `GetSomething`합니다.  
  
> [!NOTE]
>  호출 된 <xref:System.Type.GenericParameterPosition%2A> 속성 하면 예외가 발생 하는 경우 현재 <xref:System.Type> 형식 매개 변수를 나타내지 않습니다. 개방형 생성 형식의 형식 인수를 검사할 때 사용 된 <xref:System.Type.IsGenericParameter%2A> 형식 매개 변수는 변수와 구별 하는 속성입니다. <xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `true` 은 형식 매개 변수를 사용할 수 있습니다는 <xref:System.Type.GenericParameterPosition%2A> 위치로 사용 하는 메서드는 <xref:System.Type.DeclaringMethod%2A> 및 <xref:System.Type.DeclaringType%2A> 제네릭 메서드를 결정 하거나 형식 정의 정의 하는 속성 .  
  
   
  
## Examples  
 다음 예제에서는 두 개의 형식 매개 변수가 있는 제네릭 클래스를 정의 하 고 첫 번째 클래스에서 파생 되는 두 번째 제네릭 클래스를 정의 합니다. 파생된 클래스의 기본 클래스에 두 개의 형식 인수가: 첫 번째는 <xref:System.Int32>, 두 번째는 파생 된 형식의 형식 매개 변수입니다. 보고 된 위치를 포함 하 여이 예제에서는 이러한 제네릭 클래스에 대 한 정보를 표시는 <xref:System.Type.GenericParameterPosition%2A> 속성입니다.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식이 형식 매개 변수를 나타내지 않습니다. 즉, <see cref="P:System.Type.IsGenericParameter" />이 <see langword="false" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식에 대한 제네릭 형식 인수의 배열을 가져옵니다.</summary>
        <value>이 형식에 대한 제네릭 형식 인수 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 제네릭 형식 인수를; 가져옵니다. 즉, 현재 형식이 제네릭 형식 매개 변수에 대해 지정 된 형식입니다. 현재 형식이 제네릭 형식 정의 인 경우이 속성에는 빈 배열을 반환 합니다.  
  
> [!NOTE]
>  제네릭 형식이 다른 제네릭 형식 또는 제네릭 메서드에 사용 된, 제네릭 형식 인수 중 일부의 바깥쪽 메서드 또는 형식을 제네릭 형식 매개 변수를 수 있습니다.  
  
 제네릭 형식 정의 나타내는 형식의 제네릭 형식 매개 변수를 가져오려면는 <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> 속성입니다. 가져오려는 <xref:System.Reflection.TypeInfo> 현재에 대 한 개체 <xref:System.Type> 개체를 가져오려면는 <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> 확장 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>배열의 차원 수를 가져옵니다.</summary>
        <returns>현재 형식의 차수를 포함하는 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 배열의 차원 수를 표시합니다.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드의 기능은 기본 클래스에서 지원되지 않으므로 대신에 파생된 클래스에서 구현해야 합니다.</exception>
        <exception cref="T:System.ArgumentException">현재 형식은 배열이 아닙니다.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 <see cref="P:System.Type.Attributes" /> 속성을 구현하고 <see cref="T:System.Type" />과 연관된 특성을 나타내는 비트 마스크를 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Reflection.TypeAttributes" />의 특성 집합을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 생성자를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">원하는 생성자에 대한 매개 변수의 수, 순서 및 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 개체의 빈 배열입니다. 이러한 빈 배열은 <see langword="static" /> 필드 <see cref="F:System.Type.EmptyTypes" />에서 제공됩니다.</param>
        <summary>지정된 배열의 형식과 일치하는 매개 변수를 가진 public 인스턴스 생성자를 검색합니다.</summary>
        <returns>매개 변수 형식 배열의 형식과 일치하는 매개 변수를 가진 public 인스턴스 생성자를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드 public 인스턴스 생성자 찾은 클래스 이니셜라이저가 (.cctor)를 가져오는 데 사용할 수 없습니다. 클래스 이니셜라이저를 얻기 위해 사용 하는 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags>, 지정 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 이 메서드가 반환 하는 경우 요청 된 생성자가 public이 아닌, `null`합니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다. 하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는의 형식을 얻고 `MyClass`, 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 개체를 생성자 서명을 표시 합니다.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="types">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).  
  
 또는  
  
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">매개 변수 형식 배열의 해당 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체의 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 생성자를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 있으면 이 개체를 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확 하 게 일치가 없는 경우는 `binder` 에 지정 된 매개 변수 형식 강제 변환 하려고 합니다는 `types` 일치 하는 항목을 선택 하려면 배열입니다. 경우는 `binder` 일치 하는 항목을 선택한 후 수 없으면 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 하도록 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 지정 해야이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다. 하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
   
  
## Examples  
 다음 프로그램의 형식을 얻고 `MyClass1` 클래스를 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 지정 된 바인딩 플래그와 일치 하는 개체를 생성자의 서명을 표시 합니다.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 바인딩 제약 조건 및 호출 규칙을 사용하여, 지정된 인수 형식 및 한정자와 매개 변수가 일치하는 생성자를 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 생성자를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 정확 하 게 일치가 없는 경우는 `binder` 에 지정 된 매개 변수 형식 강제 변환 하려고 합니다는 `types` 일치 하는 항목을 선택 하려면 배열입니다. 경우는 `binder` 일치 하는 항목을 선택한 후 수 없으면 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 하도록 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 지정 해야이 메서드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다. 하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는의 형식을 얻고 `MyClass1`, 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 생성자 서명을 표시 하 고 지정 된 바인딩 플래그와 일치 하는 개체입니다.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 생성자를 지정된 바인딩 제약 조건 및 호출 규칙으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 있으면 이 개체를 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 정확 하 게 일치가 없는 경우는 `binder` 에 지정 된 매개 변수 형식 강제 변환 하려고 합니다는 `types` 일치 하는 항목을 선택 하려면 배열입니다. 경우는 `binder` 일치 하는 항목을 선택한 후 수 없으면 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 하도록 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드는 <xref:System.Type.GetConstructor%2A>를 구현합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />인 경우</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 생성자를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 대해 정의된 모든 public 생성자를 반환합니다.</summary>
        <returns>형식 이니셜라이저를 제외하고(정적 생성자) 현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의된 모든 public 인스턴스 생성자를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. public 인스턴스 생성자가 현재 <see cref="T:System.Type" />에 대해 정의되어 있지 않거나 현재 <see cref="T:System.Type" />이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 경우 <see cref="T:System.Reflection.ConstructorInfo" /> 형식의 빈 배열이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> 메서드 선언 순서 대로 나열 등 특정 한 순서로 생성자를 반환 하지 않습니다. 코드 영향을 받지 않아야 생성자 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 이 메서드 오버 로드는 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 메서드 오버 로드와 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저가 (.cctor)를 검색 하지 않습니다. 클래스 이니셜라이저를 사용 하는 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다. 예를 들어 경우 클래스 `C<T>` 생성자가 있는 `C(T t1)` (`Sub New(ByVal t1 As T)` Visual Basic의)를 호출 <xref:System.Type.GetConstructors%2A> 에 `C<int>` 반환는 <xref:System.Reflection.ConstructorInfo> 나타내는 `C(int t1)` C#에서 (`Sub New(ByVal t1 As Integer)` Visual basic에서).  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 <xref:System.Type.GetConstructors%2A> 메서드는 빈 배열을 반환 합니다.  
  
   
  
## Examples  
 출력을 보여 주는이 예제는 <xref:System.Type.GetConstructors%2A> 두 인스턴스 생성자 및 정적 생성자가 하나 있는 클래스에서 오버 로드 합니다.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 이 코드의 출력은입니다.  
  
 2  
  
 False  
  
 False  
  
 때문에 <xref:System.Type.GetConstructors> 오버 로드만 사용 하 여 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, 정적 생성자에 의해 합계도는 `for` 식에 의해 평가 하거나 `IsStatic`합니다.  
  
 정적 생성자를 찾기 위해 사용 하 여는 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 오버 로드, 시키고 조합 (논리적 `OR`)의 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>다음 코드 예제에 나온 것 처럼:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 이제 출력이 생성 됩니다.  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 생성자를 지정된 <see langword="BindingFlags" />로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의된 생성자 중 지정된 바인딩 제약 조건과 일치하는 모든 생성자(정의된 경우에는 형식 이니셜라이저도 포함)를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 생성자가 현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의되어 있지 않거나, 정의된 생성자 중 바인딩 제약 조건과 일치하는 것이 없거나, 현재 <see cref="T:System.Type" />이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 경우 <see cref="T:System.Type" /> 형식의 빈 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> 메서드 선언 순서 대로 나열 등 특정 한 순서로 생성자를 반환 하지 않습니다. 코드 영향을 받지 않아야 생성자 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 `bindingAttr` 데 사용할 수는 공용 생성자 또는 public 및 non-public 생성자만 반환할 것인지 지정 합니다.  
  
 정확 하 게 일치가 없는 경우는 `binder` 에 지정 된 매개 변수 형식 강제 변환 하려고 합니다는 `types` 일치 하는 항목을 선택 하려면 배열입니다. 경우는 `binder` 일치 하는 항목을 선택한 후 수 없으면 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 하도록 합니다. 기본 클래스의 생성자는 반환 되지 않습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 지정 해야이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다. 예를 들어 경우 클래스 `C<T>` 생성자가 있는 `C(T t1)` (`Sub New(ByVal t1 As T)` Visual Basic의)를 호출 <xref:System.Type.GetConstructors%2A> 에 `C<int>` 반환는 <xref:System.Reflection.ConstructorInfo> 나타내는 `C(int t1)` C#에서 (`Sub New(ByVal t1 As Integer)` Visual basic에서).  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 <xref:System.Type.GetConstructors%2A> 메서드는 빈 배열을 반환 합니다.  
  
   
  
## Examples  
 출력을 보여 주는이 예제는 <xref:System.Type.GetConstructors> 두 인스턴스 생성자 및 정적 생성자가 하나 있는 클래스에서 오버 로드 합니다.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 이 코드의 출력은입니다.  
  
 2  
  
 False  
  
 False  
  
 때문에 <xref:System.Type.GetConstructors%2A> 오버 로드만 사용 하 여 <xref:System.Reflection.BindingFlags.Public> 및 <xref:System.Reflection.BindingFlags.Instance>, 정적 생성자에 의해 합계도는 `for` 식에 의해 평가 하거나 `IsStatic`합니다.  
  
 정적 생성자를 찾기 위해 사용 하 여는 <xref:System.Type.GetConstructors%2A> 오버 로드를 전달 하는 것의 조합 (논리적 OR) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>다음 코드 예제에 나온 것 처럼:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 이제 출력이 생성 됩니다.  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 대해 정의된 멤버 중 <see cref="T:System.Reflection.DefaultMemberAttribute" />가 설정된 멤버를 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MemberInfo" />의 모든 기본 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.MemberInfo" />에 기본 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> 메서드 반환 하지 않습니다 구성원을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야에 멤버가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 구성원 속성, 메서드, 필드, 이벤트 및 등을 포함합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다. 예를 들어 경우 클래스 `C<T>` 속성이 `P` 반환 하는 `T`를 호출 <xref:System.Type.GetDefaultMembers%2A> 에 `C<int>` 반환 `int P` C#에서 (`Property P As Integer` Visual basic에서).  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다의 멤버 또는 멤버는 클래스 제약 조건의 형식 매개 변수 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 예제에서는의 기본 멤버 정보를 얻고 `MyClass` 기본 멤버를 표시 합니다.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, 현재 배열, 포인터 또는 참조 형식에 의해 포함되거나 참조되는 개체의 <see cref="T:System.Type" />을 반환합니다.</summary>
        <returns>현재 배열, 포인터 또는 참조 형식에서 포함하거나 참조하는 개체의 <see cref="T:System.Type" />입니다. 현재 <see langword="null" />이 배열 또는 포인터가 아니거나, 참조로 전달되지 않거나, 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수나 제네릭 형식을 나타내는 경우에는 <see cref="T:System.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 `null` 에 대 한는 <xref:System.Array> 클래스입니다.  
  
   
  
## Examples  
 다음 예제는 `GetElementType` 메서드.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">이름을 검색할 값입니다.</param>
        <summary>현재 열거형 형식에 대해 지정된 값을 가진 상수의 이름을 반환합니다.</summary>
        <returns>지정된 값을 가진 현재 열거형 형식의 멤버 이름이거나 그러한 상수가 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.  
  
 또는  
  
 <paramref name="value" />는 현재 형식이 아니며 현재 형식과 동일한 기본 형식도 사용하지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 열거형 형식의 멤버 이름을 반환합니다.</summary>
        <returns>열거형 멤버의 이름이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값 배열의 요소는 열거형 상수의 이진 값 (즉, 부호 없는 값)으로 정렬 됩니다. 동일한 값을 가진 열거 상수를 포함 하는 배열, 해당 이름의 순서가 지정 되지 않았습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 열거형 형식의 내부 형식을 반환합니다.</summary>
        <returns>현재 열거형의 내부 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 C# 및 Visual Basic에서 열거형의 내부 형식은 <xref:System.Int32>합니다. 다른 정수 형식에 지정할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.  
  
 또는  
  
 열거형 형식에 두 개 이상의 인스턴스 필드가 포함되어 있으므로 열거형 형식이 잘못되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 열거형 형식에 있는 상수 값의 배열을 반환합니다.</summary>
        <returns>값이 포함된 배열입니다. 배열 요소는 열거형 상수의 이진 값(즉, 부호 없는 값)을 기준으로 정렬됩니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 특정 이벤트를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 public 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는, 지정한 public 이벤트(있는 경우)를 나타내는 개체이고, 그렇지 않으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트에 하나 이상의 메서드 또는 접근자가 public에 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색에는 public static 및 public 인스턴스 이벤트가 포함 됩니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.EventInfo> 개체 및 지정된 된 이벤트에 대 한 단추 클래스에 대 한 이벤트를 가져옵니다.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 지정된 바인딩 제약 조건을 사용하여 지정된 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는, 지정한 이벤트(있는 경우)를 나타내는 개체이고, 그렇지 않으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 이벤트를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 이벤트를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 이벤트 (즉, 전용, 내부 및 보호 된 이벤트)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 이벤트에만 검색 하는 <xref:System.Type>, 상속 된 이벤트가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이벤트에 하나 이상의 메서드 또는 접근자가 public에 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> 메서드는 public 또는 public이 아닌 "클릭 하십시오." 라는 되지 않은 이벤트에 대 한 형식을 검색 하려면 `static` (`Shared` Visual basic에서).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 모든 public 이벤트를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.EventInfo" />에 의해 선언되거나 상속되는 모든 public 이벤트를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.EventInfo" />에 public 이벤트가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트에 하나 이상의 메서드 또는 접근자가 public에 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 <xref:System.Type.GetEvents%2A> 메서드 반환 하지 않습니다 이벤트는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 이벤트가 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 가져옵니다 <xref:System.Reflection.EventInfo> 개체에 대 한 모든 이벤트는 `Button` 클래스 하 고 이벤트 이름을 표시 합니다. Visual Basic 예제를 컴파일하려면 다음 명령줄을 사용 합니다.  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.EventInfo" />에 의해 선언되거나 상속되는 이벤트 중 지정된 바인딩 제약 조건과 일치하는 모든 이벤트를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.EventInfo" />에 이벤트가 없거나 해당 바인딩 제약 조건과 일치하는 이벤트가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> 메서드 반환 하지 않습니다 이벤트는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 이벤트가 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 이벤트를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 이벤트를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 이벤트 (즉, 전용, 내부 및 보호 된 이벤트)를 포함 하도록 합니다. 만 보호 하 고 기본 클래스에는 내부 이벤트 반환 됩니다. 기본 클래스에서 private 이벤트 반환 되지 않습니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 이벤트에만 검색 하는 <xref:System.Type>, 상속 된 이벤트가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이벤트에 하나 이상의 메서드 또는 접근자가 public에 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 가져옵니다 <xref:System.Reflection.EventInfo> 지정 된 바인딩 플래그와 일치 하는 개체에 대 한 모든 이벤트를 가져옵니다는 `Button` 클래스 하 고 이벤트 이름을 표시 합니다. Visual Basic 예제를 컴파일하려면 다음 명령줄을 사용 합니다.  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 필드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 데이터 필드의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 필드를 검색합니다.</summary>
        <returns>지정된 이름의 public 필드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색에는 public static 및 public 인스턴스 필드가 포함 됩니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 가져옵니다는 `Type` 지정된 된 클래스에 대 한 개체를 가져옵니다는 <xref:System.Reflection.FieldInfo> 필드에 대 한 개체 필드의 값이 표시 됩니다.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 <see cref="T:System.Type" /> 개체가 해당 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 메서드가 호출되지 않은 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />인 경우</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 데이터 필드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>지정된 필드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 필드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 필드를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 필드를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 필드 (즉, 전용, 내부 및 보호 된 필드)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 필드에만 검색 하는 <xref:System.Type>, 상속 된 필드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 가져옵니다는 `Type` 지정된 된 클래스에 대 한 개체를 가져옵니다는 <xref:System.Reflection.FieldInfo> 지정 된 바인딩 플래그와 일치 하는 필드의 값을 표시 하는 필드에 대 한 개체입니다.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 필드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 필드를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 모든 public 필드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 public 필드가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> 메서드 반환 하지 않습니다 필드는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 필드가 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 public 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예에서는 사용 하 여 `GetFields()` 메서드.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 필드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 필드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 필드가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 필드가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> 메서드 반환 하지 않습니다 필드는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 필드가 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 필드를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 필드를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 필드 (즉, 전용, 내부 및 보호 된 필드)를 포함 하도록 합니다. 만 보호 하 고 기본 클래스에 내부 필드가 반환 됩니다. 기본 클래스에 전용 필드는 반환 되지 않습니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 필드에만 검색 하는 <xref:System.Type>, 상속 된 필드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 public 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예에서는 사용 하 여 `GetFields(BindingFlags)` 메서드.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>닫힌 제네릭 형식의 형식 정의나 제네릭 형식 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns>제네릭 형식의 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 현재 형식이 제네릭 형식이 아니면 빈 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열 요소는 제네릭 형식의 유형 인수 목록에 나타나는 순서 대로 반환 됩니다.  
  
-   현재 형식이 생성된 된 닫힌된 형식 (즉,는 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `false`)를 반환 하는 배열은 <xref:System.Type.GetGenericArguments%2A> 메서드에 제네릭 형식 정의의 제네릭 형식 매개 변수에 할당 된 형식이 포함 되어 있습니다. .  
  
-   현재 형식이 제네릭 형식 정의 인 경우 형식 매개 변수 배열에 포함 되어 있습니다.  
  
-   현재 형식이 개방형 생성된 형식 (즉,는 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`) 어떤 종류의 모든 바깥쪽 제네릭 형식 또는 메서드의 형식 매개 변수 및 형식 매개 변수를 할당 되어 있지, 배열 포함 형식 및 형식 매개 변수입니다. 사용 하 여 <xref:System.Type.IsGenericParameter%2A> 구분 하는 속성입니다. 이 시나리오를 보여 주는 코드 예제를 참조 하세요.는 <xref:System.Type.ContainsGenericParameters%2A> 속성입니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Type.GetGenericArguments%2A> 메서드를 생성 된 형식의 형식 인수 및 제네릭 형식 정의의 형식 매개 변수를 표시 합니다.  
  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성입니다. 보다 큰 예제의 샘플 출력에 대 한 참조입니다.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 제네릭 형식 매개 변수에 대한 제약 조건을 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns>현재 제네릭 형식 매개 변수에 대한 제약 조건을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식 매개 변수에 각 제약 조건으로 표시는 <xref:System.Type> 개체입니다. 사용 하 여는 <xref:System.Type.IsClass%2A> 속성을 기본 클래스 제약 조건을 제약 조건 인지; 속성이 반환 하는 경우 확인할 `false`, 제약 조건에 인터페이스 제약 조건입니다. 형식 매개 변수 클래스 제약 조건이 있으며 인터페이스 제약 조건이 없을 경우 빈 배열을 반환 됩니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 형식 정의 `Test` 제약 조건이 서로 다른 두 개의 형식 매개 변수를 사용 합니다. 제약 조건을 사용 하 여 검사 프로그램을 실행 하는 경우는 <xref:System.Type.GenericParameterAttributes%2A> 속성 및 <xref:System.Type.GetGenericParameterConstraints%2A> 메서드.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Type" /> 개체가 제네릭 형식 매개 변수가 아닌 경우. 즉, <see cref="P:System.Type.IsGenericParameter" /> 속성이 <see langword="false" />를 반환합니다.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 제네릭 형식을 생성할 수 있는 제네릭 형식 정의를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>현재 형식을 생성할 수 있는 제네릭 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식 정의 다른 형식을 생성 하는 데 사용 될 수 있는 템플릿입니다. 예를 들어 제네릭 형식 정의에서 `G<T>` (C# 구문; 표시 합니다. `G(Of T)` Visual Basic의 또는 `generic <typename T> ref class G` c + +에서) 생성 하 고 형식을 인스턴스화하고 `G<int>` (`G(Of Integer)` Visual basic에서). 지정 된는 <xref:System.Type> 생성 된 형식을 나타내는이 개체는 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드는 제네릭 형식 정의 반환 합니다.  
  
 동일한 형식 인수를 사용 하 여 두 개의 생성 된 형식을 동일한 제네릭 형식 정의에서 생성 되 면는 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드가 반환 하는 동일한 <xref:System.Type> 두 유형 모두에 대 한 개체입니다.  
  
 호출 하는 경우는 <xref:System.Type.GetGenericTypeDefinition%2A> 에서 메서드는 <xref:System.Type> 이미 제네릭 형식 정의 나타내는 개체 현재 반환 <xref:System.Type>합니다.  
  
> [!IMPORTANT]
>  제네릭 형식의 배열은 그 자체로 있지 않습니다. C# 코드에서 `A<int>[] v;` 또는 Visual Basic 코드 `Dim v() As A(Of Integer)`, 변수의 형식을 `v` 는 제네릭이 아닙니다. 사용 하 여 <xref:System.Type.IsGenericType%2A> 를 호출 하기 전에 제네릭 형식 인지 확인 <xref:System.Type.GetGenericTypeDefinition%2A>합니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 일반적인 인스턴스 작성을 사용 하 여 생성 된 형식의 인스턴스를 만들고 다음 사용 하 여는 <xref:System.Type.GetType%2A> 및 <xref:System.Type.GetGenericTypeDefinition%2A> 생성된 형식 및 제네릭 형식 정의 검색 하는 메서드. 이 예제에서는 제네릭 사용 <xref:System.Collections.Generic.Dictionary%602> 유형, 생성 된 형식 나타내는 <xref:System.Collections.Generic.Dictionary%602> 의 `Test` 문자열 키가 있는 개체입니다.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식은 제네릭 형식이 아닙니다.  즉, <see cref="P:System.Type.IsGenericType" />이 <see langword="false" />를 반환합니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>이 인스턴스의 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>를 재정의합니다.  
  
   
  
## Examples  
 해시 코드를 표시 하는 다음 예제는 `System.Windows.Forms.Button` 클래스입니다.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 특정 인터페이스를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 인터페이스의 이름이 포함된 문자열입니다. 제네릭 인터페이스의 경우 이것은 형식 표시 이름입니다.</param>
        <summary>지정된 이름의 인터페이스를 검색합니다.</summary>
        <returns>개체는 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는, 지정된 이름의 인터페이스를 나타내는 개체이며(있는 경우) 이를 나타내고, 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 검색 `name` 대 소문자를 구분 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수를 검색 합니다.  
  
> [!NOTE]
>  제네릭 인터페이스는 `name` 매개 변수는 형식 표시 이름, 억음 악센트로 끝나는 (\`) 및 형식 매개 변수 수입니다. 이 제네릭 인터페이스 정 및 생성 된 제네릭 인터페이스를 둘 다에 적용 됩니다. 등을 찾기 위해 `IExample<T>` (`IExample(Of T)` Visual basic에서) 또는 `IExample<string>` (`IExample(Of String)` Visual basic에서), 검색할 ``"IExample`1"``합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Type.GetInterface%28System.String%29> 검색 하는 메서드는 <xref:System.Collections.Hashtable> 에 대 한 클래스는 <xref:System.Runtime.Serialization.IDeserializationCallback> 인터페이스 및 인터페이스의 메서드를 나열 합니다.  
  
 코드 예제도 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 메서드 오버 로드와 <xref:System.Type.GetInterfaceMap%2A> 메서드.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">현재 <see cref="T:System.Type" />이 서로 다른 형식 인수를 사용하여 같은 제네릭 인터페이스를 구현하는 형식을 나타내는 경우</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">가져올 인터페이스의 이름이 포함된 문자열입니다. 제네릭 인터페이스의 경우 이것은 형식 표시 이름입니다.</param>
        <param name="ignoreCase">
          단순한 인터페이스 이름을 지정하는 <c>name</c>의 해당 부분의 대/소문자를 무시하려면 <see langword="true" />입니다. 네임스페이스를 지정하는 부분은 대/소문자를 올바로 지정해야 합니다.  
  
 또는  
  
 <c>name</c>의 모든 부분에 대해 대/소문자를 구분하여 검색하려면 <see langword="false" />입니다.</param>
        <summary>파생 클래스에서 재정의되면 인터페이스 이름에 대해 대/소문자를 구분하지 않고 검색할지를 지정하여 지정된 인터페이스를 검색합니다.</summary>
        <returns>개체는 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는, 지정된 이름의 인터페이스를 나타내는 개체이며(있는 경우) 이를 나타내고, 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` 매개 변수 하지 네임 스페이스에는 간단한 인터페이스 이름에만 적용 됩니다. 부분 `name` 네임 스페이스는 정확한 대/소문자를 포함 해야 합니다 또는 인터페이스를 찾을 수를 지정 하는 합니다. 예를 들어 "System.icomparable"를 찾습니다는 문자열은 <xref:System.IComparable> 인터페이스를 동일 하지만 문자열 "system.icomparable" 하지 않습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수를 검색 합니다.  
  
> [!NOTE]
>  제네릭 인터페이스는 `name` 매개 변수는 형식 표시 이름, 억음 악센트로 끝나는 (\`) 및 형식 매개 변수 수입니다. 이 제네릭 인터페이스 정 및 생성 된 제네릭 인터페이스를 둘 다에 적용 됩니다. 등을 찾기 위해 `IExample<T>` (`IExample(Of T)` Visual basic에서) 또는 `IExample<string>` (`IExample(Of String)` Visual basic에서), 검색할 `"IExample`1"'.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 대/소문자 구분 검색을 수행 하는 메서드는 <xref:System.Collections.Hashtable> 에 대 한 클래스는 <xref:System.Collections.IEnumerable> 인터페이스입니다.  
  
 코드 예제도 <xref:System.Type.GetInterface%28System.String%29> 메서드 오버 로드와 <xref:System.Type.GetInterfaceMap%2A> 메서드.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">현재 <see cref="T:System.Type" />이 서로 다른 형식 인수를 사용하여 같은 제네릭 인터페이스를 구현하는 형식을 나타내는 경우</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">매핑을 검색할 인터페이스의 형식입니다.</param>
        <summary>지정된 인터페이스 형식에 대한 인터페이스 매핑을 반환합니다.</summary>
        <returns>
          <paramref name="interfaceType" />에 대한 인터페이스 매핑을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인터페이스 맵을 인터페이스 인터페이스를 구현 하는 클래스에 실제 멤버에 매핑하는 방법을 나타냅니다.  
  
 경우 현재 <xref:System.Type> 생성된 된 제네릭 형식을 나타내는, 형식 매개 변수가의 요소에 적절 한 형식 인수에 의해 대체 되는 <xref:System.Reflection.InterfaceMapping> 이 메서드에서 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.GetInterfaceMap%2A> 결정 하는 방법을 <xref:System.IFormatProvider> 인터페이스에 매핑됩니다 <xref:System.Globalization.CultureInfo> 메서드 방식 <xref:System.IAppDomainSetup> 인터페이스에 매핑됩니다 <xref:System.AppDomainSetup> 속성입니다. 때문에 <xref:System.IAppDomainSetup> 인터페이스 정의 반환 된 속성 집합이 <xref:System.Reflection.InterfaceMapping> 개체를 별도 포함 <xref:System.Reflection.MethodInfo> 속성의 get 및 set 접근자에 대 한 개체입니다.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" />이 현재 형식으로 구현되지 않은 경우  
  
 또는  
  
 <paramref name="interfaceType" /> 매개 변수가 인스턴스를 참조하지 않는 경우  
  
 또는  
  
 <paramref name="interfaceType" />이 제네릭 인터페이스이고 현재 형식이 배열 형식인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Type" />이 제네릭 형식 매개 변수를 나타내는 경우, 즉 <see cref="P:System.Type.IsGenericParameter" />가 <see langword="true" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 모든 인터페이스를 가져옵니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 모든 인터페이스를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 인터페이스가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> 메서드 반환 하지 않습니다 인터페이스를 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 인터페이스가 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 클래스의 형식을 가져오고 형식을 구현 하거나 상속 하는 모든 인터페이스를 표시 합니다. Visual Basic 예제를 컴파일하려면 다음 컴파일러 명령을 사용 합니다.  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">정적 이니셜라이저가 호출되고 예외를 발생합니다.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 지정된 멤버를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 멤버의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 멤버를 검색합니다.</summary>
        <returns>지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 멤버를 포함합니다.  
  
 구성원 속성, 메서드, 필드, 이벤트 및 등을 포함합니다.  
  
 <xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 구성원을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야에 멤버가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 이 메서드 오버 로드 클래스 이니셜라이저가 (.cctor) 찾을 수 없습니다. 클래스 이니셜라이저를 사용 하는 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다의 멤버 또는 멤버는 클래스 제약 조건의 형식 매개 변수 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다.  
  
   
  
## Examples  
 모든 멤버를 표시 하는 다음 예제는 `String` c로 시작 하는 클래스  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 멤버의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 빈 배열을 반환하려는 경우 0입니다.</param>
        <summary>지정된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 구성원 속성, 메서드, 필드, 이벤트 및 등을 포함합니다.  
  
 <xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 구성원을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야에 멤버가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 멤버를 정의 하는 검색에 포함할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 멤버 (즉, 전용, 내부 및 보호 된 멤버)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하는 <xref:System.Type>, 상속 된 멤버가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면에 대 한 ".cctor"를 지정 해야 `name`, 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서)에 대 한 `bindingAttr`합니다. 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다의 멤버 또는 멤버는 클래스 제약 조건의 형식 매개 변수 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다.  
  
   
  
## Examples  
 모든 공용 정적 멤버를 표시 하는 다음 예제는 `myString` c로 시작 하는 클래스  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 멤버의 이름이 포함된 문자열입니다.</param>
        <param name="type">검색할 값입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 빈 배열을 반환하려는 경우 0입니다.</param>
        <summary>지정된 멤버 형식의 지정된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구성원 속성, 메서드, 필드, 이벤트 및 등을 포함합니다.  
  
 <xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 구성원을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야에 멤버가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 멤버를 정의 하는 검색에 포함할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 멤버 (즉, 전용, 내부 및 보호 된 멤버)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하는 <xref:System.Type>, 상속 된 멤버가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면에 대 한 ".cctor"를 지정 해야 `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> 에 대 한 `type`, 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 에 Visual Basic의 경우)에 대 한 `bindingAttr`합니다. 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다의 멤버 또는 멤버는 클래스 제약 조건의 형식 매개 변수 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다.  
  
   
  
## Examples  
 모든 메서드를 표시 하는 다음 예제는 `myString` c로 시작 하는 클래스  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 멤버(속성, 메서드, 필드, 이벤트 등)를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 멤버를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MemberInfo" />의 모든 public 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.MemberInfo" />에 public 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구성원 속성, 메서드, 필드, 이벤트 및 등을 포함합니다.  
  
 <xref:System.Type.GetMembers%2A> 메서드 반환 하지 않습니다 구성원을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야에 멤버가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 이 메서드 오버 로드는 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 메서드 오버 로드와 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저가 (.cctor)를 검색 하지 않습니다. 클래스 이니셜라이저를 사용 하는 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다의 멤버 또는 멤버는 클래스 제약 조건의 형식 매개 변수 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Type.GetMembers> 메서드 오버 로드는 지정 된 클래스의 모든 public 멤버에 대 한 정보를 수집 합니다.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 빈 배열을 반환하려는 경우 0(<see cref="F:System.Reflection.BindingFlags.Default" />)입니다.</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MemberInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.MemberInfo" />에 대해 정의된 멤버가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구성원 속성, 메서드, 필드, 이벤트 및 등을 포함합니다.  
  
 <xref:System.Type.GetMembers%2A> 메서드 반환 하지 않습니다 구성원을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야에 멤버가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 멤버를 정의 하는 검색에 포함할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 멤버 (즉, 전용, 내부 및 보호 된 멤버)를 포함 하도록 합니다. 만 보호 하 고 반환 되는 기본 클래스에 내부 멤버가; 기본 클래스에서 전용 멤버 반환 되지 않습니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하는 <xref:System.Type>, 상속 된 멤버가 없습니다.  
  
 이 메서드를 호출할는 `Public` 플래그 또는는 `NonPublic` 플래그는 지정된 된 멤버를 반환 하 고 다른 플래그는 필요 하지 않습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 지정 해야이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 얻을 수 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MemberInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다의 멤버 또는 멤버는 클래스 제약 조건의 형식 매개 변수 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 메서드 오버 로드는 지정 된 클래스의 모든 public 인스턴스 멤버에 대 한 정보를 수집 합니다.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 메서드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 메서드의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 메서드를 검색합니다.</summary>
        <returns>지정된 이름의 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 메서드를 포함 합니다.  
  
 메서드는 오버 로드 되며 둘 이상의 public 메서드가 하는 경우는 <xref:System.Type.GetMethod%28System.String%29> 메서드가 throw는 <xref:System.Reflection.AmbiguousMatchException> 예외입니다. 다음 예제에서는 공용 오버 로드를 여러 개 있기 때문에 예외가 throw 됩니다는 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 메서드.  반면에 때문에 `Person.ToString` 메서드 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 따라서 오버 로드 되지 않습니다 및, <xref:System.Type.GetMethod%28System.String%29> 메서드는 검색할 수는 <xref:System.Reflection.MethodInfo> 개체입니다.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 특정 메서드를 검색 하려면 다음 중 하나를 수행할 수 있습니다.  
  
-   호출의 <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> 메서드를 지정 하 고는 `bindingAttr` 메서드를 고유 하 게 식별 하는 인수. 예를 들어, 형식에는 정적 및 인스턴스 오버 로드 때문에 예외가 throw 되 면 지정할 수 있습니다는 `bindingAttr` 의 인수 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>합니다.  
  
-   호출의 오버 로드는 <xref:System.Type.GetMethod%2A> 메서드를 포함 하는 `types` 메서드의 매개 변수 유형을 정의 하는 매개 변수입니다.  
  
-   호출 된 <xref:System.Type.GetMethods> 모든 형식에 속하는 공용 메서드를 포함 하는 배열을 검색 하는 메서드입니다. 명명 된 중복 메서드를 식별 하기 반복 수 있습니다 `name`합니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예에서는 라는 메서드를 가져옵니다 `MethodA`합니다.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가진 메서드가 둘 이상 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>지정된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   지정 해야 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 반환 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 검색에 공용 메서드를 포함 하도록 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 하도록 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 대/소문자를 무시 하려면 `name`합니다.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드 오버 로드 되 고 둘 이상의 오버 로드로 지정 된 제약 조건을 충족 하는 경우는 `bindingAttr` 인수를 메서드에서 throw 한 <xref:System.Reflection.AmbiguousMatchException> 예외입니다. 다음 예제에서는 예외가 발생 하기 때문에:  
  
-   `TestClass` 형식에 두 public 인스턴스 오버 로드는 `DisplayValue` 메서드를 `DisplayValue(String)` 및 `DisplayValue(String, Object[])`합니다.  
  
-   `TestClass` 형식에 두 public 인스턴스 오버 로드는 `Equals` 그 중 하나에서 상속 된 메서드 <xref:System.Object>: `Equals(TestClass)` 및 `Equals(Object)`합니다.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 특정 메서드를 검색 하려면 다음 중 하나를 수행할 수 있습니다.  
  
-   해당 바인딩 제약 조건과 변경 합니다. 이전 예제에서 공용 인스턴스를 검색 하는 `Equals` 메서드 형식에서 선언 되 고 성공적으로 상속 되지 않고 검색 `Equals(TestClass)`합니다.  
  
-   호출의 오버 로드는 <xref:System.Type.GetMethod%2A> 메서드를 포함 하는 `types` 메서드의 매개 변수 유형을 정의 하는 매개 변수입니다.  
  
-   호출 된 <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> 메서드는 지정 된 바인딩 특성을 포함 하는 형식에 속하는 메서드 중 일부를 포함 하는 배열을 검색 합니다. 명명 된 중복 메서드를 식별 하기 반복 수 있습니다 `name`합니다. 이 방법에 대 한 처리기 앞의 예제에에서 나와 <xref:System.Reflection.AmbiguousMatchException> 예외입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 바인딩 플래그와 일치 하는 메서드를 가져옵니다.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <summary>지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 메서드를 검색합니다.</summary>
        <returns>지정된 인수 형식과 일치하는 매개 변수를 가진 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 메서드를 포함 합니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  `name` 매개 변수는 형식 인수를 포함할 수 없습니다. 예를 들어 C# 코드 `GetMethod("MyGenericMethod<int>")` 텍스트 이름의 메서드를 검색 "`MyGenericMethod<int>`", 라는 메서드가 아니라 `MyGenericMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다. 대신를 사용 하 여 `GetMethod("MyGenericMethod")` 에서 적절 한 매개 변수는 `types` 배열 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `MethodA`, 다양 한 형식 인수를 지정 합니다.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제를 실행 하려면는 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 다음 예제에서는 검색 <xref:System.Reflection.MethodInfo> 나타내는 개체를 개체는 `Add` 제네릭이 아닌 형식의 메서드 (의 <xref:System.Collections.ArrayList> 클래스), 개방형 제네릭 형식 (는 <xref:System.Collections.Generic.List%601> 클래스), 및 폐쇄형된 제네릭 형식 (의 `List(Of String)` 형식.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 이 예제에서는 정의 `GetAddMethod` 적절 한 검색 <xref:System.Reflection.MethodInfo> 개체입니다. 제공 하는 `types` 호출 개방형 제네릭 형식에 대 한 인수는 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 메서드. 제공 하는 `types` 의 값을 검색 폐쇄형된 제네릭 형식에 대 한 인수는 <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정된 이름 및 지정된 매개 변수를 사용하는 메서드가 두 개 이상입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 public 메서드를 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 메서드를 포함 합니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMethod("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다. 대신를 사용 하 여 `GetMethod("MyMethod")` 에서 적절 한 매개 변수는 `types` 배열 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정된 이름 및 지정된 매개 변수를 사용하는 메서드가 두 개 이상입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 메서드를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예제에서는 `MethodA`, 바인딩 제약 조건 및 다양 한 형식 인수를 지정 합니다.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제를 실행 하려면는 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건과 지정된 호출 규칙으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `GetXXX` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 메서드를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드의 형식 인수에을 포함 하지 마십시오 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 라는 메서드가 아니라 `MyMethod` 형식의 제네릭 인수가 하나 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예제에서는 `MethodA`, 바인딩 제약 조건 지정, 호출 규칙 및 인수 형식입니다.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제를 실행 하려면는 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택을 정리하는 프로세스 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 매개 변수를 사용하지 않는 메서드를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).  
  
 또는  
  
 <see langword="null" />. <c>types</c>가 <see langword="null" />이면 일치되는 인수가 없습니다.</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건 및 호출 규칙으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 `types`가 `null`이면 일치되는 인수가 없습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 메서드를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 메서드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 메서드를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 모든 public 메서드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 public 메서드가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> 메서드 반환 하지 않습니다 메서드는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 메서드가 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 생성자는 메서드가이 호출에서 반환 된 배열에 포함 되지 않습니다. 별도 호출 `GetConstructors()` 생성자 메서드를 가져옵니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 메서드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 메서드가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 메서드가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> 메서드 반환 하지 않습니다 메서드는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 메서드가 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 메서드를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 하도록 합니다. 만 보호 하 고 기본 클래스의 내부 메서드 반환 됩니다. 기본 클래스의 전용 메서드 반환 되지 않습니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출할 때에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수는 클래스 제약 조건의 메서드나의 메서드가 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 예제에서는 클래스와 두 개의 공용 메서드와 하나의 보호 된 메서드, 만들어집니다는 `Type` 개체에 해당 하 `MyTypeClass`모든 public 및 public이 아닌 메서드를 가져오고 해당 이름을 표시 합니다.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 중첩된 특정 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 중첩 형식의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 중첩 형식을 검색합니다.</summary>
        <returns>지정된 이름의 public 중첩 형식을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 검색 `name` 대 소문자를 구분 합니다.  
  
 에 대 한 중첩 된 클래스의 단순한 이름을 사용 하 여 `name`합니다. 외부 클래스의 이름으로 한정 하지 않습니다. 중첩 된 제네릭 클래스에 대 한 형식 표시 이름을 사용 하 여-즉, 억음 악센트 및 제네릭 인수 수를 추가 합니다. 예를 들어 문자열을 사용 하 여 "내부\`1" 중첩 된 클래스 원본에 가져올 `Inner<T>` (`Inner(Of T)` Visual basic에서). 형식 매개 변수에 대 한 언어별 구문을 포함 하지 마십시오.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩 된 형식이 제네릭 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식의 폐쇄형 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 권한이 자체의 제네릭 매개 변수가 없는 경우에 중첩된 형식은 모두 일반적으로 진행 됩니다. 이 동적 어셈블리에 정의 된 또는 사용 하 여 컴파일된 중첩 형식의 경우 반드시는 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 및 중첩 된 제네릭 형식을에 정보를 참조 하십시오. <xref:System.Type.MakeGenericType%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 중첩 형식의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 지정된 중첩 형식을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 중첩 형식을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 중첩 된 클래스의 단순한 이름을 사용 하 여 `name`합니다. 외부 클래스의 이름으로 한정 하지 않습니다. 중첩 된 제네릭 클래스에 대 한 형식 표시 이름을 사용 하 여-즉, 억음 악센트 및 제네릭 매개 변수의 수를 추가 합니다. 예를 들어 문자열을 사용 하 여 "내부\`1" 중첩 된 클래스 원본에 가져올 `Inner<T>` (`Inner(Of T)` Visual basic에서). 형식 매개 변수에 대 한 언어별 구문을 포함 하지 마십시오.  
  
 다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식을 필터 플래그를 사용 하 여 중첩 정의할 수 있습니다.  
  
-   지정 해야 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 를 반환 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> public 중첩된 형식을 검색에 포함 하도록 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 중첩된 형식 (즉, 전용, 내부 및 보호 된 중첩된 형식)를 포함 하도록 합니다.  
  
 이 메서드는 중첩 된 형식을 현재 형식에 반환합니다. 현재 형식의 기본 클래스를 검색 하지 않습니다. 중첩 된 형식을 기본 클래스에서를 찾으려면 호출 상속 계층 구조를 검색 해야 <xref:System.Type.GetNestedType%2A> 각 수준에 있습니다.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 무시 됩니다.  
  
 이 메서드를 호출할는 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 플래그 또는는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 플래그 지정 된 중첩 형식 및 다른 플래그는 필요 하지 않습니다 반환 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩 된 형식이 제네릭 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식의 폐쇄형 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 권한이 자체의 제네릭 매개 변수가 없는 경우에 중첩된 형식은 모두 일반적으로 진행 됩니다. 이 동적 어셈블리에 정의 된 또는 사용 하 여 컴파일된 중첩 형식의 경우 반드시는 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 및 중첩 된 제네릭 형식을에 정보를 참조 하십시오. <xref:System.Type.MakeGenericType%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 중첩된 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 중첩된 public 형식을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 중첩된 public 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나(검색은 재귀적이 아님), 현재 <see cref="T:System.Type" />에 중첩된 public 형식이 없으면 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> 메서드 반환 하지 않습니다 형식 특정 한 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 형식이 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 즉시 현재 형식에 중첩 된 public 형식만 반환 됩니다. 검색은 재귀적이 아님.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩 된 형식이 제네릭 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식의 폐쇄형 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 권한이 자체의 제네릭 매개 변수가 없는 경우에 중첩된 형식은 모두 일반적으로 진행 됩니다. 이 동적 어셈블리에 정의 된 또는 사용 하 여 컴파일된 중첩 형식의 경우 반드시는 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 및 중첩 된 제네릭 형식을에 정보를 참조 하십시오. <xref:System.Type.MakeGenericType%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 중첩된 된 클래스를 정의 및 `struct` 에 `MyClass`, 다음 형식을 사용 하는 중첩 형식의 개체를 가져와야 하 고 `MyClass`합니다.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면 지정된 바인딩 제약 조건을 사용하여 현재 <see cref="T:System.Type" />에 중첩된 형식을 검색합니다.</summary>
        <returns>지정된 바인딩 제약 조건과 일치하는 현재 <see cref="T:System.Type" />에 중첩된 모든 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나(검색은 재귀적이 아님), 바인딩 제약 조건과 일치하는 중첩 형식이 없으면 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중첩 된 형식에 대 한 검색은 재귀적이 아님.  
  
 <xref:System.Type.GetNestedTypes%2A> 메서드 반환 하지 않습니다 형식 특정 한 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 형식이 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식을 필터 플래그를 사용 하 여 중첩 정의할 수 있습니다.  
  
-   지정 해야 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 를 반환 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> public 중첩된 형식을 검색에 포함 하도록 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 중첩된 형식 (즉, 전용, 내부 및 보호 된 중첩된 형식)를 포함 하도록 합니다.  
  
 이 메서드는 중첩 된 형식을 현재 형식에 반환합니다. 현재 형식의 기본 클래스를 검색 하지 않습니다. 중첩 된 형식을 기본 클래스에서를 찾으려면 호출 상속 계층 구조를 검색 해야 <xref:System.Type.GetNestedTypes%2A> 각 수준에 있습니다.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 무시 됩니다.  
  
 이 메서드를 호출할는 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 플래그 또는는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 플래그 지정 된 중첩 형식 및 다른 플래그는 필요 하지 않습니다 반환 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩 된 형식이 제네릭 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식의 폐쇄형 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 권한이 자체의 제네릭 매개 변수가 없는 경우에 중첩된 형식은 모두 일반적으로 진행 됩니다. 이 동적 어셈블리에 정의 된 또는 사용 하 여 컴파일된 중첩 형식의 경우 반드시는 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 및 중첩 된 제네릭 형식을에 정보를 참조 하십시오. <xref:System.Type.MakeGenericType%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 중첩 된 공용 클래스 및 두 개의 중첩된 보호 클래스 만들고 지정 된 바인딩 제약 조건과 일치 하는 클래스에 대 한 정보를 표시 합니다.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 속성을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 속성을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.PropertyInfo" />의 모든 public 속성을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.PropertyInfo" />에 public 속성이 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 호출 하는 것은 <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> 오버 로드는 `bindingAttr` 와 같으면 인수 `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` C# 및 `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` Visual Basic의 합니다. 모든 public 인스턴스 및 정적 속성이 나타내는 현재 형식에 의해 정의 된 두 반환 <xref:System.Type> 개체도 해당 형식의 기본 형식에서 상속 합니다.  
  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 <xref:System.Type.GetProperties%2A> 메서드 반환 하지 않습니다 속성을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 속성이 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `GetProperties` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />의 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.PropertyInfo" />의 속성 중 지정된 바인딩 제약 조건과 일치하는 모든 속성을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
 또는  
  
 현재 <see cref="T:System.Reflection.PropertyInfo" />에 속성이 없거나 해당 바인딩 제약 조건과 일치하는 속성이 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 <xref:System.Type.GetProperties%2A> 메서드 반환 하지 않습니다 속성을 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다. 코드 영향을 받지 않아야 속성이 반환 되는 순서에 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식을 필터 플래그를 사용 하 여 중첩 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)를 포함 하도록 합니다. 만 보호 하 고 기본 클래스에서 내부 속성이 반환 됩니다. 기본 클래스에 대 한 개인 속성 반환 되지 않습니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성에 대해서만 검색 하는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
   
  
## Examples  
 라는 클래스를 정의 하는 다음 예제에서는 `PropertyClass` 속성 6 개가 포함 된: 두 대가 public, 하나는 전용 보호 하나, 하나는 내부 (`Friend` Visual basic에서), 내부 보호 되며 하나 (`Protected Friend` Visual basic에서). 몇 가지 기본 속성 정보를 표시 합니다 (속성 이름 및 형식을 여부는 읽기/쓰기의 표시 여부는 `get` 및 `set` 접근자) 지정 된 바인딩 제약 조건과 일치 하는 속성에 대 한 합니다.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 속성을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 속성을 검색합니다.</summary>
        <returns>지정된 이름의 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함 합니다.  
  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
 실제 <xref:System.Reflection.AmbiguousMatchException> 발생은 다음과 같습니다.  
  
-   형식에는 두 개의 동일한 인덱싱된 속성 하지만 서로 다른 개수의 매개 변수 이름을 지정 합니다. 오버 로드를 사용 하 여 모호성을 해결 하는 <xref:System.Type.GetProperty%2A> 매개 변수 형식을 지정 하는 메서드.  
  
-   파생된 형식을 사용 하 여 동일한 이름의 상속된 된 속성을 숨기는 속성 선언에서 `new` 한정자 (`Shadows` Visual basic에서). 모호성을 해결 하려면 사용 된 <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> 메서드 오버 로드 하 고 추가 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 상속 되지 않은 멤버에 검색을 제한 하는 플래그입니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 간단한 인덱싱된 속성에 액세스 하기 위한 구문을 사용 하 고 해당 형식에 대 한 기본 인덱싱된 속성이 하나를 허용 합니다. 예를 들어 경우 변수 `myList` 참조 하는 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual basic에서) 3의 인덱스를 가진 요소를 검색 합니다. 속성을 재정의할 수 있습니다.  
  
 C#에서이 기능은 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어는 <xref:System.String> 라는 예 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성에는 사용자의 이름을 Item 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 확인 하려면는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 메서드를 테스트 하는 <xref:System.Reflection.DefaultMemberAttribute> 특성입니다. 형식에 있는 경우 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 검색 된 `Type` 사용자 정의 클래스의 개체는 해당 클래스의 속성을 검색 하 고 속성 이름을 표시 합니다.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 내부적으로이 속성에서 참조 하는 메타 데이터에 "Item" 이름 가져오려면 `PropertyInfo` 리플렉션을 사용 하 여 올바로 반환 하기 위해이 내부 이름을 지정 해야 합니다는 `PropertyInfo` 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가진 속성이 둘 이상 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 속성의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <summary>지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성에 대해서만 검색 하는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
 실제 <xref:System.Reflection.AmbiguousMatchException> 발생은 다음과 같습니다.  
  
-   형식에는 두 개의 동일한 인덱싱된 속성 하지만 서로 다른 개수의 매개 변수 이름을 지정 합니다. 오버 로드를 사용 하 여 모호성을 해결 하는 <xref:System.Type.GetProperty%2A> 매개 변수 형식을 지정 하는 메서드.  
  
-   동일한 이름의 상속된 된 속성을 숨기는 속성을 선언 하는 파생된 형식을 사용 하 여는 `new` 한정자 (`Shadows` Visual basic에서). 모호성을 해결 하려면 포함 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 상속 되지 않은 멤버에 검색을 제한 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 간단한 인덱싱된 속성에 액세스 하기 위한 구문을 사용 하 고 해당 형식에 대 한 기본 인덱싱된 속성이 하나를 허용 합니다. 예를 들어 경우 변수 `myList` 참조 하는 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual basic에서) 3의 인덱스를 가진 요소를 검색 합니다. 속성을 재정의할 수 있습니다.  
  
 C#에서이 기능은 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어는 <xref:System.String> 라는 예 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성에는 사용자의 이름을 Item 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 확인 하려면는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 메서드를 테스트 하는 <xref:System.Reflection.DefaultMemberAttribute> 특성입니다. 형식에 있는 경우 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 정의 클래스의 형식을 검색 하 고, 해당 클래스의 속성을 검색 하 고, 지정 된 바인딩 제약 조건에 따라 속성 이름을 표시 합니다.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <summary>지정된 이름과 반환 형식의 public 속성을 검색합니다.</summary>
        <returns>지정된 이름의 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 간단한 인덱싱된 속성에 액세스 하기 위한 구문을 사용 하 고 해당 형식에 대 한 기본 인덱싱된 속성이 하나를 허용 합니다. 예를 들어 경우 변수 `myList` 참조 하는 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual basic에서) 3의 인덱스를 가진 요소를 검색 합니다. 속성을 재정의할 수 있습니다.  
  
 C#에서이 기능은 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어는 <xref:System.String> 라는 예 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성에는 사용자의 이름을 Item 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 확인 하려면는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 메서드를 테스트 하는 <xref:System.Reflection.DefaultMemberAttribute> 특성입니다. 형식에 있는 경우 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 하나의 속성이 있는 클래스를 정의 하 고 이름 및 속성의 종류를 검색 합니다.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가진 속성이 둘 이상 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />이 <see langword="null" />이거나 <paramref name="returnType" />이 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <summary>지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</summary>
        <returns>지정된 인수 형식과 일치하는 매개 변수를 가진 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 간단한 인덱싱된 속성에 액세스 하기 위한 구문을 사용 하 고 해당 형식에 대 한 기본 인덱싱된 속성이 하나를 허용 합니다. 예를 들어 경우 변수 `myList` 참조 하는 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual basic에서) 3의 인덱스를 가진 요소를 검색 합니다. 속성을 재정의할 수 있습니다.  
  
 C#에서이 기능은 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어는 <xref:System.String> 라는 예 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성에는 사용자의 이름을 Item 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 확인 하려면는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 메서드를 테스트 하는 <xref:System.Reflection.DefaultMemberAttribute> 특성입니다. 형식에 있는 경우 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 검색 된 `Type` 사용자 정의 클래스의 개체가 해당 클래스의 속성을 검색 하 고 속성 이름 및 속성의 형식에 전달 된 인수에 지정 된 대로 표시 `GetProperty`합니다.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 인수 형식과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <summary>지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</summary>
        <returns>지정된 인수 형식과 일치하는 매개 변수를 가진 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 간단한 인덱싱된 속성에 액세스 하기 위한 구문을 사용 하 고 해당 형식에 대 한 기본 인덱싱된 속성이 하나를 허용 합니다. 예를 들어 경우 변수 `myList` 참조 하는 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual basic에서) 3의 인덱스를 가진 요소를 검색 합니다. 속성을 재정의할 수 있습니다.  
  
 C#에서이 기능은 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어는 <xref:System.String> 라는 예 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성에는 사용자의 이름을 Item 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 확인 하려면는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 메서드를 테스트 하는 <xref:System.Reflection.DefaultMemberAttribute> 특성입니다. 형식에 있는 경우 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성 기본 속성의 이름을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 인수 형식과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 public 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 에 대 한 검색 `name` 대 소문자를 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 간단한 인덱싱된 속성에 액세스 하기 위한 구문을 사용 하 고 해당 형식에 대 한 기본 인덱싱된 속성이 하나를 허용 합니다. 예를 들어 경우 변수 `myList` 참조 하는 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual basic에서) 3의 인덱스를 가진 요소를 검색 합니다. 속성을 재정의할 수 있습니다.  
  
 C#에서이 기능은 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어는 <xref:System.String> 라는 예 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성에는 사용자의 이름을 Item 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 확인 하려면는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 메서드를 테스트 하는 <xref:System.Reflection.DefaultMemberAttribute> 특성입니다. 형식에 있는 경우 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예에서는 한 `Type` 개체에 해당 하 `MyPropertyClass`,이 클래스의 인덱싱된 속성에 전달 된 인수를 사용 하 여 검색 되는 `GetProperty` 메서드.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 인수 형식 및 수정자와 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 속성의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 공개 적어도 하나의 접근자 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic에서 사용 하 여 값을 결합 `Or`)를 가져오려고 합니다.  
  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성에 대해서만 검색 하는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 적절 한 형식 인수에 의해 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수이 메서드는 제네릭 형식 또는 제네릭 메서드 정의에 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 간단한 인덱싱된 속성에 액세스 하기 위한 구문을 사용 하 고 해당 형식에 대 한 기본 인덱싱된 속성이 하나를 허용 합니다. 예를 들어 경우 변수 `myList` 참조 하는 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual basic에서) 3의 인덱스를 가진 요소를 검색 합니다. 속성을 재정의할 수 있습니다.  
  
 C#에서이 기능은 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어는 <xref:System.String> 라는 예 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성에는 사용자의 이름을 Item 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 확인 하려면는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 메서드를 테스트 하는 <xref:System.Reflection.DefaultMemberAttribute> 특성입니다. 형식에 있는 경우 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성 기본 속성의 이름을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 속성의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
 또는  
  
 0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 멤버를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
 또는  
  
 인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers">
          <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> (의 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.  
  
-   지정 해야 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 포함 하도록 `public` 및 `protected` 정적 멤버를 계층 구조입니다. `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성에 대해서만 검색 하는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />인 경우</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />를 가져옵니다.</summary>
        <returns>현재 <see cref="T:System.Type" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식에 대한 어셈블리로 한정된 이름입니다. <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요. 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</param>
        <summary>대/소문자 구분 검색하여 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>지정된 이름의 형식이 있으면 이를 반환하고 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Type.GetType%2A> 를 얻는 메서드를 한 <xref:System.Type> 정규화 된 네임 스페이스 이름을 알고 있는 경우 다른 어셈블리의 형식에 대 한 개체입니다. <xref:System.Type.GetType%2A> 에 지정 된 어셈블리의 로드를 일으킵니다 `typeName`합니다. 사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여는 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드는 <xref:System.Reflection.Assembly> 가져올 클래스를 <xref:System.Type> 개체입니다. 이 C#에서 사용 하는 것이 효율적 컴파일 타임에 프로그램에 알려진 어셈블리에는 형식이 있는 경우 <xref:System.Type.GetType%2A> Visual basic에서 또는 c + +입니다.  
  
> [!NOTE]
>  경우 `typeName` 찾을 수 없는 경우에 대 한 호출에서 <xref:System.Type.GetType%28System.String%29> 메서드 반환 `null`합니다. 예외를 throw 하지 않습니다. 제어 하려면 여부 예외가, 호출의 오버 로드는 <xref:System.Type.GetType%2A> 변수가 있는 메서드에 `throwOnError` 매개 변수입니다.  
  
 <xref:System.Type.GetType%2A> 디스크에서 로드 된 어셈블리에 대해서만 작동 합니다. 호출 하는 경우 <xref:System.Type.GetType%2A> 를 사용 하 여 정의 하는 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스 일관 되지 않은 동작이 발생할 수 있습니다. 동작 인지에 따라 동적 어셈블리 영구, 즉, 사용 하 여 만든는 `RunAndSave` 또는 `Save` 액세스의 모드는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다. 동적 어셈블리 지속적이 고 전에 디스크에 기록 된 경우 `GetType` 은 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다. 어셈블리 경우 디스크에 저장 하지 않은 경우 `GetType` 메서드가 호출 될 `null`합니다. `GetType` 임시 동적 어셈블리; 인식할 수 없음 따라서 호출 `GetType` 동적 어셈블리에서 임시 형식을 검색할 반환 `null`합니다.  
  
 사용 하도록 `GetType` 동적 모듈에서 구독 하는 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에. 그렇지 않으면 해당 어셈블리의 두 복사본이 메모리에 발생 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 배열 또는 COM 형식을만 검색가 이미 사용 가능한 클래스의 테이블에 로드 되었습니다.  
  
 `typeName` 정규화 할 수 있습니다 형식 이름은 네임 스페이스 또는 사양을 포함 하는 어셈블리 이름을 정규화 된 어셈블리 이름입니다. <xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.  
  
 경우 `typeName` 네임 스페이스만 어셈블리 이름을 포함 합니다.이 메서드를 호출 하는 개체의 어셈블리와 Mscorlib.dll이 순서 대로 검색 합니다. 일부 또는 전체 어셈블리 이름으로 정규화 된 typeName 이면이 메서드는 지정된 된 어셈블리에 검색 합니다. 어셈블리에 강력한 이름이 있으면는 완전 한 어셈블리 이름이 필요 합니다.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 속성 중첩된 형식, 어셈블리 이름 및 제네릭 형식 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다. 공용 언어 런타임을 지 원하는 모든 컴파일러는 중첩 된 클래스의 단순한 이름을 내보내고 리플렉션에서 다음 규칙에 따라 쿼리 시 형식 표시 이름을 생성 합니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0의에서 프로세서 아키텍처 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어 "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에 포함 되지 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. 만들어 형식을 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체와의 적절 한 오버 로드에 전달 된 <xref:System.Reflection.Assembly.Load%2A> 메서드. 그런 다음 사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 메서드. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|역따옴표 (')|제네릭 형식의 이름 끝에 있는 형식 매개 변수 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.|  
|대괄호 ()|생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록 내에서 정규화 된 어셈블리 형식을 묶습니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
  
 예를 들어 클래스에 대 한 정규화 된 이름을 다음과 같이 표시 될 수 있습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 이스케이프 문자는 더하기 기호 (+) 해야 합니다 (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션 다음과 같이이 문자열을 내보냅니다.  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "+ +"가 "\\+\\+", 및 "\\"가 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데 사용 된 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리의 정규화 된 형식 이름으로 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식으로 이름을 찾을 것은 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서 합니다. <xref:System.Type.GetType%2A> 어셈블리와 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름에는 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자가 포함 될 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공백은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 연결 합니다. 어셈블리 이름에 ',' 구분 기호 앞에 공백이 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 이름은 억음 악센트 기호로 끝납니다 (\`) 제네릭 형식 인수 개수를 나타내는 숫자가 차례로 표시 합니다. 이 이름 관리의 목적은 제네릭 형식을 지원 형식 매개 변수의 수가 달라 하지만 같은 이름의 동일한 범위에서 발생 하는 컴파일러에서 허용 하는 것입니다. 리플렉션 형식 표시 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 및 `Tuple(Of T0, T1)` Visual basic에서 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#입니다.  
  
 제네릭 형식에 대 한 형식 인수 목록이 대괄호로 묶이며 형식 인수는 쉼표로 구분 합니다. 예를 들어, 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다. A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 유형의 키를 가진 <xref:System.String> 다음과 같이 표현 될 수 있습니다.  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 형식 인수 목록 내에서 정규화 된 어셈블리 형식을 지정 하려면 정규화 된 어셈블리 형식을 대괄호로 묶습니다. 그렇지 않으면 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표로 구분 하는 추가 형식 인수로 해석 됩니다. 예를 들어는 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 유형의 키를 가진 fromMyAssembly.dll <xref:System.String>, 다음과 같이 지정할 수 있습니다.  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  형식 매개 변수 목록에 나타나는 경우에 정규화 된 어셈블리 형식은 대괄호로 묶을 수 있습니다. 형식 매개 변수 목록에서 정규화 형식에 대 한 어셈블리에서 검색 규칙은 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.  
  
 Null 허용 유형은 제네릭 형식의 특별 한 경우입니다. 예를 들어, null 허용 <xref:System.Int32> 문자열 "System.Nullable'1[System.Int32]"으로 표시 됩니다.  
  
> [!NOTE]
>  C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 얻을 수 있습니다. 예를 들어, null 허용 <xref:System.Boolean> 에서 형식을 반환 `typeof(Nullable<bool>)` C#에서는 여 `Nullable<Boolean>::typeid` 및 c + +에서는 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.  
  
 다음 표에서 함께 사용 하면 구문을 보여 줍니다. `GetType` 다양 한 형식에 대 한 합니다.  
  
|가져오려는|사용|  
|------------|---------|  
|Null 허용 <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType*")`|  
|에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType**")`|  
|관리 되는 포인터 또는 참조 `MyType`|`Type.GetType("MyType&")`. 포인터와 달리 참조는 한 수준으로 제한됩니다.|  
|부모 클래스와 중첩된 된 클래스|`Type.GetType("MyParentClass+MyNestedClass")`|  
|0 인 1 차원 배열|`Type.GetType("MyType[]")`|  
|알 수 없는 하한값 있는 1 차원 배열|`Type.GetType("MyType[*]")`|  
|N 차원 배열|총 n-1 번 대괄호 안에 쉼표 (,)입니다. 예를 들어 `System.Object[,,]` 나타냅니다는 3 차원 `Object` 배열입니다.|  
|1 차원 배열의 배열|`Type.GetType("MyType[][]")`|  
|알 수 없는 하 한을 가진 사각형 2 차원 배열|`Type.GetType("MyType[,]")`|  
|한 형식 인수가 있는 제네릭 형식|`Type.GetType("MyGenericType`1[MyType]")`|  
|두 형식 인수가 있는 제네릭 형식|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|두 개의 어셈블리로 한정 된 형식 인수로 제네릭 형식|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|어셈블리의 정규화 된 형식 인수가 지정 된 어셈블리의 정규화 된 제네릭 형식|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|두 개의 형식 인수로 제네릭 형식이 형식 인수는 제네릭 형식|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 다음 예제에서는의 유형을 검색 `System.Int32` 형식 개체를 사용 하 여 표시 하 고는 <xref:System.Type.FullName%2A> 속성 `System.Int32`합니다.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>  
  
 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식에 대한 어셈블리로 한정된 이름입니다. <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요. 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</param>
        <param name="throwOnError">
          형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <summary>대/소문자를 구분하여 검색하고 형식이 없으면 예외를 throw할지를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Type.GetType%2A> 를 얻는 메서드를 한 <xref:System.Type> 해당 정규화 된 네임 스페이스 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체입니다. <xref:System.Type.GetType%2A> 에 지정 된 어셈블리의 로드를 일으킵니다 `typeName`합니다. 사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여는 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드는 <xref:System.Reflection.Assembly> 가져올 클래스를 <xref:System.Type> 개체입니다. 컴파일 타임에 프로그램에 알려진 어셈블리에는 형식이 있는 경우는 보다 효율적으로 사용할 `typeof` C#에서는 <xref:System.Type.GetType%2A> Visual basic에서 또는 `typeid` c + +에서입니다.  
  
 `GetType` 디스크에서 로드 된 어셈블리에 대해서만 작동 합니다. 호출 하는 경우 `GetType` 를 사용 하 여 정의 하는 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스 일관 되지 않은 동작이 발생할 수 있습니다. 동작 인지에 따라 동적 어셈블리 영구, 즉, 사용 하 여 만든는 `RunAndSave` 또는 `Save` 액세스의 모드는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다. 동적 어셈블리 지속적이 고 전에 디스크에 기록 된 경우 `GetType` 은 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다. 어셈블리 경우 디스크에 저장 하지 않은 경우 `GetType` 메서드가 호출 될 `null`합니다. `GetType` 임시 동적 어셈블리; 인식할 수 없음 따라서 호출 `GetType` 동적 어셈블리에서 임시 형식을 검색할 반환 `null`합니다.  
  
 사용 하도록 `GetType` 동적 모듈에서 구독 하는 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에. 그렇지 않으면 해당 어셈블리의 두 복사본이 메모리에 발생 합니다.  
  
 `throwOnError` 때 일어나는 발견 되지 않으면 형식과 특정 한 다른 예외 조건을 표시 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다. 값에 관계 없이 몇 가지 예외가 throw 된 `throwOnError`합니다. 예를 들어 형식을 찾았지만 로드할 수 없는 경우는 <xref:System.TypeLoadException> throw 되 경우에 `throwOnError` 은 `false`합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 배열 또는 COM 형식을만 검색가 이미 사용 가능한 클래스의 테이블에 로드 되었습니다.  
  
 `typeName` 정규화 할 수 있습니다 형식 이름은 네임 스페이스 또는 사양을 포함 하는 어셈블리 이름을 정규화 된 어셈블리 이름입니다. <xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.  
  
 경우 `typeName` 네임 스페이스만 어셈블리 이름을 포함 합니다.이 메서드를 호출 하는 개체의 어셈블리와 Mscorlib.dll이 순서 대로 검색 합니다. 일부 또는 전체 어셈블리 이름으로 정규화 된 typeName 이면이 메서드는 지정된 된 어셈블리에 검색 합니다. 어셈블리에 강력한 이름이 있으면는 완전 한 어셈블리 이름이 필요 합니다.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 속성 중첩된 형식, 어셈블리 이름 및 제네릭 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다. 공용 언어 런타임을 지 원하는 모든 컴파일러는 중첩 된 클래스의 단순한 이름을 내보내고 리플렉션에서 다음 규칙에 따라 쿼리 시 형식 표시 이름을 생성 합니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0의에서 프로세서 아키텍처 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어 "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에 포함 되지 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. 만들어 형식을 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체와의 적절 한 오버 로드에 전달 된 <xref:System.Reflection.Assembly.Load%2A> 메서드. 그런 다음 사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 메서드. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|역따옴표 (')|제네릭 형식의 이름 끝에 있는 형식 매개 변수 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.|  
|대괄호 ()|생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록 내에서 정규화 된 어셈블리 형식을 묶습니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
  
 예를 들어 클래스에 대 한 정규화 된 이름을 다음과 같이 표시 될 수 있습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 이스케이프 문자는 더하기 기호 (+) 해야 합니다 (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션 다음과 같이이 문자열을 내보냅니다.  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "+ +"가 "\\+\\+", 및 "\\"가 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데 사용 된 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리의 정규화 된 형식 이름으로 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식으로 이름을 찾을 것은 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서 합니다. <xref:System.Type.GetType%2A> 어셈블리와 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름에는 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자가 포함 될 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공백은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 연결 합니다. 어셈블리 이름에 ',' 구분 기호 앞에 공백이 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 이름은 억음 악센트 기호로 끝납니다 (\`) 제네릭 형식 인수 개수를 나타내는 숫자가 차례로 표시 합니다. 이 이름 관리의 목적은 제네릭 형식을 지원 형식 매개 변수의 수가 달라 하지만 같은 이름의 동일한 범위에서 발생 하는 컴파일러에서 허용 하는 것입니다. 리플렉션 형식 표시 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 및 `Tuple(Of T0, T1)` Visual basic에서 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#입니다.  
  
 제네릭 형식에 대 한 형식 인수 목록이 대괄호로 묶이며 형식 인수는 쉼표로 구분 합니다. 예를 들어, 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다. A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 유형의 키를 가진 <xref:System.String> 다음과 같이 표현 될 수 있습니다.  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 형식 인수 목록 내에서 정규화 된 어셈블리 형식을 지정 하려면 정규화 된 어셈블리 형식을 대괄호로 묶습니다. 그렇지 않으면 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표로 구분 하는 추가 형식 인수로 해석 됩니다. 예를 들어 한 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 유형의 키를 가진 MyAssembly.dll에서 <xref:System.String>, 다음과 같이 지정할 수 있습니다.  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  형식 매개 변수 목록에 나타나는 경우에 정규화 된 어셈블리 형식은 대괄호로 묶을 수 있습니다. 형식 매개 변수 목록에서 정규화 형식에 대 한 어셈블리에서 검색 규칙은 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.  
  
 Null 허용 유형은 제네릭 형식의 특별 한 경우입니다. 예를 들어, null 허용 <xref:System.Int32> 문자열 "System.Nullable'1[System.Int32]"으로 표시 됩니다.  
  
> [!NOTE]
>  C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 얻을 수 있습니다. 예를 들어, null 허용 <xref:System.Boolean> 에서 형식을 반환 `typeof(Nullable<bool>)` C#에서는 여 `Nullable<Boolean>::typeid` 및 c + +에서는 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.  
  
 다음 표에서 함께 사용 하면 구문을 보여 줍니다. `GetType` 다양 한 형식에 대 한 합니다.  
  
|가져오려는|사용|  
|------------|---------|  
|Null 허용 <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType*")`|  
|에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType**")`|  
|관리 되는 포인터 또는 참조 `MyType`|`Type.GetType("MyType&")`. 포인터와 달리 참조는 한 수준으로 제한됩니다.|  
|부모 클래스와 중첩된 된 클래스|`Type.GetType("MyParentClass+MyNestedClass")`|  
|0 인 1 차원 배열|`Type.GetType("MyArray[]")`|  
|알 수 없는 하한값 있는 1 차원 배열|`Type.GetType("MyArray[*]")`|  
|N 차원 배열|총 n-1 번 대괄호 안에 쉼표 (,)입니다. 예를 들어 `System.Object[,,]` 나타냅니다는 3 차원 `Object` 배열입니다.|  
|2 차원 배열은 배열|`Type.GetType("MyArray[][]")`|  
|알 수 없는 하 한을 가진 사각형 2 차원 배열|`Type.GetType("MyArray[,]")`|  
|한 형식 인수가 있는 제네릭 형식|`Type.GetType("MyGenericType`1[MyType]")`|  
|두 형식 인수가 있는 제네릭 형식|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|두 개의 어셈블리로 한정 된 형식 인수로 제네릭 형식|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|어셈블리의 정규화 된 형식 인수가 지정 된 어셈블리의 정규화 된 제네릭 형식|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|두 개의 형식 인수로 제네릭 형식이 형식 인수는 제네릭 형식|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 다음 예제에서는의 유형을 검색 `System.Int32` 형식 개체를 사용 하 여 표시 하 고는 <xref:System.Type.FullName%2A> 속성 `System.Int32`합니다. 형식 개체 존재 하지 않는 어셈블리를 가리키는 경우이 예제에서는 예외를 throw 합니다.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문을 포함합니다. 예를 들어 "MyType[,*,]"입니다.  
  
 또는  
  
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 [Windows 스토어 앱용 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 또는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>  
  
 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식에 대한 어셈블리로 한정된 이름입니다. <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요. 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</param>
        <param name="throwOnError">
          형식을 찾을 수 없어 예외를 throw하는 경우 <see langword="true" />이고 <see langword="false" />를 반환하는 경우 <see langword="null" />입니다. <see langword="false" />를 지정하면 일부 다른 예외 조건을 표시하지 않지만 모두 그렇지는 않습니다. 예외 섹션을 참조하세요.</param>
        <param name="ignoreCase">
          <c>typeName</c>에 대해 대/소문자를 구분하지 않는 검색을 수행하려면 <see langword="true" />이고, <c>typeName</c>에 대해 대/소문자를 구분하는 검색을 수행하려면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 구분하여 검색할지 여부와 형식이 없으면 예외를 throw할지 여부를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Type.GetType%2A> 를 얻는 메서드를 한 <xref:System.Type> 해당 정규화 된 네임 스페이스 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체입니다. <xref:System.Type.GetType%2A> 에 지정 된 어셈블리의 로드를 일으킵니다 `typeName`합니다. 사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여는 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드는 <xref:System.Reflection.Assembly> 가져올 클래스를 <xref:System.Type> 개체입니다. 컴파일 타임에 프로그램에 알려진 어셈블리에는 형식이 있는 경우는 보다 효율적으로 사용할 `typeof` C#에서는 <xref:System.Type.GetType%2A> Visual basic에서 또는 `typeid` c + +에서입니다.  
  
 `GetType` 디스크에서 로드 된 어셈블리에 대해서만 작동 합니다. 호출 하는 경우 `GetType` 를 사용 하 여 정의 하는 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스 일관 되지 않은 동작이 발생할 수 있습니다. 동작 인지에 따라 동적 어셈블리 영구, 즉, 사용 하 여 만든는 `RunAndSave` 또는 `Save` 액세스의 모드는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다. 동적 어셈블리 지속적이 고 전에 디스크에 기록 된 경우 `GetType` 은 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다. 어셈블리 경우 디스크에 저장 하지 않은 경우 `GetType` 메서드가 호출 될 `null`합니다. `GetType` 임시 동적 어셈블리; 인식할 수 없음 따라서 호출 `GetType` 동적 어셈블리에서 임시 형식을 검색할 반환 `null`합니다.  
  
 사용 하도록 `GetType` 동적 모듈에서 구독 하는 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에. 그렇지 않으면 해당 어셈블리의 두 복사본이 메모리에 발생 합니다.  
  
 `throwOnError` 때 일어나는 발견 되지 않으면 형식과 특정 한 다른 예외 조건을 표시 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다. 값에 관계 없이 몇 가지 예외가 throw 된 `throwOnError`합니다. 예를 들어 형식을 찾았지만 로드할 수 없는 경우는 <xref:System.TypeLoadException> throw 되 경우에 `throwOnError` 은 `false`합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드는 형식에 반영 하는 경우.  
  
|멤버 형식|정적|비정적|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명 하 여 숨겨집니다.|  
|이벤트(event)|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름으로 숨기기 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 구문과 같습니다 된다는 점입니다. 리플렉션 속성 이름 및 서명으로 숨기기 구조체로 처리 합니다. 다음의 참고 2 참조 하십시오.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  속성 및 이벤트는 리플렉션을 위해 이름 및 서명으로 숨기기는 합니다. 기본 클래스에는 get 및 set 접근자를 모두 포함 하는 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성 기본 클래스 속성이 숨겨지고 설정자 기본 클래스에 액세스할 수 없습니다.  
  
3.  사용자 지정 특성은 공용 형식 시스템의 일부가 아닙니다.  
  
 배열 또는 COM 형식을만 검색가 이미 사용 가능한 클래스의 테이블에 로드 되었습니다.  
  
 `typeName` 정규화 할 수 있습니다 형식 이름은 네임 스페이스 또는 사양을 포함 하는 어셈블리 이름을 정규화 된 어셈블리 이름입니다. <xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.  
  
 경우 `typeName` 네임 스페이스만 어셈블리 이름을 포함 합니다.이 메서드를 호출 하는 개체의 어셈블리와 Mscorlib.dll이 순서 대로 검색 합니다. 일부 또는 전체 어셈블리 이름으로 정규화 된 typeName 이면이 메서드는 지정된 된 어셈블리에 검색 합니다. 어셈블리에 강력한 이름이 있으면는 완전 한 어셈블리 이름이 필요 합니다.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 속성 중첩된 형식, 어셈블리 이름 및 형식 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다. 공용 언어 런타임을 지 원하는 모든 컴파일러는 중첩 된 클래스의 단순한 이름을 내보내고 리플렉션에서 다음 규칙에 따라 쿼리 시 형식 표시 이름을 생성 합니다.  
  
> [!NOTE]
>  .NET Framework 버전 2.0의에서 프로세서 아키텍처 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어 "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에 포함 되지 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. 만들어 형식을 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체와의 적절 한 오버 로드에 전달 된 <xref:System.Reflection.Assembly.Load%2A> 메서드. 그런 다음 사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 메서드. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|역따옴표 (')|제네릭 형식의 이름 끝에 있는 형식 매개 변수 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.|  
|대괄호 ()|생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록 내에서 정규화 된 어셈블리 형식을 묶습니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
  
 예를 들어 클래스에 대 한 정규화 된 이름을 다음과 같이 표시 될 수 있습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 이스케이프 문자는 더하기 기호 (+) 해야 합니다 (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션 다음과 같이이 문자열을 내보냅니다.  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "+ +"가 "\\+\\+", 및 "\\"가 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데 사용 된 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리의 정규화 된 형식 이름으로 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식으로 이름을 찾을 것은 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서 합니다. <xref:System.Type.GetType%2A> 어셈블리와 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름에는 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자가 포함 될 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공백은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 연결 합니다. 어셈블리 이름에 ',' 구분 기호 앞에 공백이 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 이름은 억음 악센트 기호로 끝납니다 (\`) 제네릭 형식 인수 개수를 나타내는 숫자가 차례로 표시 합니다. 이 이름 관리의 목적은 제네릭 형식을 지원 형식 매개 변수의 수가 달라 하지만 같은 이름의 동일한 범위에서 발생 하는 컴파일러에서 허용 하는 것입니다. 리플렉션 형식 표시 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 및 `Tuple(Of T0, T1)` Visual basic에서 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#입니다.  
  
 제네릭 형식에 대 한 형식 인수 목록이 대괄호로 묶이며 형식 인수는 쉼표로 구분 합니다. 예를 들어, 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다. A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 유형의 키를 가진 <xref:System.String> 다음과 같이 표현 될 수 있습니다.  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 형식 인수 목록 내에서 정규화 된 어셈블리 형식을 지정 하려면 정규화 된 어셈블리 형식을 대괄호로 묶습니다. 그렇지 않으면 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표로 구분 하는 추가 형식 인수로 해석 됩니다. 예를 들어 한 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 유형의 키를 가진 MyAssembly.dll에서 <xref:System.String>, 다음과 같이 지정할 수 있습니다.  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  형식 매개 변수 목록에 나타나는 경우에 정규화 된 어셈블리 형식은 대괄호로 묶을 수 있습니다. 형식 매개 변수 목록에서 정규화 형식에 대 한 어셈블리에서 검색 규칙은 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.  
  
 Null 허용 유형은 제네릭 형식의 특별 한 경우입니다. 예를 들어, null 허용 <xref:System.Int32> 문자열 "System.Nullable'1[System.Int32]"으로 표시 됩니다.  
  
> [!NOTE]
>  C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 얻을 수 있습니다. 예를 들어, null 허용 <xref:System.Boolean> 에서 형식을 반환 `typeof(Nullable<bool>)` C#에서는 여 `Nullable<Boolean>::typeid` 및 c + +에서는 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.  
  
 다음 표에서 함께 사용 하면 구문을 보여 줍니다. `GetType` 다양 한 형식에 대 한 합니다.  
  
|가져오려는|사용|  
|------------|---------|  
|Null 허용 <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType*")`|  
|에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType**")`|  
|관리 되는 포인터 또는 참조 `MyType`|`Type.GetType("MyType&")`. 포인터와 달리 참조는 한 수준으로 제한됩니다.|  
|부모 클래스와 중첩된 된 클래스|`Type.GetType("MyParentClass+MyNestedClass")`|  
|0 인 1 차원 배열|`Type.GetType("MyArray[]")`|  
|알 수 없는 하한값 있는 1 차원 배열|`Type.GetType("MyArray[*]")`|  
|N 차원 배열|총 n-1 번 대괄호 안에 쉼표 (,)입니다. 예를 들어 `System.Object[,,]` 나타냅니다는 3 차원 `Object` 배열입니다.|  
|2 차원 배열은 배열|`Type.GetType("MyArray[][]")`|  
|알 수 없는 하 한을 가진 사각형 2 차원 배열|`Type.GetType("MyArray[,]")`|  
|한 형식 인수가 있는 제네릭 형식|`Type.GetType("MyGenericType`1[MyType]")`|  
|두 형식 인수가 있는 제네릭 형식|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|두 개의 어셈블리로 한정 된 형식 인수로 제네릭 형식|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|어셈블리의 정규화 된 형식 인수가 지정 된 어셈블리의 정규화 된 제네릭 형식|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|두 개의 형식 인수로 제네릭 형식이 형식 인수는 제네릭 형식|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문을 포함합니다. 예를 들어 "MyType[,*,]"입니다.  
  
 또는  
  
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식의 이름입니다. <c>typeResolver</c> 매개 변수가 제공되는 경우 형식 이름은 <c>typeResolver</c>에서 확인 가능한 임의의 문자열일 수 있습니다. <c>assemblyResolver</c> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <c>typeName</c>은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</param>
        <param name="assemblyResolver">
          <c>typeName</c>에 지정된 어셈블리를 찾고 반환하는 메서드입니다. 어셈블리 이름이 <c>assemblyResolver</c>에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다. <c>typeName</c>에 어셈블리의 이름이 포함되어 있지 않으면 <c>assemblyResolver</c>가 호출되지 않습니다. <c>assemblyResolver</c>가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.  
  
 주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오. 그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.</param>
        <param name="typeResolver">
          <c>assemblyResolver</c> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <c>typeName</c>에 지정된 형식을 찾고 반환하는 메서드입니다. 어셈블리가 제공되지 않는 경우 <c>typeResolver</c> 메서드에서 어셈블리를 제공할 수 있습니다. 이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <see langword="false" />가 전달됩니다.  
  
 주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</param>
        <summary>어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</summary>
        <returns>지정된 이름을 가진 형식이거나, 형식이 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법에 대 한 정보에 대 한 사용 시나리오는 `assemblyResolver` 및 `typeResolver` 에서 매개 변수를 찾을 수 있습니다는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  경우 `typeName` 찾을 수 없는 경우에 대 한 호출에서 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 메서드 반환 `null`합니다. 예외를 throw 하지 않습니다. 제어 하려면 여부 예외가, 호출의 오버 로드는 <xref:System.Type.GetType%2A> 변수가 있는 메서드에 `throwOnError` 매개 변수입니다.  
  
 이이 메서드 오버 로드는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 하 `false` 에 대 한는 `throwOnError` 및 `ignoreCase` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외를 throw합니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 형식 이름과 어셈블리 이름(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자를 포함하는 경우)에 구문 분석할 때 오류가 발생합니다.  
  
 또는  
  
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.  
  
 또는  
  
 <paramref name="typeName" />에 잘못된 어셈블리 이름이 포함되어 있습니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 이름이 없는 유효한 어셈블리 이름입니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
 또는  
  
 어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식의 이름입니다. <c>typeResolver</c> 매개 변수가 제공되는 경우 형식 이름은 <c>typeResolver</c>에서 확인 가능한 임의의 문자열일 수 있습니다. <c>assemblyResolver</c> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <c>typeName</c>은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</param>
        <param name="assemblyResolver">
          <c>typeName</c>에 지정된 어셈블리를 찾고 반환하는 메서드입니다. 어셈블리 이름이 <c>assemblyResolver</c>에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다. <c>typeName</c>에 어셈블리의 이름이 포함되어 있지 않으면 <c>assemblyResolver</c>가 호출되지 않습니다. <c>assemblyResolver</c>가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.  
  
 주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오. 그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.</param>
        <param name="typeResolver">
          <c>assemblyResolver</c> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <c>typeName</c>에 지정된 형식을 찾고 반환하는 메서드입니다. 어셈블리가 제공되지 않는 경우 이 메서드에서 어셈블리를 제공할 수 있습니다. 이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <see langword="false" />가 전달됩니다.  
  
 주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</param>
        <param name="throwOnError">
          형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <summary>형식을 찾을 수 없는 경우 예외를 throw할지를 지정하고 어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법에 대 한 정보에 대 한 사용 시나리오는 `assemblyResolver` 및 `typeResolver` 에서 매개 변수를 찾을 수 있습니다는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
 이이 메서드 오버 로드는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 하 `false` 에 대 한는 `ignoreCase` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 형식 이름과 어셈블리 이름(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자를 포함하는 경우)에 구문 분석할 때 오류가 발생합니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />에 잘못된 구문이 포함된 경우(예: "MyType[,*,]").  
  
 또는  
  
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="typeName" />에 잘못된 어셈블리 이름이 포함되어 있습니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 이름이 없는 유효한 어셈블리 이름입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
 또는  
  
 어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식의 이름입니다. <c>typeResolver</c> 매개 변수가 제공되는 경우 형식 이름은 <c>typeResolver</c>에서 확인 가능한 임의의 문자열일 수 있습니다. <c>assemblyResolver</c> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <c>typeName</c>은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</param>
        <param name="assemblyResolver">
          <c>typeName</c>에 지정된 어셈블리를 찾고 반환하는 메서드입니다. 어셈블리 이름이 <c>assemblyResolver</c>에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다. <c>typeName</c>에 어셈블리의 이름이 포함되어 있지 않으면 <c>assemblyResolver</c>가 호출되지 않습니다. <c>assemblyResolver</c>가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.  
  
 주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오. 그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.</param>
        <param name="typeResolver">
          <c>assemblyResolver</c> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <c>typeName</c>에 지정된 형식을 찾고 반환하는 메서드입니다. 어셈블리가 제공되지 않는 경우 이 메서드에서 어셈블리를 제공할 수 있습니다. 이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <c>ignoreCase</c>의 값이 전달됩니다.  
  
 주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</param>
        <param name="throwOnError">
          형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <param name="ignoreCase">
          <c>typeName</c>에 대해 대/소문자를 구분하지 않는 검색을 수행하려면 <see langword="true" />이고, <c>typeName</c>에 대해 대/소문자를 구분하는 검색을 수행하려면 <see langword="false" />입니다.</param>
        <summary>형식을 찾을 수 없는 경우 대/소문자를 구분하는 검색을 수행할지 여부 및 예외를 throw할지를 지정하고 어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드 및 연결 된 오버 로드를 사용 하 여 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 및 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>)의 기본 구현을 바꿀는 <xref:System.Type.GetType%2A> 보다 유연한 구현으로 메서드. 형식 이름 및 포함 된 어셈블리의 이름을 확인 하는 사용자 고유의 메서드를 제공 하 여 다음을 수행할 수 있습니다.  
  
-   형식에서 로드 되는 어셈블리의 버전을 제어 합니다.  
  
-   찾을 어셈블리 이름을 포함 하지 않는 형식 이름에 대해 다른 위치를 제공 합니다.  
  
-   부분 어셈블리 이름을 사용 하 여 어셈블리를 로드 합니다.  
  
-   서브 클래스를 반환 <xref:System.Type?displayProperty=nameWithType> 공용 언어 런타임 (CLR)에서 만들어지지 않습니다.  
  
 예를 들어 버전 독립적 serialization에이 메서드를 사용 하면 "가장 적합 한" 어셈블리에 대 한 이름의 일부를 사용 하 여 검색할 수 있습니다. 다른 오버 로드는 <xref:System.Type.GetType%2A> 방법은 버전 번호를 포함 하는 정규화 된 어셈블리 형식 이름을 필요 합니다.  
  
 형식 시스템의 다른 구현과의 서브 클래스를 반환 해야 할 수 <xref:System.Type?displayProperty=nameWithType> CLR에서 만들어지지 않은; 유형의 모든의 다른 오버 로드에서 반환 되는 <xref:System.Type.GetType%2A> 메서드는 런타임 형식입니다.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>사용 정보  
 이 메서드 오버 로드 및 연결 된 오버 로드의 구문 분석 `typeName` 는 어셈블리의 이름 및 형식 이름으로 한 다음 이름을 확인 합니다. 어셈블리 이름 확인 어셈블리의 컨텍스트에서 형식 이름을 확인 해야 하기 때문에 형식 이름 확인 하기 전에 발생 합니다.  
  
> [!NOTE]
>  정규화 된 어셈블리 형식 이름에 대 한 개념을 잘 모르는 경우 참조는 <xref:System.Type.AssemblyQualifiedName%2A> 속성입니다.  
  
 경우 `typeName` 이름이 아닙니다. 정규화 된 어셈블리, 어셈블리 확인을 건너뜁니다. Mscorlib.dll 또는 현재 실행 중인 어셈블리의 컨텍스트에서 정규화 되지 않은 형식 이름을 확인할 수 있습니다 또는에서 어셈블리를 선택적으로 제공할 수는 `typeResolver` 매개 변수입니다. 포함 하거나 다른 종류의 이름 확인에 테이블로 표시 된 어셈블리 이름을 생략 효과 [혼합 된 이름 확인](#mixed_name_resolution) 섹션.  
  
 일반적인 사용법 정보:  
  
-   메서드를 통과 하지 못한 `assemblyResolver` 또는 `typeResolver` 알 수 없거나 신뢰할 수 없는 호출자에서 온 경우. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.  
  
    > [!CAUTION]
    >  알 수 없거나 신뢰할 수 없는 호출자의 메서드를 사용 하 여 악성 코드에 대 한 권한 상승 될 수 있습니다.  
  
-   생략 하면는 `assemblyResolver` 및/또는 `typeResolver` 값, 매개 변수는 `throwOnError` 매개 변수는 기본 확인을 수행 하는 메서드에 전달 됩니다.  
  
-   경우 `throwOnError` 은 `true`,이 메서드에서 throw 한 <xref:System.TypeLoadException> 때 `typeResolver` 반환 `null`, 및 <xref:System.IO.FileNotFoundException> 때 `assemblyResolver` 반환 `null`합니다.  
  
-   이 메서드에 의해 throw 된 예외를 catch 하지 않습니다 `assemblyResolver` 및 `typeResolver`합니다. 확인자 메서드에 의해 throw 되는 모든 예외에 책임이 있습니다.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>어셈블리 확인  
 `assemblyResolver` 메서드 수신는 <xref:System.Reflection.AssemblyName> 개체에 포함 된 어셈블리 이름 문자열을 구문 분석 하 여 생성 되는 `typeName`합니다. 경우 `typeName` 는 어셈블리 이름을 포함 하지 않는 `assemblyResolver` 호출 되지 않습니다 및 `null` 에 전달 `typeResolver`합니다.  
  
 경우 `assemblyResolver` 가 되지 않으면 표준 어셈블리를 제공 된 조사는 어셈블리를 찾는 데 사용 합니다. 경우 `assemblyResolver` 제공 됩니다는 <xref:System.Type.GetType%2A> 메서드는 표준 조사를 수행 하지 않습니다;이 경우 확인 해야 하면 `assemblyResolver` 를 전달 하는 모든 어셈블리를 처리할 수 있습니다.  
  
 `assemblyResolver` 메서드를 반환 하도록 `null` 어셈블리를 확인할 수 없는 경우. 경우 `assemblyResolver` 반환 `null`, `typeResolver` 호출 되지 않습니다 추가 처리 없이 발생 합니다 또한; 경우 `throwOnError` 은 `true`, <xref:System.IO.FileNotFoundException> throw 됩니다.  
  
 경우는 <xref:System.Reflection.AssemblyName> 에 전달 되는 `assemblyResolver` 이 부분 이름, 하나 이상의 해당 부분의 `null`합니다. 예를 들어, 버전이 없는 경우는 <xref:System.Reflection.AssemblyName.Version%2A> 속성은 `null`합니다. 경우는 <xref:System.Reflection.AssemblyName.Version%2A> 속성을는 <xref:System.Reflection.AssemblyName.CultureInfo%2A> 속성을 및 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> 메서드가 모두 반환 `null`, 어셈블리의 단순한 이름을 제공 합니다. `assemblyResolver` 메서드 사용 하거나 어셈블리 이름의 모든 부분을 무시할 수 있습니다.  
  
 다른 어셈블리 확인 옵션의 효과에 테이블로 표시 됩니다는 [혼합 된 이름 확인](#mixed_name_resolution) 섹션 간단 하 고 정규화 된 어셈블리 형식 이름입니다.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>형식 확인  
 경우 `typeName` 어셈블리 이름을 지정 하지 않는 `typeResolver` 가 항상 호출 합니다. 경우 `typeName` 어셈블리 이름 지정 `typeResolver` 어셈블리 이름이 성공적으로 확인 되는 경우에 호출 됩니다. 경우 `assemblyResolver` 또는 표준 어셈블리 반환 검색 `null`, `typeResolver` 호출 되지 않습니다.  
  
 `typeResolver` 메서드 3 개 인수를 받습니다.  
  
-   검색 어셈블리 또는 `null` 경우 `typeName` 어셈블리 이름을 포함 하지 않습니다.  
  
-   단순한 이름 형식입니다. 중첩된 된 형식의 경우이 포함 하는 가장 바깥쪽 형식입니다. 제네릭 형식의 경우 제네릭 형식의 단순한 이름입니다.  
  
-   부울 값이 `true` 형식 이름의 대/소문자가 구분 되지 않을 경우.  
  
 구현에는 이러한 인수를 사용 하는 방법을 결정 합니다. `typeResolver` 메서드를 반환 하도록 `null` 유형을 확인할 수 없는 경우. 경우 `typeResolver` 반환 `null` 및 `throwOnError` 은 `true`,이 오버 로드의 <xref:System.Type.GetType%2A> throw 한 <xref:System.TypeLoadException>합니다.  
  
 다른 형식 확인 옵션의 효과에 테이블로 표시 됩니다는 [혼합 된 이름 확인](#mixed_name_resolution) 섹션 간단 하 고 정규화 된 어셈블리 형식 이름입니다.  
  
#### <a name="resolving-nested-types"></a>중첩된 형식 확인  
 경우 `typeName` 는 중첩 형식이 가장 바깥쪽의 이름만 포함 하는 형식에 전달 되 `typeResolver`합니다. 때 `typeResolver` 이 형식을 반환 된 <xref:System.Type.GetNestedType%2A> 메서드는 가장 안쪽 중첩된 형식을 해결 될 때까지 재귀적으로 호출 됩니다.  
  
#### <a name="resolving-generic-types"></a>제네릭 형식 확인  
 <xref:System.Type.GetType%2A> 재귀적으로 제네릭 형식을 확인 하기 위해 호출 됩니다: 제네릭 형식 자체를 해결 하려면 먼저 해당 형식 인수를 해결 하려면 다음 합니다. 형식 인수가 일반, <xref:System.Type.GetType%2A> 그 형식 인수를 해결 하는 재귀적으로 호출 됩니다.  
  
 조합의 `assemblyResolver` 및 `typeResolver` 모든 수준의이 재귀를 확인할 수 반드시 제공 해야 합니다. 예를 들어, 제공 하는 `assemblyResolver` 의 로드를 제어 하는 `MyAssembly`합니다. 제네릭 형식을 확인 하려는 경우 다음과 같이 `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` Visual basic에서). 다음과 같은 제네릭 형식 이름을 전달할 수도 있습니다.  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 다음에 유의 `MyType` 어셈블리를 한정 된 형식 인수입니다. 이름을 <xref:System.Collections.Generic.Dictionary%602> 및 <xref:System.String> 클래스 정규화 된 어셈블리는 없습니다. 프로그램 `typeResolver` 어셈블리 처리할 수 있어야 하거나 `null`받으므로, `null` 에 대 한 <xref:System.Collections.Generic.Dictionary%602> 및 <xref:System.String>합니다. 오버 로드를 호출 하 여 해당 사례를 처리할 수는 <xref:System.Type.GetType%2A> 정규화 되지 않은 형식 이름의 둘 다 Mscorlib.dll에 때문에 문자열을 사용 하는 메서드:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` 없기 때문에 이러한 형식 이름은 정규화 된 어셈블리 사전 형식 및 문자열 형식에 대 한 메서드가 호출 되지 않습니다.  
  
 이제 대신 가정 `System.String`, 첫 번째 제네릭 인수 형식이 `YourType`에서 `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 이 어셈블리가 Mscorlib.dll 또는 현재 실행 중인 있으므로 해결할 수 없는 `YourType` 정규화 된 어셈블리 이름이 없는 합니다. 때문에 프로그램 `assemblyResolve` 됩니다 재귀적으로 호출, 있어야이 경우를 처리 하 합니다. 반환 하는 대신 `null` 이외의 어셈블리에 대해 `MyAssembly`, 제공 된를 사용 하 여 어셈블리 로드를 지금 수행 <xref:System.Reflection.AssemblyName> 개체입니다.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 다시 [사용 정보](#usage_notes)합니다.  
  
#### <a name="resolving-type-names-with-special-characters"></a>특수 문자를 사용한 형식 이름 확인  
 특정 문자 어셈블리의 정규화 된 이름에서 특별 한 의미를 갖습니다. 이러한 문자를 포함 하는 단순 형식 이름, 단순한 이름 정규화 된 어셈블리 이름의 일부인 경우 문자 구문 분석 오류가 발생 합니다. 구문 분석 오류를 방지 하려면 이스케이프 해야 정규화 된 어셈블리 이름을 전달할 수 전에 백슬래시로 특수 문자는 <xref:System.Type.GetType%2A> 메서드. 예를 들어, 한 유형의 이름은 `Strange]Type`, 대괄호 보다 먼저 다음과 같은 이스케이프 문자를 추가 해야 합니다: `Strange\]Type`합니다.  
  
> [!NOTE]
>  이러한 특수 문자를 사용 하 여 이름을 Visual Basic 또는 C#에서 만들 수 없지만 동적 어셈블리 내보내기 하거나 Microsoft MSIL (intermediate language)을 사용 하 여 만들 수 있습니다.  
  
 다음 표에서 형식 이름에 특수 문자를 보여 줍니다.  
  
|문자|의미|  
|---------------|-------------|  
|`,` (쉼표)|어셈블리의 정규화 된 이름에 대 한 구분 기호입니다.|  
|`[]` (대괄호)|접미사 쌍으로 배열 형식을 나타내고; 구분 기호 쌍으로 제네릭 인수 목록 및 정규화 된 어셈블리 이름을 포함합니다.|  
|`&` (앰퍼샌드)|접미사로 형식이 참조 형식이 나타냅니다.|  
|`*` (별표)|접미사로 형식이 포인터 형식임을 나타냅니다.|  
|`+` (더하기)|중첩 된 형식에 대 한 구분 기호입니다.|  
|`\` (백슬래시)|이스케이프 문자입니다.|  
  
 와 같은 <xref:System.Type.AssemblyQualifiedName%2A> 올바르게 이스케이프 된 문자열 반환 합니다. 올바르게 이스케이프 된 문자열을 전달 해야 합니다는 <xref:System.Type.GetType%2A> 메서드. 차례로 <xref:System.Type.GetType%2A> 메서드에서 올바르게 이스케이프 된 이름을 전달 `typeResolver` 및 기본 형식 확인 방법에 있습니다. 이스케이프 되지 않은 이름에 이름을 비교 해야 하는 경우 `typeResolver`, 이스케이프 문자를 제거 해야 합니다.  
  
 다시 [사용 정보](#usage_notes)합니다.  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>혼합 된 이름 확인  
 다음 표에서 간의 상호 작용 요약 `assemblyResolver`, `typeResolver`, 및 형식 이름 및 어셈블리 이름을의 모든 조합에 대 한 기본 이름 확인 `typeName`:  
  
|형식 이름의 내용|어셈블리 확인자 메서드|형식 확인자 메서드|결과|  
|---------------------------|------------------------------|--------------------------|------------|  
|형식, 어셈블리|null|null|호출에 해당 하는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.|  
|형식, 어셈블리|제공|null|`assemblyResolver` 어셈블리를 반환 하거나 반환 `null` 어셈블리를 확인할 수 없는 경우. 어셈블리가 확인 되는 경우는 <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 그렇지는 형식을 확인 하려고 하지 않은 경우; 메서드 오버 로드는 어셈블리에서 형식을 로드 하는 데 사용 됩니다.|  
|형식, 어셈블리|null|제공|어셈블리 이름을 변환에 해당 하는 <xref:System.Reflection.AssemblyName> 개체와 호출은 <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> 어셈블리를 가져오려면 메서드 오버 로드 합니다. 에 전달 되기 어셈블리 해결 되 면 `typeResolver`, 그렇지 않으면 `typeResolver` 호출 되지 않습니다 추가 시도가 형식을 확인 하 고 있습니다.|  
|형식, 어셈블리|제공|제공|`assemblyResolver` 어셈블리를 반환 하거나 반환 `null` 어셈블리를 확인할 수 없는 경우. 에 전달 되기 어셈블리 해결 되 면 `typeResolver`, 그렇지 않으면 `typeResolver` 호출 되지 않습니다 추가 시도가 형식을 확인 하 고 있습니다.|  
|형식|null이 고, 제공|null|호출에 해당 하는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 오버 로드 합니다. 어셈블리 이름이 제공 되지 않았으므로 Mscorlib.dll 및 현재 실행 중인 어셈블리가 검색 됩니다. 경우 `assemblyResolver` 제공는 무시 됩니다.|  
|type|null이 고, 제공|제공|`typeResolver` 를 호출 하 고 `null` 어셈블리에 전달 합니다. `typeResolver` 목적을 위해 로드 하는 어셈블리를 포함 하 여 모든 어셈블리에서 형식을 제공할 수 있습니다. 경우 `assemblyResolver` 제공는 무시 됩니다.|  
|어셈블리|null이 고, 제공|null이 고, 제공|A <xref:System.IO.FileLoadException> 어셈블리 이름 처럼 구문 분석 유형 어셈블리의 정규화 된 이름 이므로 throw 됩니다. 따라서 잘못 된 어셈블리 이름이 됩니다.|  
  
 다시: [사용 정보](#usage_notes), [어셈블리 확인](#resolving_assemblies), [형식 확인](#resolving_types)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 형식 이름과 어셈블리 이름(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자를 포함하는 경우)에 구문 분석할 때 오류가 발생합니다.  
  
 또는  
  
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />에 잘못된 구문이 포함된 경우(예: "MyType[,*,]").  
  
 또는  
  
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.  
  
 또는  
  
 <paramref name="typeName" />에 잘못된 어셈블리 이름이 포함되어 있습니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 이름이 없는 유효한 어셈블리 이름입니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
 또는  
  
 어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">형식을 확인할 개체의 배열입니다.</param>
        <summary>지정된 배열의 개체 형식을 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Type" />의 해당 요소에 대한 형식을 나타내는 <paramref name="args" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.Type.GetTypeArray%2A> 메서드를 배열 요소 유형을 나열 합니다.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="args" />의 요소 중 하나가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 하나 이상이 예외를 throw합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">내부 형식 코드를 가져올 형식입니다.</param>
        <summary>지정된 <see cref="T:System.Type" />의 내부 형식 코드를 가져옵니다.</summary>
        <returns>지정된 형식의 코드이거나, <see cref="F:System.TypeCode.Empty" />이 <paramref name="type" />인 경우는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상속 하는 경우 <xref:System.Type>를 재정의 하 여이 메서드의 동작을 변경할 수는 <xref:System.Type.GetTypeCodeImpl%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 방법을 <xref:System.TypeCode> 열거형을 사용할 수 있습니다. 결정 블록 내에서 `WriteObjectInfo` 메서드는 <xref:System.TypeCode> 의 <xref:System.Object> 매개 변수를 검사 하 고 적절 한 메시지는 콘솔에 기록 됩니다.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Type" /> 인스턴스에 대한 내부 형식 코드를 반환합니다.</summary>
        <returns>내부 형식의 형식 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는에 대 한 구현을 제공는 `static` (C#에서) 또는 `Shared` (Visual Basic)에서는 <xref:System.Type.GetTypeCode%28System.Type%29> 메서드. 상속 하는 경우 <xref:System.Type>의 사용자 지정 구현을 제공 하려면이 메서드를 재정의할 수 있습니다 <xref:System.Type.GetTypeCode%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 가져옵니다.</summary>
        <returns>
          CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 응용 프로그램에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에서 반환 된 형식이 COM 개체 인지 확인 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 대 한 런타임에 바인딩된 액세스에 대 한 해당 ProgID (프로그래밍 식별자) 알고 있는 개체입니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 두 단계로 이루어집니다.  
  
1.  가져오기는 <xref:System.Type> 을 나타내는 개체는`__ComObject` 호출 하 여 CLSID에 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
 그림에 대 한 예제를 참조 하십시오.  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> 인스턴스화할 때 발생할 수 있는 모든 예외를 무시 하는 오버 로드는 <xref:System.Type> 기반 개체는 `clsid` 인수입니다. 경우 예외가 throw 되는 참고 `clsid` 레지스트리에서 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID를 사용 하 여 [Application 개체](http://msdn.microsoft.com/library/office/ff838565.aspx) 를 Microsoft Word 응용 프로그램을 나타내는 COM 형식을 검색 합니다. 호출 하 여 다음 형식을 인스턴스화하는 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다는 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) 메서드.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>.NET Framework 개체와 COM 개체로 작업할 때 사용 하기 위해이 메서드를 사용 합니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성은 <see langword="true" />)에서 반환 되는 guid는 <see cref="P:System.Type.GUID" /> 속성입니다. 메서드가 <see cref="T:System.Type" /> 개체에 대 한.NET Framework GUID에 해당 하는 개체를 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 다음 예제와 같이 메서드.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 대신,는 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및는 관리 되지 않는 COM 개체의 GUID를 검색 하에 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드가 관리 되지 않는 COM 개체를 나타내야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <param name="throwOnError">
          발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
 또는  
  
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns>
          CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 응용 프로그램에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에서 반환 된 형식이 COM 개체 인지 확인 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 대 한 런타임에 바인딩된 액세스에 대 한 해당 ProgID (프로그래밍 식별자) 알고 있는 개체입니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 두 단계로 이루어집니다.  
  
1.  가져오기는 <xref:System.Type> 을 나타내는 개체는 `__ComObject` 호출 하 여 CLSID에 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
 그림에 대 한 예제를 참조 하십시오.  
  
 등의 예외도 <xref:System.OutOfMemoryException> 지정 하는 경우 throw 됩니다 `true` 에 대 한 `throwOnError`, 하지만 등록 되지 않은 clsid 하지 못합니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID를 사용 하 여 [Application 개체](http://msdn.microsoft.com/library/office/ff838565.aspx) 를 Microsoft Word 응용 프로그램을 나타내는 COM 형식을 검색 합니다. 호출 하 여 다음 형식을 인스턴스화하는 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다는 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) 메서드. 형식을 로드 하는 동안 오류가 발생 하면 예외가 throw 됩니다.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>.NET Framework 개체와 COM 개체로 작업할 때 사용 하기 위해이 메서드를 사용 합니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성은 <see langword="true" />)에서 반환 되는 guid는 <see cref="P:System.Type.GUID" /> 속성입니다. 메서드가 <see cref="T:System.Type" /> 개체에 대 한.NET Framework GUID에 해당 하는 개체를 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 다음 예제와 같이 메서드.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 대신,는 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및는 관리 되지 않는 COM 개체의 GUID를 검색 하에 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드가 관리 되지 않는 COM 개체를 나타내야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 지정된 서버에서 가져옵니다.</summary>
        <returns>
          CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 응용 프로그램에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에서 반환 된 형식이 COM 개체 인지 확인 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 대 한 런타임에 바인딩된 액세스에 대 한 해당 ProgID (프로그래밍 식별자) 알고 있는 개체입니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 두 단계로 이루어집니다.  
  
1.  가져오기는 <xref:System.Type> 을 나타내는 개체는 `__ComObject` 호출 하 여 CLSID에 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID를 사용 하 여 [Application 개체](http://msdn.microsoft.com/library/office/ff838565.aspx) computer17.central.contoso.com 라는 서버에서 Microsoft Word 응용 프로그램을 나타내는 COM 형식을 검색할 수 있습니다. 호출 하 여 다음 형식을 인스턴스화하는 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다는 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) 메서드.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>.NET Framework 개체와 COM 개체로 작업할 때 사용 하기 위해이 메서드를 사용 합니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성은 <see langword="true" />)에서 반환 되는 guid는 <see cref="P:System.Type.GUID" /> 속성입니다. 메서드가 <see cref="T:System.Type" /> 개체에 대 한.NET Framework GUID에 해당 하는 개체를 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 다음 예제와 같이 메서드.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 대신,는 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및는 관리 되지 않는 COM 개체의 GUID를 검색 하에 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드가 관리 되지 않는 COM 개체를 나타내야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <param name="throwOnError">
          발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
 또는  
  
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 지정된 서버에서 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns>
          CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 응용 프로그램에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에서 반환 된 형식이 COM 개체 인지 확인 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 대 한 런타임에 바인딩된 액세스에 대 한 해당 ProgID (프로그래밍 식별자) 알고 있는 개체입니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 두 단계로 이루어집니다.  
  
1.  가져오기는 <xref:System.Type> 을 나타내는 개체는 `__ComObject` 호출 하 여 CLSID에 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
 등의 예외도 <xref:System.OutOfMemoryException> 지정 하는 경우 throw 됩니다 `true` 에 대 한 `throwOnError`, 하지만 등록 되지 않은 clsid 하지 못합니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID를 사용 하 여 [Application 개체](http://msdn.microsoft.com/library/office/ff838565.aspx) computer17.central.contoso.com 라는 서버에서 Microsoft Word 응용 프로그램을 나타내는 COM 형식을 검색할 수 있습니다. 호출 하 여 다음 형식을 인스턴스화하는 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다는 [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) 메서드. 형식을 로드 하는 동안 오류가 발생 하면 예외가 throw 됩니다.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>.NET Framework 개체와 COM 개체로 작업할 때 사용 하기 위해이 메서드를 사용 합니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성은 <see langword="true" />)에서 반환 되는 guid는 <see cref="P:System.Type.GUID" /> 속성입니다. 하지만 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 메서드가 반환 되는 <see cref="T:System.Type" /> 관리 되는 특정 개체에 대 한 GUID에 해당 하는 개체를 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 다음 예제와 같이 메서드 보여 줍니다.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 대신,는 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및는 관리 되지 않는 COM 개체의 GUID를 검색 하에 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드가 관리 되지 않는 COM 개체를 나타내야 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">형식을 참조하는 개체입니다.</param>
        <summary>지정된 형식 핸들이 참조하는 형식을 가져옵니다.</summary>
        <returns>지정된 <see cref="T:System.RuntimeTypeHandle" />에서 참조하는 형식이거나 <see langword="null" />의 <see cref="P:System.RuntimeTypeHandle.Value" /> 속성이 <paramref name="handle" />인 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은 얻은 것 응용 프로그램 도메인 에서만 유효 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.GetTypeFromHandle%2A> 가져올 메서드를 한 <xref:System.Type> 에서 개체는 <xref:System.RuntimeTypeHandle> 에서 제공 되는 <xref:System.Type.GetTypeHandle%2A> 메서드.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 형식의 ProgID입니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져오고 <see cref="T:System.Type" />을 로드하는 동안 오류가 발생하면 null을 반환합니다.</summary>
        <returns>
          <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. Progid 네임 스페이스의 개념에 의해 대체 때문에 Microsoft.NET Framework에서 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 형식의 ProgID입니다.</param>
        <param name="throwOnError">
          발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
 또는  
  
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns>
          <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. 프로그램 Id 네임 스페이스의 개념에 의해 대체 때문에 Microsoft.NET Framework에서 사용 되지 않습니다.  
  
   
  
## Examples  
 다음 예에서는를 ProgID 유효 하지 않을 경우 예외를 throw 할지를 지정 ProgID를 전달 하 여 형식을 검색 합니다. 다음 예에서는 모든 적절 한 예외 메시지와 함께 ProgID와 관련 된 클래스 Id를 표시 합니다.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">지정된 ProgID가 등록되어 있지 않습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 형식의 ProgID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 지정된 서버에서 가져오고, 형식을 로드하는 동안 오류가 발생하면 null을 반환합니다.</summary>
        <returns>
          <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. 프로그램 Id 네임 스페이스의 개념에 의해 대체 때문에 Microsoft.NET Framework에서 사용 되지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 ProgID 및 서버 이름을 전달 하 여 형식을 검색 합니다. 이 예제에서는 다음의 ProgID와 관련 된 클래스 Id를 표시 하거나 ProgID 또는 서버 이름이 유효 하지 않을 경우 예외를 throw 합니다.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 <see cref="T:System.Type" />의 ProgID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <param name="throwOnError">
          발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
 또는  
  
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 지정된 서버에서 가져오고, 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns>
          <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. 프로그램 Id 네임 스페이스의 개념에 의해 대체 때문에 Microsoft.NET Framework에서 사용 되지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 ProgID 및 서버 이름을 전달 하 여 형식을 검색 합니다. 다음 예에서는를 ProgID 또는 서버 이름이 유효 하지 않을 경우 예외를 throw 할지를 지정 된 ProgID와 관련 된 클래스 Id를 표시 합니다.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">지정된 ProgID가 등록되어 있지 않습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Type 핸들을 가져올 개체입니다.</param>
        <summary>지정된 개체의 <see cref="T:System.Type" />에 대한 핸들을 가져옵니다.</summary>
        <returns>지정된 <see cref="T:System.Type" />의 <see cref="T:System.Object" />에 대한 핸들입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은 얻은 것 응용 프로그램 도메인 에서만 유효 합니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스를 정의 `MyClass1`인스턴스를 가져오고 개체의 런타임 핸들을 검색 합니다.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />과 관련된 GUID를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" />과 관련된 GUID입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식과 연결 된 GUID는 <xref:System.Runtime.InteropServices.GuidAttribute> 특성입니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스를 만드는 `MyClass1` 는 공용 메서드를 사용 하 여 만듭니다는 `Type` 개체에 해당 하 `MyClass1`, 가져옵니다는 <xref:System.Guid> 를 사용 하 여 구조체는 `GUID` 속성의는 `Type` 클래스.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 다른 형식을 포함하거나 참조하는지 여부, 즉 현재 <see cref="T:System.Type" />이 배열 또는 포인터이거나 참조로 전달되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 배열 또는 포인터이거나 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 Type.GetType("Int32[]") 합니다. HasElementType 반환 `true`, 하지만 Type.GetType("Int32") 합니다. HasElementType 반환 `false`합니다. HasElementType도 반환 `true` "Int32 *"에 대 한 및 "Int32 &".  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수 나타냅니다 `false`합니다.  
  
   
  
## Examples  
 다음 예에서는 반환 `true` 또는 `false` 개체가 배열, 참조 형식 또는 포인터 인지 여부에 따라 합니다.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.HasElementType" /> 속성을 구현하고 현재 <see cref="T:System.Type" />이 다른 형식을 포함하거나 참조하는지 여부, 즉 현재 <see cref="T:System.Type" />이 배열 또는 포인터이거나 참조로 전달되는지를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 배열 또는 포인터이거나 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 Type.GetType("Int32[]") 합니다. 에서는 반환 `true`, 하지만 Type.GetType("Int32") 합니다. 에서는 반환 `false`합니다. 에서는 또한 반환 `true` "Int32 *"에 대 한 및 "Int32 &".  
  
   
  
## Examples  
 다음 예제에서는 클래스를 정의 `MyTypeDelegator`, 재정의 하는 `HasElementTypeImpl` 메서드. 기본 클래스에 대 한 검사는 `HasElementType` 요소의 입력 속성을 표시 합니다.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 멤버를 호출합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.  
  
 또는  
  
 기본 멤버를 호출하는 빈 문자열("")입니다.  
  
 또는  
  
 <see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</param>
        <param name="invokeAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다. 액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다. 조회 형식을 지정할 필요가 없습니다. 조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다. 변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</param>
        <param name="target">지정한 멤버를 호출할 개체입니다.</param>
        <param name="args">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</param>
        <summary>지정된 바인딩 제약 조건과 인수 목록을 사용하여 지정된 멤버를 호출합니다.</summary>
        <returns>호출된 멤버의 반환 값을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 멤버를 정의 하는 검색에 포함할 수 있습니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 멤버 (즉,: 전용 및 보호 된 멤버)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 정적 멤버는 계층 구조를 포함 하도록 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하는 <xref:System.Type>, 상속 된 멤버가 없습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버와 수행할 작업을 나타내는 데 사용할 수 있습니다.  
  
-   `CreateInstance` 생성자를 호출 합니다. `name` 무시 됩니다. 다른 호출 플래그와 함께 사용할 수 없습니다.  
  
-   `InvokeMethod` 메서드를 있지만 하지 생성자 또는 형식 이니셜라이저가 호출 합니다. 함께 사용할 수 없습니다 `SetField` 또는 `SetProperty`합니다. 경우 `InvokeMethod` 단독으로 지정 된 `BindingFlags.Public`, `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.  
  
-   `GetField` 필드의 값을 합니다. 함께 사용할 수 없습니다 `SetField`합니다.  
  
-   `SetField` 필드의 값을 설정 합니다. 함께 사용할 수 없습니다 `GetField`합니다.  
  
-   `GetProperty` 속성을 가져오기. 함께 사용할 수 없습니다 `SetProperty`합니다.  
  
-   `SetProperty` 속성을 설정 합니다. 함께 사용할 수 없습니다 `GetProperty`합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드는 다음 조건이 모두 해당 하는 경우 호출 됩니다.  
  
-   메서드 선언의 매개 변수 수가의 인수 개수는 `args` 배열 (기본 인수는 멤버에 대해 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).  
  
-   각 인수 형식이 매개 변수 형식의 바인더에서 변환할 수 있습니다.  
  
 바인더는 모두 일치 하는 메서드 제공 됩니다. 요청 된 바인딩 형식에 따라 이들이 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등). 메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.  
  
 메서드가 선택 된 후 호출 됩니다. 내게 필요한 옵션은 해당 시점에 확인 됩니다. 검색은 메서드와 연결 된 내게 필요한 옵션 특성에 따라 검색할 어떤 메서드 집합을 제어할 수 있습니다. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 의 메서드는 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 해야 합니다. 기본 바인더 가장 구체적으로 일치를 선택합니다.  
  
 완전히 신뢰할 수 있는 코드;에 대 한 액세스 제한은 무시 됩니다. 즉, private 생성자, 메서드, 필드 및 속성 액세스 하 고 수를 통해 호출 <xref:System.Reflection> 때마다 코드는 완전히 신뢰 합니다.  
  
 사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다. 예를 들어 F C 및 F 클래스에 라는 공용 인스턴스 필드를 설정 하려면이 `String`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 F가는 `String[]`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 이 새 배열 F 필드가 초기화 됩니다. 사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 문자열 "b"에 F를 보유 하는 배열에서 문자열 "z" 변경 됩니다.  
  
 호출 하는 경우는 `IDispatch` 멤버, 멤버 이름 대신 DispID 문자열 형식을 사용 하 여 지정할 수 있습니다 "[DispID = # #]"입니다. 예를 들어 MyComMethod DispID이 3 이면 문자열 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다. DispID로 멤버를 호출 하는 보다 이름별으로 멤버를 조회 합니다. 복잡 한 집계 시나리오에서에서는 DispID가 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 멤버의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `InvokeMember` 형식의 멤버에 액세스 하 합니다.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.  
  
 또는  
  
 이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.  
  
 또는  
  
 명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</exception>
        <exception cref="T:System.MethodAccessException">지정된 멤버가 클래스 이니셜라이저입니다.</exception>
        <exception cref="T:System.MissingFieldException">필드 또는 속성을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.  
  
 또는  
  
 현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</exception>
        <exception cref="T:System.Reflection.TargetException">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework에서는 현재 이 메서드를 지원하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다. 즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.  
  
 또는  
  
 기본 멤버를 호출하는 빈 문자열("")입니다.  
  
 또는  
  
 <see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</param>
        <param name="invokeAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다. 액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다. 조회 형식을 지정할 필요가 없습니다. 조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다. 변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</param>
        <param name="target">지정한 멤버를 호출할 개체입니다.</param>
        <param name="args">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</param>
        <param name="culture">사용할 전역화 로캘을 나타내는 개체입니다. 이 개체는 숫자 <see cref="T:System.String" />을 <see cref="T:System.Double" />로 변환하는 등의 로캘별 변환에 사용할 수 있습니다.  
  
 또는  
  
 현재 스레드의 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="T:System.Globalization.CultureInfo" />)입니다.</param>
        <summary>지정된 바인딩 제약 조건과 지정된 인수 목록 및 문화권을 사용하여 지정된 멤버를 호출합니다.</summary>
        <returns>호출된 멤버의 반환 값을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더는 처리 하지 않더라도 <xref:System.Globalization.CultureInfo> (의 `culture` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `culture`합니다.  
  
> [!NOTE]
>  사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 멤버를 정의 하는 검색에 포함할 수 있습니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 멤버 (즉, 전용, 내부 및 보호 된 멤버)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 정적 멤버는 계층 구조를 포함 하도록 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하는 <xref:System.Type>, 상속 된 멤버가 없습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버와 수행할 작업을 나타내는 데 사용할 수 있습니다.  
  
-   `CreateInstance` 생성자를 호출 합니다. `name` 무시 됩니다. 다른 호출 플래그와 함께 사용할 수 없습니다.  
  
-   `InvokeMethod` 메서드를 있지만 하지 생성자 또는 형식 이니셜라이저가 호출 합니다. 함께 사용할 수 없습니다 `SetField` 또는 `SetProperty`합니다. 경우 `InvokeMethod` 단독으로 지정 된 `BindingFlags.Public`, `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.  
  
-   `GetField` 필드의 값을 합니다. 함께 사용할 수 없습니다 `SetField`합니다.  
  
-   `SetField` 필드의 값을 설정 합니다. 함께 사용할 수 없습니다 `GetField`합니다.  
  
-   `GetProperty` 속성을 가져오기. 함께 사용할 수 없습니다 `SetProperty`합니다.  
  
-   `SetProperty` 속성을 설정 합니다. 함께 사용할 수 없습니다 `GetProperty`합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드는 다음 조건이 모두 해당 하는 경우 호출 됩니다.  
  
-   메서드 선언의 매개 변수 수가의 인수 개수는 `args` 배열 (기본 인수는 멤버에 대해 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).  
  
-   각 인수 형식이 매개 변수 형식의 바인더에서 변환할 수 있습니다.  
  
 바인더는 모두 일치 하는 메서드 제공 됩니다. 요청 된 바인딩 형식에 따라 이들이 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등). 메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.  
  
 메서드가 선택 된 후 호출 됩니다. 내게 필요한 옵션은 해당 시점에 확인 됩니다. 검색은 메서드와 연결 된 내게 필요한 옵션 특성에 따라 검색할 어떤 메서드 집합을 제어할 수 있습니다. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 의 메서드는 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 해야 합니다. 기본 바인더 가장 구체적으로 일치를 선택합니다.  
  
 완전히 신뢰할 수 있는 코드;에 대 한 액세스 제한은 무시 됩니다. 즉, private 생성자, 메서드, 필드 및 속성 액세스 하 고 수 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 통해 호출 합니다.  
  
 사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다. 예를 들어 F C 및 F 클래스에 라는 공용 인스턴스 필드를 설정 하려면이 `String` 와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 F가는 `String[]`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 이 새 배열 F 필드가 초기화 됩니다. 사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 문자열 "b"에 F를 보유 하는 배열에서 문자열 "z" 변경 됩니다.  
  
 호출 하는 경우는 `IDispatch` 멤버는 멤버 이름 대신 문자열 형식을 사용 하 여 dispid 값을 지정할 수 있습니다 "[DispID = # #]"입니다. 예를 들어 MyComMethod DispID이 3 이면 문자열 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다. DispID로 멤버를 호출 하는 보다 이름별으로 멤버를 조회 합니다. 복잡 한 집계 시나리오에서에서는 DispID가 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 멤버의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.  
  
 또는  
  
 이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.  
  
 또는  
  
 명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</exception>
        <exception cref="T:System.MethodAccessException">지정된 멤버가 클래스 이니셜라이저입니다.</exception>
        <exception cref="T:System.MissingFieldException">필드 또는 속성을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.  
  
 또는  
  
 현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</exception>
        <exception cref="T:System.Reflection.TargetException">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다. 즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.  
  
 또는  
  
 기본 멤버를 호출하는 빈 문자열("")입니다.  
  
 또는  
  
 <see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</param>
        <param name="invokeAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다. 액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다. 조회 형식을 지정할 필요가 없습니다. 조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
 또는  
  
 <see cref="P:System.Type.DefaultBinder" />를 사용할 null 참조(Visual Basic에는 없음)입니다. 변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</param>
        <param name="target">지정한 멤버를 호출할 개체입니다.</param>
        <param name="args">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</param>
        <param name="modifiers">
          <c>args</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다. 매개 변수의 관련 특성은 해당 멤버의 시그니처에 저장됩니다.  
  
 기본 바인더는 COM 구성 요소를 호출하는 경우에만 이 매개 변수를 처리합니다.</param>
        <param name="culture">사용할 전역화 로캘을 나타내는 <see cref="T:System.Globalization.CultureInfo" /> 개체입니다. 이 개체는 숫자 String을 Double로 변환하는 등의 로캘 관련 변환에 사용할 수 있습니다.  
  
 또는  
  
 현재 스레드의 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="T:System.Globalization.CultureInfo" />)입니다.</param>
        <param name="namedParameters">
          <c>args</c> 배열의 값이 전달될 매개 변수의 이름이 있는 배열입니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 바인딩 제약 조건과 지정된 인수 목록, 한정자 및 문화권을 사용하여 지정된 멤버를 호출합니다.</summary>
        <returns>호출된 멤버의 반환 값을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` 생성자 멤버 또는 멤버 메서드를 호출, 가져옵니다 또는 속성 멤버를 설정, 가져옵니다 또는 데이터 필드 멤버를 설정 또는 가져옵니다 또는 배열 멤버의 요소를 가져오거나 설정 합니다.  
  
> [!NOTE]
>  사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.  
  
 호출 하는 경우는 `IDispatch` 멤버는 멤버 이름 대신 문자열 형식을 사용 하 여 dispid 값을 지정할 수 있습니다 "[DispID = # #]"입니다. 예를 들어 MyComMethod DispID이 3 이면 문자열 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다. DispID로 멤버를 호출 하는 보다 이름별으로 멤버를 조회 합니다. 복잡 한 집계 시나리오에서에서는 DispID가 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.  
  
 기본 바인더는 처리 하지 않더라도 <xref:System.Reflection.ParameterModifier> 또는 <xref:System.Globalization.CultureInfo> (의 `modifiers` 및 `culture` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스는 사용자 지정 처리 하는 바인더를 작성 하 `modifiers` 및 `culture`. `ParameterModifier` COM interop를 통해 호출할 때만 사용 되 고 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 `namedParameters` 배열의 각 매개 변수는 `args` 배열에 있는 해당 요소의 값을 가져옵니다. `args`의 길이가 `namedParameters`의 길이보다 크면 나머지 인수 값은 순서대로 전달됩니다.  
  
 `namedParameters` 입력된 배열에 있는 인수의 순서를 변경 하려면 배열은 사용할 수 있습니다. 예를 들어 메서드가 있다고 가정 하면 `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` Visual basic에서) 및 입력된 배열 `{ 42, "x" }`, 입력된 배열에 변경 되지 않은 전달 될 수 있습니다 `args` 경우 배열 `{ "b", "a" }` 을 위해 제공 된 `namedParameters`합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 멤버를 정의 하는 검색에 포함할 수 있습니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 멤버를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 멤버 (즉, 전용, 내부 및 보호 된 멤버)를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 정적 멤버는 계층 구조를 포함 하도록 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하는 <xref:System.Type>, 상속 된 멤버가 없습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버와 수행할 작업을 나타내는 데 사용할 수 있습니다.  
  
-   `CreateInstance` 생성자를 호출 합니다. `name` 무시 됩니다. 다른 호출 플래그와 함께 사용할 수 없습니다.  
  
-   `InvokeMethod` 메서드를 있지만 하지 생성자 또는 형식 이니셜라이저가 호출 합니다. 함께 사용할 수 없습니다 `SetField` 또는 `SetProperty`합니다. 경우 `InvokeMethod` 단독으로 지정 된 `BindingFlags.Public`, `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.  
  
-   `GetField` 필드의 값을 합니다. 함께 사용할 수 없습니다 `SetField`합니다.  
  
-   `SetField` 필드의 값을 설정 합니다. 함께 사용할 수 없습니다 `GetField`합니다.  
  
-   `GetProperty` 속성을 가져오기. 함께 사용할 수 없습니다 `SetProperty`합니다.  
  
-   `SetProperty` 속성을 설정 합니다. 함께 사용할 수 없습니다 `GetProperty`합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드는 다음 조건이 모두 해당 하는 경우 호출 됩니다.  
  
-   메서드 선언의 매개 변수 수가의 인수 개수는 `args` 배열 (기본 인수는 멤버에 대해 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).  
  
-   각 인수 형식이 매개 변수 형식의 바인더에서 변환할 수 있습니다.  
  
 바인더는 모두 일치 하는 메서드 제공 됩니다. 요청 된 바인딩 형식에 따라 이들이 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등). 메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.  
  
 메서드가 선택 된 후 호출 됩니다. 내게 필요한 옵션은 해당 시점에 확인 됩니다. 검색은 메서드와 연결 된 내게 필요한 옵션 특성에 따라 검색할 어떤 메서드 집합을 제어할 수 있습니다. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 의 메서드는 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 해야 합니다. 기본 바인더 가장 구체적으로 일치를 선택합니다.  
  
 `InvokeMember` 용도 기본값이 지정 된 매개 변수가 있는 메서드를 호출 합니다. 이러한 메서드에 바인딩할 리플렉션 해야 <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> 를 지정 해야 합니다. 기본값이 있는 매개 변수에 대해 서로 다른 값을 제공 하거나 제공 <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> 기본값을 사용 하도록 합니다.  
  
 예를 들어 MyMethod 같은 메서드 (x, y float int 2.0 =) 합니다. 이 메서드를 호출 하는 첫 번째 인수 MyMethod(4)로, 위 바인딩 플래그 중 하나를 전달 하 고 첫 번째 인수에 대 한 4 즉, 두 개의 인수를 전달 하 고 `Missing.Value` 두 번째 인수에 대 한 합니다. 사용 하지 않는 한 `Missing.Value`와 선택적 매개 변수를 생략할 수 없습니다는 `Invoke` 메서드. 이렇게 해야 하는 경우 사용 하 여 `InvokeMember` 대신 합니다.  
  
 완전히 신뢰할 수 있는 코드;에 대 한 액세스 제한은 무시 됩니다. 즉, private 생성자, 메서드, 필드 및 속성 액세스 하 고 수를 통해 호출 <xref:System.Reflection> 때마다 코드는 완전히 신뢰 합니다.  
  
 사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다. 예를 들어 F C 및 F 클래스에 라는 공용 인스턴스 필드를 설정 하려면이 `String`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 F가는 `String[]`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 이 새 배열 F 필드가 초기화 됩니다. 사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 문자열 "b"에 F를 보유 하는 배열에서 문자열 "z" 변경 됩니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 멤버의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.  
  
 또는  
  
 <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.  
  
 또는  
  
 명명된 매개 변수 배열이 인수 배열보다 큽니다.  
  
 또는  
  
 이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.  
  
 또는  
  
 명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</exception>
        <exception cref="T:System.MethodAccessException">지정된 멤버가 클래스 이니셜라이저입니다.</exception>
        <exception cref="T:System.MissingFieldException">필드 또는 속성을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.  
  
 또는  
  
 인수 이름이 제공된 멤버를 <paramref name="namedParameters" />에서 찾을 수 없습니다.  
  
 또는  
  
 현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</exception>
        <exception cref="T:System.Reflection.TargetException">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다. 즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 추상이며 재정의되어야 하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" />이 추상이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A> 속성에서 반환 `true` 다음과 같은 경우:  
  
-   현재 형식이 추상; 즉, 인스턴스화할 수 없습니다 되지만 파생 된 클래스에 대 한 기본 클래스로 사용할 수 있습니다. C#에서 클래스를 추상으로 표시 됩니다는 [추상](~/docs/csharp/language-reference/keywords/abstract.md) 키워드입니다; Visual Basic의 경우에서으로 표시 됩니다는 [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) 키워드입니다.  
  
-   현재 형식이 인터페이스를 보여 줍니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 <xref:System.Type> 다음과 같은 형식을 나타내는 개체: 형식 반환 포함 `true` 지정 된 개체가 있으면 `abstract`, 그렇지 않으면 반환 `false`합니다.  
  
-   `AbstractClass`추상 클래스 (클래스로 표시 `abstract` C# 및 `MustInherit` Visual basic에서).  
  
-   `DerivedClass`에서 상속 되는 클래스 `AbstractClass`합니다.  
  
-   `SingleClass`를 상속할 수 없는 클래스입니다. 으로 정의 되어 `sealed` C# 및 `NotInheritable` Visual Basic의 합니다.  
  
-   `ITypeInfo`를 인터페이스입니다.  
  
-   `ImplementingClass`를 구현 하는 클래스는 `ITypeInfo` 인터페이스입니다.  
  
 메서드가 반환 `true` 에 대해서만 `AbstractClass`, 추상 클래스 및 `ITypeInfo`, 인터페이스입니다.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="AnsiClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />에 대해 문자열 형식 특성 <see langword="AnsiClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 합니다. 문자열 형식 특성은 문자열의 해석 방법을 정의 하 여 상호 운용성을 향상 시킵니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 합니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 필드 정보를 가져와서 검사는 `AnsiClass` 특성입니다.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>유형이 배열인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 유형이 배열이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A> 속성에서 반환 `false` 에 대 한는 <xref:System.Array> 클래스입니다. 또한 반환 `false` 현재 인스턴스가 <xref:System.Type> 컬렉션 형식 이거나 같은 컬렉션을 사용 하도록 디자인 된 인터페이스를 나타내는 개체 <xref:System.Collections.IEnumerable> 또는 <xref:System.Collections.Generic.IEnumerable%601>합니다.  
  
 배열에 대 한 확인을 코드와 같은 사용 합니다.  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 이 속성은 항상 현재 형식이 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 경우 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Type.IsArray%2A> 속성입니다.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsArray" /> 속성을 구현하고 <see cref="T:System.Type" />이 배열인지를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 배열이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스는 <xref:System.Array> 클래스 반환 해야 `false` 개체 배열이 아닌 있기 때문에 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 `IsArrayImpl` 에서 메서드는 `MyTypeDelegator` 클래스 변수는 배열, 고 결과 표시 하는 경우 확인 합니다.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">현재 형식과 비교할 형식입니다.</param>
        <summary>지정한 형식의 인스턴스를 현재 형식의 인스턴스에 할당할 수 있는지 여부를 결정합니다.</summary>
        <returns>
          다음 조건 중 하나 이상이 true일 경우 <see langword="true" />입니다.  
  
-   <paramref name="c" /> 및 현재 인스턴스가 동일한 형식으로 나타납니다.  
  
-   <paramref name="c" />가 현재 인스턴스에서 직접 또는 간접으로 파생됩니다. 현재 인스턴스에서 상속하는 경우 <paramref name="c" />는 현재 인스턴스에서 직접 파생되며 현재 인스턴스에서 상속하는 하나 이상의 클래스의 연속에서 상속하는 경우 <paramref name="c" />는 현재 인스턴스에서 직접 파생됩니다.  
  
-   현재 인스턴스는 <paramref name="c" />를 구현하는 인터페이스입니다.  
  
-   <paramref name="c" />는 제네릭 형식 매개 변수이며, 현재 인스턴스는 <paramref name="c" />의 제약 조건 중 하나를 나타냅니다.  
  
     다음 예제에서 현재 인스턴스는 <see cref="T:System.IO.Stream" /> 클래스를 나타내는 <see cref="T:System.Type" /> 개체입니다. <c>GenericWithConstraint</c>는 제네릭 형식 매개 변수가 <see cref="T:System.IO.Stream" /> 형식이어야 하는 제네릭 형식입니다. <see cref="M:System.Type.IsAssignableFrom(System.Type)" />에 제네릭 형식 매개 변수를 전달하는 것은 제네릭 형식 매개 변수의 인스턴스를 <see cref="T:System.IO.Stream" /> 개체에 할당할 수 있음을 나타냅니다.  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" />는 값 형식을 나타내며 현재 인스턴스는 <c>Nullable&lt;c&gt;</c>(Visual Basic에서 <c>Nullable(Of c)</c>)를 나타냅니다.  
  
 이러한 조건에 해당하지 않거나 <paramref name="c" />가 <see langword="false" />이면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A> 인스턴스의 지 여부를 결정 메서드를 사용할 수 `c` 지정할 수 있는 현재 형식의 인스턴스로 메서드 그 형식은 디자인 타임에 알 수 없는 개체를 처리 하는 경우에 유용 하 고 조건부 허용 다음 예제와 같이 할당을 보여 줍니다.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 이 메서드 따라서를 사용 하면 다음 throw 하지 않고 런타임에 실행될지와 같은 코드 줄을 한 <xref:System.InvalidCastException> 예외 나 비슷한 예외:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
> [!NOTE]
>  제네릭 형식 정의 생성된 된 닫힌된 형식에서 할당할 수 없으면입니다. 폐쇄형된 생성된 형식을 할당할 수 없습니다, 즉 `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual basic에서) 형식의 변수에 `MyGenericList<T>`합니다.  
  
 경우는 `c` 매개 변수는 형식 <xref:System.Reflection.Emit.TypeBuilder>, 결과를 구축할 수 있는 형식에 기반 합니다. 다음 코드 예제에서는이 라는 기본 제공된 형식을 사용 하 여 `B`합니다.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 다음 예제는 `IsAssignableFrom` 정의 된 클래스, 정수 배열 및 제네릭 메서드를 사용 하 여 합니다.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="AutoClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />에 대해 문자열 형식 특성 <see langword="AutoClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 합니다. 문자열 형식 특성은 문자열의 해석 방법을 정의 하 여 상호 운용성을 향상 시킵니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식의 필드가 공용 언어 런타임에 의해 자동으로 배치되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 여부 형식 레이아웃 특성 및 다음 테스트를 선택 하는 열거형 값 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 설정 됩니다. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드가 메모리에 배치 되는 방식을 나타냅니다.  
  
 동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 유형을 만들 때. 코드에서 적용는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성이 <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> 클래스의 레이아웃에 적절 한 방법을 결정 하면 런타임이 형식에 열거형 값입니다.  
  
> [!NOTE]
>  사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 확인 하 여부는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 되었습니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>.`  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 형식의 인스턴스를 만들고 표시는 <xref:System.Type.IsAutoLayout%2A> 속성입니다.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 참조로 전달되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 실제 형식으로, 참조로 전달 된 형식을 역참조를 다음 호출 <xref:System.Type.GetElementType%2A> 해당 형식에 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 `IsByRef` 속성을 지정된 된 형식의 참조로 전달 되는지 여부를 확인 합니다. 이 예제에서는 클래스 정의 `MyTypeDelegator`, 재정의 하는 `HasElementTypeImpl` 메서드. 기본 클래스에 대 한 검사는 `HasElementType` 요소의 입력 속성을 표시 합니다.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsByRef" /> 속성을 구현하고 <see cref="T:System.Type" />이 참조로 전달되는지를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 클래스 혹은 대리자인지, 즉 값 형식 또는 인터페이스가 아닌지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 클래스이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 `true` 대리자 뿐만 아니라 클래스에 대 한 합니다. 반환 `false` 형식에 대 한 값 (구조 및 열거형)에 대해 boxed 됩니다 하는 경우에 마찬가지입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `true`합니다. 하는 경우 현재 <xref:System.Type> 이 속성은 반환 생성된 된 제네릭 형식을 나타내는 `true` 제네릭 형식 정의 클래스 정의; 경우 즉, 정의 하지 않는 인터페이스 또는 값 형식입니다.  
  
> [!NOTE]
>  이 속성은 반환 `true` 에 대 한 `Type` 방향을 나타내는 인스턴스는 <xref:System.Enum> 및 <xref:System.ValueType> 클래스입니다. 이 두 클래스는 값 형식 및 열거형에 대 한 기본 형식을 각각 있지만 열거형 또는 값 형식 자체 되지는 않습니다. 자세한 내용은 참조는 <xref:System.Type.IsValueType%2A> 및 <xref:System.Type.IsEnum%2A> 속성입니다.  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 클래스 또는 인터페이스 형식 선언을 구별 하는 열거형 값입니다. 그러나 클래스와 값 형식으로 표시 됩니다는는 <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> 특성입니다. 형식의 특성 속성 및 사용 하 여 값을 검색 하는 경우는 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 호출 또한 해야 형식이 값 형식 대신 클래스 하는지 여부를 결정 하는 값은 <xref:System.Type.IsValueType%2A> 속성입니다. 에 대 한 예제는 <xref:System.Reflection.TypeAttributes> 열거형 anexample 뿐만 아니라 추가 정보를 포함 합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 형식의 인스턴스를 만들고이 형식이 클래스 인지를 나타냅니다.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 COM 개체인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 COM 개체이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 `false` 개체 되지 않기 때문에 COM 인터페이스의 경우. Microsoft.NET Framework 개체에서 COM 인터페이스를 구현할 수 있습니다.  
  
 또한 COM 클래스를 로드 하 고 얻을 수는 `Type` 를 사용 하 여 해당 COM 클래스에 대 한 개체는 [Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int`> (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsCOMObject" /> 속성을 구현하고 <see cref="T:System.Type" />이 COM 개체인지를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 COM 개체이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 `false` 개체 되지 않기 때문에 COM 인터페이스의 경우. Microsoft.NET Framework 개체에서 COM 인터페이스를 구현할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 개체가 생성된 제네릭 형식을 나타내는지를 지정하는 값을 가져옵니다. 생성된 제네릭 형식의 인스턴스를 만들 수 있습니다.</summary>
        <value>
          이 개체가 생성된 제네릭 형식을 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성된 된 제네릭 형식에 명시적 형식을 모든 제네릭 형식 매개 변수와에 제공 되어 있습니다. 폐쇄형된 제네릭 형식으로도에 참조 됩니다.  
  
 이 속성이 `true`, 현재 형식의 인스턴스를 만들 수 있습니다; 때 `false`를 할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스 멤버에 대 한 호출을 차단 하 고 동기화와 같이 클래스에 적용 되는 정책을 적용 하는 컨텍스트. 원격 컨텍스트에 대 한 정보를 자세한 참조 <xref:System.Runtime.Remoting.Contexts.Context>합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성은 <xref:System.Type> 클래스입니다. 있는지 여부 지정된 된 형식의 호스팅될 수 컨텍스트에서 그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 있는지 확인 합니다.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Type.IsContextful" /> 속성을 구현하고, <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있는지 여부를 확인합니다.</summary>
        <returns>
          <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 클래스 멤버에 대 한 호출을 차단 하 고 동기화와 같이 클래스에 적용 되는 정책을 적용 하는 컨텍스트.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 `IsContextfulImpl` 메서드.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 열거형을 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 <see langword="true" />이 열거형을 나타내면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 `true` 열거형에 대 한는 <xref:System.Enum> 자체를 입력 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하 여 `IsEnum` 속성.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">테스트할 값입니다.</param>
        <summary>현재 열거형 형식에 지정된 값이 있는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          지정된 값이 현재 열거형 형식의 멤버이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" />는 열거형의 내부 형식이 될 수 없는 형식입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">현재 형식과 같은지 테스트되는 COM 형식입니다.</param>
        <summary>두 COM 형식이 같은 ID를 갖고 동일 형식이 될 수 있는지를 확인합니다.</summary>
        <returns>
          COM 형식이 현재 형식과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 한 형식은 실행하기 위해 로드된 어셈블리에 있고 나머지 형식은 리플렉션 전용 컨텍스트로 로드된 어셈블리에 있는 경우에도 이 메서드는 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], interop에서 COM 형식에 대 한 형식 정보를 가져오는 관리 되는 어셈블리를 요구 하는 대신 관리 되는 어셈블리에 직접 COM 형식에 대 한 형식 정보를 포함 하는 공용 언어 런타임에서 지원 어셈블리입니다. 포함된 형식 정보에는 관리되는 어셈블리에서 실제로 사용되는 형식 및 멤버만 포함되므로 두 개의 관리되는 어셈블리에서 동일한 COM 형식이 전혀 다르게 표시될 수 있습니다. 관리되는 어셈블리마다 COM 형식의 해당 보기를 나타내는 다른 <xref:System.Type> 개체가 있습니다. 공용 언어 런타임은 인터페이스, 구조체, 열거형 및 대리자에 대한 이러한 다양한 보기 간에 형식 동등을 지원합니다.  
  
 형식 동등은 관리되는 어셈블리 간에 전달되는 COM 개체를 수신 어셈블리에서 적절한 관리되는 형식으로 캐스팅할 수 있음을 의미합니다. <xref:System.Type.IsEquivalentTo%2A> 메서드 어셈블리가 다른 어셈블리에서 가져온 COM 개체와 동일한 COM id로 처음 어셈블리의 자체 포함 된 interop 형식 중 하나에 있는지 확인할 수 있도록 하 고 있으므로 해당 형식으로 캐스팅 될 수 있습니다.  
  
 자세한 내용은 참조 [동일 형식 및 포함 된 Interop 형식](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식의 필드가 명시적으로 지정된 오프셋에 배치되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 여부 형식 레이아웃 특성 및 다음 테스트를 선택 하는 열거형 값 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 설정 됩니다. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드가 메모리에 배치 되는 방식을 나타냅니다.  
  
 동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 유형을 만들 때. 코드에서 적용는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성이 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 필드 시작할 오프셋을 명시적으로 지정 되어 있는지를 지정 하는 형식에 열거형 값입니다.  
  
> [!NOTE]
>  사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 확인 하 여부는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 되었습니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 형식의 인스턴스를 만들고 값을 표시 해당 <xref:System.Type.IsExplicitLayout%2A> 속성입니다. 사용 하 여는 `MySystemTime` 클래스에 대 한 코드 예제에서는에 포함 되어 있는 <xref:System.Runtime.InteropServices.StructLayoutAttribute>합니다.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 제네릭 형식 또는 메서드 정의의 형식 매개 변수를 나타내는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" /> 개체가 제네릭 형식 정의나 메서드 정의의 형식 매개 변수를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> 제네릭 형식 매개 변수를 나타내는 개체를 호출 하 여 얻을 수 있습니다는 <xref:System.Type.GetGenericArguments%2A> 의 메서드는 <xref:System.Type> 제네릭 형식 정의 나타내는 개체 또는 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> 의 메서드는 <xref:System.Reflection.MethodInfo> 제네릭 메서드를 나타내는 개체입니다 정의 합니다.  
  
-   제네릭 형식 또는 메서드 정의 대 한는 <xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `true` 결과 배열의 모든 요소에 대 한 합니다.  
  
-   형식이 나 메서드를 실행 하는 것에 대 한는 <xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `false` 에서 반환 된 배열의 모든 요소에 대 한는 <xref:System.Type.GetGenericArguments%2A> 메서드.  
  
-   개방형 생성된 형식 또는 메서드를 실행 하는 것에 대 한 일부 배열 요소의 특정 형식일 수 있습니다 및 다른 형식 매개 변수가 될 수 있습니다. <xref:System.Type.IsGenericParameter%2A> 반환 `false` 형식에 대해 및 `true` 형식 매개 변수입니다. 에 대 한 코드 예제는 <xref:System.Type.ContainsGenericParameters%2A> 속성 혼합 형식 및 형식 매개 변수가 있는 제네릭 클래스를 보여 줍니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.IsGenericParameter%2A> 제네릭 형식에 제네릭 형식 매개 변수를 테스트 하는 속성입니다.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 제네릭 형식인지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" /> 현재 형식이 제네릭 형식입니다. 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Type.IsGenericType%2A> 속성을 확인 여부는 <xref:System.Type> 개체 제네릭 형식을 나타냅니다. 사용 하 여는 <xref:System.Type.ContainsGenericParameters%2A> 속성을 확인 여부는 <xref:System.Type> 개방형 생성된 형식이 나 폐쇄형된 생성된 형식 개체를 나타냅니다.  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A> 속성에서 반환 `false` 즉시 형식이 제네릭 경우. 예를 들어 요소가 형식의 배열을 `A<int>` (`A(Of Integer)` Visual basic에서)은 제네릭 형식 자체.  
  
 다음 표에서 일반 리플렉션에 사용 되는 일반적인 용어에 대 한 고정 조건을 요약 되어 있습니다.  
  
|용어|고정|  
|----------|---------------|  
|제네릭 형식 정의(generic type definition)|<xref:System.Type.IsGenericTypeDefinition%2A> 속성은 `true`입니다.<br /><br /> 제네릭 형식을 정의합니다. 생성된 된 형식을 호출 하 여 만든는 <xref:System.Type.MakeGenericType%2A> 메서드를는 <xref:System.Type> 형식 인수의 배열을 지정 하 고 제네릭 형식 정의 나타내는 개체입니다.<br /><br /> <xref:System.Type.MakeGenericType%2A> 제네릭 형식 정의에 대해서만 호출할 수 있습니다.<br /><br /> 모든 제네릭 형식 정의 제네릭 형식 (의 <xref:System.Type.IsGenericType%2A> 속성은 `true`), 이지만 반대는 그렇지 합니다.|  
|제네릭 형식(generic type)|<xref:System.Type.IsGenericType%2A> 속성은 `true`입니다.<br /><br /> 제네릭 형식 정의 개방형 생성된 형식이 나 폐쇄형된 생성된 형식 수 있습니다.<br /><br /> 배열 형식 요소 형식이 제네릭 인지 자체 제네릭 형식이 있습니다. 경우도 마찬가지는 <xref:System.Type> 제네릭 형식에 대 한 포인터를 나타내는 개체입니다.|  
|개방형 생성된 형식|<xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`입니다.<br /><br /> 예로 할당 되지 않은 형식 매개 변수를 제네릭 형식을, 개방형 생성된 형식 또는 제네릭 형식 정의에 중첩 된 형식 또는 형식 인수를 가진 제네릭 형식을 <xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`합니다.<br /><br /> 개방형 생성된 형식 인스턴스의 생성 하는 것이 불가능 합니다.<br /><br /> Note 하지 개방형 생성된 형식이 모두 일반적으로 진행 됩니다. 예를 들어 배열 요소 형식이 제네릭 형식 정의는 제네릭 및 제네릭이 아니거나 개방형 생성된 형식에 대 한 포인터.|  
|폐쇄형된 생성된 형식|<xref:System.Type.ContainsGenericParameters%2A> 속성은 `false`입니다.<br /><br /> 재귀적으로 검사 형식에 할당 되지 않은 제네릭 매개 변수가 없는 경우.|  
|제네릭 형식 매개 변수(generic type parameter)|<xref:System.Type.IsGenericParameter%2A> 속성은 `true`입니다.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`입니다.<br /><br /> 제네릭 형식 정의 나중에 할당할 수 있는 형식에 대 한 자리 표시자입니다.|  
|제네릭 형식 인수(generic type argument)|제네릭 형식 매개 변수를 포함 하 여 모든 형식일 수 있습니다.<br /><br /> 형식 인수를 배열로 지정 <xref:System.Type> 에 전달 된 개체는 <xref:System.Type.MakeGenericType%2A> 메서드 생성된 된 제네릭 형식을 만들 때. 결과 형식의 인스턴스를 만들 수는 경우는 <xref:System.Type.ContainsGenericParameters%2A> 속성 이어야 `false` 모든 형식 인수에 대 한 합니다.|  
  
 다음 코드 예제와 테이블 이러한 용어 및 고정 중 일부를 보여 줍니다. `Derived` 기본 형식이 해당 형식 인수 목록에 형식 및 형식 매개 변수가 혼합 되어 생성 된 형식 이므로 클래스는 특히 중요 합니다.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 다음 표에서 클래스에 빌드 및 사용 하는 예를 보여 줍니다 `Base`, `Derived`, 및 `G`합니다. C + + 및 C# 코드가 동일 하면 항목이 하나만 표시 됩니다.  
  
|예|고정|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|이 유형에:<br /><br /> <xref:System.Type.IsGenericType%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `true`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>가 `true`인 경우|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|이 유형에:<br /><br /> <xref:System.Type.IsGenericType%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>가 `true`인 경우|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|변수의 형식에 대 한 `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> `false` 때문에 `d` 은 배열입니다.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>가 `false`인 경우|  
|`T``U`, 및 `V` (나타나는 모든 위치)|<xref:System.Type.IsGenericParameter%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericType%2A> `false` 제네릭 형식에 형식 매개 변수를 제한할 수 있기 때문입니다.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true` 때문에 `T`, `U`, 및 `V` 제네릭 형식 매개 변수에 사용 하는 합니다. 나중에 할당 된 형식 인수에 대해 아무 것입니다.|  
|필드의 유형 `F`|<xref:System.Type.IsGenericType%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> `false` 의 형식 매개 변수에 형식이 할당 된 때문에 `G`합니다. 이 호출한 것과 동일는 <xref:System.Type.MakeGenericType%2A> 메서드.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true` 때문에 필드의 형식을 `F` 개방형 생성 된 형식인 형식 인수가 있습니다. 생성 된 형식이 열려 때문에 해당 형식 인수 (즉, `Base`)는 제네릭 형식 정의 합니다. 재귀적 특성 들 여 <xref:System.Type.IsGenericType%2A> 속성입니다.|  
|중첩된 클래스 `Nested`|<xref:System.Type.IsGenericType%2A> `true`경우라도는 `Nested` 제네릭 형식에 중첩 되는 클래스에 자체의 제네릭 형식 매개 변수가 없습니다.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `true`인 경우 즉, 호출 수는 <xref:System.Type.MakeGenericType%2A> 메서드와 공급 바깥쪽 형식의 형식 매개 변수 `Derived`합니다.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> `true` 바깥쪽 형식 때문에 `Derived`, 제네릭 형식 매개 변수가 있습니다. 재귀적 특성 들 여 <xref:System.Type.ContainsGenericParameters%2A> 속성입니다.|  
  
   
  
## Examples  
 값을 표시 하는 다음 코드 예제는 <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, 및 <xref:System.Type.ContainsGenericParameters%2A> 주의 섹션에 설명 하는 형식에 대 한 속성. 속성 값의 설명에 대 한 설명에 함께 제공 된 표를 참조 합니다.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 다른 제네릭 형식을 생성하는 데 사용될 수 있는 제네릭 형식 정의를 나타내는지를 가리키는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" /> 개체가 제네릭 형식 정의를 나타내면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식 정의 다른 형식을 생성 하는 데 사용 될 수 있는 템플릿입니다. 예를 들어 제네릭 형식 정의에서 `G<T>` (C# 구문; 표시 합니다. `G(Of T)` Visual Basic의 또는 `generic <typename T> ref class G` c + +에서) 생성 하 고 형식을 인스턴스화할 수 `G<int>` (`G(Of Integer)` Visual Basic의)를 호출 하 여는 <xref:System.Type.MakeGenericType%2A> 포함 하는 제네릭 인수 목록을 사용 하 여 메서드는 <xref:System.Int32> 형식입니다. 지정 된는 <xref:System.Type> 생성 된 형식을 나타내는이 개체는 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드는 제네릭 형식 정의 가져옵니다 다시 다시 합니다.  
  
 사용 하 여는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성을 현재 형식에서 새 형식을 만들 수 있는지 확인 합니다. 경우는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성에서 반환 `true`, 호출할 수 있습니다는 <xref:System.Type.MakeGenericType%2A> 방법을 새 제네릭 형식을 만들 수 있습니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 여부는 제네릭 형식 정의가 포함 된 형식에 대 한 정보를 표시 합니다. 생성된 된 형식, 제네릭 형식 정의 및 일반 형식에 대 한 정보가 표시 됩니다.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />에 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 특성이 적용되어 있는지 여부를 나타내는 값을 가져옵니다. 이 특성은 해당 형식이 COM 형식 라이브러리에서 가져온 것임을 나타냅니다.</summary>
        <value>
          <see langword="true" />에 <see cref="T:System.Type" />가 있으면 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>.`  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">현재 형식과 비교할 개체입니다.</param>
        <summary>지정된 개체가 현재 <see cref="T:System.Type" />의 인스턴스인지를 확인합니다.</summary>
        <returns>
          현재 <see langword="Type" />이 <paramref name="o" />가 나타내는 개체의 상속 계층 구조에 속하거나 현재 <see langword="Type" />이 <paramref name="o" />가 구현하는 인터페이스이면 <see langword="true" />입니다. 이러한 조건에 해당하지 않거나 <paramref name="o" />가 <see langword="null" />이거나 현재 <see langword="Type" />이 개방형 제네릭 형식(즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" /> 반환)이면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
> [!NOTE]
>  생성된 된 형식을 제네릭 형식 정의의 인스턴스가 아닙니다. 즉, `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual basic에서)의 인스턴스가 아닌 `MyGenericList<T>` (`MyGenericList(Of T)` Visual basic에서).  
  
   
  
## Examples  
 다음 예제에서는 `IsInstanceOfType` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 인터페이스인지, 즉 클래스 또는 값 형식이 아닌지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 인터페이스이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> 클래스, 인터페이스 또는 값 형식으로 형식 선언이 구별 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 인터페이스를 만듭니다 인터페이스 형식을 확인 하 고 클래스에 있는지 여부를 나타내는 `IsInterface` 속성 집합입니다.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메타데이터에 정의되고 내보낸 순서로 현재 형식의 필드가 순차적으로 배치되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 여부 형식 레이아웃 특성 및 다음 테스트를 선택 하는 열거형 값 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 설정 됩니다. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드가 메모리에 배치 되는 방식을 나타냅니다.  
  
 동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 유형을 만들 때. 코드에서 적용는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성이 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 열거형 값을 해당 레이아웃은 순차적 지정 하는 형식입니다.  
  
> [!NOTE]
>  사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 확인 하 여부는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 되었습니다.  
  
 자세한 내용은 "II: 메타 데이터 정의 및 의미" 인프라 CLI (공용 언어) 설명서에 대 한 사양의 9.1.2 섹션을 참조 합니다. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](http://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](http://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제는 클래스의 인스턴스를 만드는 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 열거형 값에는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 클래스 설정 된 경우에 대 한 검사는 <xref:System.Type.IsLayoutSequential%2A> 속성을 결과 표시 합니다.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 참조로 마샬링되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 참조에 의해 마샬링되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성은 <xref:System.Type> 클래스입니다. 있는지 여부 지정된 된 형식의 호스팅될 수 컨텍스트에서 그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 있는지 확인 합니다.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Type.IsMarshalByRef" /> 속성을 구현하고, <see cref="T:System.Type" />이 참조에 의해 마샬링되는지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 참조에 의해 마샬링되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 형식을 참조로 마샬링되 하 고 결과 표시 하는지 여부를 결정 합니다.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" /> 개체가 다른 형식의 정의 안에 중첩된 정의를 가진 형식을 나타내는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 다른 형식 안에 중첩되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> 속성에서 반환 `true` 모든 표시 여부에 관계 없이 형식에 중첩 합니다. 를 테스트 하려면 중첩 및 표시 유형에 대해 동시에 관련된 속성을 사용 하 여 <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, 또는 <xref:System.Type.IsNestedPublic%2A>합니다.  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> 열거형 멤버 유형에 대 한 표시 유형 특성을 선택 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형에 대 한 다양 한 형식을 포함 하는 중첩 된 클래스와 외부 클래스를 만듭니다. 그런 다음의 표시 여부와 관련 된 숫자 값을 검색 <xref:System.Type> 부모 유형 및 각 변수와 중첩된 형식에 대 한 속성.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 중첩되었으며 자체 어셈블리 내에서만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 중첩되어 있고 자체 어셈블리 내에서만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형에 대 한 다양 한 형식을 포함 하는 중첩 된 클래스와 외부 클래스를 만듭니다. 그런 다음의 표시 여부와 관련 된 숫자 값을 검색 <xref:System.Type> 부모 유형 및 각 변수와 중첩된 형식에 대 한 속성.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 중첩되었으며 자체 패밀리와 자체 어셈블리 모두에 속하는 클래스에만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 중첩되어 있고 자체 패밀리와 자체 어셈블리 모두에 속하는 클래스에만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic 언어 어셈블리의 보호 된 형식에만 표시 되는 중첩된 형식을 정의할 수 있도록 하는 의미 체계를 포함 하지 않습니다. `protected internal` C#의 표시 유형 및 `Protected Friend` Visual Basic의 표시 유형을 보호 된 형식 및 동일한 어셈블리의 형식에 표시 되는 중첩된 형식을 정의 합니다.  
  
 A <xref:System.Type> 같은 모든 개체를 개체의 제품군 이루어집니다 <xref:System.Type> 및 그 하위 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형에 대 한 다양 한 형식을 포함 하는 중첩 된 클래스와 외부 클래스를 만듭니다. 그런 다음의 표시 여부와 관련 된 숫자 값을 검색 <xref:System.Type> 부모 유형 및 각 변수와 중첩된 형식에 대 한 속성.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 중첩되었으며 자체 패밀리 내에서만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 중첩되어 있고 자체 패밀리 내에서만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
 A <xref:System.Type> 정확히의 모든 개체를 개체의 제품군 이루어집니다 동일한 <xref:System.Type> 및 그 하위 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형에 대 한 다양 한 형식을 포함 하는 중첩 된 클래스와 외부 클래스를 만듭니다. 그런 다음의 표시 여부와 관련 된 숫자 값을 검색 <xref:System.Type> 부모 유형 및 각 변수와 중첩된 형식에 대 한 속성.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 중첩되었으며 자체 패밀리와 자체 어셈블리 중 하나에 속하는 클래스에만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 중첩되어 있고 자체 패밀리 또는 자체 어셈블리에 속하는 클래스에만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식의 표시 되 `protected internal` C# 또는 `Protected Friend` Visual Basic의 경우에 <xref:System.Type.IsNestedFamORAssem%2A> 속성에서 반환 `true`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
 A <xref:System.Type> 정확히의 모든 개체를 개체의 제품군 이루어집니다 동일한 <xref:System.Type> 및 그 하위 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형에 대 한 다양 한 형식을 포함 하는 중첩 된 클래스와 외부 클래스를 만듭니다. 그런 다음의 표시 여부와 관련 된 숫자 값을 검색 <xref:System.Type> 부모 유형 및 각 변수와 중첩된 형식에 대 한 속성.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 중첩되어 있고 private 형식으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 중첩되어 있고 private 형식으로 선언되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형에 대 한 다양 한 형식을 포함 하는 중첩 된 클래스와 외부 클래스를 만듭니다. 그런 다음의 표시 여부와 관련 된 숫자 값을 검색 <xref:System.Type> 부모 유형 및 각 변수와 중첩된 형식에 대 한 속성.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클래스가 중첩되어 있고 public 형식으로 선언되어 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          클래스가 중첩되어 있고 public 형식으로 선언되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형에 대 한 다양 한 형식을 포함 하는 중첩 된 클래스와 외부 클래스를 만듭니다. 그런 다음의 표시 여부와 관련 된 숫자 값을 검색 <xref:System.Type> 부모 유형 및 각 변수와 중첩된 형식에 대 한 속성.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 public으로 선언되어 있지 않은지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 public으로 선언되어 있지 않고 중첩 형식이 아니면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중첩된 형식; 함께이 속성을 사용 하지 마십시오 사용 하 여 <xref:System.Type.IsNestedPublic%2A> 속성 대신 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 이 예제에서는 용도 `IsNotPublic` 표시 유형 가져올 속성입니다.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 다음 코드 예제에서는 사용할 수 없는 이유 `IsPublic` 및 `IsNotPublic` 중첩 된 클래스에 대 한 합니다.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 중첩 된 클래스에 대 한 결과를 무시 `IsPublic` 및 `IsNotPublic` 의 결과에 주의 `IsNestedPublic` 및 `IsNestedPrivate`합니다. 이 코드 조각에 대 한 리플렉션을 출력은 다음과 같이 합니다.  
  
|클래스|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|FALSE|false|  
|B|false|false|true|FALSE|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 포인터인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 포인터이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수 나타냅니다 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예에서는 사용 하 여 `IsPointer` 속성입니다.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsPointer" /> 속성을 구현하고 <see cref="T:System.Type" />이 포인터인지를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 포인터이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 기본 형식 중 하나인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 기본 형식 중 하나이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 형식은 <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, 및 <xref:System.Single>합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수 나타냅니다 `false`합니다.  
  
   
  
## Examples  
 다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성은 <xref:System.Type> 클래스입니다. 있는지 여부 지정된 된 형식의 호스팅될 수 컨텍스트에서 그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 있는지 확인 합니다.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsPrimitive" /> 속성을 구현하고 <see cref="T:System.Type" />이 기본 형식 중 하나인지를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 기본 형식 중 하나이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 형식은 <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, 및 <xref:System.Single>합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 형식이 기본 형식이 고 결과 표시 하는지 여부를 결정 합니다.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 public으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 public으로 선언되어 있고 중첩 형식이 아니면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중첩된 형식; 사용 안 함 사용 하 여 <xref:System.Type.IsNestedPublic%2A> 대신 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 반환 제네릭 형식의 형식 매개 변수를 나타내는 `true`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 인스턴스를 만듭니다. `MyTestClass`에 대 한 검사는 `IsPublic` 속성을 결과 표시 합니다.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 중첩 된 클래스에 대 한 결과를 무시 `IsPublic` 및 `IsNotPublic` 의 결과에 주의 <xref:System.Type.IsNestedPublic%2A> 및 <xref:System.Type.IsNestedPrivate%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 봉인된 형식으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 봉인된 형식으로 선언되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 인스턴스를 만듭니다.는 `sealed` 클래스에 대 한 검사는 `IsSealed` 속성을 결과 표시 합니다.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 현재 신뢰 수준에서 보안에 중요한 형식이거나 보안 안전에 중요한 형식이어서 중요한 작업을 수행할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 형식이 보안에 중요한 형식이거나 보안 안전에 중요한 형식인 경우 <see langword="true" />이고 투명 형식인 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 공용 언어 런타임 (CLR)에 의해 결정 된 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다. 다음 표에서 이러한 속성의 조합은 같습니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성의 값은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. (예를 들어 샌드 박싱된 응용 프로그램 도메인) 부분적으로 신뢰할 수 있는 응용 프로그램 도메인에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임에서는 어셈블리가 위치 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰할 수 있는 응용 프로그램 도메인에 로드 되어 있는 경우에 부분 신뢰 어셈블리의 보안 주석에 유용 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)은 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전히 신뢰 되어 로드 항상 현재 신뢰 수준은 완전히 신뢰할 수 있는 항상 이므로. 사용 하 여 어셈블리 및 응용 프로그램 도메인의 현재 신뢰 수준을 확인할 수 있습니다는 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 및 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명도 대 한 정보를 참조 하십시오. [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 현재 신뢰 수준에서 보안 안전에 중요한 형식인지 즉, 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 형식이 현재 신뢰 수준에서 보안에 중요한 형식인 경우 <see langword="true" />이고 보안에 중요한 형식이거나 투명 형식인 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 공용 언어 런타임 (CLR)에 의해 결정 된 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다. 다음 표에서 이러한 속성의 조합은 같습니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성의 값은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. (예를 들어 샌드 박싱된 응용 프로그램 도메인) 부분적으로 신뢰할 수 있는 응용 프로그램 도메인에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임에서는 어셈블리가 위치 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰할 수 있는 응용 프로그램 도메인에 로드 되어 있는 경우에 부분 신뢰 어셈블리의 보안 주석에 유용 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)은 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전히 신뢰 되어 로드 항상 현재 신뢰 수준은 완전히 신뢰할 수 있는 항상 이므로. 사용 하 여 어셈블리 및 응용 프로그램 도메인의 현재 신뢰 수준을 확인할 수 있습니다는 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 및 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명도 대 한 정보를 참조 하십시오. [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          형식이 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 반환 하는 경우 `true`, <xref:System.Type.IsSecurityCritical%2A> 및 <xref:System.Type.IsSecuritySafeCritical%2A> 속성 반환 `false`합니다.  
  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 공용 언어 런타임 (CLR)에 의해 결정 된 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다. 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성의 값은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. (예를 들어 샌드 박싱된 응용 프로그램 도메인) 부분적으로 신뢰할 수 있는 응용 프로그램 도메인에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임에서는 어셈블리가 위치 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰할 수 있는 응용 프로그램 도메인에 로드 되어 있는 경우에 부분 신뢰 어셈블리의 보안 주석에 유용 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)은 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전히 신뢰 되어 로드 항상 현재 신뢰 수준은 완전히 신뢰할 수 있는 항상 이므로. 사용 하 여 어셈블리 및 응용 프로그램 도메인의 현재 신뢰 수준을 확인할 수 있습니다는 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 및 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명도 대 한 정보를 참조 하십시오. [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />의 serialization 가능 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" />을 serialize할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
.NET 표준에 정의 된 형식으로 표시 되지 않은 <xref:System.SerializableAttribute>합니다. 대신, 각.NET 구현 형식을 직렬화 가능 인지 확인 합니다. 실행 시 사용할 수 있습니다는 <xref:System.Type.IsSerializable%2A> 속성을 구현 하는 형식의 인스턴스로의 serialization을 지원 하는지 여부를 확인 합니다. 자세한 내용 및 예제에 대 한 참조 [표준.NET 개체를 직렬화 가능 인지 확인 하는 방법을](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)합니다.
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는의 인스턴스를 만들고 `MyTestClass` [Serializable] 특성을 설정 하 고 확인 하는 클래스는 `IsSerializable` 속성에 대 한 `true` 또는 `false`합니다.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>별도의 처리가 필요한 이름이 형식에 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          별도의 처리가 필요한 이름이 형식에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이름으로 시작 하거나 밑줄 문자 (_)을 속성 접근자 메서드 오버 로드 된 연산자를 포함 하는 예 일부 컴파일러에서 특별 한 취급이 필요할 수 있는 형식입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">현재 형식과 비교할 형식입니다.</param>
        <summary>현재 <see cref="T:System.Type" />이 지정된 <see cref="T:System.Type" />에서 파생되는지 여부를 확인합니다.</summary>
        <returns>
          현재 <see langword="true" />이 <see langword="Type" />에서 파생되면 <paramref name="c" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드는 <see langword="false" /> 및 현재 <paramref name="c" />이 동일한 경우에도 <see langword="Type" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출할 수 있습니다는 <xref:System.Type.IsSubclassOf%2A> 메서드를 다음 중 하나를 결정 합니다.  
  
-   여부 하나의 클래스에서 다른 파생 됩니다.  
  
-   형식에서 파생 되는 여부 <xref:System.ValueType>합니다. 그러나는 <xref:System.Type.IsValueType%2A> 되는 형식이 값 형식 인지 확인 하는 보다 효율적인 방법입니다.  
  
-   형식에서 파생 되는 여부 <xref:System.Enum>합니다. 그러나는 <xref:System.Type.IsEnum%2A> 메서드는 형식이 열거형 인지 확인 하는 보다 효율적인 방법입니다.  
  
-   형식이 인지는, 대리자, 즉 중 하나에서 파생 되는 여부 <xref:System.Delegate> 또는 <xref:System.MulticastDelegate>합니다.  
  
 <xref:System.Type.IsSubclassOf%2A> 인터페이스 다른 인터페이스에서 파생 되는 여부 또는 클래스 인터페이스를 구현 하는지 여부를 결정 하는 메서드를 사용할 수 없습니다. 사용 하 여는 <xref:System.Type.IsAssignableFrom%2A> 다음 예제와 같이를 위해서는 메서드.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수 또는 해당 클래스 제약 조건에서 파생 된 제네릭 형식 또는 제네릭 메서드 정의에 <xref:System.Object?displayProperty=nameWithType> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  인터페이스와 함께 사용할 경우를 제외 하 고 <xref:System.Type.IsSubclassOf%2A> 의 반대입니다 <xref:System.Type.IsAssignableFrom%2A>합니다. 즉, 경우 `t1.IsSubclassOf(t2)` 은 `true`, 다음 `t2.IsAssignableFrom(t1)` 이기도 `true`합니다.  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 예에서는 라는 클래스를 만들고 `Class1` 및 라는 파생된 클래스가 `DerivedC1`합니다. 호출 된 <xref:System.Type.IsSubclassOf%2A> 메서드는 `DerivedC1` 의 서브 클래스가 `Class1`합니다.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" />가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="UnicodeClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />에 대해 문자열 형식 특성 <see langword="UnicodeClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 하는 데 사용 됩니다. 문자열 형식 특성은 문자열의 해석 방법을 정의 하 여 상호 운용성을 향상 시킵니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />이 값 형식인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />이 값 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값 형식은 비트; 시퀀스로 표현 되는 형식 값 형식은 클래스 또는 인터페이스 되지 않습니다. 값 형식 이라고 "구조체" 일부 프로그래밍 언어에서입니다. 열거형은 값 형식의 특별 한 경우입니다.  
  
 이 속성은 반환 `false` 에 대 한는 <xref:System.ValueType> 클래스 <xref:System.ValueType> 자체 값 유형이 아닙니다. 모든 값 형식에 대 한 기본 클래스 이며 따라서 모든 값 형식에 지정할 수 있습니다. 하지 않는 것이 가능한 경우 <xref:System.ValueType> 자체이 값 형식이 있습니다. 형식의 필드에 할당 된 경우 값 형식은 boxed <xref:System.ValueType>합니다.  
  
 이 속성은 반환 `true` 열거형에 대 한는 <xref:System.Enum> 자체를 입력 합니다. 이 동작을 보여 주는 예제를 참조 하십시오. <xref:System.Type.IsEnum%2A>합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 형식 변수를 만들고 `MyEnum`에 대 한 검사는 `IsValueType` 속성을 결과 표시 합니다.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Type.IsValueType" /> 속성을 구현하고 <see cref="T:System.Type" />이 값 형식인지 여부, 즉 클래스 또는 인터페이스가 아닌지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />이 값 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 대체 형식 시스템의 구현을 사용할 수 있도록 제공 됩니다. 일반적으로 응용 프로그램 코드에서 사용 되지 않습니다 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />을 어셈블리 외부의 코드에서 액세스할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 <see langword="true" />이 public 형식이거나 바깥쪽 형식이 모두 public인 public 중첩 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하 여 형식 구성 요소 어셈블리의 공용 인터페이스의 일부 인지 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 클래스를 어셈블리 외부에 표시 되는 중 하나에 테스트 합니다.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 형식의 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>하한이 0인 현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>하한이 0인 현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> 메서드 요소 형식이 런타임 시 계산 되는 배열 형식을 생성 하는 방법을 제공 합니다.  
  
 **참고** 공용 언어 런타임 (즉, 1 차원 배열에 항상 0부터 시작) 벡터 사이의 구분 작업을 수행 하 고 다차원 배열입니다. 1 차원만 항상 벡터만 차원 수가 발생 하는 다차원 배열로 같지 않습니다. 벡터 형식을 만드는이 메서드 오버 로드만 사용할 수 있으며 벡터 형식을 만드는 유일한 방법입니다. 사용 하 여는 <xref:System.Type.MakeArrayType%28System.Int32%29> 메서드 오버 로드 다차원 배열 형식을 만들 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스입니다.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
 또는  
  
 현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">배열의 차수입니다. 이 수는 32보다 작거나 같아야 합니다.</param>
        <summary>지정된 차수의 현재 형식 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>지정된 차수의 현재 형식 배열을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> 메서드 요소 형식이 런타임 시 계산 되는 배열 형식을 생성 하는 방법을 제공 합니다.  
  
> [!NOTE]
>  공용 언어 런타임 (즉, 1 차원 배열에 항상 0부터 시작) 벡터 사이의 구분 작업을 수행 하 고 다차원 배열입니다. 1 차원만 항상 벡터만 차원 수가 발생 하는 다차원 배열로 같지 않습니다. 벡터 형식; 만들려면이 메서드 오버 로드를 사용할 수 없습니다. 경우 `rank` 이 1 이면이 메서드 오버 로드에는 차원 수가 발생 하는 다차원 배열 형식을 반환 합니다. 사용 된 <xref:System.Type.MakeArrayType> 형식을 만들려면 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스입니다.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" />이 잘못되었습니다. 예를 들면, 0 또는 음수입니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
 또는  
  
 현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.  
  
 또는  
  
 <paramref name="rank" />이(가) 32보다 큽니다.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Type" />(Visual Basic의 경우 <see langword="ref" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see langword="ByRef" /> 개체를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Type" />(Visual Basic의 경우 <see langword="ref" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see langword="ByRef" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A> 메서드를 생성 하는 방법을 제공 `ref` 형식 (`ByRef` Visual basic에서) 매개 변수를 나열 합니다.  
  
 경우 Microsoft 중간 언어 (MSIL) 구문을 사용 하 여 현재 <xref:System.Type> 개체가 나타내는 <xref:System.Int32>,이 메서드는 반환 된 <xref:System.Type> 나타내는 개체 `Int32&`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스입니다.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
 또는  
  
 현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">현재 제네릭 형식의 형식 매개 변수로 대체할 형식 배열입니다.</param>
        <summary>형식 배열의 요소를 현재 제네릭 형식 정의의 형식 매개 변수로 대체하며 생성된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Type" />의 요소를 현재 제네릭 형식의 형식 매개 변수로 대체하여 생성된 형식을 나타내는 <paramref name="typeArguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A> 메서드를 사용 하면 특정 형식을 만드는 제네릭 형식 정의의 형식 매개 변수에 할당 하는 코드를 작성할 수는 <xref:System.Type> 생성된 된 특정 형식을 나타내는 개체입니다. 이 사용 하 여 <xref:System.Type> 생성 된 형식의 런타임 인스턴스를 만드는 개체입니다.  
  
 형식을 사용 하 여 생성 <xref:System.Type.MakeGenericType%2A> 열릴 수 있으며, 즉, 형식 인수의 중 일부 제네릭 메서드 또는 형식의 바깥쪽 형식 매개 변수를 수 있습니다. 동적 어셈블리를 생성할 때 이러한 개방형 생성된 형식이 사용할 수 있습니다. 예를 들어 클래스 `Base` 및 `Derived` 다음 코드에 있습니다.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 생성 하려면 `Derived` 동적 어셈블리에 해야 하는 기본 형식을 생성 합니다. 이 작업을 수행 하려면 호출는 <xref:System.Type.MakeGenericType%2A> 에서 메서드는 <xref:System.Type> 클래스를 나타내는 개체 `Base`, 제네릭 형식 인수를 사용 하 여 <xref:System.Int32> 형식 매개 변수 `V` 에서 `Derived`합니다. 형식 및 제네릭 형식 매개 변수는 모두로 표시 되므로 <xref:System.Type> 개체를 모두 포함 하는 배열에 전달 될 수는 <xref:System.Type.MakeGenericType%2A> 메서드.  
  
> [!NOTE]
>  와 같은 생성된 된 형식을 `Base<int, V>` 코드를 내보낼 때 유용 하지만 호출할 수 없습니다는 <xref:System.Type.MakeGenericType%2A> 이 형식의 메서드는 제네릭 형식 정의 없기 때문에 합니다. 인스턴스화할 수 있는 폐쇄형된 생성된 형식을 만들려면 먼저 호출는 <xref:System.Type.GetGenericTypeDefinition%2A> 가져올 메서드를 한 <xref:System.Type> 제네릭 형식 정의 나타내는 개체와 호출 다음 <xref:System.Type.MakeGenericType%2A> 원하는 형식 인수를 사용 합니다.  
  
 <xref:System.Type> 에서 반환 된 개체 <xref:System.Type.MakeGenericType%2A> 동일는 <xref:System.Type> 호출 하 여 가져온는 <xref:System.Object.GetType%2A> 메서드 결과 생성 된 형식을 또는 <xref:System.Object.GetType%2A> 모든 생성에서 작성 된 동일한 제네릭 형식 동일한 형식 인수를 사용 하 여 정의 입력 합니다.  
  
> [!NOTE]
>  제네릭 형식의 배열 자체 제네릭 형식이 있습니다. 호출할 수 없습니다 <xref:System.Type.MakeGenericType%2A> 같은 배열을 입력 `C<T>[]` (`Dim ac() As C(Of T)` Visual basic에서). 폐쇄형된 제네릭 형식을 생성 하려면 `C<T>[]`, 호출 <xref:System.Type.GetElementType%2A> 제네릭 형식 정의를 가져오려면 `C<T>`; 호출 <xref:System.Type.MakeGenericType%2A> ; 생성된 된 형식을 만들고 마지막으로 호출 하려면 제네릭 형식 정의에 <xref:System.Type.MakeArrayType%2A> 메서드 배열 형식을 만들려면 생성 된 형식입니다. 포인터 형식의 마찬가지 및 `ref` 형식 (`ByRef` Visual basic에서).  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
## <a name="nested-types"></a>중첩 형식  
 C#, c + + 또는 Visual Basic을 사용 하 여 제네릭 형식이 정의 하는 경우 중첩된 형식은 모두 제네릭 합니다. 이 세 언어 모두 중첩 형식의 형식 매개 변수 목록이 바깥쪽 형식의 형식 매개 변수를 포함 하기 때문에 중첩된 된 형식이 있는 각각의 형식 매개 변수가 없는 경우에 마찬가지입니다. 다음 클래스를 고려 합니다.  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 중첩 된 클래스의 형식 매개 변수 목록 `Inner` 두 형식 매개 변수가 `T` 및 `U`는 첫 번째는 바깥쪽 클래스의 형식 매개 변수입니다. 마찬가지로, 중첩 된 클래스의 형식 매개 변수 목록 `Innermost1` 세 개의 형식 매개 변수가 `T`, `U`, 및 `V`와 `T` 및 `U` 는 바깥쪽 클래스에서 발생 합니다. 중첩 된 클래스 `Innermost2` 두 형식 매개 변수가 `T` 및 `U`는 바깥쪽 클래스에서 나오는 합니다.  
  
 바깥쪽 형식의 매개 변수 목록에 둘 이상의 형식 매개 변수를 중첩 형식의 형식 매개 변수 목록의 순서 대로 모든 형식 매개 변수에 포함 됩니다.  
  
 중첩 된 형식에 대 한 제네릭 형식 정의에서 제네릭 형식을 생성, 호출 된 <xref:System.Type.MakeGenericType%2A> 메서드는 배열 사용 하 여 모든 바깥쪽 형식의 가장 바깥쪽 제네릭 형식으로 시작 및 종료와 형식 인수 배열을 연결 하 여 형성는 자체의 형식 매개 변수가 있는 경우에 중첩된 형식 자체의 인수 배열을 입력 합니다. 인스턴스를 만드는 `Innermost1`, 호출 된 <xref:System.Type.MakeGenericType%2A> T, U 및 V에 할당할 세 개의 형식을 포함 하는 배열 사용 하 여 메서드. 인스턴스를 만드는 `Innermost2`, 호출 된 <xref:System.Type.MakeGenericType%2A> T, U 및에 할당할 수는 두 가지 형식이 포함 된 배열 사용 하 여 메서드  
  
 언어는 중첩 형식의 필드를 정의 하려면 바깥쪽 형식의 형식 매개 변수를 사용할 수 있도록이 방식 바깥쪽 형식의 형식 매개 변수를 전파 합니다. 그렇지 않은 경우 형식 매개 변수는 범위는 중첩 형식의 본문 내에 수 없습니다. 동적 어셈블리에서 코드를 생성 하거나 사용 하 여 바깥쪽 형식의 형식 매개 변수를 전파 하지 않고 중첩된 형식을 정의할 수는 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다. MSIL 어셈블러에 대해 다음 코드를 살펴보세요.  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 이 예제에서는 수 없는 형식의 필드를 정의 하려면 `T` 또는 `U` 클래스에서 `Innermost`이러한 형식 매개 변수 범위에 없기 때문에, 합니다. 다음 어셈블러 코드는 c + +, Visual Basic 및 C#에 정의 된 경우 마찬가지 방식으로 동작 하는 중첩된 클래스를 정의 합니다.  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 사용할 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 고급 언어에 정의 된 중첩 된 클래스를 검사 하 고이 명명 스키마를 확인할 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.MakeGenericType%2A> 에 대 한 제네릭 형식 정의에서 생성된 된 형식을 만드는 메서드를는 <xref:System.Collections.Generic.Dictionary%602> 유형입니다. 생성 된 형식은 <xref:System.Collections.Generic.Dictionary%602> 의 `Test` 문자열 키가 있는 개체입니다.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식이 제네릭 형식의 정의를 나타내지 않습니다. 즉, <see cref="P:System.Type.IsGenericTypeDefinition" />이 <see langword="false" />를 반환합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeArguments" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArguments" />의 요소 수가 현재 제네릭 형식 정의의 형식 매개 변수 수와 같지 않은 경우  
  
 또는  
  
 <paramref name="typeArguments" />의 요소가 현재 제네릭 형식의 해당 형식 매개 변수에 지정된 제약 조건을 충족하지 않는 경우  
  
 또는  
  
 <paramref name="typeArguments" />는 포인터 형식(<see cref="P:System.Type.IsPointer" />는 <see langword="true" />를 반환), 참조로 전달되는 형식(<see cref="P:System.Type.IsByRef" />는 <see langword="true" />를 반환) 또는 <see cref="T:System.Void" />인  요소를 포함합니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 형식에 대한 포인터를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>현재 형식에 대한 포인터를 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> 메서드 매개 변수 목록에 대 한 포인터 형식을 생성 하는 방법을 제공 합니다.  
  
 경우 Microsoft 중간 언어 (MSIL) 구문을 사용 하 여 현재 <xref:System.Type> 개체가 나타내는 <xref:System.Int32>,이 메서드는 반환 된 <xref:System.Type> 나타내는 개체 `Int32*`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스입니다.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
 또는  
  
 현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버가 형식 또는 중첩 형식임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값을 가져옵니다.</summary>
        <value>이 멤버가 형식 또는 중첩 형식임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 재정의 <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>합니다. 따라서 집합을 조사할 때 <xref:System.Reflection.MemberInfo> 개체-반환 하는 배열 예를 들어 <xref:System.Type.GetMembers%2A>-는 <xref:System.Reflection.MemberInfo.MemberType%2A> 속성에서 반환 <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> 때 지정된 된 멤버는 중첩 형식이 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서)를 따라이 속성의 값이 결정 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제는 `MemberType` 필드에 대 한 매개 변수로 `GetMember` 메서드:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" /> 정보의 손실된 값을 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 `Missing` 매개 변수의 기본 값을 얻기 위해 리플렉션을 통해 호출에 대 한 필드입니다. 경우는 `Missing` 매개 변수 값에 대 한 필드에 전달 하 고 해당 매개 변수에 대해 기본 가치가 없습니다는 <xref:System.ArgumentException> throw 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용을 보여 줍니다.는 `Missing` 필드를 기본 인수로 사용 하 여 메서드를 호출 합니다.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 이 코드의 결과는 다음과 같습니다.  
  
 a = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 a = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 정의된 모듈(DLL)을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />이 정의된 모듈입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 제네릭 형식 정의가 정의 된 모듈을 반환 합니다. 예를 들어의 인스턴스를 만들 경우 `MyGenericStack<int>`, <xref:System.Type.Module%2A> 는 모듈을 반환 하는 생성된 된 형식에 대 한 속성 `MyGenericStack<T>` 정의 됩니다.  
  
 마찬가지로, 하는 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식을 포함 하는 어셈블리 반환 `T`합니다.  
  
   
  
## Examples  
 사용법을 설명 하는 다음 예제는 <xref:System.Type.Namespace%2A> 및 `Module` 속성 및 <xref:System.Type.ToString%2A> 방식의 <xref:System.Type>합니다.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Type" />의 네임스페이스를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" />의 네임스페이스입니다. 현재 인스턴스가 제네릭 매개 변수를 나타내거나 네임스페이스가 없으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네임 스페이스는는 논리적 디자인 타임 명명 규칙 인 주로 응용 프로그램에서 범위를 정의 하 고 클래스와 단일 계층 구조에서 다른 형식을 구성 하는 데 사용 합니다. 런타임에서의 측면에서 보면 네임 스페이스가 없는 합니다.  
  
 하는 경우 현재 <xref:System.Type> 생성 된 제네릭 형식을 나타내며,이 속성 제네릭 형식 정의 포함 하는 네임 스페이스를 반환 합니다. 마찬가지로, 하는 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식 정의 포함 하는 네임 스페이스 반환 `T`합니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 개체를이 속성은 반환 `null`합니다.  
  
   
  
## Examples  
 사용법을 설명 하는 다음 예제는 `Namespace` 및 <xref:System.Type.Module%2A> 속성 및 <xref:System.Type.ToString%2A> 방식의 <xref:System.Type>합니다.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 개체입니다.</param>
        <param name="right">비교할 두 번째 개체입니다.</param>
        <summary>두 <see cref="T:System.Type" /> 개체가 같은지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 개체입니다.</param>
        <param name="right">비교할 두 번째 개체입니다.</param>
        <summary>두 <see cref="T:System.Type" /> 개체가 같지 않은지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버를 얻는 데 사용된 클래스 개체를 가져옵니다.</summary>
        <value>이 <see langword="Type" /> 개체를 얻는 데 사용된 <see cref="T:System.Type" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 <xref:System.Type> 개체의 경우이 속성의 값은 항상의 값과 같으면는 <xref:System.Type.DeclaringType%2A> 속성입니다.  
  
   
  
## Examples  
 이 예제에는 중첩 된 클래스의 반사 된 유형을 표시합니다.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 <see cref="T:System.Type" />의 어셈블리로 한정된 이름입니다.</param>
        <param name="throwIfNotFound">
          형식을 찾을 없는 경우 <see langword="true" />을 throw하려면 <see cref="T:System.TypeLoadException" />이고, 형식을 찾을 수 없는 경우 <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <param name="ignoreCase">
          <c>typeName</c>에 대해 대/소문자를 구분하지 않는 검색을 수행하려면 <see langword="true" />이고, <c>typeName</c>에 대해 대/소문자를 구분하는 검색을 수행하려면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 구분하여 검색할지 여부와 형식이 없으면 예외를 throw할지를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다. 형식은 실행을 위해서가 아니라 리플렉션을 위해서만 로드됩니다.</summary>
        <returns>지정된 이름의 형식이 있으면 이를 반환하고 그렇지 않으면 <see langword="null" />을 반환합니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwIfNotFound" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwIfNotFound" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식을 포함 하는 어셈블리 되어 있지 않은 경우 리플렉션 전용 컨텍스트에 로드를 사용 하는 <xref:System.Type.ReflectionOnlyGetType%2A> 메서드는 첫 번째에 해당 어셈블리를 로드 하는 리플렉션 위해서만 사용 하 여는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 메서드를 호출 하 여 형식을 로드 하는 다음의 어셈블리의 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 메서드. 어셈블리의 정규화 된 이름에 대 한 정보를 참조 하십시오.는 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> 속성입니다. 형식 이름 지정에 대 한 자세한 내용은 참조는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
 실행을 위해 로드 된 어셈블리가 이미 있으면 다른 복사본 리플렉션 전용 컨텍스트에 로드 됩니다.  
  
 `throwIfNotFound` 때 일어나는 발견 되지 않으면 형식과 특정 한 다른 예외 조건을 표시 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다. 값에 관계 없이 몇 가지 예외가 throw 된 `throwIfNotFound`합니다. 예를 들어, 어셈블리 유효 하지 않을 경우는 <xref:System.BadImageFormatException> 예외가 경우에 `throwIfNotFound` 은 `false`합니다.  
  
 리플렉션 전용 컨텍스트를 사용 하는 방법에 대 한 자세한 내용은 참조 [하는 방법: 리플렉션 컨텍스트에 로드 어셈블리](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.  
  
 또는  
  
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
 또는  
  
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 개체의 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />에 어셈블리 이름이 포함되지 않습니다.  
  
 또는  
  
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문(예: "MyType[,*,]")을 포함합니다.  
  
 또는  
  
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
 또는  
  
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
 또는  
  
 어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식의 레이아웃을 설명하는 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />를 가져옵니다.</summary>
        <value>현재 형식의 전체 레이아웃 기능을 설명하는 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />를 가져옵니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 반환 되지 않습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 메서드. 대신,이 속성을 사용 하 여를 가져오려고 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 클래스, 구조체 및 특별 한 레이아웃 특성 (구조 내에 중첩 된 클래스)를 사용 하는 구조체를 먼저 정의 합니다. 이 예제에서는 다음 사용 하 여는 <xref:System.Type.StructLayoutAttribute%2A> 속성을 한 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 각 형식과 특성의 속성을 표시 합니다.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터입니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see langword="String" />의 이름을 나타내는 <see langword="Type" />을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.String" />의 이름을 나타내는 <see cref="T:System.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 정규화 된 공용 언어 런타임 네임 스페이스 및 모든 기본 형식에 대 한 이름을 반환합니다. 예를 들어 C# 명령 `(long)0.Type().ToString()` 단순히 "Int64" 대신 "System.Int64"를 반환 합니다.  
  
 하는 경우 현재 <xref:System.Type> 네임 스페이스 및 중첩 된 형식이 아니라는 어셈블리가 정규화 된 제네릭 형식, 형식 및 해당 형식 인수를 나타냅니다. 하는 경우 현재 <xref:System.Type> 나타냅니다 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 형식 매개 변수가 비 정규화 된 이름을 반환 합니다.  
  
   
  
## Examples  
 사용법을 설명 하는 다음 예제는 <xref:System.Type.Namespace%2A> 및 <xref:System.Type.Module%2A> 속성 및 `ToString` 방식의 <xref:System.Type>합니다.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 반환 된 문자열을 비교 하는 다음 예제는 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성입니다.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 대한 핸들을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />에 대한 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` 형식을 나타내는 내부 데이터 구조에 대 한 포인터를 캡슐화 합니다. 이 핸들은 프로세스 수명 동안 고유 합니다. 핸들을 얻은 응용 프로그램 도메인에만 유효 합니다.  
  
   
  
## Examples  
 다음 예제에서는 해당 유형의 핸들을 반환 하 고 핸들에서 형식을 가져오고 표시 하는 메서드에 핸들을 전달 합니다.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework에서는 현재 이 속성을 지원하지 않습니다.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식에 대한 이니셜라이저를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" />에 대한 클래스 생성자의 이름이 들어 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스 이니셜라이저는를 통해 사용할 수는 <xref:System.Type.FindMembers%2A> 메서드, 또는 오버 로드를 통해는 <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, 및 <xref:System.Type.GetConstructors%2A> 사용 하는 메서드와 <xref:System.Reflection.BindingFlags> 매개 변수로 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식을 나타내는 공용 언어 런타임에서 제공되는 형식을 나타냅니다.</summary>
        <value>
          <see cref="T:System.Type" />의 내부 시스템 형식입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>