<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c442b0e3855ad0206a02ff13f35e3b09a89b66f" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48621110" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="94b23-101">클래스 형식, 인터페이스 형식, 배열 형식, 값 형식, 열거형 형식, 형식 매개 변수, 제네릭 형식 정의 및 개방형 생성 제네릭 형식이나 폐쇄형 생성 제네릭 형식에 대한 형식 선언을 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="94b23-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-102">`Type` 루트를 <xref:System.Reflection> 기능 메타 데이터에 액세스 하는 기본 방법 이며 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="94b23-103">멤버를 사용 하 여 <xref:System.Type> 뿐만 아니라 모듈 및 클래스는 배포 된 어셈블리 (예: 생성자, 메서드, 필드, 속성 및 클래스의 이벤트), 형식 멤버에 대 한 형식 선언에 대 한 정보를 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="94b23-104">리플렉션을 사용 하 여 해당 액세스 수준에 관계 없이 형식 및 해당 멤버에 대 한 정보를 코드에 필요한 권한은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="94b23-105">리플렉션을 사용 하 여 public 멤버 또는 액세스 수준을 볼 수 있도록 일반 컴파일하는 동안 다른 멤버에 액세스 하는 코드에 필요한 권한은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="94b23-106">그러나 리플렉션을 사용 하는 일반적으로 액세스할 수 없습니다, private 또는 internal 메서드와 같은 보호 된 형식의 필드 또는 멤버에 액세스 하 여 코드에 대 한 클래스를 상속 하지 않습니다, 코드 있어야 <xref:System.Security.Permissions.ReflectionPermission>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="94b23-107">참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="94b23-108">`Type` 여러 구현을 허용 하는 추상 기본 클래스 이며</span><span class="sxs-lookup"><span data-stu-id="94b23-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="94b23-109">시스템은 파생된 클래스를 항상 제공 `RuntimeType`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="94b23-110">리플렉션에서 런타임 라는 단어로 시작 하는 모든 클래스는 시스템 및 지원 비교 작업에 대 한 개체당 한 번만 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-111">다중 스레드 시나리오에서를 잠그지 마십시오 <xref:System.Type> 개체에 대 한 액세스를 동기화 하기 위해 `static` 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="94b23-112">제어 하지 않습니다 수 없는 다른 코드 클래스 형식이 잠글 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="94b23-113">이 인해 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-113">This might result in a deadlock.</span></span> <span data-ttu-id="94b23-114">대신 개인을 잠그는 방식으로 정적 데이터에 대 한 액세스를 동기화 `static` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-115">파생된 클래스는 호출 코드의 기본 클래스의 protected 멤버를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="94b23-116">또한 호출 코드의 어셈블리의 어셈블리 구성원에 게 액세스가 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="94b23-117">일반적으로 초기 바인딩 코드에서 액세스할 수 있는 경우 다음도 수 액세스 바인딩된 코드에서.</span><span class="sxs-lookup"><span data-stu-id="94b23-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-118">다른 인터페이스를 확장 하는 인터페이스에서 확장된 된 인터페이스에 정의 된 메서드를 상속 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="94b23-119">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="94b23-119">In this section:</span></span>  
  
 <span data-ttu-id="94b23-120">[유형을 형식 개체를 나타내지?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="94b23-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="94b23-121">[형식 개체를 검색합니다.](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="94b23-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="94b23-122">같음에 대 한 형식 개체를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="94b23-123">유형을 형식 개체를 나타내지?</span><span class="sxs-lookup"><span data-stu-id="94b23-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="94b23-124">이 클래스는 스레드로부터 안전 합니다. 여러 스레드는이 형식의 인스턴스에서 동시에 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="94b23-125">인스턴스는 <xref:System.Type> 클래스 다음 형식 중 하나를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="94b23-126">클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-126">Classes</span></span>  
  
-   <span data-ttu-id="94b23-127">값 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-127">Value types</span></span>  
  
-   <span data-ttu-id="94b23-128">배열</span><span class="sxs-lookup"><span data-stu-id="94b23-128">Arrays</span></span>  
  
-   <span data-ttu-id="94b23-129">인터페이스</span><span class="sxs-lookup"><span data-stu-id="94b23-129">Interfaces</span></span>  
  
-   <span data-ttu-id="94b23-130">열거형</span><span class="sxs-lookup"><span data-stu-id="94b23-130">Enumerations</span></span>  
  
-   <span data-ttu-id="94b23-131">대리자</span><span class="sxs-lookup"><span data-stu-id="94b23-131">Delegates</span></span>  
  
-   <span data-ttu-id="94b23-132">생성 된 제네릭 형식 및 제네릭 형식 정의</span><span class="sxs-lookup"><span data-stu-id="94b23-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="94b23-133">인수를 입력 하 고 생성 된 제네릭 형식, 제네릭 형식 정 및 제네릭 메서드 정의의 매개 변수를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="94b23-134">형식 개체를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="94b23-135"><xref:System.Type> 다음과 같이 특정 형식과 관련 된 개체를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="94b23-136">인스턴스 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 메서드가 반환 되는 <xref:System.Type> 인스턴스의 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="94b23-137">모든 관리 되는 형식에서 파생 되므로 <xref:System.Object>, <xref:System.Object.GetType%2A> 형식일 인스턴스의 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="94b23-138">다음 예제에서는 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 개체 배열의 각 개체의 런타임 형식을 확인 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="94b23-139">정적 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 메서드는 반환 된 <xref:System.Type> 정규화 된 이름을 사용 하 여 지정 된 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="94b23-140">합니다 <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, 및 <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> 메서드는 반환 `Type` 모듈에 정의 된 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="94b23-141">첫 번째 메서드는 배열을 가져오는 데 사용할 수 있습니다 <xref:System.Type> 모듈에 정의 된 모든 공용 및 개인 형식에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="94b23-142">(의 인스턴스를 가져올 수 있습니다 `Module` 를 통해 합니다 <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> 메서드를 또는 <xref:System.Type.Module%2A?displayProperty=nameWithType> 속성입니다.)</span><span class="sxs-lookup"><span data-stu-id="94b23-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="94b23-143">합니다 <xref:System.Reflection.Assembly?displayProperty=nameWithType> 개체를 비롯 한 어셈블리에 정의 된 클래스를 검색 하는 방법의 번호가 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, 및 <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="94b23-144"><xref:System.Type.FindInterfaces%2A> 메서드 형식에서 지 원하는 인터페이스 형식의 필터링 된 목록을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="94b23-145">합니다 <xref:System.Type.GetElementType%2A> 메서드가 반환 되는 `Type` 요소를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="94b23-146"><xref:System.Type.GetInterfaces%2A> 하 고 <xref:System.Type.GetInterface%2A> 메서드는 반환 <xref:System.Type> 형식에서 지원 되는 인터페이스 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="94b23-147">합니다 <xref:System.Type.GetTypeArray%2A> 메서드는 배열을 반환 <xref:System.Type> 임의의 개체 집합에서 지정 된 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="94b23-148">개체 형식의 배열을 사용 하 여 지정 된 <xref:System.Object>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="94b23-149">합니다 <xref:System.Type.GetTypeFromProgID%2A> 고 <xref:System.Type.GetTypeFromCLSID%2A> 메서드가 COM 상호 운용성을 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="94b23-150">반환 되는 <xref:System.Type> 로 지정 된 형식을 나타내는 개체를 `ProgID` 또는 `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="94b23-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="94b23-151"><xref:System.Type.GetTypeFromHandle%2A> 메서드는 상호 운용성을 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="94b23-152">반환 된 `Type` 클래스 핸들에 의해 지정 된 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="94b23-153">C# `typeof` c + + 연산자 `typeid` 연산자 및 Visual Basic `GetType` 연산자 가져오기는 `Type` 형식에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="94b23-154"><xref:System.Type.MakeGenericType%2A> 메서드가 반환 되는 <xref:System.Type> 개방형 생성된 형식은 생성 된 제네릭 형식을 나타내는 개체입니다 해당 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`, 닫힌 생성 된 형식 그렇지 않은 경우 및 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="94b23-155">이 닫혀 있는 경우에 제네릭 형식을 인스턴스화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="94b23-156">합니다 <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, 및 <xref:System.Type.MakeByRefType%2A> 메서드는 반환 <xref:System.Type> 나타내는 개체를 각각 지정된 된 형식, 참조 매개 변수의 형식과 지정된 된 형식에 대 한 포인터의 배열 (`ref` C#에서는 `ByRef`Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="94b23-157">같음에 대 한 형식 개체를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="94b23-158">A <xref:System.Type> 개체를 나타내는 형식이 고유한 지, 즉 두 <xref:System.Type> 동일한 형식을 나타내는 경우에 개체 참조가 동일한 개체를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="94b23-159">이렇게 하면 비교 <xref:System.Type> 참조 같음을 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="94b23-160">다음 예제에서는 비교를 <xref:System.Type> 동일한 형식의 지 여부를 확인 하는 정수 값의 수를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="94b23-161">다음 예제에서는 몇 가지 대표적인 기능의 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-161">The following  example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="94b23-162">C# `typeof` 연산자 (`GetType` Visual Basic의 연산자 `typeid` Visual c + +에서 연산자) 가져오는 데 사용 되는 <xref:System.Type> 개체를 나타내는 <xref:System.String>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-162">The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="94b23-163">이 <xref:System.Type> 개체를 <xref:System.Type.GetMethod%2A> 메서드 가져오는 데 사용 되는 <xref:System.Reflection.MethodInfo> 나타내는 <xref:System.String.Substring%2A> 시작 위치 및 길이 사용 하는 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.</span></span>  
  
 <span data-ttu-id="94b23-164">오버 로드 시그니처를 식별 하려면 코드 예제는 두 가지를 포함 하는 임시 배열을 만듭니다 <xref:System.Type> 개체를 나타내는 `int` (`Integer` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-165">배열에 두 개의 참조 인스턴스를 정확 하 게 포함 <xref:System.Type> 나타내는 `int` 현재 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="94b23-166">모든 형식에 대 한 인스턴스가 하나만 <xref:System.Type> 응용 프로그램 도메인당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="94b23-167">코드 예제에서는 합니다 <xref:System.Reflection.MethodInfo> 를 호출 하는 <xref:System.String.Substring%2A> 문자열 "Hello, World!", 메서드 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="94b23-168">이 형식은 스레드로부터 안전합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="94b23-168">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="94b23-169">상속 하는 경우 <see langword="Type" />, 멤버를 재정의 해야 합니다.</span>
        <span class="sxs-lookup">
          <span data-stu-id="94b23-169">When you inherit from <see langword="Type" />, you must override the following members:</span>
        </span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" /><span data-ttu-id="94b23-170">
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span><span class="sxs-lookup"><span data-stu-id="94b23-170">
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span></span> 
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">
      <span data-ttu-id="94b23-171">형식 정보 보기</span>
      <span class="sxs-lookup">
        <span data-stu-id="94b23-171">Viewing Type Information</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-172">
            <see cref="T:System.Type" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-172">Initializes a new instance of the <see cref="T:System.Type" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-173">형식 개체를 생성 하는 동안이 생성자는 파생된 클래스에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-173">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-174">형식이 선언되는 <see cref="T:System.Reflection.Assembly" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-174">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span>
          </span>
          <span data-ttu-id="94b23-175">제네릭 형식의 경우 제네릭 형식이 정의되는 <see cref="T:System.Reflection.Assembly" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-175">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-176">현재 형식이 포함된 어셈블리를 설명하는 <see cref="T:System.Reflection.Assembly" /> 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-176">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span>
          </span>
          <span data-ttu-id="94b23-177">제네릭 형식의 경우 인스턴스는 특정한 생성된 형식을 만들고 사용하는 어셈블리가 아니라 제네릭 형식 정의가 포함된 어셈블리를 설명합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-177">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-178">하는 경우 현재 <xref:System.Type> 개체가 생성 된 제네릭 형식을 나타내는지,이 속성에는 제네릭 형식 정의 포함 하는 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-178">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="94b23-179">예를 들어, 제네릭 형식 정의 포함 하는 MyGenerics.dll 이라는 어셈블리를 만든 `MyGenericStack<T>` (`MyGenericStack(Of T)` Visual basic에서는 `generic<T> ref class MyGenericStack` c + +에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-179">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="94b23-180">인스턴스를 만들면 `MyGenericStack<int>` (`MyGenericStack(Of Integer)` Visual Basic의) 다른 어셈블리에는 <xref:System.Type.Assembly%2A> 생성 된 형식에 대 한 속성을 반환 합니다는 <xref:System.Reflection.Assembly> MyGenerics.dll를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-180">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="94b23-181">마찬가지로, 경우 현재 <xref:System.Type> 개체는 할당 되지 않은 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식이 포함 된 어셈블리를 반환 합니다. `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-181">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="94b23-182">경우는 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 속성을 사용할 수 없습니다,.NET Core 또는 유니버설 Windows 플랫폼와 같은 특정.NET 구현에서 사용 하 여는 <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> 속성 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-182">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="94b23-183">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-183">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-184">다음 예제에서는 클래스와 연결 된 어셈블리 이름 및 형식의 정규화 된 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-184">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-185">이 <see cref="T:System.Type" /> 개체가 로드된 어셈블리의 이름을 비롯하여 형식의 어셈블리 한정 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-185">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-186">
            <see cref="T:System.Type" />이 로드된 어셈블리의 이름을 비롯한 <see cref="T:System.Type" />의 어셈블리 한정 이름입니다. 현재 인스턴스가 제네릭 형식 매개 변수를 나타낼 경우에는 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-186">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-187">형식의 정규화 된 어셈블리 이름을 형식 이름, 어셈블리의 표시 이름 뒤에 쉼표, 해당 네임 스페이스를 포함 하 여 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-187">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="94b23-188">어셈블리의 표시 이름을 사용 하 여 가져온는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-188">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-189">.NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-189">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="94b23-190">예를 들어, "ProcessorArchitecture = msil"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-190">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="94b23-191">그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-191">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="94b23-192"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-192">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="94b23-193">공용 언어 런타임에서 지 원하는 모든 컴파일러는 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-193">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="94b23-194">구분 기호</span><span class="sxs-lookup"><span data-stu-id="94b23-194">Delimiter</span></span>|<span data-ttu-id="94b23-195">의미</span><span class="sxs-lookup"><span data-stu-id="94b23-195">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="94b23-196">백슬래시(\\)</span><span class="sxs-lookup"><span data-stu-id="94b23-196">Backslash (\\)</span></span>|<span data-ttu-id="94b23-197">이스케이프 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-197">Escape character.</span></span>|  
|<span data-ttu-id="94b23-198">쉼표 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-198">Comma (,)</span></span>|<span data-ttu-id="94b23-199">어셈블리 이름을 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-199">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="94b23-200">더하기 기호 (+)</span><span class="sxs-lookup"><span data-stu-id="94b23-200">Plus sign (+)</span></span>|<span data-ttu-id="94b23-201">중첩된 된 클래스 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-201">Precedes a nested class.</span></span>|  
|<span data-ttu-id="94b23-202">마침표 (입니다.)</span><span class="sxs-lookup"><span data-stu-id="94b23-202">Period (.)</span></span>|<span data-ttu-id="94b23-203">네임 스페이스 식별자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-203">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="94b23-204">대괄호 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-204">Brackets ([])</span></span>|<span data-ttu-id="94b23-205">형식 이름을 후 해당 형식의 배열을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-205">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="94b23-206">또는</span><span class="sxs-lookup"><span data-stu-id="94b23-206">-or-</span></span><br /><br /> <span data-ttu-id="94b23-207">제네릭 형식에 대 한 제네릭 형식 인수 목록을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-207">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="94b23-208">또는</span><span class="sxs-lookup"><span data-stu-id="94b23-208">-or-</span></span><br /><br /> <span data-ttu-id="94b23-209">형식 인수 목록을 내는 어셈블리의 정규화 된 형식을으로 둘러쌉니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-209">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="94b23-210">예를 들어, 클래스에 대 한 어셈블리의 정규화 된 이름을이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-210">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="94b23-211">네임 스페이스에는 예를 들어 TopNamespace.Sub+Namespace 더하기 기호를 포함 된 경우 더하기 (+)는 뒤에 야 이스케이프 문자 (\\) 중첩 구분 기호로 해석 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-211">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="94b23-212">리플렉션이이 문자열을 다음과 같이 내보내기는:</span><span class="sxs-lookup"><span data-stu-id="94b23-212">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="94b23-213">"+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-213">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="94b23-214">이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-214">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="94b23-215">찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-215">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="94b23-216"><xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서.</span><span class="sxs-lookup"><span data-stu-id="94b23-216"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="94b23-217"><xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-217"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="94b23-218">형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-218">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="94b23-219">형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-219">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="94b23-220">공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-220">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="94b23-221">어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-221">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="94b23-222">제네릭 형식의 제네릭 인수는 어셈블리 이름으로 정규화 된 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-222">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="94b23-223">에 대 한 어셈블리의 정규화 된 유형 이름에 예를 들어 `MyGenericClass<int>` (`MyGenericClass(Of Integer)` Visual basic에서), `int` 에 대 한 정규화 된 어셈블리 형식 이름으로 확장 됩니다 <xref:System.Int32>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-223">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="94b23-224">하는 경우 현재 <xref:System.Type> 개체는 제네릭 매개 변수를 나타내는 경우이 속성은 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-224">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-225">다음 예제에서는 클래스와 연결 된 어셈블리 이름 및 형식의 정규화 된 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-225">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="94b23-226">다음 예제에서 반환 된 문자열을 비교 합니다 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="94b23-226">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-227">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-227">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-228">
            <see cref="T:System.Type" />과 관련된 특성을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-228">Gets the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-229">
            <see cref="T:System.Reflection.TypeAttributes" />이 값이 지정되어 있지 않은 제네릭 형식 매개 변수를 나타내지 않는 경우 <see cref="T:System.Type" />의 특성 집합을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-229">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-230">일부 멤버는 <xref:System.Reflection.TypeAttributes> 열거형 값의 그룹을 나타내는 마스크 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-230">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="94b23-231">각 그룹에는 기본 값이 0 인 멤버로 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-231">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="94b23-232">예를 들어, 기본 값 합니다 <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> 멤버를 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 그룹은 0을 그대로 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 멤버를 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 그룹.</span><span class="sxs-lookup"><span data-stu-id="94b23-232">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="94b23-233">이 때문에 이러한 값을 테스트 하기 전에 마스크를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-233">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="94b23-234">예제에서는 그림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-234">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="94b23-235">대부분의 경우 속성 같은 <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, 및 <xref:System.Type.IsSpecialName%2A> 유형 특성 보다 사용 하기가 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-235">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="94b23-236">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성에는 제네릭 형식 정의의 특성을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-236">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="94b23-237">예를 들어,에 대 한 반환 하는 특성 `MyGenericClass<int>` (`MyGenericClass(Of Integer)` Visual Basic의) 특성 `MyGenericClass<T>` (`MyGenericClass(Of T)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-237">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="94b23-238">경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 나타내는-즉, 경우는 <xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `true` -는 <xref:System.Reflection.TypeAttributes> 이 속성에서 반환 된 값 지정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-238">If the current <xref:System.Type> represents a generic type parameter — that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` — the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-239">다음 예제에서는 용도 <xref:System.Type.Attributes%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-239">The following example usesthe <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-240">현재 <see cref="T:System.Type" />이 직접 상속된 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-240">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-241">현재 <see cref="T:System.Type" />이 직접 상속하는 <see cref="T:System.Type" />이거나, 현재 <see langword="null" />이 <see langword="Type" /> 클래스나 인터페이스를 나타내면 <see cref="T:System.Object" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-241">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-242">기본 유형 현재 형식이 직접 상속 된 형식이입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-242">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="94b23-243"><xref:System.Object> 되지 않은 기본 형식, 따라서 유형만 `null` 의 기본 형식으로 반환 됩니다 <xref:System.Object>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-243"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="94b23-244">인터페이스는 0 개 이상의 기본 인터페이스;에서 상속 따라서이 속성은 반환 `null` 경우는 `Type` 개체 인터페이스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-244">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="94b23-245">기본 인터페이스를 사용 하 여 확인할 수 있습니다 <xref:System.Type.GetInterfaces%2A> 또는 <xref:System.Type.FindInterfaces%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-245">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="94b23-246">하는 경우 현재 <xref:System.Type> 은 생성 된 제네릭 형식을 나타내며, 기본 형식을 제네릭 인수를 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-246">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="94b23-247">예를 들어 다음 선언을 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-247">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="94b23-248">생성 된 형식에 대 한 `C<int>` (`C(Of Integer)` Visual basic에서), <xref:System.Type.BaseType%2A> 속성에서 반환 `B<int>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-248">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="94b23-249">하는 경우 현재 <xref:System.Type> 제네릭 형식 정의의 형식 매개 변수를 나타내는 <xref:System.Type.BaseType%2A> 클래스 제약 조건, 즉, 형식 매개 변수를 상속 해야 클래스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-249">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="94b23-250">클래스 제약 조건이 없는 경우 <xref:System.Type.BaseType%2A> 반환 <xref:System.Object?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-250">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="94b23-251">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-251">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-252">다음 예제는 <xref:System.Type.BaseType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-252">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="94b23-253">다음 예제에서는 재귀를 사용 하 여 어셈블리에 있는 각 클래스의 완전 한 상속 계층 구조를 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-253">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="94b23-254">이 예제에서는 라는 클래스를 정의 `C` 라는 클래스에서 파생 되는 `B`는 라는 클래스에서 파생 됩니다, `A`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-254">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-255">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-255">Reflection and Generic Types</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-256">현재 <see cref="T:System.Type" /> 개체에 특정 형식으로 바뀌지 않은 형식 매개 변수가 있는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-256">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-257">
            <see langword="true" /> 개체 자체가 제네릭 형식 매개 변수이거나 특정 형식이 적용되지 않은 형식 매개 변수이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-257">
              <see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-258">형식의 인스턴스를 만들기 위해 없는 제네릭 형식 정의 또는 형식 자체에서 모든 바깥쪽 제네릭 형식 또는 모든 요소 형식의 형식 인수에서 개방형 생성된 형식 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-258">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="94b23-259">두 번째 방법은 재귀적으로 검사 하는 경우, 형식에 제네릭 형식 매개 변수가 없는 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-259">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="94b23-260">형식 일 수 있으므로 임의의 복잡 한이 결정을 내릴는 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-260">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="94b23-261">편의 위해 및 오류의 가능성을 줄이기 위해는 <xref:System.Type.ContainsGenericParameters%2A> 속성 제공를 인스턴스화할 수 있는 폐쇄형된 생성된 형식을 구분 하는 표준 방법 및 개방형 생성 형식 일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-261">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="94b23-262">경우는 <xref:System.Type.ContainsGenericParameters%2A> 속성이 반환 `true`, 형식을 인스턴스화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-262">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="94b23-263"><xref:System.Type.ContainsGenericParameters%2A> 속성 형식 매개 변수를 재귀적으로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-263">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="94b23-264">예를 들어 반환 `true` 요소가 들어 있는 형식 배열에 대 한 `A<T>` (`A(Of T)` Visual basic에서) 배열 되지 않더라도 제네릭 자체, 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-264">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="94b23-265">동작을 사용 하 여이 대조해 보세요 합니다 <xref:System.Type.IsGenericType%2A> 반환 하는 속성 `false` 배열에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-265">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="94b23-266">예제에서는 클래스 및 값을 표시 하는 테이블 집합에 대 한 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성 참조 <xref:System.Type.IsGenericType%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-266">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-267">다음 예제에서는 두 형식 매개 변수를 사용 하 여 제네릭 클래스를 정의 하 고 첫 번째 클래스에서 파생 되는 두 번째 제네릭 클래스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-267">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="94b23-268">파생된 클래스의 기본 클래스에 두 개의 형식 인수: 첫 번째는 <xref:System.Int32> 두 번째는 파생 된 형식의 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-268">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="94b23-269">보고 된 위치를 포함 하 여 이러한 제네릭 클래스에 대 한 정보를 표시 하는 예제에는 <xref:System.Type.GenericParameterPosition%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-269">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-270">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-270">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-271">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-271">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-272">현재 <see cref="T:System.Reflection.MethodBase" />가 제네릭 메서드의 형식 매개 변수를 나타내는 경우 선언 메서드를 나타내는 <see cref="T:System.Type" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-272">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-273">현재 <see cref="T:System.Type" />이 제네릭 메서드의 형식 매개 변수를 나타내면 선언하는 메서드를 나타내는 <see cref="T:System.Reflection.MethodBase" />이고, 그렇지 않으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-273">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-274">선언 메서드는 제네릭 메서드 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-274">The declaring method is a generic method definition.</span></span> <span data-ttu-id="94b23-275">즉, 경우 <xref:System.Type.DeclaringMethod%2A> 반환 하지 않는 `null`, 한 다음 `DeclaringMethod.IsGenericMethodDefinition` 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-275">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="94b23-276">합니다 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 제네릭 형식 정의 또는 제네릭 메서드 정의 원래 정의 된 제네릭 형식 매개 변수는 속성을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-276">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="94b23-277">경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환을 <xref:System.Reflection.MethodInfo>하 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체는 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-277">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="94b23-278">경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환 `null`, 해당 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환을 <xref:System.Type> 제네릭 형식 정의 나타내며 현재 개체 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-278">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="94b23-279">시작 합니다 <xref:System.Type.DeclaringMethod%2A> 형식의 속성을 해당 <xref:System.Type.IsGenericParameter%2A> 속성은 `false` throw는 <xref:System.InvalidOperationException>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-279">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="94b23-280"><xref:System.Reflection.MethodBase> 에서 반환 하는 합니다 <xref:System.Type.DeclaringMethod%2A> 속성이 <xref:System.Reflection.MethodInfo> 제네릭 메서드인 경우 또는 <xref:System.Reflection.ConstructorInfo> 제네릭 생성자의 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-280">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-281">제네릭 생성자는.NET framework 버전 2.0에서 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-281">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="94b23-282">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-282">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-283">다음 코드 예제에서는 제네릭 메서드가 메서드에 형식 인수를 할당 하 고 생성된 된 제네릭 메서드를 호출 하는 클래스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-283">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="94b23-284">또한 생성된 된 메서드 및 제네릭 메서드 정의 대 한 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-284">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="94b23-285">제네릭 메서드 정의의 형식 매개 변수에 대 한 정보를 표시 하는 경우는 `DisplayGenericMethodInfo` 메서드를 예제 코드의 값이 표시는 <xref:System.Type.DeclaringMethod%2A> 메서드의 제네릭 형식 매개 변수에 대 한 속성.</span><span class="sxs-lookup"><span data-stu-id="94b23-285">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-286">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-286">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-287">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-287">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-288">현재 중첩 형식 또는 제네릭 형식 매개 변수를 선언하는 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-288">Gets the type that declares the current nested type or generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-289">현재 형식이 중첩 형식이면 바깥쪽 형식을 나타내고 현재 형식이 제네릭 형식의 형식 매개 변수이면 제네릭 형식 정의를 나타내며 현재 형식이 제네릭 메서드의 형식 매개 변수이면 제네릭 메서드를 선언하는 형식을 나타내는 <see cref="T:System.Type" /> 개체이고, 그렇지 않으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-289">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-290">하는 경우 현재 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타내며,이 속성에는 제네릭 형식 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-290">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="94b23-291">하는 경우 현재 <xref:System.Type> 개체는 제네릭 메서드의 형식 매개 변수를 나타내며,이 속성에는 제네릭 메서드 정의 포함 하는 형식을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-291">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="94b23-292">형식이 제네릭 인지, 제네릭 형식 정의 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-292">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="94b23-293">다음 코드에서는 제네릭 형식 정의 반환 하는, 합니다 <xref:System.Collections.Generic.List%601> 포함 하는 제네릭 클래스는 <xref:System.Collections.Generic.List%601.ConvertAll%2A> 제네릭 메서드:</span><span class="sxs-lookup"><span data-stu-id="94b23-293">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="94b23-294">경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 속성의 제네릭 형식 매개 변수는 제네릭 형식 정의 또는 제네릭 메서드 정의 식별 합니다. 원래 정의 된:</span><span class="sxs-lookup"><span data-stu-id="94b23-294">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="94b23-295">경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환을 <xref:System.Reflection.MethodInfo>하 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체는 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-295">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="94b23-296">경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환 `null`, 해당 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환을 <xref:System.Type> 제네릭 형식 정의 나타내며 현재 개체 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-296">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="94b23-297">시작 합니다 <xref:System.Type.DeclaringType%2A> 형식의 속성을 해당 <xref:System.Type.IsGenericParameter%2A> 속성은 `false` throw는 <xref:System.InvalidOperationException>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-297">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-298">이 예제에서는 파생된 클래스에서 메서드의 선언 형식이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-298">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-299">
            <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />에서 호출하는 적절한 멤버를 선택하기 위해 내부 규칙을 구현하는 기본 바인더에 대한 참조를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-299">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-300">시스템에서 사용되는 기본 바인더에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-300">A reference to the default binder used by the system.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-301">공용 언어 런타임에서 제공 하는 기본 바인더는 대부분의 특수 한 경우를 제외한 모든 환경에서 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-301">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="94b23-302">파생 된 형식 제공 되는 기본 바인더의 다른 다음과 같이 규칙을 정의 하는 바인더를 해야 하는 경우는 <xref:System.Reflection.Binder> 클래스를 사용 하 여 해당 형식의 인스턴스를 전달 합니다 `binder` 매개 변수 중 하나는 <xref:System.Type.InvokeMember%2A> 오버 로드.</span><span class="sxs-lookup"><span data-stu-id="94b23-302">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="94b23-303">리플렉션 공용 형식 시스템의 액세스 가능성 규칙을 모델링합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-303">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="94b23-304">예를 들어 호출자에 게 동일한 어셈블리의 경우 호출자에 게 필요가 없습니다 특별 한 권한이 내부 멤버에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-304">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="94b23-305">그렇지 않으면 호출자에 게 필요한 <xref:System.Security.Permissions.ReflectionPermission>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-305">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="94b23-306">이것이, 보호 되는 멤버 조회를 사용 하 여 일관 된, private 및 등입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-306">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="94b23-307">일반 원칙 <xref:System.Reflection.Binder.ChangeType%2A> 확대 데이터 손실이 없는 변환을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-307">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="94b23-308">확대 변환의 예로 64 비트 부호 있는 정수 값을 32 비트 부호 있는 정수 값을 변환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-308">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="94b23-309">이 축소 변환 시 데이터가 손실 될 수 있는에서 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-309">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="94b23-310">축소 변환의 예로 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-310">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="94b23-311">다음 표에 기본 바인더에 의해 지원 되는 변환이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-311">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="94b23-312">원본 유형</span><span class="sxs-lookup"><span data-stu-id="94b23-312">Source Type</span></span>|<span data-ttu-id="94b23-313">대상 유형</span><span class="sxs-lookup"><span data-stu-id="94b23-313">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="94b23-314">모든 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-314">Any type</span></span>|<span data-ttu-id="94b23-315">해당 기본 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-315">Its base type.</span></span>|  
|<span data-ttu-id="94b23-316">모든 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-316">Any type</span></span>|<span data-ttu-id="94b23-317">인터페이스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-317">The interface it implements.</span></span>|  
|<span data-ttu-id="94b23-318">Char</span><span class="sxs-lookup"><span data-stu-id="94b23-318">Char</span></span>|<span data-ttu-id="94b23-319">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-319">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="94b23-320">Byte</span><span class="sxs-lookup"><span data-stu-id="94b23-320">Byte</span></span>|<span data-ttu-id="94b23-321">Char Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-321">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="94b23-322">SByte</span><span class="sxs-lookup"><span data-stu-id="94b23-322">SByte</span></span>|<span data-ttu-id="94b23-323">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-323">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="94b23-324">UInt16</span><span class="sxs-lookup"><span data-stu-id="94b23-324">UInt16</span></span>|<span data-ttu-id="94b23-325">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-325">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="94b23-326">Int16</span><span class="sxs-lookup"><span data-stu-id="94b23-326">Int16</span></span>|<span data-ttu-id="94b23-327">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-327">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="94b23-328">UInt32</span><span class="sxs-lookup"><span data-stu-id="94b23-328">UInt32</span></span>|<span data-ttu-id="94b23-329">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-329">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="94b23-330">Int32</span><span class="sxs-lookup"><span data-stu-id="94b23-330">Int32</span></span>|<span data-ttu-id="94b23-331">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-331">Int64, Single, Double</span></span>|  
|<span data-ttu-id="94b23-332">UInt64</span><span class="sxs-lookup"><span data-stu-id="94b23-332">UInt64</span></span>|<span data-ttu-id="94b23-333">Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-333">Single, Double</span></span>|  
|<span data-ttu-id="94b23-334">Int64</span><span class="sxs-lookup"><span data-stu-id="94b23-334">Int64</span></span>|<span data-ttu-id="94b23-335">Single, Double</span><span class="sxs-lookup"><span data-stu-id="94b23-335">Single, Double</span></span>|  
|<span data-ttu-id="94b23-336">Single</span><span class="sxs-lookup"><span data-stu-id="94b23-336">Single</span></span>|<span data-ttu-id="94b23-337">Double</span><span class="sxs-lookup"><span data-stu-id="94b23-337">Double</span></span>|  
|<span data-ttu-id="94b23-338">비참조</span><span class="sxs-lookup"><span data-stu-id="94b23-338">Non-reference</span></span>|<span data-ttu-id="94b23-339">참조로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-339">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="94b23-340">다음 예제에서 기본 바인더를 가져옵니다 합니다 `DefaultBinder` 속성을 전달 하 여 MyClass의 멤버를 호출 하 고는 `DefaultBinder` 매개 변수로 값 <xref:System.Type.InvokeMember%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-340">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-341">
            <see cref="T:System.Type" />의 네임스페이스에 있는 이름을 구분합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-341">Separates names in the namespace of the <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-342">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-342">This field is read-only.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-343">
            <see cref="T:System.Type" /> 형식의 빈 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-343">Represents an empty array of type <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-344">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-344">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="94b23-345">다음 코드 예제는 `EmptyTypes` 중 하나에 사용 되는 필드를 `GetConstructor` 매개 변수가 없는 생성자를 가져오기 위한 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-345">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-346">현재 <see cref="T:System.Type" />의 내부 시스템 형식이 지정된 <see cref="T:System.Object" /> 또는 <see cref="T:System.Type" />의 내부 시스템 형식과 동일한지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-346">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="94b23-347">현재 <see cref="T:System.Type" />의 내부 시스템 형식과 비교할 내부 시스템 형식이 있는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-347">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-348">성공적인 비교를 위해 <c>o</c>는 캐스팅되거나 <see cref="T:System.Type" /> 형식의 개체로 변환될 수 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-348">For the comparison to succeed, <c>o</c> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-349">현재 <see cref="T:System.Type" /> 개체의 내부 시스템 형식이 지정된 <see cref="T:System.Object" />의 내부 시스템 형식과 동일한지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-349">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-350">
            <paramref name="o" />의 내부 시스템 형식이 현재 <see cref="T:System.Type" />의 내부 시스템 형식과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-350">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="94b23-351">다음 경우에도 이 메서드는 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-351">This method also returns <see langword="false" /> if: .</span>
          </span>
          <span data-ttu-id="94b23-352">
-   <paramref name="o" />이 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-352">
-   <paramref name="o" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-353">
-   <paramref name="o" />는 캐스트되거나 <see cref="T:System.Type" /> 개체로 변환될 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-353">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-354">이 메서드는 <xref:System.Object.Equals%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-354">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="94b23-355">캐스팅 `o` 형식의 개체로 <xref:System.Type> 호출을 <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-355">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-356">다음 예제에서는 <xref:System.Type.Equals%28System.Object%29> 다양 한 비교할 <xref:System.Type> 다양 한 인스턴스 개체 <xref:System.Object> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="94b23-356">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="94b23-357">특히 주목할 예제에 대 한 두 가지 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-357">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="94b23-358">비교는 <xref:System.Type> 갖는 정수를 나타내는 개체를 <xref:System.Reflection.TypeInfo> 반환 하는 정수를 나타내는 개체입니다 `true` 때문에 <xref:System.Reflection.TypeInfo> 에서 파생 됩니다 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-358">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="94b23-359">비교는 <xref:System.Type> 나타내는 개체를 <xref:System.Collections.Generic.IList%601> 개체 (개방형 제네릭 형식)를 `List(Of String)` 개체 (폐쇄형된 제네릭 형식)를 반환 합니다 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-359">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="94b23-360">현재 <see cref="T:System.Type" />의 내부 시스템 형식과 비교할 내부 시스템 형식이 있는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-360">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-361">현재 <see cref="T:System.Type" />의 내부 시스템 형식이 지정된 <see cref="T:System.Type" />의 내부 시스템 형식과 동일한지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-361">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-362">
            <paramref name="o" />의 내부 시스템 형식이 현재 <see cref="T:System.Type" />의 내부 시스템 형식과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-362">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="94b23-363">다음 예제에서는 `Equals` 두 형식을 비교 하려면.</span><span class="sxs-lookup"><span data-stu-id="94b23-363">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-364">특성에 사용되는 멤버 필터를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-364">Represents the member filter used on attributes.</span>
          </span>
          <span data-ttu-id="94b23-365">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-365">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-366">이 필드는 사용 하는 대리자에 대 한 참조를 포함 합니다 <xref:System.Type.FindMembers%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-366">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="94b23-367">이 대리자로 캡슐화 된 메서드는 두 매개 변수: 첫 번째는 <xref:System.Reflection.MemberInfo> 개체 이며 두 번째는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-367">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="94b23-368">메서드를 결정 하는지 여부를 `MemberInfo` 개체에 의해 지정 된 조건과 일치 하는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-368">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="94b23-369">합니다 `Object` 클래스의 필드 중 하나의 값을 할당할 수 있습니다 <xref:System.Reflection.FieldAttributes>를 <xref:System.Reflection.MethodAttributes>, 또는 <xref:System.Reflection.MethodImplAttributes>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-369">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="94b23-370">예를 들어 합니다 `Object` 필드의 값을 할당 `FieldAttributes` Public과 같은 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-370">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="94b23-371">이런 경우는 `FilterAttribute` 대리자를 호출 반환 `true` 메서드를 나타내는 경우에는 `MemberInfo` 개체 메타 데이터에서 public 필드 특성으로 데코 레이트 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-371">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-372">다음 예제에서는 합니다 `FilterAttribute` 대리자를 매개 변수로 전달 합니다 <xref:System.Type.FindMembers%2A> 메서드를 지정 된 멤버 및 해당 특성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-372">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-373">이름에 사용되는 멤버 필터(대/소문자 구분)를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-373">Represents the case-sensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="94b23-374">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-374">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-375">이 필드는 사용 하는 대리자에 대 한 참조를 포함 합니다 <xref:System.Type.FindMembers%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-375">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="94b23-376">이 대리자로 캡슐화 된 메서드는 두 매개 변수: 첫 번째는 <xref:System.Reflection.MemberInfo> 개체 이며 두 번째는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-376">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="94b23-377">메서드를 결정 하는지 여부를 `MemberInfo` 개체에 의해 지정 된 조건과 일치 하는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-377">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="94b23-378">`Object` 후행 포함할 수 있는 문자열 값이 할당은 "\*" 와일드 카드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-378">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="94b23-379">유일한 와일드 카드 최종 문자열 일치가 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-379">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="94b23-380">예를 들어를 `Object` "바이트 \*" 값을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-380">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="94b23-381">이런 경우는 `FilterName` 대리자를 호출 반환 `true` 메서드를 나타내는 경우에는 `MemberInfo` 개체에 이름이 "바이트"를 사용 하 여 시작 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-381">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-382">다음 코드 예제에서는 연결 된 사용자 정의 메서드를 가져옵니다 `Application` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-382">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-383">이름에 사용되는 멤버 필터(대/소문자를 구분하지 않음)를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-383">Represents the case-insensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="94b23-384">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-384">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-385">이 필드는 사용 하는 대리자에 대 한 참조를 포함 합니다 <xref:System.Type.FindMembers%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-385">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="94b23-386">이 대리자로 캡슐화 된 메서드는 두 매개 변수: 첫 번째는 <xref:System.Reflection.MemberInfo> 개체 이며 두 번째는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-386">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="94b23-387">메서드를 결정 하는지 여부를 `MemberInfo` 개체에 의해 지정 된 조건과 일치 하는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-387">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="94b23-388">`Object` 후행 포함할 수 있는 문자열 값이 할당은 "\*" 와일드 카드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-388">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="94b23-389">유일한 와일드 카드 최종 문자열 일치가 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-389">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="94b23-390">예를 들어를 `Object` "바이트 \*" 값을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-390">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="94b23-391">이런 경우는 `FilterName` 대리자 호출 되 면 true를 반환만 메서드를 나타내는 경우는 `MemberInfo` 개체에 이름이 "byte", 대/소문자 무시를 사용 하 여 시작 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-391">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-392">다음 예제에서는 합니다 `MemberFilter` 대리자를 매개 변수로 전달 합니다 <xref:System.Type.FindMembers%2A> 메서드를 메서드 및 해당 특성의 표시를 `String` 대/소문자를 무시 하 고 문자 "c"로 시작 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-392">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="94b23-393">인터페이스를 <c>filterCriteria</c>에 대해 비교하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-393">The delegate that compares the interfaces against <c>filterCriteria</c>.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="94b23-394">반환되는 배열에 인터페이스가 포함되어야 하는지를 결정하는 검색 조건입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-394">The search criteria that determines whether an interface should be included in the returned array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-395">현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 인터페이스의 필터링된 목록을 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-395">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-396">현재 <see cref="T:System.Type" />에 의해 구현되거나 상속된 인터페이스의 필터링된 목록을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 해당 필터와 일치하는 인터페이스 중에서 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속된 인터페이스가 없는 경우에는 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-396">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-397">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-397">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="94b23-398"><xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> 및 <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> 대리자가 제공한 합니다 <xref:System.Reflection.Module?displayProperty=nameWithType> 클래스도 사용할 수 있습니다, 법률의는 <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-398">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="94b23-399">이 클래스에서 구현 된 인터페이스의 모든 값은 기본 클래스 또는 자체이 클래스에서 선언 하는지 여부를 검색 하는 동안 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-399">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="94b23-400">이 메서드 검색 인터페이스가 구현 하는 각 인터페이스의 각 각각 구현 하는 일치 하는 모든와 일치 하는 인터페이스를 반환 합니다. 기본 클래스 계층 (즉, 일치 하는 인터페이스의 전이적 closure이 반환 됨).</span><span class="sxs-lookup"><span data-stu-id="94b23-400">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="94b23-401">중복 된 인터페이스가 없는 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-401">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="94b23-402">하는 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <xref:System.Type.FindInterfaces%2A> 형식 매개 변수에 대 한 제약 조건에 선언 된 모든 인터페이스를 검색 하 고 인터페이스를 통해 상속 된 모든 인터페이스 제약 조건에서 선언 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-402">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="94b23-403">하는 경우 현재 <xref:System.Type> 제네릭 형식의 형식 인수를 나타내는 <xref:System.Type.FindInterfaces%2A> 제약 조건과 일치 하는지 여부 또는 형식으로 구현 하는 모든 인터페이스를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-403">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-404"><xref:System.Type.FindInterfaces%2A> 제네릭 되지 않는 형식에도 제네릭 인터페이스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-404"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="94b23-405">예를 들어 제네릭이 아닌 형식을 구현할 수 있습니다 `IEnumerable<int>` (`IEnumerable(Of Integer)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-405">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-406">다음 예제에서는 지정된 된 인터페이스 구현 또는 지정된 된 형식에서 상속 및 인터페이스 이름을 표시 한 다음를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-406">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-407">
            <paramref name="filter" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-407">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-408">정적 이니셜라이저가 호출되고 예외를 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-408">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">
          <span data-ttu-id="94b23-409">검색할 멤버 형식을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-409">An object that indicates the type of member to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-410">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-410">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-411">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-411">-or-</span>
          </span>
          <span data-ttu-id="94b23-412">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-412">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="94b23-413">비교를 수행하여 현재 검사 중인 멤버가 <c>filterCriteria</c>와 일치하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />를 반환하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-413">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <c>filterCriteria</c> and <see langword="false" /> otherwise.</span>
          </span>
          <span data-ttu-id="94b23-414">이 클래스에서 제공하는 <see langword="FilterAttribute" />, <see langword="FilterName" /> 및 <see langword="FilterNameIgnoreCase" /> 대리자를 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-414">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span>
          </span>
          <span data-ttu-id="94b23-415">첫 번째 대리자는 <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> 및 <see langword="MethodImplAttributes" />의 필드를 검색 조건으로 사용하고 다른 두 대리자는 <see langword="String" /> 개체를 검색 조건으로 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-415">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="94b23-416">
            <see langword="MemberInfo" /> 개체의 배열에 멤버가 반환되는지를 결정하는 검색 조건입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-416">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span>
          </span>
          <span data-ttu-id="94b23-417">
            <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> 및 <see langword="MethodImplAttributes" />의 필드는 이 클래스에서 제공하는 <see langword="FilterAttribute" /> 대리자와 함께 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-417">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-418">지정된 멤버 형식의 <see cref="T:System.Reflection.MemberInfo" /> 개체에 대한 필터링된 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-418">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-419">지정된 멤버 형식의 <see cref="T:System.Reflection.MemberInfo" /> 개체에 대한 필터링된 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-419">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
          <span data-ttu-id="94b23-420">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-420">-or-</span>
          </span>
          <span data-ttu-id="94b23-421">현재 <see cref="T:System.Reflection.MemberInfo" />에 필터 조건과 일치하는 <see cref="T:System.Type" /> 형식의 멤버가 없으면 <paramref name="memberType" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-421">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-422">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-422">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="94b23-423">멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-423">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="94b23-424">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-424">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-425">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-425">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-426">지정 `BindingFlags.Instance` 검색에서 인스턴스 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-426">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-427">지정 `BindingFlags.Static` 검색에 정적 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-427">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-428">지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-428">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-429">지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-429">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="94b23-430">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-430">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-431">`BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-431">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-432">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-432">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-433">유효한 값에 대 한 <xref:System.Type.MemberType%2A> 에 정의 된 <xref:System.Reflection.MemberInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-433">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="94b23-434">이러한 멤버가 없으면 빈 배열이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-434">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="94b23-435">이 메서드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-435">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-436">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-436">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-437">하는 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 형식 매개 변수를 나타내는 <xref:System.Type.FindMembers%2A> 클래스 제약 조건 및 형식 매개 변수의 인터페이스 제약 조건으로 선언 된 모든 멤버를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-437">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-438">다음 예제에서는 지정 된 검색 조건과 일치 하는 클래스에서 모든 멤버를 찾아서 다음 일치 하는 멤버를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-438">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-439">
            <paramref name="filter" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-439">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-440">해당 네임스페이스는 포함하지만 어셈블리는 포함하지 않는 형식의 정규화된 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-440">Gets the fully qualified name of the type, including its namespace but not its assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-441">해당 네임스페이스는 포함하지만 어셈블리는 포함하지 않는 형식의 정규화된 이름이거나 현재 인스턴스가 제네릭 형식 매개 변수, 배열 형식, 포인터 형식, 형식 매개 변수에 기초한 <see langword="null" /> 형식 또는 제네릭 형식 정의가 아니지만 확인되지 않은 형식 매개 변수가 들어 있는 제네릭 형식인 경우에는 <see langword="byref" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-441">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-442">정규화 된 이름에 예를 들어 합니다 <xref:System.String> 형식은 `System.String`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-442">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="94b23-443">반환 되는 어셈블리의 정규화 된 이름을 사용 하 여이 대조해 보세요는 <xref:System.Type.AssemblyQualifiedName%2A> 속성을 전체 어셈블리 이름과 전체 이름으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-443">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="94b23-444">문자열에 형식 인수를 반환한 현재 형식이 닫힌된 제네릭 형식을 나타내면는 <xref:System.Type.FullName%2A> 제네릭 형식 자체의 문자열 표현을 해당 전체에서 정규화 되지 않은 경우에 속성 전체 어셈블리 이름으로 정규화 됩니다 어셈블리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-444">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="94b23-445">다음 예제에서는 제네릭 형식 정의 나타내는 형식 및 닫힌된 제네릭 형식을 나타내는 FullName 속성 차이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-445">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="94b23-446">이 속성은 반환 `null` 경우:</span><span class="sxs-lookup"><span data-stu-id="94b23-446">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="94b23-447">현재 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-447">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="94b23-448">다음 예제에서는 형식 매개 변수를 검색 합니다 <xref:System.Nullable%601> 형식 및 표시 하려고 해당 <xref:System.Type.FullName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-448">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="94b23-449">현재 <xref:System.Type> 개체 배열 형식, 포인터 형식으로 나타내는 또는 `byref` 제네릭 형식 매개 변수를 기반으로 하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-449">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="94b23-450">다음 예제에서는 제네릭 형식 정의 `Generictype1<T>`, 세 가지 메서드를 사용 하 여: `Display(T[])`, T; 형식의 배열을 전달 되는 `HandleT(T)`를 T 개체를 전달 되는 및 `ChangeValue(ref T)`, T 개체 참조로 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-450">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="94b23-451">C# 및 Visual Basic을 허용 하지 않으므로 T에 대 한 포인터로 정의 하는 `HandleT` 메서드를 호출 했습니다를 <xref:System.Type.MakePointerType%2A> 메서드는 <xref:System.Type> 제네릭 형식에 대 한 포인터를 만들려면 메서드의 매개 변수 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-451">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="94b23-452">예제의 출력 하는 세 가지 경우 모두 표시 합니다 <xref:System.Type.FullName%2A> 속성은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-452">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="94b23-453">현재 형식에 특정 형식으로 바뀌지 않은 제네릭 형식 매개 변수가 (즉, 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`), 형식을 제네릭 형식 정의가 아닙니다. 하지만 (즉,는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성 반환 `false`</span><span class="sxs-lookup"><span data-stu-id="94b23-453">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="94b23-454">다음 예에서 `Derived<T>` 에서 상속 `Base<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-454">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="94b23-455"><xref:System.Type.BaseType%2A> 속성을 가져옵니다 합니다 <xref:System.Type> 의 기본 형식을 나타내는 개체입니다 `Derived<T>`, 및 해당 <xref:System.Type.FullName%2A> 속성에서 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-455">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="94b23-456">가져오려는 <xref:System.Type.FullName%2A> 없는 `null`, 사용할 수는 <xref:System.Type.GetGenericTypeDefinition%2A> 예제와 같이 제네릭 형식 정의 가져오는 방법.</span><span class="sxs-lookup"><span data-stu-id="94b23-456">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="94b23-457">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-457">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-458">다음 예제에서는 지정 된 형식의 전체 이름을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-458">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="94b23-459">다음 예제에서 반환 된 문자열을 비교 합니다 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="94b23-459">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-460">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-460">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-461">현재 제네릭 형식 매개 변수의 공 분산과 특수 제약 조건을 설명하는 <see cref="T:System.Reflection.GenericParameterAttributes" /> 플래그의 조합을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-461">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-462">현재 제네릭 형식 매개 변수의 공 분산 및 특수 제약 조건을 설명하는 <see cref="T:System.Reflection.GenericParameterAttributes" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-462">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-463">이 속성의 값을 현재 제네릭 형식 매개 변수를 공변 (covariant) 인지 여부를 나타내는 플래그 및 특수 제약 조건을 설명 하는 플래그를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-463">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="94b23-464">사용 하 여는 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> 값을 공변성 (covariance) 플래그를 선택 하 고 사용 하 여는 <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> 제약 조건 플래그를 선택 하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-464">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="94b23-465">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-465">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-466">다음 코드 예제에서는 제네릭 형식 정의 `Test` 제약 조건이 서로 다른 두 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-466">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="94b23-467">제약 조건을 사용 하 여 검사 된 프로그램을 실행 하는 경우는 <xref:System.Type.GenericParameterAttributes%2A> 속성 및 <xref:System.Type.GetGenericParameterConstraints%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-467">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-468">현재 <see cref="T:System.Type" /> 개체가 제네릭 형식 매개 변수가 아닌 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-468">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="94b23-469">즉, <see cref="P:System.Type.IsGenericParameter" /> 속성이 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-469">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-470">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-470">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-471">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-471">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-472">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-472">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-473">
            <see cref="T:System.Type" /> 개체가 제네릭 형식이나 제네릭 메서드의 형식 매개 변수를 나타내는 경우, 해당 매개 변수가 선언된 제네릭 형식 또는 메서드의 형식 매개 변수 목록에서 해당 형식 매개 변수가 있는 위치를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-473">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-474">형식 매개 변수가 정의된 제네릭 형식 또는 메서드의 형식 매개 변수 목록에서 해당 형식 매개 변수가 있는 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-474">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span>
          </span>
          <span data-ttu-id="94b23-475">위치 번호는 0부터 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-475">Position numbers begin at 0.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-476"><xref:System.Type.GenericParameterPosition%2A> 속성의 위치를 반환 형식 매개 변수를 제네릭 형식 정의 또는 제네릭 메서드 정의의 매개 변수 목록의 형식 매개 변수에 원래 정의 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-476">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="94b23-477">합니다 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 속성 제네릭 형식 또는 메서드 정의 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-477">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="94b23-478">경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환을 <xref:System.Reflection.MethodInfo>하 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체는 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-478">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="94b23-479">경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환 `null`, 해당 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환을 <xref:System.Type> 제네릭 형식 정의 나타내며 현재 개체 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-479">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="94b23-480">값에 대 한 올바른 컨텍스트를 지정 하는 <xref:System.Type.GenericParameterPosition%2A> 는 제네릭 형식 또는 형식 매개 변수에 속하는 메서드를 식별 하는 데 필요한 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-480">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="94b23-481">예를 들어, 제네릭 메서드의 반환 값을 고려할 `GetSomething` 다음 코드에서:</span><span class="sxs-lookup"><span data-stu-id="94b23-481">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="94b23-482">반환한 형식과 `GetSomething` 클래스에 제공 된 형식 인수에 따라 달라 집니다 `A` 하 고 `GetSomething` 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-482">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="94b23-483">가져올 수 있습니다는 <xref:System.Reflection.MethodInfo> 에 대 한 `GetSomething`는 반환 형식을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-483">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="94b23-484">반환 형식의 형식 매개 변수를 검사 하는 경우 <xref:System.Type.GenericParameterPosition%2A> 둘 다에 대해 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-484">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="94b23-485">위치가 `V` 이므로 0 `V` 클래스에 대 한 형식 매개 변수 목록의 첫 번째 형식 매개 변수는 `A`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-485">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="94b23-486">위치가 `X` 이므로 0 `X` 에 대 한 형식 매개 변수 목록의 첫 번째 형식 매개 변수는 `GetSomething`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-486">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-487">호출을 <xref:System.Type.GenericParameterPosition%2A> 속성 예외를 발생 하는 경우 현재 <xref:System.Type> 형식 매개 변수를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-487">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="94b23-488">개방형 생성 형식의 형식 인수를 검사할 때 사용 된 <xref:System.Type.IsGenericParameter%2A> 형식 매개 변수는 형식이 되 고 설명 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-488">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="94b23-489"><xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `true` ; 형식 매개 변수에 대해 사용할 수 있습니다 합니다 <xref:System.Type.GenericParameterPosition%2A> 위치로 사용 하는 메서드를 <xref:System.Type.DeclaringMethod%2A> 및 <xref:System.Type.DeclaringType%2A> 형식 정의 하는 정의 또는 제네릭 메서드를 확인 하는 속성 .</span><span class="sxs-lookup"><span data-stu-id="94b23-489">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-490">다음 예제에서는 두 형식 매개 변수를 사용 하 여 제네릭 클래스를 정의 하 고 첫 번째 클래스에서 파생 되는 두 번째 제네릭 클래스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-490">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="94b23-491">파생된 클래스의 기본 클래스에 두 개의 형식 인수: 첫 번째는 <xref:System.Int32>, 두 번째는 파생 된 형식의 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-491">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="94b23-492">보고 된 위치를 포함 하 여 이러한 제네릭 클래스에 대 한 정보를 표시 하는 예제에는 <xref:System.Type.GenericParameterPosition%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-492">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-493">현재 형식이 형식 매개 변수를 나타내지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-493">The current type does not represent a type parameter.</span>
          </span>
          <span data-ttu-id="94b23-494">즉, <see cref="P:System.Type.IsGenericParameter" />이 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-494">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-495">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-495">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-496">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-496">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-497">이 형식에 대한 제네릭 형식 인수의 배열을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-497">Gets an array of the generic type arguments for this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-498">이 형식에 대한 제네릭 형식 인수 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-498">An array of the generic type arguments for this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-499">이 속성에만 제네릭 형식 인수를; 가져옵니다. 즉, 현재 형식의 제네릭 형식 매개 변수에 대해 지정 된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-499">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="94b23-500">현재 형식이 제네릭 형식 정의 인 경우이 속성에 빈 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-500">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-501">다른 제네릭 형식 또는 제네릭 메서드는 제네릭 형식을 사용 하는 경우 해당 제네릭 형식 인수 중 일부는 바깥쪽 메서드 또는 형식을 제네릭 형식 매개 변수를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-501">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="94b23-502">제네릭 형식 정의 나타내는 형식의 제네릭 형식 매개 변수를 사용 합니다 <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-502">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="94b23-503">가져올는 <xref:System.Reflection.TypeInfo> 현재 <xref:System.Type> 개체를 사용 하 여는 <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> 확장 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-503">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-504">배열의 차원 수를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-504">Gets the number of dimensions in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-505">현재 형식의 차수를 포함하는 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-505">An integer that contains the number of dimensions in the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="94b23-506">다음 예제에서는 배열의 차원 수를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-506">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-507">이 메서드의 기능은 기본 클래스에서 지원되지 않으므로 대신에 파생된 클래스에서 구현해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-507">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-508">현재 형식은 배열이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-508">The current type is not an array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-509">파생 클래스에서 재정의되면 <see cref="P:System.Type.Attributes" /> 속성을 구현하고 <see cref="T:System.Type" />과 연관된 특성을 나타내는 비트 마스크를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-509">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-510">
            <see cref="T:System.Reflection.TypeAttributes" />의 특성 집합을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-510">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-511">현재 <see cref="T:System.Type" />의 특정 생성자를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-511">Gets a specific constructor of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">
          <span data-ttu-id="94b23-512">원하는 생성자에 대한 매개 변수의 수, 순서 및 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-512">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span>
          </span>
          <span data-ttu-id="94b23-513">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-513">-or-</span>
          </span>
          <span data-ttu-id="94b23-514">매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 개체의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-514">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="94b23-515">이러한 빈 배열은 <see langword="static" /> 필드 <see cref="F:System.Type.EmptyTypes" />에서 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-515">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-516">지정된 배열의 형식과 일치하는 매개 변수를 가진 public 인스턴스 생성자를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-516">Searches for a public instance constructor whose parameters match the types in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-517">매개 변수 형식 배열의 형식과 일치하는 매개 변수를 가진 public 인스턴스 생성자를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-517">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-518">이 메서드 오버 로드 public 인스턴스 생성자 찾은 클래스 이니셜라이저가 (.cctor)를 가져오는 데 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-518">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="94b23-519">클래스 이니셜라이저가 사용 하는 오버 로드 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-519">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-520">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-520">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-521">이 메서드가 반환 하는 경우 요청 된 생성자가 public이 아닌, `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-521">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-522">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-522">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-523">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-523">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-524">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-524">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="94b23-525">하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-525">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-526">다음 예제에서는의 형식을 가져옵니다 `MyClass`를 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 개체를 생성자 시그니처를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-526">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-527">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-527">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-528">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-528">-or-</span>
          </span>
          <span data-ttu-id="94b23-529">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-529">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-530">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-530">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-531">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-531">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-532">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-532">-or-</span>
          </span>
          <span data-ttu-id="94b23-533">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-533">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-534">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-534">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-535">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-535">-or-</span>
          </span>
          <span data-ttu-id="94b23-536">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-536">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-537">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-537">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="94b23-538">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-538">-or-</span>
          </span>
          <span data-ttu-id="94b23-539">매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-539">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="94b23-540">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-540">-or-</span>
          </span>
          <span data-ttu-id="94b23-541">
            <see cref="F:System.Type.EmptyTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-541">
              <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-542">매개 변수 형식 배열의 해당 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-542">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span>
          </span>
          <span data-ttu-id="94b23-543">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-543">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-544">지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 생성자를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-544">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-545">지정된 요구 사항과 일치하는 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 있으면 이 개체를 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-545">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-546">정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-546">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="94b23-547">경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-547">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="94b23-548">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-548">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-549">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-549">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-550">지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-550">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="94b23-551">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-551">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="94b23-552">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-552">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-553">이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-553">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-554">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-554">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-555">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-555">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-556">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-556">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-557">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-557">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="94b23-558">하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-558">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-559">다음 프로그램의 형식을 얻고 `MyClass1` 클래스를 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 지정 된 바인딩 플래그와 일치 하는 개체를 생성자의 시그니처를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-559">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-560">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-560">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-561">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-561">-or-</span>
          </span>
          <span data-ttu-id="94b23-562">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-562">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-563">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-563">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-564">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-564">-or-</span>
          </span>
          <span data-ttu-id="94b23-565">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-565">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-566">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-566">-or-</span>
          </span>
          <span data-ttu-id="94b23-567">
            <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-567">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-568">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-568">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-569">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-569">-or-</span>
          </span>
          <span data-ttu-id="94b23-570">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-570">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-571">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-571">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-572">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-572">-or-</span>
          </span>
          <span data-ttu-id="94b23-573">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-573">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="94b23-574">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-574">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-575">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-575">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="94b23-576">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-576">-or-</span>
          </span>
          <span data-ttu-id="94b23-577">매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-577">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-578">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-578">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-579">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-579">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-580">지정된 바인딩 제약 조건 및 호출 규칙을 사용하여, 지정된 인수 형식 및 한정자와 매개 변수가 일치하는 생성자를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-580">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-581">지정된 요구 사항과 일치하는 생성자를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-581">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-582">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-582">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-583">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-583">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-584">정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-584">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="94b23-585">경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-585">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="94b23-586">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-586">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-587">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-587">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-588">지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-588">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="94b23-589">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-589">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="94b23-590">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-590">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-591">이 메서드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-591">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-592">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-592">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-593">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-593">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-594">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-594">Member Type</span></span>|<span data-ttu-id="94b23-595">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-595">Static</span></span>|<span data-ttu-id="94b23-596">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-596">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-597">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-597">Constructor</span></span>|<span data-ttu-id="94b23-598">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-598">No</span></span>|<span data-ttu-id="94b23-599">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-599">No</span></span>|  
|<span data-ttu-id="94b23-600">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-600">Field</span></span>|<span data-ttu-id="94b23-601">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-601">No</span></span>|<span data-ttu-id="94b23-602">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-602">Yes.</span></span> <span data-ttu-id="94b23-603">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-603">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-604">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-604">Event</span></span>|<span data-ttu-id="94b23-605">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-605">Not applicable</span></span>|<span data-ttu-id="94b23-606">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-606">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-607">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-607">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-608">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-608">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-609">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-609">Method</span></span>|<span data-ttu-id="94b23-610">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-610">No</span></span>|<span data-ttu-id="94b23-611">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-611">Yes.</span></span> <span data-ttu-id="94b23-612">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-612">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-613">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-613">Nested Type</span></span>|<span data-ttu-id="94b23-614">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-614">No</span></span>|<span data-ttu-id="94b23-615">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-615">No</span></span>|  
|<span data-ttu-id="94b23-616">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-616">Property</span></span>|<span data-ttu-id="94b23-617">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-617">Not applicable</span></span>|<span data-ttu-id="94b23-618">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-618">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-619">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-619">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-620">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-620">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-621">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-621">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-622">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-622">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-623">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-623">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-624">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-624">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-625">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-625">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-626">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-626">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-627">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-627">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-628">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-628">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="94b23-629">하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-629">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-630">다음 예제에서는의 형식을 가져옵니다 `MyClass1`를 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 개체가 지정 된 바인딩 플래그와 일치 하는 생성자 시그니처를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-630">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-631">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-631">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-632">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-632">-or-</span>
          </span>
          <span data-ttu-id="94b23-633">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-633">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-634">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-634">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-635">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-635">-or-</span>
          </span>
          <span data-ttu-id="94b23-636">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-636">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-637">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-637">-or-</span>
          </span>
          <span data-ttu-id="94b23-638">
            <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-638">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-639">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-639">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-640">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-640">-or-</span>
          </span>
          <span data-ttu-id="94b23-641">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-641">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-642">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-642">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-643">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-643">-or-</span>
          </span>
          <span data-ttu-id="94b23-644">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-644">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="94b23-645">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-645">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-646">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-646">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="94b23-647">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-647">-or-</span>
          </span>
          <span data-ttu-id="94b23-648">매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-648">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-649">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-649">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-650">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-650">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-651">파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 생성자를 지정된 바인딩 제약 조건 및 호출 규칙으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-651">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-652">지정된 요구 사항과 일치하는 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 있으면 이 개체를 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-652">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-653">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-653">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-654">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-654">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-655">정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-655">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="94b23-656">경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-656">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="94b23-657">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-657">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-658">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-658">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-659">지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-659">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="94b23-660">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-660">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="94b23-661">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-661">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-662">이 메서드는 <xref:System.Type.GetConstructor%2A>를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-662">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-663">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-663">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-664">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-664">-or-</span>
          </span>
          <span data-ttu-id="94b23-665">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-665">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-666">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-666">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-667">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-667">-or-</span>
          </span>
          <span data-ttu-id="94b23-668">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-668">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-669">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-669">-or-</span>
          </span>
          <span data-ttu-id="94b23-670">
            <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-670">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-671">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-671">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-672">현재 <see cref="T:System.Type" />의 생성자를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-672">Gets the constructors of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-673">현재 <see cref="T:System.Type" />에 대해 정의된 모든 public 생성자를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-673">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-674">형식 이니셜라이저를 제외하고(정적 생성자) 현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의된 모든 public 인스턴스 생성자를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-674">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span>
          </span>
          <span data-ttu-id="94b23-675">public 인스턴스 생성자가 현재 <see cref="T:System.Type" />에 대해 정의되어 있지 않거나 현재 <see cref="T:System.Type" />이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 경우 <see cref="T:System.Reflection.ConstructorInfo" /> 형식의 빈 배열이 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-675">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-676"><xref:System.Type.GetConstructors%2A> 메서드 선언 순서와 같은 특정 순서로 생성자를 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-676">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="94b23-677">코드 영향을 받지 않아야 생성자 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-677">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-678">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-678">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-679">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-679">Member Type</span></span>|<span data-ttu-id="94b23-680">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-680">Static</span></span>|<span data-ttu-id="94b23-681">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-681">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-682">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-682">Constructor</span></span>|<span data-ttu-id="94b23-683">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-683">No</span></span>|<span data-ttu-id="94b23-684">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-684">No</span></span>|  
|<span data-ttu-id="94b23-685">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-685">Field</span></span>|<span data-ttu-id="94b23-686">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-686">No</span></span>|<span data-ttu-id="94b23-687">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-687">Yes.</span></span> <span data-ttu-id="94b23-688">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-688">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-689">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-689">Event</span></span>|<span data-ttu-id="94b23-690">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-690">Not applicable</span></span>|<span data-ttu-id="94b23-691">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-691">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-692">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-692">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-693">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-693">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-694">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-694">Method</span></span>|<span data-ttu-id="94b23-695">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-695">No</span></span>|<span data-ttu-id="94b23-696">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-696">Yes.</span></span> <span data-ttu-id="94b23-697">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-697">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-698">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-698">Nested Type</span></span>|<span data-ttu-id="94b23-699">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-699">No</span></span>|<span data-ttu-id="94b23-700">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-700">No</span></span>|  
|<span data-ttu-id="94b23-701">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-701">Property</span></span>|<span data-ttu-id="94b23-702">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-702">Not applicable</span></span>|<span data-ttu-id="94b23-703">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-703">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-704">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-704">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-705">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-705">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-706">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-706">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-707">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-707">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-708">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-708">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-709">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-709">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-710">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-710">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-711">이 메서드 오버 로드를 호출 합니다 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 메서드 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-711">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-712">클래스 이니셜라이저가 (.cctor)를 검색 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-712">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="94b23-713">클래스 이니셜라이저를 사용 하는 오버 로드를 사용 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-713">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-714">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-714">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-715">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-715">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="94b23-716">예를 들어 경우 클래스 `C<T>` 생성자가 `C(T t1)` (`Sub New(ByVal t1 As T)` Visual Basic의)를 호출 <xref:System.Type.GetConstructors%2A> 에 `C<int>` 반환을 <xref:System.Reflection.ConstructorInfo> 나타내는 `C(int t1)` C# (`Sub New(ByVal t1 As Integer)` Visual Basic의).</span><span class="sxs-lookup"><span data-stu-id="94b23-716">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="94b23-717">하는 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 <xref:System.Type.GetConstructors%2A> 메서드는 빈 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-717">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-718">출력을 보여 주는이 예제는 <xref:System.Type.GetConstructors%2A> 두 인스턴스 생성자 및 정적 생성자가 하나 있는 클래스에서 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-718">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="94b23-719">이 코드의 출력이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-719">The output of this code is:</span></span>  
  
 <span data-ttu-id="94b23-720">2</span><span class="sxs-lookup"><span data-stu-id="94b23-720">2</span></span>  
  
 <span data-ttu-id="94b23-721">False</span><span class="sxs-lookup"><span data-stu-id="94b23-721">False</span></span>  
  
 <span data-ttu-id="94b23-722">False</span><span class="sxs-lookup"><span data-stu-id="94b23-722">False</span></span>  
  
 <span data-ttu-id="94b23-723">때문에 <xref:System.Type.GetConstructors> 오버 로드만 사용 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>에서 정적 생성자를 계산 하지 않습니다는 `for` 식에서 계산 하거나 `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="94b23-723">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="94b23-724">정적 생성자를 찾기 위해 사용 하 여는 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 오버 로드 하 고 조합을 전달 (논리적 `OR`)의 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>를 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>다음 코드 예제에 나와 있는 것 처럼:</span><span class="sxs-lookup"><span data-stu-id="94b23-724">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="94b23-725">이제 출력이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-725">Now the output is:</span></span>  
  
 <span data-ttu-id="94b23-726">3</span><span class="sxs-lookup"><span data-stu-id="94b23-726">3</span></span>  
  
 <span data-ttu-id="94b23-727">False</span><span class="sxs-lookup"><span data-stu-id="94b23-727">False</span></span>  
  
 <span data-ttu-id="94b23-728">True</span><span class="sxs-lookup"><span data-stu-id="94b23-728">True</span></span>  
  
 <span data-ttu-id="94b23-729">False</span><span class="sxs-lookup"><span data-stu-id="94b23-729">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-730">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-730">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-731">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-731">-or-</span>
          </span>
          <span data-ttu-id="94b23-732">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-732">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-733">파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 생성자를 지정된 <see langword="BindingFlags" />로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-733">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-734">현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의된 생성자 중 지정된 바인딩 제약 조건과 일치하는 모든 생성자(정의된 경우에는 형식 이니셜라이저도 포함)를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-734">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span>
          </span>
          <span data-ttu-id="94b23-735">생성자가 현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의되어 있지 않거나, 정의된 생성자 중 바인딩 제약 조건과 일치하는 것이 없거나, 현재 <see cref="T:System.Type" />이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 경우 <see cref="T:System.Type" /> 형식의 빈 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-735">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-736"><xref:System.Type.GetConstructors%2A> 메서드 선언 순서와 같은 특정 순서로 생성자를 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-736">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="94b23-737">코드 영향을 받지 않아야 생성자 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-737">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-738">`bindingAttr` public 생성자 또는 public 및 non-public 생성자만 반환할 것인지를 지정 하려면 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-738">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="94b23-739">정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-739">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="94b23-740">경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-740">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="94b23-741">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-741">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-742">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-742">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-743">지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-743">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="94b23-744">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-744">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="94b23-745">기본 클래스의 생성자는 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-745">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="94b23-746">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-746">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-747">이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-747">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-748">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-748">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-749">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-749">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="94b23-750">예를 들어 경우 클래스 `C<T>` 생성자가 `C(T t1)` (`Sub New(ByVal t1 As T)` Visual Basic의)를 호출 <xref:System.Type.GetConstructors%2A> 에 `C<int>` 반환을 <xref:System.Reflection.ConstructorInfo> 나타내는 `C(int t1)` C# (`Sub New(ByVal t1 As Integer)` Visual Basic의).</span><span class="sxs-lookup"><span data-stu-id="94b23-750">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="94b23-751">하는 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 <xref:System.Type.GetConstructors%2A> 메서드는 빈 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-751">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-752">출력을 보여 주는이 예제는 <xref:System.Type.GetConstructors> 두 인스턴스 생성자 및 정적 생성자가 하나 있는 클래스에서 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-752">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="94b23-753">이 코드의 출력이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-753">The output of this code is:</span></span>  
  
 <span data-ttu-id="94b23-754">2</span><span class="sxs-lookup"><span data-stu-id="94b23-754">2</span></span>  
  
 <span data-ttu-id="94b23-755">False</span><span class="sxs-lookup"><span data-stu-id="94b23-755">False</span></span>  
  
 <span data-ttu-id="94b23-756">False</span><span class="sxs-lookup"><span data-stu-id="94b23-756">False</span></span>  
  
 <span data-ttu-id="94b23-757">때문에 <xref:System.Type.GetConstructors%2A> 오버 로드만 사용 <xref:System.Reflection.BindingFlags.Public> 및 <xref:System.Reflection.BindingFlags.Instance>에서 정적 생성자를 계산 하지 않습니다는 `for` 식에서 계산 하거나 `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="94b23-757">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="94b23-758">정적 생성자를 찾기 위해 사용 하 여는 <xref:System.Type.GetConstructors%2A> 오버 로드 하 고의 조합 (논리적 OR)을 전달 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>를 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>다음 코드 예제 에서처럼:</span><span class="sxs-lookup"><span data-stu-id="94b23-758">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="94b23-759">이제 출력이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-759">Now the output is:</span></span>  
  
 <span data-ttu-id="94b23-760">3</span><span class="sxs-lookup"><span data-stu-id="94b23-760">3</span></span>  
  
 <span data-ttu-id="94b23-761">False</span><span class="sxs-lookup"><span data-stu-id="94b23-761">False</span></span>  
  
 <span data-ttu-id="94b23-762">True</span><span class="sxs-lookup"><span data-stu-id="94b23-762">True</span></span>  
  
 <span data-ttu-id="94b23-763">False</span><span class="sxs-lookup"><span data-stu-id="94b23-763">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-764">현재 <see cref="T:System.Type" />에 대해 정의된 멤버 중 <see cref="T:System.Reflection.DefaultMemberAttribute" />가 설정된 멤버를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-764">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-765">현재 <see cref="T:System.Reflection.MemberInfo" />의 모든 기본 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-765">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-766">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-766">-or-</span>
          </span>
          <span data-ttu-id="94b23-767">현재 <see cref="T:System.Reflection.MemberInfo" />에 기본 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-767">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-768"><xref:System.Type.GetDefaultMembers%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-768">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-769">코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-769">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-770">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-770">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="94b23-771">멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-771">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="94b23-772">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-772">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-773">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-773">Member Type</span></span>|<span data-ttu-id="94b23-774">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-774">Static</span></span>|<span data-ttu-id="94b23-775">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-775">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-776">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-776">Constructor</span></span>|<span data-ttu-id="94b23-777">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-777">No</span></span>|<span data-ttu-id="94b23-778">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-778">No</span></span>|  
|<span data-ttu-id="94b23-779">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-779">Field</span></span>|<span data-ttu-id="94b23-780">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-780">No</span></span>|<span data-ttu-id="94b23-781">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-781">Yes.</span></span> <span data-ttu-id="94b23-782">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-782">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-783">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-783">Event</span></span>|<span data-ttu-id="94b23-784">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-784">Not applicable</span></span>|<span data-ttu-id="94b23-785">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-785">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-786">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-786">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-787">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-787">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-788">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-788">Method</span></span>|<span data-ttu-id="94b23-789">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-789">No</span></span>|<span data-ttu-id="94b23-790">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-790">Yes.</span></span> <span data-ttu-id="94b23-791">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-791">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-792">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-792">Nested Type</span></span>|<span data-ttu-id="94b23-793">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-793">No</span></span>|<span data-ttu-id="94b23-794">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-794">No</span></span>|  
|<span data-ttu-id="94b23-795">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-795">Property</span></span>|<span data-ttu-id="94b23-796">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-796">Not applicable</span></span>|<span data-ttu-id="94b23-797">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-797">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-798">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-798">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-799">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-799">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-800">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-800">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-801">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-801">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-802">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-802">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-803">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-803">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-804">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-804">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-805">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-805">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="94b23-806">예를 들어 경우 클래스 `C<T>` 속성이 `P` 반환 하는 `T`를 호출 <xref:System.Type.GetDefaultMembers%2A> 에 `C<int>` 반환 `int P` C# (`Property P As Integer` Visual Basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-806">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="94b23-807">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-807">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-808">다음 예제에서는의 기본 멤버 정보를 얻고 `MyClass` 기본 멤버를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-808">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-809">파생 클래스에서 재정의되면, 현재 배열, 포인터 또는 참조 형식에 의해 포함되거나 참조되는 개체의 <see cref="T:System.Type" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-809">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-810">현재 배열, 포인터 또는 참조 형식에서 포함하거나 참조하는 개체의 <see cref="T:System.Type" />입니다. 현재 <see langword="null" />이 배열 또는 포인터가 아니거나, 참조로 전달되지 않거나, 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수나 제네릭 형식을 나타내는 경우에는 <see cref="T:System.Type" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-810">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-811">이 메서드는 반환 `null` 에 대 한는 <xref:System.Array> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-811">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-812">다음 예제는 `GetElementType` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-812">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="94b23-813">이름을 검색할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-813">The value whose name is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-814">현재 열거형 형식에 대해 지정된 값을 가진 상수의 이름을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-814">Returns the name of the constant that has the specified value, for the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-815">지정된 값을 가진 현재 열거형 형식의 멤버 이름이거나 그러한 상수가 없는 경우 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-815">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-816">현재 형식은 열거형이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-816">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="94b23-817">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-817">-or-</span>
          </span>
          <span data-ttu-id="94b23-818">
            <paramref name="value" />는 현재 형식이 아니며 현재 형식과 동일한 기본 형식도 사용하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-818">
              <paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-819">
            <paramref name="value" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-819">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-820">현재 열거형 형식의 멤버 이름을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-820">Returns the names of the members of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-821">열거형 멤버의 이름이 포함된 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-821">An array that contains the names of the members of the enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-822">반환 값 배열 요소의 열거형 상수의 이진 값 (즉, 부호 없는 값)으로 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-822">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="94b23-823">동일한 값을 가진 열거 상수를 포함 하는 경우 해당 이름의 순서가 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-823">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-824">현재 형식은 열거형이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-824">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-825">현재 열거형 형식의 내부 형식을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-825">Returns the underlying type of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-826">현재 열거형의 내부 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-826">The underlying type of the current enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-827">기본적으로 C# 및 Visual Basic에서 열거형의 내부 형식은 <xref:System.Int32>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-827">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="94b23-828">다른 정수 형식에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-828">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-829">현재 형식은 열거형이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-829">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="94b23-830">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-830">-or-</span>
          </span>
          <span data-ttu-id="94b23-831">열거형 형식에 두 개 이상의 인스턴스 필드가 포함되어 있으므로 열거형 형식이 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-831">The enumeration type is not valid, because it contains more than one instance field.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-832">현재 열거형 형식에 있는 상수 값의 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-832">Returns an array of the values of the constants in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-833">값이 포함된 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-833">An array that contains the values.</span>
          </span>
          <span data-ttu-id="94b23-834">배열 요소는 열거형 상수의 이진 값(즉, 부호 없는 값)을 기준으로 정렬됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-834">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-835">현재 형식은 열거형이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-835">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-836">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 특정 이벤트를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-836">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-837">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-837">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-838">지정된 public 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-838">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-839">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는, 지정한 public 이벤트(있는 경우)를 나타내는 개체이고, 그렇지 않으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-839">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-840">메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-840">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="94b23-841">그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-841">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-842">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-842">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-843">검색에는 public static 및 public 인스턴스 이벤트가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-843">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="94b23-844">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-844">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-845">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-845">Member Type</span></span>|<span data-ttu-id="94b23-846">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-846">Static</span></span>|<span data-ttu-id="94b23-847">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-847">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-848">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-848">Constructor</span></span>|<span data-ttu-id="94b23-849">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-849">No</span></span>|<span data-ttu-id="94b23-850">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-850">No</span></span>|  
|<span data-ttu-id="94b23-851">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-851">Field</span></span>|<span data-ttu-id="94b23-852">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-852">No</span></span>|<span data-ttu-id="94b23-853">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-853">Yes.</span></span> <span data-ttu-id="94b23-854">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-854">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-855">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-855">Event</span></span>|<span data-ttu-id="94b23-856">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-856">Not applicable</span></span>|<span data-ttu-id="94b23-857">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-857">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-858">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-858">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-859">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-859">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-860">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-860">Method</span></span>|<span data-ttu-id="94b23-861">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-861">No</span></span>|<span data-ttu-id="94b23-862">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-862">Yes.</span></span> <span data-ttu-id="94b23-863">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-863">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-864">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-864">Nested Type</span></span>|<span data-ttu-id="94b23-865">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-865">No</span></span>|<span data-ttu-id="94b23-866">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-866">No</span></span>|  
|<span data-ttu-id="94b23-867">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-867">Property</span></span>|<span data-ttu-id="94b23-868">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-868">Not applicable</span></span>|<span data-ttu-id="94b23-869">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-869">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-870">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-870">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-871">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-871">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-872">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-872">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-873">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-873">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-874">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-874">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-875">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-875">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-876">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-876">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-877">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-877">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-878">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-878">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-879">다음 예제에서는 <xref:System.Reflection.EventInfo> 개체 및 지정된 된 이벤트에 대 한 단추 클래스에 대 한 이벤트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-879">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-880">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-880">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-881">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-881">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-882">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-882">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-883">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-883">-or-</span>
          </span>
          <span data-ttu-id="94b23-884">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-884">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-885">파생 클래스에서 재정의되면, 지정된 바인딩 제약 조건을 사용하여 지정된 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-885">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-886">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는, 지정한 이벤트(있는 경우)를 나타내는 개체이고, 그렇지 않으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-886">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-887">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 이벤트를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-887">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-888">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-888">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-889">지정 `BindingFlags.Public` 검색에 공용 이벤트를 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-889">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="94b23-890">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 이벤트 (즉, 전용, 내부 및 보호 된 이벤트)를 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-890">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-891">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-891">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-892">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-892">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-893">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-893">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-894">`BindingFlags.DeclaredOnly` 에 선언 된 이벤트만 검색 하는 <xref:System.Type>, 상속 된 이벤트가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-894">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-895">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-895">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-896">메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-896">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="94b23-897">그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-897">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-898">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-898">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-899">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-899">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-900">다음 코드 예제에서는 합니다 <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> public 또는 public이 아닌 이벤트를 "Click" 라는 아닌 형식을 검색 하는 방법 `static` (`Shared` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-900">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-901">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-901">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-902">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-902">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-903">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 모든 public 이벤트를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-903">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-904">현재 <see cref="T:System.Reflection.EventInfo" />에 의해 선언되거나 상속되는 모든 public 이벤트를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-904">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-905">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-905">-or-</span>
          </span>
          <span data-ttu-id="94b23-906">현재 <see cref="T:System.Reflection.EventInfo" />에 public 이벤트가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-906">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-907">메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-907">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="94b23-908">그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-908">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-909"><xref:System.Type.GetEvents%2A> 메서드 반환 하지 않습니다 이벤트를 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-909">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-910">코드 영향을 받지 않아야 이벤트가 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-910">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-911">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-911">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="94b23-912">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-912">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-913">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-913">Member Type</span></span>|<span data-ttu-id="94b23-914">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-914">Static</span></span>|<span data-ttu-id="94b23-915">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-915">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-916">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-916">Constructor</span></span>|<span data-ttu-id="94b23-917">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-917">No</span></span>|<span data-ttu-id="94b23-918">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-918">No</span></span>|  
|<span data-ttu-id="94b23-919">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-919">Field</span></span>|<span data-ttu-id="94b23-920">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-920">No</span></span>|<span data-ttu-id="94b23-921">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-921">Yes.</span></span> <span data-ttu-id="94b23-922">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-922">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-923">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-923">Event</span></span>|<span data-ttu-id="94b23-924">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-924">Not applicable</span></span>|<span data-ttu-id="94b23-925">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-925">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-926">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-926">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-927">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-927">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-928">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-928">Method</span></span>|<span data-ttu-id="94b23-929">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-929">No</span></span>|<span data-ttu-id="94b23-930">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-930">Yes.</span></span> <span data-ttu-id="94b23-931">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-931">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-932">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-932">Nested Type</span></span>|<span data-ttu-id="94b23-933">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-933">No</span></span>|<span data-ttu-id="94b23-934">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-934">No</span></span>|  
|<span data-ttu-id="94b23-935">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-935">Property</span></span>|<span data-ttu-id="94b23-936">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-936">Not applicable</span></span>|<span data-ttu-id="94b23-937">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-937">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-938">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-938">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-939">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-939">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-940">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-940">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-941">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-941">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-942">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-942">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-943">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-943">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-944">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-944">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-945">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-945">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-946">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-946">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-947">다음 예제에서는 배열을 가져옵니다 <xref:System.Reflection.EventInfo> 개체에 대 한 모든 이벤트는 `Button` 클래스 및 이벤트 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-947">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="94b23-948">Visual Basic 예제를 컴파일하려면 다음 명령줄을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-948">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-949">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-949">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-950">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-950">-or-</span>
          </span>
          <span data-ttu-id="94b23-951">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-951">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-952">파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-952">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-953">현재 <see cref="T:System.Reflection.EventInfo" />에 의해 선언되거나 상속되는 이벤트 중 지정된 바인딩 제약 조건과 일치하는 모든 이벤트를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-953">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="94b23-954">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-954">-or-</span>
          </span>
          <span data-ttu-id="94b23-955">현재 <see cref="T:System.Reflection.EventInfo" />에 이벤트가 없거나 해당 바인딩 제약 조건과 일치하는 이벤트가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-955">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-956"><xref:System.Type.GetEvents%2A> 메서드 반환 하지 않습니다 이벤트를 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-956">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-957">코드 영향을 받지 않아야 이벤트가 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-957">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-958">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 이벤트를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-958">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-959">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-959">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-960">지정 `BindingFlags.Public` 검색에 공용 이벤트를 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-960">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="94b23-961">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 이벤트 (즉, 전용, 내부 및 보호 된 이벤트)를 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-961">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="94b23-962">만 보호 하 고 기본 클래스의 내부 이벤트 반환 됩니다. 기본 클래스에서 private 이벤트 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-962">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="94b23-963">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-963">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-964">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-964">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-965">`BindingFlags.DeclaredOnly` 에 선언 된 이벤트만 검색 하는 <xref:System.Type>, 상속 된 이벤트가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-965">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-966">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-966">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-967">메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-967">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="94b23-968">그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-968">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-969">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-969">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-970">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-970">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-971">다음 예제에서는 배열을 가져옵니다 <xref:System.Reflection.EventInfo> 지정 된 바인딩 플래그와 일치 하는 개체에 대 한 모든 이벤트를 가져옵니다는 `Button` 클래스 및 이벤트 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-971">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="94b23-972">Visual Basic 예제를 컴파일하려면 다음 명령줄을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-972">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-973">현재 <see cref="T:System.Type" />의 특정 필드를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-973">Gets a specific field of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-974">가져올 데이터 필드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-974">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-975">지정된 이름의 public 필드를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-975">Searches for the public field with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-976">지정된 이름의 public 필드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-976">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-977">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-977">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-978">검색에는 public static 및 public 인스턴스 필드가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-978">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="94b23-979">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-979">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-980">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건 필드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-980">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-981">다음 예제에서는 합니다 `Type` 지정된 된 클래스에 대 한 개체를 가져옵니다는 <xref:System.Reflection.FieldInfo> 필드에 대 한 개체 필드의 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-981">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-982">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-982">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-983">이 <see cref="T:System.Type" /> 개체가 해당 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 메서드가 호출되지 않은 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-983">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-984">가져올 데이터 필드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-984">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-985">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-985">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-986">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-986">-or-</span>
          </span>
          <span data-ttu-id="94b23-987">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-987">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-988">지정된 필드를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-988">Searches for the specified field, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-989">지정된 요구 사항과 일치하는 필드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-989">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-990">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-990">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-991">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-991">Member Type</span></span>|<span data-ttu-id="94b23-992">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-992">Static</span></span>|<span data-ttu-id="94b23-993">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-993">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-994">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-994">Constructor</span></span>|<span data-ttu-id="94b23-995">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-995">No</span></span>|<span data-ttu-id="94b23-996">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-996">No</span></span>|  
|<span data-ttu-id="94b23-997">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-997">Field</span></span>|<span data-ttu-id="94b23-998">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-998">No</span></span>|<span data-ttu-id="94b23-999">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-999">Yes.</span></span> <span data-ttu-id="94b23-1000">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1000">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1001">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1001">Event</span></span>|<span data-ttu-id="94b23-1002">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1002">Not applicable</span></span>|<span data-ttu-id="94b23-1003">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1003">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1004">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1004">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1005">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1005">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1006">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1006">Method</span></span>|<span data-ttu-id="94b23-1007">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1007">No</span></span>|<span data-ttu-id="94b23-1008">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1008">Yes.</span></span> <span data-ttu-id="94b23-1009">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1009">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1010">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1010">Nested Type</span></span>|<span data-ttu-id="94b23-1011">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1011">No</span></span>|<span data-ttu-id="94b23-1012">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1012">No</span></span>|  
|<span data-ttu-id="94b23-1013">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1013">Property</span></span>|<span data-ttu-id="94b23-1014">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1014">Not applicable</span></span>|<span data-ttu-id="94b23-1015">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1015">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1016">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1016">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1017">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1017">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1018">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1018">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1019">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1019">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1020">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1020">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1021">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1021">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1022">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1022">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1023">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 필드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1023">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1024">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1024">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1025">지정 `BindingFlags.Public` 검색에서 public 필드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1025">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1026">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 (즉, 전용, 내부 및 보호 된) 필드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1026">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1027">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1027">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1028">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1028">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1029">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1029">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1030">`BindingFlags.DeclaredOnly` 에 선언 된 필드만 검색할는 <xref:System.Type>, 상속 된 필드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1030">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1031">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1031">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1032">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1032">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1033">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건 필드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1033">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1034">다음 예제에서는 합니다 `Type` 지정된 된 클래스에 대 한 개체를 가져옵니다는 <xref:System.Reflection.FieldInfo> 지정 된 바인딩 플래그와 일치 하는 필드의 값을 표시 필드에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1034">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1035">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1035">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1036">현재 <see cref="T:System.Type" />의 필드를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1036">Gets the fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1037">현재 <see cref="T:System.Type" />의 모든 public 필드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1037">Returns all the public fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1038">현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 모든 public 필드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1038">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-1039">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1039">-or-</span>
          </span>
          <span data-ttu-id="94b23-1040">현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 public 필드가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1040">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1041"><xref:System.Type.GetFields%2A> 메서드 반환 하지 않습니다 필드를 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1041">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1042">코드 영향을 받지 않아야 필드가 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1042">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1043">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1043">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1044">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1044">Member Type</span></span>|<span data-ttu-id="94b23-1045">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1045">Static</span></span>|<span data-ttu-id="94b23-1046">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1046">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1047">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1047">Constructor</span></span>|<span data-ttu-id="94b23-1048">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1048">No</span></span>|<span data-ttu-id="94b23-1049">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1049">No</span></span>|  
|<span data-ttu-id="94b23-1050">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1050">Field</span></span>|<span data-ttu-id="94b23-1051">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1051">No</span></span>|<span data-ttu-id="94b23-1052">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1052">Yes.</span></span> <span data-ttu-id="94b23-1053">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1053">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1054">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1054">Event</span></span>|<span data-ttu-id="94b23-1055">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1055">Not applicable</span></span>|<span data-ttu-id="94b23-1056">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1056">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1057">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1057">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1058">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1058">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1059">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1059">Method</span></span>|<span data-ttu-id="94b23-1060">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1060">No</span></span>|<span data-ttu-id="94b23-1061">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1061">Yes.</span></span> <span data-ttu-id="94b23-1062">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1062">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1063">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1063">Nested Type</span></span>|<span data-ttu-id="94b23-1064">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1064">No</span></span>|<span data-ttu-id="94b23-1065">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1065">No</span></span>|  
|<span data-ttu-id="94b23-1066">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1066">Property</span></span>|<span data-ttu-id="94b23-1067">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1067">Not applicable</span></span>|<span data-ttu-id="94b23-1068">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1068">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1069">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1069">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1070">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1070">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1071">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1071">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1072">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1072">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1073">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1073">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1074">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1074">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1075">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1075">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1076">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1076">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1077">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 public 필드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1077">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1078">다음 예제에서는 사용 하 여 `GetFields()` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-1078">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1079">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1079">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1080">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1080">-or-</span>
          </span>
          <span data-ttu-id="94b23-1081">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1081">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1082">파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 필드를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1082">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1083">현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 필드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1083">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="94b23-1084">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1084">-or-</span>
          </span>
          <span data-ttu-id="94b23-1085">현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 필드가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 필드가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1085">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1086"><xref:System.Type.GetFields%2A> 메서드 반환 하지 않습니다 필드를 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1086">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1087">코드 영향을 받지 않아야 필드가 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1087">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1088">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 필드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1088">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1089">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1089">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1090">지정 `BindingFlags.Public` 검색에서 public 필드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1090">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1091">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 (즉, 전용, 내부 및 보호 된) 필드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1091">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="94b23-1092">만 보호 하 고 기본 클래스의 내부 필드가 반환 됩니다. 기본 클래스에서 private 필드 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1092">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="94b23-1093">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1093">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1094">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1094">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1095">`BindingFlags.DeclaredOnly` 에 선언 된 필드만 검색할는 <xref:System.Type>, 상속 된 필드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1095">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1096">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1096">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1097">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1097">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1098">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 public 필드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1098">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1099">다음 예제에서는 사용 하 여 `GetFields(BindingFlags)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-1099">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1100">닫힌 제네릭 형식의 형식 정의나 제네릭 형식 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1100">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1101">제네릭 형식의 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1101">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span>
          </span>
          <span data-ttu-id="94b23-1102">현재 형식이 제네릭 형식이 아니면 빈 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1102">Returns an empty array if the current type is not a generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1103">배열 요소는 제네릭 형식의 형식 인수 목록에 나타나는 순서 대로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1103">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="94b23-1104">현재 형식이 닫힌 생성 된 형식인 경우 (즉, 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성이 반환 `false`)를 반환 하는 배열을 <xref:System.Type.GetGenericArguments%2A> 메서드는 제네릭 형식 정의의 제네릭 형식 매개 변수에 할당 된 형식을 포함 .</span><span class="sxs-lookup"><span data-stu-id="94b23-1104">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="94b23-1105">현재 형식이 제네릭 형식 정의 인 경우 배열 형식 매개 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1105">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="94b23-1106">현재 형식이 개방형 생성된 형식 (즉, 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성이 반환 `true`) 어떤 종류의 모든 형식 매개 변수 및 바깥쪽 제네릭 형식 또는 메서드의 형식 매개 변수를 할당 된 있지, 배열에 포함 형식 및 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1106">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="94b23-1107">사용 된 <xref:System.Type.IsGenericParameter%2A> 구분 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1107">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="94b23-1108">이 시나리오를 보여 주는 코드 예를 참조 하세요.를 <xref:System.Type.ContainsGenericParameters%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1108">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-1109">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1109">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1110">다음 코드 예제에서는 <xref:System.Type.GetGenericArguments%2A> 생성 된 형식의 형식 인수 및 해당 제네릭 형식 정의의 형식 매개 변수를 표시 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1110">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="94b23-1111">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1111">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="94b23-1112">샘플 출력에 대 한 더 큰 예제를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1112">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-1113">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1113">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="94b23-1114">파생 클래스에서 구현을 제공해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1114">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-1115">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1115">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-1116">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1116">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1117">현재 제네릭 형식 매개 변수에 대한 제약 조건을 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1117">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1118">현재 제네릭 형식 매개 변수에 대한 제약 조건을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1118">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1119">제네릭 형식 매개 변수의 각 제약 조건으로 표현 됩니다는 <xref:System.Type> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1119">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="94b23-1120">사용 합니다 <xref:System.Type.IsClass%2A> 제약 조건이 기본 클래스 제약 조건 인지; 속성을 반환 하는 경우를 결정 하는 속성 `false`, 제약 조건 인터페이스 제약 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1120">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="94b23-1121">형식 매개 변수에 클래스 제약 조건이 있고 인터페이스 제약 조건이 없는 경우 빈 배열이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1121">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="94b23-1122">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1122">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1123">다음 코드 예제에서는 제네릭 형식 정의 `Test` 제약 조건이 서로 다른 두 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1123">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="94b23-1124">제약 조건을 사용 하 여 검사 된 프로그램을 실행 하는 경우는 <xref:System.Type.GenericParameterAttributes%2A> 속성 및 <xref:System.Type.GetGenericParameterConstraints%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-1124">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-1125">현재 <see cref="T:System.Type" /> 개체가 제네릭 형식 매개 변수가 아닌 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1125">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="94b23-1126">즉, <see cref="P:System.Type.IsGenericParameter" /> 속성이 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1126">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-1127">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1127">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1128">현재 제네릭 형식을 생성할 수 있는 제네릭 형식 정의를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1128">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1129">현재 형식을 생성할 수 있는 제네릭 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1129">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1130">제네릭 형식 정의 다른 형식을 생성 하는 데 사용 될 수 있는 템플릿입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1130">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="94b23-1131">예를 들어, 제네릭 형식 정의에서 `G<T>` (C# 구문;으로 표현 합니다. `G(Of T)` Visual basic에서 또는 `generic <typename T> ref class G` c + +에서)를 생성 하 고 형식을 인스턴스화할 수 있습니다 `G<int>` (`G(Of Integer)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1131">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="94b23-1132">지정 된을 <xref:System.Type> 생성 된 형식을이 나타내는 개체를 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드는 제네릭 형식 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1132">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="94b23-1133">두 개의 생성 된 형식을 같은 제네릭 형식 정의에서 생성 되 면 동일한 형식 인수를 사용 하 여는 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드를 반환 하는 동일한 <xref:System.Type> 두 유형 모두에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1133">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="94b23-1134">호출 하는 경우는 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드를 <xref:System.Type> 이미 제네릭 형식 정의 나타내는 개체 현재 반환 <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="94b23-1134">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="94b23-1135">제네릭 형식의 배열 자체는 제네릭이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1135">An array of generic types is not itself generic.</span></span> <span data-ttu-id="94b23-1136">C# 코드에서 `A<int>[] v;` 또는 Visual Basic 코드 `Dim v() As A(Of Integer)`, 변수의 형식을 `v` 는 제네릭이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1136">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="94b23-1137">사용 하 여 <xref:System.Type.IsGenericType%2A> 형식을 호출 하기 전에 제네릭 인지 여부를 확인 하려면 <xref:System.Type.GetGenericTypeDefinition%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1137">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="94b23-1138">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1138">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1139">다음 코드 예제에서는 일반 인스턴스 생성을 사용 하 여 생성 된 형식의 인스턴스를 만들고 사용 하 여는 <xref:System.Type.GetType%2A> 고 <xref:System.Type.GetGenericTypeDefinition%2A> 생성 된 형식 및 제네릭 형식 정의 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1139">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="94b23-1140">이 예제에서는 제네릭 <xref:System.Collections.Generic.Dictionary%602> 유형, 생성 된 형식 나타내는 <xref:System.Collections.Generic.Dictionary%602> 의 `Test` 문자열 키를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1140">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-1141">현재 형식은 제네릭 형식이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1141">The current type is not a generic type.</span>
          </span>
          <span data-ttu-id="94b23-1142">즉, <see cref="P:System.Type.IsGenericType" />이 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1142">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-1143">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1143">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="94b23-1144">파생 클래스에서 구현을 제공해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1144">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-1145">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1145">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-1146">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1146">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1147">이 인스턴스의 해시 코드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1147">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1148">이 인스턴스의 해시 코드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1148">The hash code for this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1149">이 메서드는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1149">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1150">해시 코드를 표시 하는 다음 예제는 `System.Windows.Forms.Button` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1150">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1151">현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 특정 인터페이스를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1151">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1152">가져올 인터페이스의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1152">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="94b23-1153">제네릭 인터페이스의 경우 이것은 형식 표시 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1153">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1154">지정된 이름의 인터페이스를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1154">Searches for the interface with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1155">개체는 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는, 지정된 이름의 인터페이스를 나타내는 개체이며(있는 경우) 이를 나타내고, 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1155">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1156">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1156">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="94b23-1157">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1157">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1158">하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1158">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1159">제네릭 인터페이스에 대 한 합니다 `name` 매개 변수는 잘못 된 이름, 억음 악센트 끝나는 (\`) 및 형식 매개 변수의 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1159">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="94b23-1160">이것이 제네릭 인터페이스 정 및 생성 된 제네릭 인터페이스를 모두 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1160">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="94b23-1161">예를 들어 찾을 수 `IExample<T>` (`IExample(Of T)` Visual basic에서) 또는 `IExample<string>` (`IExample(Of String)` Visual basic에서), 검색할 ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="94b23-1161">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1162">다음 코드 예제에서는 합니다 <xref:System.Type.GetInterface%28System.String%29> 검색 하는 방법을 <xref:System.Collections.Hashtable> 클래스는 <xref:System.Runtime.Serialization.IDeserializationCallback> 인터페이스 및 인터페이스의 메서드를 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1162">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="94b23-1163">코드 예제도 합니다 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 메서드 오버 로드 및 <xref:System.Type.GetInterfaceMap%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-1163">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1164">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1164">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1165">현재 <see cref="T:System.Type" />이 서로 다른 형식 인수를 사용하여 같은 제네릭 인터페이스를 구현하는 형식을 나타내는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1165">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1166">가져올 인터페이스의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1166">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="94b23-1167">제네릭 인터페이스의 경우 이것은 형식 표시 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1167">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="94b23-1168">단순한 인터페이스 이름을 지정하는 <c>name</c>의 해당 부분의 대/소문자를 무시하려면 <see langword="true" />입니다. 네임스페이스를 지정하는 부분은 대/소문자를 올바로 지정해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1168">
              <see langword="true" /> to ignore the case of that part of <c>name</c> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span>
          </span>
          <span data-ttu-id="94b23-1169">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1169">-or-</span>
          </span>
          <span data-ttu-id="94b23-1170">
            <c>name</c>의 모든 부분에 대해 대/소문자를 구분하여 검색하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1170">
              <see langword="false" /> to perform a case-sensitive search for all parts of <c>name</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1171">파생 클래스에서 재정의되면 인터페이스 이름에 대해 대/소문자를 구분하지 않고 검색할지를 지정하여 지정된 인터페이스를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1171">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1172">개체는 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는, 지정된 이름의 인터페이스를 나타내는 개체이며(있는 경우) 이를 나타내고, 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1172">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1173">`ignoreCase` 매개 변수 단순한 인터페이스 이름을 네임 스페이스 필요가만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1173">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="94b23-1174">부분 `name` 네임 스페이스에는 정확한 대/소문자 있어야 합니다. 또는 인터페이스를 찾을 수 없습니다 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1174">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="94b23-1175">예를 들어, "System.icomparable" 찾습니다 문자열을 <xref:System.IComparable> 인터페이스 되지만 문자열 "system.icomparable" 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1175">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="94b23-1176">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1176">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1177">하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1177">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1178">제네릭 인터페이스에 대 한 합니다 `name` 매개 변수는 잘못 된 이름, 억음 악센트 끝나는 (\`) 및 형식 매개 변수의 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1178">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="94b23-1179">이것이 제네릭 인터페이스 정 및 생성 된 제네릭 인터페이스를 모두 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1179">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="94b23-1180">예를 들어 찾을 수 `IExample<T>` (`IExample(Of T)` Visual basic에서) 또는 `IExample<string>` (`IExample(Of String)` Visual basic에서), 검색할 `"IExample`1"'.</span><span class="sxs-lookup"><span data-stu-id="94b23-1180">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1181">다음 코드 예제에서는 합니다 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 의 대/소문자 구분 검색을 수행 하는 방법을 <xref:System.Collections.Hashtable> 클래스는 <xref:System.Collections.IEnumerable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1181">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="94b23-1182">코드 예제도 합니다 <xref:System.Type.GetInterface%28System.String%29> 메서드 오버 로드 및 <xref:System.Type.GetInterfaceMap%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-1182">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1183">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1183">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1184">현재 <see cref="T:System.Type" />이 서로 다른 형식 인수를 사용하여 같은 제네릭 인터페이스를 구현하는 형식을 나타내는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1184">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="94b23-1185">매핑을 검색할 인터페이스의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1185">The interface type to retrieve a mapping for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1186">지정된 인터페이스 형식에 대한 인터페이스 매핑을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1186">Returns an interface mapping for the specified interface type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1187">
            <paramref name="interfaceType" />에 대한 인터페이스 매핑을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1187">An object that represents the interface mapping for <paramref name="interfaceType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1188">인터페이스 맵을 인터페이스는 인터페이스를 구현 하는 클래스의 실제 멤버에 매핑되는 방법을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1188">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="94b23-1189">경우 현재 <xref:System.Type> 생성된 된 제네릭 형식을 나타내는, 형식 매개 변수 요소에 적절 한 형식 인수를 바뀝니다는 <xref:System.Reflection.InterfaceMapping> 이 메서드에서 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1189">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1190">다음 예제에서는 합니다 <xref:System.Type.GetInterfaceMap%2A> 결정 하는 방법 하는 방법을 <xref:System.IFormatProvider> 인터페이스에 매핑됩니다 <xref:System.Globalization.CultureInfo> 메서드를 하는 방법과 <xref:System.IAppDomainSetup> 인터페이스에 매핑됩니다 <xref:System.AppDomainSetup> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1190">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="94b23-1191">때문에 <xref:System.IAppDomainSetup> 인터페이스의 속성에서 반환된 된 집합 정의 <xref:System.Reflection.InterfaceMapping> 별도 개체에 포함 됩니다 <xref:System.Reflection.MethodInfo> 속성의 get 및 set 접근자에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1191">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-1192">
            <paramref name="interfaceType" />이 현재 형식으로 구현되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1192">
              <paramref name="interfaceType" /> is not implemented by the current type.</span>
          </span>
          <span data-ttu-id="94b23-1193">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1193">-or-</span>
          </span>
          <span data-ttu-id="94b23-1194">
            <paramref name="interfaceType" /> 매개 변수가 인스턴스를 참조하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1194">The <paramref name="interfaceType" /> parameter does not refer to an interface.</span>
          </span>
          <span data-ttu-id="94b23-1195">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1195">-or-</span>
          </span>
          <span data-ttu-id="94b23-1196">
            <paramref name="interfaceType" />이 제네릭 인터페이스이고 현재 형식이 배열 형식인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1196">
              <paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1197">
            <paramref name="interfaceType" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1197">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-1198">현재 <see cref="T:System.Type" />이 제네릭 형식 매개 변수를 나타내는 경우, 즉 <see cref="P:System.Type.IsGenericParameter" />가 <see langword="true" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1198">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-1199">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1199">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="94b23-1200">파생 클래스에서 구현을 제공해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1200">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1201">파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 모든 인터페이스를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1201">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1202">현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 모든 인터페이스를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1202">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-1203">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1203">-or-</span>
          </span>
          <span data-ttu-id="94b23-1204">현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 인터페이스가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1204">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1205"><xref:System.Type.GetInterfaces%2A> 메서드 반환 하지 않습니다 인터페이스를 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1205">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1206">코드 영향을 받지 않아야 인터페이스 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1206">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1207">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1207">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1208">하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1208">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1209">다음 예제에서는 지정된 된 클래스의 형식을 가져오고 형식을 구현 하거나 상속 하는 모든 인터페이스를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1209">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="94b23-1210">Visual Basic 예제를 컴파일하려면 다음 컴파일러 명령을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1210">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-1211">정적 이니셜라이저가 호출되고 예외를 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1211">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1212">현재 <see cref="T:System.Type" />의 지정된 멤버를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1212">Gets the specified members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1213">가져올 public 멤버의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1213">The string containing the name of the public members to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1214">지정된 이름의 public 멤버를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1214">Searches for the public members with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1215">지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1215">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1216">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1216">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-1217">Public static 및 public 인스턴스 멤버를 포함 하는 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1217">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="94b23-1218">멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1218">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="94b23-1219"><xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1219">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1220">코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1220">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1221">이 메서드 오버 로드 (.cctor) 클래스 이니셜라이저를 찾지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1221">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="94b23-1222">클래스 이니셜라이저를 사용 하는 오버 로드를 사용 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1222">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-1223">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1223">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-1224">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1224">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1225">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1225">Member Type</span></span>|<span data-ttu-id="94b23-1226">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1226">Static</span></span>|<span data-ttu-id="94b23-1227">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1227">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1228">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1228">Constructor</span></span>|<span data-ttu-id="94b23-1229">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1229">No</span></span>|<span data-ttu-id="94b23-1230">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1230">No</span></span>|  
|<span data-ttu-id="94b23-1231">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1231">Field</span></span>|<span data-ttu-id="94b23-1232">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1232">No</span></span>|<span data-ttu-id="94b23-1233">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1233">Yes.</span></span> <span data-ttu-id="94b23-1234">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1234">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1235">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1235">Event</span></span>|<span data-ttu-id="94b23-1236">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1236">Not applicable</span></span>|<span data-ttu-id="94b23-1237">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1237">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1238">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1238">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1239">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1239">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1240">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1240">Method</span></span>|<span data-ttu-id="94b23-1241">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1241">No</span></span>|<span data-ttu-id="94b23-1242">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1242">Yes.</span></span> <span data-ttu-id="94b23-1243">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1243">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1244">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1244">Nested Type</span></span>|<span data-ttu-id="94b23-1245">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1245">No</span></span>|<span data-ttu-id="94b23-1246">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1246">No</span></span>|  
|<span data-ttu-id="94b23-1247">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1247">Property</span></span>|<span data-ttu-id="94b23-1248">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1248">Not applicable</span></span>|<span data-ttu-id="94b23-1249">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1249">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1250">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1250">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1251">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1251">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1252">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1252">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1253">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1253">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1254">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1254">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1255">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1255">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1256">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1256">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1257">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1257">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1258">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1258">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1259">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1259">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1260">예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1260">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1261">모든 멤버를 표시 하는 다음 예제는 `String` C 문자로 시작 하는 클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-1261">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1262">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1262">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1263">가져올 멤버의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1263">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1264">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1264">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1265">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1265">-or-</span>
          </span>
          <span data-ttu-id="94b23-1266">빈 배열을 반환하려는 경우 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1266">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1267">지정된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1267">Searches for the specified members, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1268">지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1268">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1269">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1269">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="94b23-1270">멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1270">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="94b23-1271"><xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1271">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1272">코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1272">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1273">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1273">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1274">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1274">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1275">지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1275">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1276">지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1276">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1277">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1277">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1278">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1278">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1279">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1279">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1280">`BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1280">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1281">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1281">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1282">이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면에 대 한 ".cctor"를 지정 해야 합니다 `name`, 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서)에 대 한 `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="94b23-1282">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="94b23-1283">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1283">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-1284">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1284">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1285">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1285">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1286">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1286">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1287">예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1287">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1288">모든 공용 정적 멤버를 표시 하는 다음 예제는 `myString` C 문자로 시작 하는 클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-1288">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1289">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1289">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1290">가져올 멤버의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1290">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="94b23-1291">검색할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1291">The value to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1292">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1292">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1293">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1293">-or-</span>
          </span>
          <span data-ttu-id="94b23-1294">빈 배열을 반환하려는 경우 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1294">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1295">지정된 멤버 형식의 지정된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1295">Searches for the specified members of the specified member type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1296">지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1296">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1297">멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1297">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="94b23-1298"><xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1298">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1299">코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1299">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1300">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1300">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1301">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1301">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1302">지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1302">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1303">지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1303">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1304">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1304">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1305">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1305">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1306">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1306">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1307">`BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1307">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1308">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1308">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1309">이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면에 대 한 ".cctor"를 지정 해야 합니다 `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> 에 대 한 `type`, 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 에서 Visual Basic의 경우)에 대 한 `bindingAttr`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1309">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="94b23-1310">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1310">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-1311">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1311">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1312">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1312">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1313">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1313">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1314">예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1314">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1315">모든 메서드를 표시 하는 다음 예제는 `myString` C 문자로 시작 하는 클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-1315">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1316">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1316">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-1317">파생 클래스에서 구현을 제공해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1317">A derived class must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1318">현재 <see cref="T:System.Type" />의 멤버(속성, 메서드, 필드, 이벤트 등)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1318">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1319">현재 <see cref="T:System.Type" />의 모든 public 멤버를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1319">Returns all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1320">현재 <see cref="T:System.Reflection.MemberInfo" />의 모든 public 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1320">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-1321">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1321">-or-</span>
          </span>
          <span data-ttu-id="94b23-1322">현재 <see cref="T:System.Reflection.MemberInfo" />에 public 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1322">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1323">멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1323">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="94b23-1324"><xref:System.Type.GetMembers%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1324">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1325">코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1325">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1326">이 메서드 오버 로드를 호출 합니다 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 메서드 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1326">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-1327">클래스 이니셜라이저가 (.cctor)를 검색 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1327">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="94b23-1328">클래스 이니셜라이저를 사용 하는 오버 로드를 사용 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1328">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-1329">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1329">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-1330">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1330">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1331">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1331">Member Type</span></span>|<span data-ttu-id="94b23-1332">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1332">Static</span></span>|<span data-ttu-id="94b23-1333">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1333">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1334">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1334">Constructor</span></span>|<span data-ttu-id="94b23-1335">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1335">No</span></span>|<span data-ttu-id="94b23-1336">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1336">No</span></span>|  
|<span data-ttu-id="94b23-1337">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1337">Field</span></span>|<span data-ttu-id="94b23-1338">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1338">No</span></span>|<span data-ttu-id="94b23-1339">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1339">Yes.</span></span> <span data-ttu-id="94b23-1340">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1340">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1341">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1341">Event</span></span>|<span data-ttu-id="94b23-1342">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1342">Not applicable</span></span>|<span data-ttu-id="94b23-1343">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1343">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1344">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1344">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1345">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1345">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1346">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1346">Method</span></span>|<span data-ttu-id="94b23-1347">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1347">No</span></span>|<span data-ttu-id="94b23-1348">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1348">Yes.</span></span> <span data-ttu-id="94b23-1349">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1349">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1350">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1350">Nested Type</span></span>|<span data-ttu-id="94b23-1351">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1351">No</span></span>|<span data-ttu-id="94b23-1352">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1352">No</span></span>|  
|<span data-ttu-id="94b23-1353">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1353">Property</span></span>|<span data-ttu-id="94b23-1354">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1354">Not applicable</span></span>|<span data-ttu-id="94b23-1355">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1355">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1356">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1356">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1357">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1357">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1358">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1358">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1359">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1359">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1360">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1360">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1361">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1361">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1362">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1362">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1363">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1363">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1364">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1364">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1365">다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Type.GetMembers> 메서드 오버 로드는 지정 된 클래스의 모든 public 멤버에 대 한 정보를 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1365">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1366">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1366">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1367">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1367">-or-</span>
          </span>
          <span data-ttu-id="94b23-1368">빈 배열을 반환하려는 경우 0(<see cref="F:System.Reflection.BindingFlags.Default" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1368">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1369">파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1369">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1370">현재 <see cref="T:System.Reflection.MemberInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1370">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="94b23-1371">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1371">-or-</span>
          </span>
          <span data-ttu-id="94b23-1372">현재 <see cref="T:System.Reflection.MemberInfo" />에 대해 정의된 멤버가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1372">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1373">멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1373">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="94b23-1374"><xref:System.Type.GetMembers%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1374">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1375">코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1375">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1376">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1376">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1377">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1377">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1378">지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1378">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1379">지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1379">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="94b23-1380">만 보호 하 고 반환 되는 기본 클래스에 내부 멤버가; 기본 클래스에서 private 멤버는 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1380">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="94b23-1381">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1381">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1382">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1382">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1383">`BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1383">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1384">이 메서드를 호출할 합니다 `Public` 플래그 또는 `NonPublic` 플래그 지정 된 멤버를 반환 하 고 다른 플래그는 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1384">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="94b23-1385">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1385">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1386">이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1386">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="94b23-1387">클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1387">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-1388">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1388">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1389">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1389">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1390">다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 메서드 오버 로드는 지정 된 클래스의 모든 공용 인스턴스 멤버에 대 한 정보를 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1390">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1391">현재 <see cref="T:System.Type" />의 특정 메서드를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1391">Gets a specific method of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1392">가져올 public 메서드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1392">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1393">지정된 이름의 public 메서드를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1393">Searches for the public method with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1394">지정된 이름의 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1394">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1395">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1395">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-1396">Static 및 public에 대 한 공용 인스턴스 메서드를 포함 하는 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1396">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="94b23-1397">메서드 오버 로드 하 고 둘 이상의 공용 메서드가 합니다 <xref:System.Type.GetMethod%28System.String%29> 메서드가 throw는 <xref:System.Reflection.AmbiguousMatchException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1397">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="94b23-1398">공용 둘 이상의 오버 로드 이므로 다음 예제에서는 예외가 throw 됩니다는 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-1398">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="94b23-1399">반면에 때문에 `Person.ToString` 메서드 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 따라서 오버 로드 되지 하 고, <xref:System.Type.GetMethod%28System.String%29> 메서드는 검색할 수 있습니다를 <xref:System.Reflection.MethodInfo> 개체.</span><span class="sxs-lookup"><span data-stu-id="94b23-1399">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="94b23-1400">특정 메서드를 검색 하려면 다음 중 하나를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1400">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="94b23-1401">호출을 <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> 메서드 지정을 `bindingAttr` 메서드를 고유 하 게 식별 하는 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1401">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="94b23-1402">예를 들어, 형식에 정적 및 인스턴스 오버 로드 때문에 예외가 throw 되 면 지정할 수 있습니다는 `bindingAttr` 인수의 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1402">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="94b23-1403">오버 로드를 호출 합니다 <xref:System.Type.GetMethod%2A> 포함 하는 메서드를 `types` 메서드의 매개 변수 유형을 정의 하는 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1403">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="94b23-1404">호출 된 <xref:System.Type.GetMethods> 모든 형식에 속한 공용 메서드를 포함 하는 배열을 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1404">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="94b23-1405">이름이 중복 된 메서드를 식별 하기 위해 다음 반복할 수 있습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1405">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="94b23-1406">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1406">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1407">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1407">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1408">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1408">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1409">예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1409">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1410">다음 예제에서는 명명 된 메서드를 가져옵니다 `MethodA`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1410">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1411">지정한 이름을 가진 메서드가 둘 이상 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1411">More than one method is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1412">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1412">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1413">가져올 메서드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1413">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1414">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1414">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1415">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1415">-or-</span>
          </span>
          <span data-ttu-id="94b23-1416">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1416">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1417">지정된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1417">Searches for the specified method, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1418">지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1418">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1419">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1419">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1420">중 하나를 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1420">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1421">지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 검색에서 공용 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1421">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1422">지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1422">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1423">지정할 <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1423">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1424">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1424">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1425"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1425"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1426"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1426"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1427">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1427">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1428">메서드 오버 로드 되 고 둘 이상의 오버 로드로 지정 된 제약 조건을 충족 하는 경우는 `bindingAttr` 인수는 메서드가 throw는 <xref:System.Reflection.AmbiguousMatchException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1428">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="94b23-1429">다음 예제에서는 없으므로 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1429">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="94b23-1430">`TestClass` 형식에는 두 개의 공용 인스턴스 오버 로드가 합니다 `DisplayValue` 메서드를 `DisplayValue(String)` 및 `DisplayValue(String, Object[])`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1430">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="94b23-1431">`TestClass` 형식은 두 공용 인스턴스 오버 로드는 `Equals` 메서드를 그 중 하나에서 상속 됩니다 <xref:System.Object>: `Equals(TestClass)` 및 `Equals(Object)`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1431">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="94b23-1432">특정 메서드를 검색 하려면 다음 중 하나를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1432">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="94b23-1433">해당 바인딩 제약 조건과 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1433">Change the binding constraints.</span></span> <span data-ttu-id="94b23-1434">공용 인스턴스를 검색 하는 동안 이전 예에서 `Equals` 형식으로 선언 되 고 성공적으로 상속 되지 메서드 검색 `Equals(TestClass)`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1434">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="94b23-1435">오버 로드를 호출 합니다 <xref:System.Type.GetMethod%2A> 포함 하는 메서드를 `types` 메서드의 매개 변수 유형을 정의 하는 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1435">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="94b23-1436">호출 된 <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> 모든 형식에 속하는 지정 된 바인딩 특성이 있는 메서드를 포함 하는 배열을 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1436">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="94b23-1437">이름이 중복 된 메서드를 식별 하기 위해 다음 반복할 수 있습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1437">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="94b23-1438">이 접근 방식에 대 한 이전 예제의 처리기에 설명 되어는 <xref:System.Reflection.AmbiguousMatchException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1438">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="94b23-1439">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1439">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1440">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1440">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1441">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1441">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1442">예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1442">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1443">다음 예제에서는 지정된 된 바인딩 플래그와 일치 하는 메서드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1443">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1444">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1444">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1445">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1445">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1446">가져올 public 메서드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1446">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-1447">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1447">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="94b23-1448">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1448">-or-</span>
          </span>
          <span data-ttu-id="94b23-1449">매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1449">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1450">지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 메서드를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1450">Searches for the specified public method whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1451">지정된 인수 형식과 일치하는 매개 변수를 가진 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1451">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1452">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1452">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-1453">Static 및 public에 대 한 공용 인스턴스 메서드를 포함 하는 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1453">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1454">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1454">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-1455">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1455">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-1456">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1456">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1457">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1457">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1458">`name` 매개 변수 형식 인수를 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1458">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="94b23-1459">예를 들어 C# 코드 `GetMethod("MyGenericMethod<int>")` 텍스트 이름 사용 하 여 메서드에 대 한 검색 "`MyGenericMethod<int>`"을 대신 명명 된 메서드에 대 한 `MyGenericMethod` 형식의 제네릭 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1459">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="94b23-1460">대신 `GetMethod("MyGenericMethod")` 적절 한 매개 변수를 사용 하 여는 `types` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1460">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1461">다음 예제에서는 특정 오버 로드 `MethodA`, 다양 한 형식 인수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1461">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1462">합니다 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제는 `/unsafe` 컴파일러 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1462">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="94b23-1463">다음 예제에서는 검색 <xref:System.Reflection.MethodInfo> 나타내는 개체를 `Add` 제네릭이 아닌 형식의 메서드 (합니다 <xref:System.Collections.ArrayList> 클래스), 개방형 제네릭 형식 (는 <xref:System.Collections.Generic.List%601> 클래스), 및 닫힌된 제네릭 형식 (는 `List(Of String)` 형식.</span><span class="sxs-lookup"><span data-stu-id="94b23-1463">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="94b23-1464">이 예제에서는 정의 `GetAddMethod` 적절 한 검색 하는 메서드 <xref:System.Reflection.MethodInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1464">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="94b23-1465">제공 하는 `types` 개방형 제네릭 형식에 대 한 인수를 호출 합니다 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-1465">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="94b23-1466">제공 하는 `types` 의 값을 얻어냅니다 닫힌된 제네릭 형식에 대 한 인수는 <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> 속성.</span><span class="sxs-lookup"><span data-stu-id="94b23-1466">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1467">지정된 이름 및 지정된 매개 변수를 사용하는 메서드가 두 개 이상입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1467">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1468">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1468">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1469">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1469">-or-</span>
          </span>
          <span data-ttu-id="94b23-1470">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1470">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1471">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1471">-or-</span>
          </span>
          <span data-ttu-id="94b23-1472">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1472">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-1473">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1473">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1474">가져올 public 메서드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1474">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-1475">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1475">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="94b23-1476">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1476">-or-</span>
          </span>
          <span data-ttu-id="94b23-1477">매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1477">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-1478">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1478">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-1479">COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1479">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="94b23-1480">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1480">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1481">지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 public 메서드를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1481">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1482">지정된 요구 사항과 일치하는 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1482">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1483">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1483">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-1484">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1484">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-1485">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1485">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-1486">Static 및 public에 대 한 공용 인스턴스 메서드를 포함 하는 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1486">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1487">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1487">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-1488">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1488">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-1489">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1489">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1490">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1490">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1491">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1491">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1492">예를 들어 C# 코드 `GetMethod("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1492">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="94b23-1493">대신 `GetMethod("MyMethod")` 적절 한 매개 변수를 사용 하 여는 `types` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1493">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1494">지정된 이름 및 지정된 매개 변수를 사용하는 메서드가 두 개 이상입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1494">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1495">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1495">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1496">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1496">-or-</span>
          </span>
          <span data-ttu-id="94b23-1497">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1497">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1498">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1498">-or-</span>
          </span>
          <span data-ttu-id="94b23-1499">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1499">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-1500">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1500">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-1501">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1501">-or-</span>
          </span>
          <span data-ttu-id="94b23-1502">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1502">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1503">가져올 메서드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1503">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1504">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1504">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1505">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1505">-or-</span>
          </span>
          <span data-ttu-id="94b23-1506">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1506">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-1507">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1507">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-1508">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1508">-or-</span>
          </span>
          <span data-ttu-id="94b23-1509">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1509">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-1510">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1510">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="94b23-1511">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1511">-or-</span>
          </span>
          <span data-ttu-id="94b23-1512">매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1512">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-1513">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1513">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-1514">COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1514">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="94b23-1515">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1515">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1516">지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1516">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1517">지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1517">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1518">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1518">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-1519">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1519">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-1520">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1520">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1521">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1521">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1522">지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1522">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1523">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1523">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1524">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1524">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1525">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1525">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1526">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1526">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1527">`BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1527">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1528">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1528">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1529">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1529">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-1530">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1530">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-1531">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1531">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1532">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1532">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1533">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1533">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1534">예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1534">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1535">다음 예제에서는 특정 오버 로드 `MethodA`, 바인딩 제약 조건 및 다양 한 형식 인수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1535">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1536">합니다 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제는 `/unsafe` 컴파일러 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1536">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1537">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1537">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1538">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1538">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1539">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1539">-or-</span>
          </span>
          <span data-ttu-id="94b23-1540">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1540">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1541">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1541">-or-</span>
          </span>
          <span data-ttu-id="94b23-1542">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1542">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-1543">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1543">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-1544">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1544">-or-</span>
          </span>
          <span data-ttu-id="94b23-1545">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1545">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1546">가져올 메서드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1546">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1547">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1547">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1548">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1548">-or-</span>
          </span>
          <span data-ttu-id="94b23-1549">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1549">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-1550">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1550">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-1551">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1551">-or-</span>
          </span>
          <span data-ttu-id="94b23-1552">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1552">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="94b23-1553">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1553">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-1554">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1554">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="94b23-1555">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1555">-or-</span>
          </span>
          <span data-ttu-id="94b23-1556">매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1556">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-1557">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1557">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-1558">COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1558">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="94b23-1559">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1559">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1560">지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건과 지정된 호출 규칙으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1560">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1561">지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1561">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1562">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1562">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-1563">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1563">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-1564">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `GetXXX` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1564">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1565">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1565">Member Type</span></span>|<span data-ttu-id="94b23-1566">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1566">Static</span></span>|<span data-ttu-id="94b23-1567">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1567">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1568">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1568">Constructor</span></span>|<span data-ttu-id="94b23-1569">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1569">No</span></span>|<span data-ttu-id="94b23-1570">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1570">No</span></span>|  
|<span data-ttu-id="94b23-1571">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1571">Field</span></span>|<span data-ttu-id="94b23-1572">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1572">No</span></span>|<span data-ttu-id="94b23-1573">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1573">Yes.</span></span> <span data-ttu-id="94b23-1574">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1574">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1575">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1575">Event</span></span>|<span data-ttu-id="94b23-1576">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1576">Not applicable</span></span>|<span data-ttu-id="94b23-1577">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1577">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1578">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1578">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1579">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1579">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1580">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1580">Method</span></span>|<span data-ttu-id="94b23-1581">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1581">No</span></span>|<span data-ttu-id="94b23-1582">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1582">Yes.</span></span> <span data-ttu-id="94b23-1583">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1583">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1584">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1584">Nested Type</span></span>|<span data-ttu-id="94b23-1585">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1585">No</span></span>|<span data-ttu-id="94b23-1586">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1586">No</span></span>|  
|<span data-ttu-id="94b23-1587">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1587">Property</span></span>|<span data-ttu-id="94b23-1588">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1588">Not applicable</span></span>|<span data-ttu-id="94b23-1589">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1589">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1590">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1590">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1591">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1591">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1592">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1592">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1593">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1593">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1594">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1594">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1595">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1595">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1596">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1596">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1597">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1597">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1598">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1598">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1599">지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1599">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1600">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1600">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1601">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1601">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1602">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1602">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1603">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1603">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1604">`BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1604">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1605">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1605">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1606">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1606">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-1607">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1607">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-1608">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1608">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1609">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1609">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1610">제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1610">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="94b23-1611">예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1611">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1612">다음 예제에서는 특정 오버 로드 `MethodA`, 바인딩 제약 조건과 지정, 호출 규칙 및 다양 한 인수 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1612">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1613">합니다 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제는 `/unsafe` 컴파일러 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1613">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1614">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1614">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1615">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1615">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1616">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1616">-or-</span>
          </span>
          <span data-ttu-id="94b23-1617">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1617">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1618">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1618">-or-</span>
          </span>
          <span data-ttu-id="94b23-1619">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1619">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-1620">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1620">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-1621">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1621">-or-</span>
          </span>
          <span data-ttu-id="94b23-1622">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1622">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1623">가져올 메서드의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1623">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1624">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1624">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1625">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1625">-or-</span>
          </span>
          <span data-ttu-id="94b23-1626">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1626">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-1627">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1627">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-1628">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1628">-or-</span>
          </span>
          <span data-ttu-id="94b23-1629">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1629">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="94b23-1630">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택을 정리하는 프로세스 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1630">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-1631">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1631">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="94b23-1632">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1632">-or-</span>
          </span>
          <span data-ttu-id="94b23-1633">매개 변수를 사용하지 않는 메서드를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1633">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span>
          </span>
          <span data-ttu-id="94b23-1634">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1634">-or-</span>
          </span>
          <span data-ttu-id="94b23-1635">
            <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1635">
              <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-1636">
            <c>types</c>가 <see langword="null" />이면 일치되는 인수가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1636">If <c>types</c> is <see langword="null" />, arguments are not matched.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-1637">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1637">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-1638">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1638">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1639">파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건 및 호출 규칙으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1639">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1640">지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1640">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1641">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1641">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-1642">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1642">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-1643">`types`가 `null`이면 일치되는 인수가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1643">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="94b23-1644">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1644">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1645">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1645">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1646">지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1646">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1647">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1647">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1648">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1648">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1649">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1649">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1650">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1650">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1651">`BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1651">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1652">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1652">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1653">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1653">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1654">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1654">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-1655">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1655">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-1656">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1656">-or-</span>
          </span>
          <span data-ttu-id="94b23-1657">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1657">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-1658">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1658">-or-</span>
          </span>
          <span data-ttu-id="94b23-1659">
            <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1659">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-1660">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1660">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1661">현재 <see cref="T:System.Type" />의 메서드를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1661">Gets the methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1662">현재 <see cref="T:System.Type" />의 모든 public 메서드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1662">Returns all the public methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1663">현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 모든 public 메서드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1663">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-1664">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1664">-or-</span>
          </span>
          <span data-ttu-id="94b23-1665">현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 public 메서드가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1665">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1666"><xref:System.Type.GetMethods%2A> 메서드 반환 하지 않습니다 메서드를 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1666">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1667">코드 영향을 받지 않아야 메서드가 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1667">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1668">생성자는 메서드가이 호출에서 반환 된 배열에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1668">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="94b23-1669">별도 호출 `GetConstructors()` 생성자 메서드를 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1669">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="94b23-1670">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1670">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1671">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1671">Member Type</span></span>|<span data-ttu-id="94b23-1672">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1672">Static</span></span>|<span data-ttu-id="94b23-1673">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1673">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1674">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1674">Constructor</span></span>|<span data-ttu-id="94b23-1675">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1675">No</span></span>|<span data-ttu-id="94b23-1676">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1676">No</span></span>|  
|<span data-ttu-id="94b23-1677">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1677">Field</span></span>|<span data-ttu-id="94b23-1678">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1678">No</span></span>|<span data-ttu-id="94b23-1679">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1679">Yes.</span></span> <span data-ttu-id="94b23-1680">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1680">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1681">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1681">Event</span></span>|<span data-ttu-id="94b23-1682">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1682">Not applicable</span></span>|<span data-ttu-id="94b23-1683">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1683">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1684">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1684">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1685">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1685">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1686">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1686">Method</span></span>|<span data-ttu-id="94b23-1687">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1687">No</span></span>|<span data-ttu-id="94b23-1688">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1688">Yes.</span></span> <span data-ttu-id="94b23-1689">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1689">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1690">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1690">Nested Type</span></span>|<span data-ttu-id="94b23-1691">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1691">No</span></span>|<span data-ttu-id="94b23-1692">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1692">No</span></span>|  
|<span data-ttu-id="94b23-1693">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1693">Property</span></span>|<span data-ttu-id="94b23-1694">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1694">Not applicable</span></span>|<span data-ttu-id="94b23-1695">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1695">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1696">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1696">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1697">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1697">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1698">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1698">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1699">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1699">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1700">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1700">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1701">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1701">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1702">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1702">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1703">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1703">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-1704">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1704">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-1705">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1705">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1706">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1706">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1707">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1707">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1708">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1708">-or-</span>
          </span>
          <span data-ttu-id="94b23-1709">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1709">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1710">파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1710">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1711">현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 메서드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1711">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="94b23-1712">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1712">-or-</span>
          </span>
          <span data-ttu-id="94b23-1713">현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 메서드가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 메서드가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1713">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1714"><xref:System.Type.GetMethods%2A> 메서드 반환 하지 않습니다 메서드를 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1714">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1715">코드 영향을 받지 않아야 메서드가 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1715">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1716">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1716">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1717">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1717">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1718">지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1718">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1719">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1719">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="94b23-1720">만 보호 하 고 기본 클래스 내부 메서드 반환 됩니다. 기본 클래스의 전용 메서드는 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1720">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="94b23-1721">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1721">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1722">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1722">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1723">`BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1723">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1724">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1724">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1725">생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1725">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="94b23-1726">호출 하는 경우에 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1726">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="94b23-1727">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1727">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1728">하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1728">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1729">다음 예제에서는 두 개의 공용 메서드와 하나의 보호 된 메서드를 사용 하 여 클래스를 만들고, 만듭니다는 `Type` 개체에 해당 하 `MyTypeClass`모든 public 및 public이 아닌 메서드를 가져오고 해당 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1729">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1730">현재 <see cref="T:System.Type" />에 중첩된 특정 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1730">Gets a specific type nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1731">가져올 중첩 형식의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1731">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1732">지정된 이름의 public 중첩 형식을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1732">Searches for the public nested type with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1733">지정된 이름의 public 중첩 형식을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1733">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1734">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1734">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="94b23-1735">에 대 한 중첩 된 클래스의 단순한 이름을 사용 하 여 `name`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1735">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="94b23-1736">외부 클래스의 이름으로 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1736">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="94b23-1737">중첩 된 제네릭 클래스에 대 한 잘못 된 이름을 사용 하 여-즉, 억음 악센트 및 제네릭 인수의 개수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1737">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="94b23-1738">예를 들어 문자열을 사용 하 여 "내부\`1" 중첩 된 클래스를 가져오려면 제네릭 `Inner<T>` (`Inner(Of T)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1738">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="94b23-1739">언어별 구문은 형식 매개 변수를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1739">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="94b23-1740">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1740">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1741">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1741">Member Type</span></span>|<span data-ttu-id="94b23-1742">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1742">Static</span></span>|<span data-ttu-id="94b23-1743">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1743">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1744">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1744">Constructor</span></span>|<span data-ttu-id="94b23-1745">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1745">No</span></span>|<span data-ttu-id="94b23-1746">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1746">No</span></span>|  
|<span data-ttu-id="94b23-1747">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1747">Field</span></span>|<span data-ttu-id="94b23-1748">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1748">No</span></span>|<span data-ttu-id="94b23-1749">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1749">Yes.</span></span> <span data-ttu-id="94b23-1750">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1750">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1751">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1751">Event</span></span>|<span data-ttu-id="94b23-1752">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1752">Not applicable</span></span>|<span data-ttu-id="94b23-1753">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1753">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1754">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1754">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1755">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1755">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1756">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1756">Method</span></span>|<span data-ttu-id="94b23-1757">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1757">No</span></span>|<span data-ttu-id="94b23-1758">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1758">Yes.</span></span> <span data-ttu-id="94b23-1759">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1759">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1760">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1760">Nested Type</span></span>|<span data-ttu-id="94b23-1761">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1761">No</span></span>|<span data-ttu-id="94b23-1762">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1762">No</span></span>|  
|<span data-ttu-id="94b23-1763">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1763">Property</span></span>|<span data-ttu-id="94b23-1764">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1764">Not applicable</span></span>|<span data-ttu-id="94b23-1765">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1765">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1766">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1766">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1767">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1767">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1768">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1768">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1769">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1769">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1770">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1770">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1771">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1771">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1772">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1772">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1773">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1773">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="94b23-1774">중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1774">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="94b23-1775">바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1775">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1776">하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1776">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="94b23-1777">이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1777">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="94b23-1778">중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1778">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1779">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1779">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1780">가져올 중첩 형식의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1780">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1781">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1781">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1782">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1782">-or-</span>
          </span>
          <span data-ttu-id="94b23-1783">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1783">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1784">파생 클래스에서 재정의되면, 지정된 중첩 형식을 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1784">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1785">지정된 요구 사항과 일치하는 중첩 형식을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1785">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1786">에 대 한 중첩 된 클래스의 단순한 이름을 사용 하 여 `name`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1786">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="94b23-1787">외부 클래스의 이름으로 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1787">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="94b23-1788">중첩 된 제네릭 클래스에 대 한 잘못 된 이름을 사용 하 여-즉, 억음 악센트와 제네릭 매개 변수 개수를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1788">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="94b23-1789">예를 들어 문자열을 사용 하 여 "내부\`1" 중첩 된 클래스를 가져오려면 제네릭 `Inner<T>` (`Inner(Of T)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1789">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="94b23-1790">언어별 구문은 형식 매개 변수를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1790">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="94b23-1791">다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식 필터 플래그를 사용 하는 중첩 된 정의 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1791">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1792">중 하나를 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 반환을 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1792">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1793">지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> public 중첩된 형식을 검색에 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1793">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1794">지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 중첩된 형식 (즉, 전용, 내부 및 보호 된 중첩된 형식)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1794">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="94b23-1795">이 메서드는 현재 형식의 중첩 된 형식만 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1795">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="94b23-1796">현재 형식의 기본 클래스를 검색 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1796">It does not search the base classes of the current type.</span></span> <span data-ttu-id="94b23-1797">기본 클래스에서 중첩 된 형식을 찾으려고 호출 상속 계층 구조를 검색 해야 <xref:System.Type.GetNestedType%2A> 각 수준에서.</span><span class="sxs-lookup"><span data-stu-id="94b23-1797">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="94b23-1798"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1798"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="94b23-1799">이 메서드를 호출할 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 플래그 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 플래그 지정 된 중첩 된 형식과 다른 플래그는 필요 하지 않습니다 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1799">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="94b23-1800">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1800">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1801">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1801">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="94b23-1802">중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1802">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="94b23-1803">바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1803">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1804">하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1804">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="94b23-1805">이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1805">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="94b23-1806">중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1806">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1807">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1807">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1808">현재 <see cref="T:System.Type" />에 중첩된 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1808">Gets the types nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1809">현재 <see cref="T:System.Type" />에 중첩된 public 형식을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1809">Returns the public types nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1810">현재 <see cref="T:System.Type" />에 중첩된 public 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나(검색은 재귀적이 아님), 현재 <see cref="T:System.Type" />에 중첩된 public 형식이 없으면 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1810">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1811"><xref:System.Type.GetNestedTypes%2A> 메서드 반환 하지 않습니다 형식을 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1811">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1812">코드 영향을 받지 않아야 형식이 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1812">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1813">즉시 현재 형식에 중첩 된 public 형식만 반환 됩니다. 검색은 재귀적이 아님.</span><span class="sxs-lookup"><span data-stu-id="94b23-1813">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="94b23-1814">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1814">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1815">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1815">Member Type</span></span>|<span data-ttu-id="94b23-1816">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1816">Static</span></span>|<span data-ttu-id="94b23-1817">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1817">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1818">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1818">Constructor</span></span>|<span data-ttu-id="94b23-1819">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1819">No</span></span>|<span data-ttu-id="94b23-1820">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1820">No</span></span>|  
|<span data-ttu-id="94b23-1821">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1821">Field</span></span>|<span data-ttu-id="94b23-1822">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1822">No</span></span>|<span data-ttu-id="94b23-1823">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1823">Yes.</span></span> <span data-ttu-id="94b23-1824">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1824">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1825">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1825">Event</span></span>|<span data-ttu-id="94b23-1826">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1826">Not applicable</span></span>|<span data-ttu-id="94b23-1827">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1827">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1828">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1828">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1829">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1829">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1830">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1830">Method</span></span>|<span data-ttu-id="94b23-1831">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1831">No</span></span>|<span data-ttu-id="94b23-1832">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1832">Yes.</span></span> <span data-ttu-id="94b23-1833">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1833">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1834">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1834">Nested Type</span></span>|<span data-ttu-id="94b23-1835">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1835">No</span></span>|<span data-ttu-id="94b23-1836">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1836">No</span></span>|  
|<span data-ttu-id="94b23-1837">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1837">Property</span></span>|<span data-ttu-id="94b23-1838">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1838">Not applicable</span></span>|<span data-ttu-id="94b23-1839">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1839">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1840">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1840">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1841">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1841">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1842">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1842">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1843">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1843">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1844">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1844">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1845">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1845">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1846">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1846">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1847">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1847">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="94b23-1848">중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1848">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="94b23-1849">바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1849">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1850">하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1850">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="94b23-1851">이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1851">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="94b23-1852">중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1852">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1853">다음 예제에서는 중첩 된 클래스를 정의 및 `struct` 에 `MyClass`, 다음 형식을 사용 하는 중첩 형식의 개체를 가져옵니다 `MyClass`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1853">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1854">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1854">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1855">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1855">-or-</span>
          </span>
          <span data-ttu-id="94b23-1856">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1856">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1857">파생 클래스에서 재정의되면 지정된 바인딩 제약 조건을 사용하여 현재 <see cref="T:System.Type" />에 중첩된 형식을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1857">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1858">지정된 바인딩 제약 조건과 일치하는 현재 <see cref="T:System.Type" />에 중첩된 모든 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나(검색은 재귀적이 아님), 바인딩 제약 조건과 일치하는 중첩 형식이 없으면 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1858">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1859">중첩 된 형식에 대 한 검색은 재귀적이 아님.</span><span class="sxs-lookup"><span data-stu-id="94b23-1859">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="94b23-1860"><xref:System.Type.GetNestedTypes%2A> 메서드 반환 하지 않습니다 형식을 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1860">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1861">코드 영향을 받지 않아야 형식이 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1861">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1862">다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식 필터 플래그를 사용 하는 중첩 된 정의 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1862">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1863">중 하나를 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 반환을 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1863">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1864">지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> public 중첩된 형식을 검색에 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1864">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1865">지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 중첩된 형식 (즉, 전용, 내부 및 보호 된 중첩된 형식)를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1865">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="94b23-1866">이 메서드는 현재 형식의 중첩 된 형식만 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1866">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="94b23-1867">현재 형식의 기본 클래스를 검색 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1867">It does not search the base classes of the current type.</span></span> <span data-ttu-id="94b23-1868">기본 클래스에서 중첩 된 형식을 찾으려고 호출 상속 계층 구조를 검색 해야 <xref:System.Type.GetNestedTypes%2A> 각 수준에서.</span><span class="sxs-lookup"><span data-stu-id="94b23-1868">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="94b23-1869"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1869"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="94b23-1870">이 메서드를 호출할 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 플래그 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 플래그 지정 된 중첩 된 형식과 다른 플래그는 필요 하지 않습니다 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1870">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="94b23-1871">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1871">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1872">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1872">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="94b23-1873">중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1873">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="94b23-1874">바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1874">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-1875">하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1875">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="94b23-1876">이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1876">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="94b23-1877">중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1877">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1878">다음 예제에서는 두 중첩 된 공용 클래스 및 두 개의 중첩 된 보호 된 클래스를 만들고 지정 된 바인딩 제약 조건과 일치 하는 클래스에 대 한 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1878">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1879">현재 <see cref="T:System.Type" />의 속성을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1879">Gets the properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1880">현재 <see cref="T:System.Type" />의 모든 public 속성을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1880">Returns all the public properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1881">현재 <see cref="T:System.Reflection.PropertyInfo" />의 모든 public 속성을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1881">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="94b23-1882">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1882">-or-</span>
          </span>
          <span data-ttu-id="94b23-1883">현재 <see cref="T:System.Reflection.PropertyInfo" />에 public 속성이 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1883">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1884">이 오버 로드는 호출에 해당 하는 <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> 오버 로드를 `bindingAttr` 같음 인수 `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` C# 및 `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1884">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="94b23-1885">모든 공용 인스턴스 및 정적 속성을 현재 형식에 의해 정의 된 두 반환 <xref:System.Type> 개체 뿐만 아니라 해당 기본 형식에서 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1885">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="94b23-1886">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1886">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-1887">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1887">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-1888"><xref:System.Type.GetProperties%2A> 메서드 반환 하지 않습니다 속성을 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1888">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1889">코드 영향을 받지 않아야 속성 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1889">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1890">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-1890">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-1891">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1891">Member Type</span></span>|<span data-ttu-id="94b23-1892">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-1892">Static</span></span>|<span data-ttu-id="94b23-1893">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-1893">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-1894">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-1894">Constructor</span></span>|<span data-ttu-id="94b23-1895">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1895">No</span></span>|<span data-ttu-id="94b23-1896">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1896">No</span></span>|  
|<span data-ttu-id="94b23-1897">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-1897">Field</span></span>|<span data-ttu-id="94b23-1898">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1898">No</span></span>|<span data-ttu-id="94b23-1899">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1899">Yes.</span></span> <span data-ttu-id="94b23-1900">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1900">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1901">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-1901">Event</span></span>|<span data-ttu-id="94b23-1902">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1902">Not applicable</span></span>|<span data-ttu-id="94b23-1903">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1903">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1904">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1904">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1905">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1905">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-1906">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-1906">Method</span></span>|<span data-ttu-id="94b23-1907">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1907">No</span></span>|<span data-ttu-id="94b23-1908">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-1908">Yes.</span></span> <span data-ttu-id="94b23-1909">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1909">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-1910">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-1910">Nested Type</span></span>|<span data-ttu-id="94b23-1911">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1911">No</span></span>|<span data-ttu-id="94b23-1912">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-1912">No</span></span>|  
|<span data-ttu-id="94b23-1913">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1913">Property</span></span>|<span data-ttu-id="94b23-1914">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-1914">Not applicable</span></span>|<span data-ttu-id="94b23-1915">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1915">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-1916">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1916">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1917">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1917">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-1918">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1918">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-1919">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1919">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-1920">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1920">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-1921">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1921">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-1922">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1922">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-1923">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1923">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1924">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1924">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1925">다음 예제에서는 `GetProperties` 메서드를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1925">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1926">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1926">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1927">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1927">-or-</span>
          </span>
          <span data-ttu-id="94b23-1928">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1928">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1929">파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />의 속성을 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1929">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1930">현재 <see cref="T:System.Reflection.PropertyInfo" />의 속성 중 지정된 바인딩 제약 조건과 일치하는 모든 속성을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1930">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="94b23-1931">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1931">-or-</span>
          </span>
          <span data-ttu-id="94b23-1932">현재 <see cref="T:System.Reflection.PropertyInfo" />에 속성이 없거나 해당 바인딩 제약 조건과 일치하는 속성이 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1932">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1933">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1933">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-1934">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1934">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-1935"><xref:System.Type.GetProperties%2A> 메서드 반환 하지 않습니다 속성을 특정 순서로 같은 알파벳 또는 선언 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1935">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="94b23-1936">코드 영향을 받지 않아야 속성 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1936">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="94b23-1937">다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식 필터 플래그를 사용 하는 중첩 된 정의 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1937">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1938">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1938">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1939">지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1939">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1940">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1940">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="94b23-1941">만 보호 하 고 기본 클래스의 내부 속성이 반환 됩니다. 기본 클래스에서 private 속성 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1941">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="94b23-1942">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1942">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1943">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1943">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1944">`BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1944">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1945">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1945">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-1946">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1946">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-1947">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1947">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-1948">이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1948">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1949">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1949">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1950">라는 클래스를 정의 하는 다음 예제에서는 `PropertyClass` 6 개의 속성을 포함 하는: 두는 공용, 개인 것, 보호 되는 하나, 하나는 내부 (`Friend` Visual basic에서), 내부 보호 되며 하나 (`Protected Friend` Visual Basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1950">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="94b23-1951">일부 기본 속성 정보를 표시 합니다 (속성 이름 및 형식을 읽기/쓰기가 가능 하며의 표시 여부는 해당 여부를 해당 `get` 및 `set` 접근자) 지정 된 바인딩 제약 조건과 일치 하는 속성에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1951">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-1952">현재 <see cref="T:System.Type" />의 특정 속성을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1952">Gets a specific property of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1953">가져올 공용 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1953">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1954">지정된 이름의 public 속성을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1954">Searches for the public property with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1955">지정된 이름의 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1955">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1956">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1956">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-1957">검색 public static 및 public 인스턴스 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1957">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="94b23-1958">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1958">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-1959">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1959">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-1960">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1960">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-1961">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1961">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="94b23-1962">있는 경우 <xref:System.Reflection.AmbiguousMatchException> 발생은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1962">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="94b23-1963">형식에는 두 개의 동일한 인덱싱된 속성 이름을 다른 개수의 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1963">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="94b23-1964">모호성을 해결할 수의 오버 로드를 사용 합니다 <xref:System.Type.GetProperty%2A> 매개 변수 형식을 지정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1964">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="94b23-1965">파생된 된 형식을 사용 하 여 동일한 이름의 상속된 된 속성을 숨기는 속성을 선언 합니다 `new` 한정자 (`Shadows` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-1965">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="94b23-1966">모호성을 해결 하려면 사용 합니다 <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> 메서드 오버 로드 하 고 추가 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 상속 되지 않은 멤버에 검색을 제한 하는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1966">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="94b23-1967">인덱서 및 기본 속성</span><span class="sxs-lookup"><span data-stu-id="94b23-1967">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="94b23-1968">하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1968">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="94b23-1969">예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1969">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="94b23-1970">속성을 오버 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1970">You can overload the property.</span></span>  
  
 <span data-ttu-id="94b23-1971">C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1971">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="94b23-1972">기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1972">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="94b23-1973">그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1973">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="94b23-1974">예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1974">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="94b23-1975">C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1975">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="94b23-1976">형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="94b23-1976">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="94b23-1977">형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1977">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-1978">다음 예제에서는 검색 된 `Type` 사용자 정의 클래스의 개체 클래스의 속성을 검색 하 고 속성 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1978">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="94b23-1979">내부적으로이 속성은 참조 메타 데이터에서 이름이 "항목"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1979">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="94b23-1980">가져오려면 `PropertyInfo` 리플렉션을 사용 하 여 올바르게 반환 하기 위해이 내부 이름을 지정 해야 합니다는 `PropertyInfo` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1980">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-1981">지정한 이름을 가진 속성이 둘 이상 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1981">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-1982">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1982">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-1983">가져올 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1983">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-1984">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1984">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-1985">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1985">-or-</span>
          </span>
          <span data-ttu-id="94b23-1986">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1986">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-1987">지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1987">Searches for the specified property, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-1988">지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-1988">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-1989">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1989">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-1990">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1990">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-1991">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1991">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-1992">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1992">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-1993">지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1993">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1994">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1994">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-1995">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1995">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-1996">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1996">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-1997">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1997">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-1998">`BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-1998">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-1999">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-1999">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-2000">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2000">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-2001">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2001">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="94b23-2002">있는 경우 <xref:System.Reflection.AmbiguousMatchException> 발생은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2002">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="94b23-2003">형식에는 두 개의 동일한 인덱싱된 속성 이름을 다른 개수의 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2003">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="94b23-2004">모호성을 해결할 수의 오버 로드를 사용 합니다 <xref:System.Type.GetProperty%2A> 매개 변수 형식을 지정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2004">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="94b23-2005">파생된 형식 선언에 동일한 이름의 상속된 된 속성을 숨기는 속성을 사용 하 여는 `new` 한정자 (`Shadows` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-2005">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="94b23-2006">모호성을 해결 하려면 포함 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 상속 되지 않은 멤버에 검색을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2006">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="94b23-2007">인덱서 및 기본 속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2007">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="94b23-2008">하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2008">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="94b23-2009">예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2009">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="94b23-2010">속성을 오버 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2010">You can overload the property.</span></span>  
  
 <span data-ttu-id="94b23-2011">C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2011">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="94b23-2012">기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2012">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="94b23-2013">그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2013">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="94b23-2014">예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2014">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="94b23-2015">C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2015">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="94b23-2016">형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="94b23-2016">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="94b23-2017">형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2017">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-2018">다음 예제에서는 사용자 정의 클래스의 형식을 검색, 해당 클래스의 속성을 검색 및 지정 된 바인딩 제약 조건에 따라 속성 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2018">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-2019">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2019">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2020">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2020">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-2021">가져올 공용 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2021">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="94b23-2022">속성의 반환 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2022">The return type of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2023">지정된 이름과 반환 형식의 public 속성을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2023">Searches for the public property with the specified name and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2024">지정된 이름의 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2024">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2025">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2025">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-2026">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2026">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-2027">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2027">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-2028">검색 public static 및 public 인스턴스 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2028">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="94b23-2029">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2029">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-2030">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2030">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="94b23-2031">인덱서 및 기본 속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2031">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="94b23-2032">하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2032">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="94b23-2033">예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2033">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="94b23-2034">속성을 오버 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2034">You can overload the property.</span></span>  
  
 <span data-ttu-id="94b23-2035">C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2035">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="94b23-2036">기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2036">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="94b23-2037">그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2037">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="94b23-2038">예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2038">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="94b23-2039">C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2039">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="94b23-2040">형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="94b23-2040">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="94b23-2041">형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2041">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-2042">다음 예제에서는 하나의 속성이 있는 클래스를 정의 및 이름 및 형식의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2042">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-2043">지정한 이름을 가진 속성이 둘 이상 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2043">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2044">
            <paramref name="name" />이 <see langword="null" />이거나 <paramref name="returnType" />이 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2044">
              <paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-2045">가져올 공용 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2045">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-2046">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2046">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="94b23-2047">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2047">-or-</span>
          </span>
          <span data-ttu-id="94b23-2048">인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2048">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2049">지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2049">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2050">지정된 인수 형식과 일치하는 매개 변수를 가진 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2050">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2051">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2051">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-2052">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2052">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-2053">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2053">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-2054">검색 public static 및 public 인스턴스 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2054">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="94b23-2055">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2055">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-2056">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2056">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="94b23-2057">인덱서 및 기본 속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2057">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="94b23-2058">하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2058">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="94b23-2059">예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2059">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="94b23-2060">속성을 오버 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2060">You can overload the property.</span></span>  
  
 <span data-ttu-id="94b23-2061">C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2061">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="94b23-2062">기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2062">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="94b23-2063">그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2063">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="94b23-2064">예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2064">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="94b23-2065">C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2065">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="94b23-2066">형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="94b23-2066">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="94b23-2067">형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2067">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-2068">다음 예제에서는 검색 된 `Type` 사용자 정의 클래스의 개체 클래스의 속성을 검색 하 고 속성 이름 및 속성의 형식에 전달 된 인수에 지정 된 대로 표시 `GetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2068">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-2069">지정한 이름을 가지며 지정된 인수 형식과 일치하는 속성이 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2069">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2070">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2070">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2071">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2071">-or-</span>
          </span>
          <span data-ttu-id="94b23-2072">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2072">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2073">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2073">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="94b23-2074">
            <paramref name="types" />의 요소가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2074">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-2075">가져올 공용 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2075">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="94b23-2076">속성의 반환 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2076">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-2077">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2077">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="94b23-2078">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2078">-or-</span>
          </span>
          <span data-ttu-id="94b23-2079">인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2079">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2080">지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2080">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2081">지정된 인수 형식과 일치하는 매개 변수를 가진 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2081">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2082">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2082">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-2083">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2083">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-2084">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2084">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-2085">검색 public static 및 public 인스턴스 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2085">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="94b23-2086">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2086">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-2087">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2087">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="94b23-2088">인덱서 및 기본 속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2088">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="94b23-2089">하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2089">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="94b23-2090">예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2090">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="94b23-2091">속성을 오버 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2091">You can overload the property.</span></span>  
  
 <span data-ttu-id="94b23-2092">C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2092">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="94b23-2093">기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2093">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="94b23-2094">그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2094">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="94b23-2095">예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2095">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="94b23-2096">C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2096">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="94b23-2097">형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="94b23-2097">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="94b23-2098">형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2098">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-2099">지정한 이름을 가지며 지정된 인수 형식과 일치하는 속성이 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2099">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2100">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2100">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2101">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2101">-or-</span>
          </span>
          <span data-ttu-id="94b23-2102">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2102">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2103">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2103">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="94b23-2104">
            <paramref name="types" />의 요소가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2104">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-2105">가져올 공용 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2105">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="94b23-2106">속성의 반환 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2106">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-2107">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2107">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="94b23-2108">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2108">-or-</span>
          </span>
          <span data-ttu-id="94b23-2109">인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2109">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-2110">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2110">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-2111">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2111">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2112">지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2112">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2113">지정된 요구 사항과 일치하는 public 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2113">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2114">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2114">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-2115">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2115">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-2116">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2116">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-2117">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2117">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-2118">검색 `name` 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2118">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="94b23-2119">검색 public static 및 public 인스턴스 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2119">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="94b23-2120">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2120">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-2121">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2121">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="94b23-2122">인덱서 및 기본 속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2122">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="94b23-2123">하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2123">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="94b23-2124">예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2124">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="94b23-2125">속성을 오버 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2125">You can overload the property.</span></span>  
  
 <span data-ttu-id="94b23-2126">C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2126">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="94b23-2127">기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2127">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="94b23-2128">그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2128">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="94b23-2129">예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2129">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="94b23-2130">C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2130">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="94b23-2131">형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="94b23-2131">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="94b23-2132">형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2132">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-2133">다음 예에서는 `Type` 개체에 해당 하 `MyPropertyClass`, 전달 되는 인수를 사용 하 여이 클래스의 인덱싱된 속성을 검색 하는 및를 `GetProperty` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-2133">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-2134">지정한 이름을 가지며 지정된 인수 형식 및 수정자와 일치하는 속성이 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2134">More than one property is found with the specified name and matching the specified argument types and modifiers.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2135">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2135">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2136">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2136">-or-</span>
          </span>
          <span data-ttu-id="94b23-2137">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2137">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2138">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2138">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-2139">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2139">-or-</span>
          </span>
          <span data-ttu-id="94b23-2140">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2140">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-2141">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2141">-or-</span>
          </span>
          <span data-ttu-id="94b23-2142">
            <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2142">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="94b23-2143">
            <paramref name="types" />의 요소가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2143">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-2144">가져올 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2144">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-2145">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2145">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-2146">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2146">-or-</span>
          </span>
          <span data-ttu-id="94b23-2147">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2147">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-2148">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2148">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-2149">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2149">-or-</span>
          </span>
          <span data-ttu-id="94b23-2150">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2150">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="94b23-2151">속성의 반환 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2151">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-2152">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2152">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="94b23-2153">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2153">-or-</span>
          </span>
          <span data-ttu-id="94b23-2154">인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2154">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-2155">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2155">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-2156">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2156">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2157">지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2157">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2158">지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2158">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2159">속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2159">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="94b23-2160">그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2160">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="94b23-2161">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2161">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-2162">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2162">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-2163">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2163">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-2164">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2164">Member Type</span></span>|<span data-ttu-id="94b23-2165">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-2165">Static</span></span>|<span data-ttu-id="94b23-2166">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-2166">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-2167">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-2167">Constructor</span></span>|<span data-ttu-id="94b23-2168">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2168">No</span></span>|<span data-ttu-id="94b23-2169">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2169">No</span></span>|  
|<span data-ttu-id="94b23-2170">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-2170">Field</span></span>|<span data-ttu-id="94b23-2171">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2171">No</span></span>|<span data-ttu-id="94b23-2172">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2172">Yes.</span></span> <span data-ttu-id="94b23-2173">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2173">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2174">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-2174">Event</span></span>|<span data-ttu-id="94b23-2175">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2175">Not applicable</span></span>|<span data-ttu-id="94b23-2176">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2176">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2177">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2177">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2178">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2178">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-2179">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-2179">Method</span></span>|<span data-ttu-id="94b23-2180">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2180">No</span></span>|<span data-ttu-id="94b23-2181">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2181">Yes.</span></span> <span data-ttu-id="94b23-2182">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2182">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2183">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2183">Nested Type</span></span>|<span data-ttu-id="94b23-2184">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2184">No</span></span>|<span data-ttu-id="94b23-2185">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2185">No</span></span>|  
|<span data-ttu-id="94b23-2186">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2186">Property</span></span>|<span data-ttu-id="94b23-2187">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2187">Not applicable</span></span>|<span data-ttu-id="94b23-2188">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2188">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2189">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2189">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2190">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2190">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-2191">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2191">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-2192">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2192">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-2193">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2193">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2194">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2194">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-2195">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2195">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-2196">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2196">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-2197">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2197">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-2198">지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2198">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="94b23-2199">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2199">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-2200">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2200">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-2201">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2201">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-2202">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2202">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-2203">`BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2203">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-2204">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2204">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-2205">하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2205">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="94b23-2206">하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2206">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="94b23-2207">인덱서 및 기본 속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2207">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="94b23-2208">하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2208">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="94b23-2209">예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2209">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="94b23-2210">속성을 오버 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2210">You can overload the property.</span></span>  
  
 <span data-ttu-id="94b23-2211">C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2211">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="94b23-2212">기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2212">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="94b23-2213">그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2213">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="94b23-2214">예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2214">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="94b23-2215">C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2215">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="94b23-2216">형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성.</span><span class="sxs-lookup"><span data-stu-id="94b23-2216">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="94b23-2217">형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2217">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-2218">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2218">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2219">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2219">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2220">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2220">-or-</span>
          </span>
          <span data-ttu-id="94b23-2221">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2221">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2222">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2222">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-2223">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2223">-or-</span>
          </span>
          <span data-ttu-id="94b23-2224">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2224">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-2225">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2225">-or-</span>
          </span>
          <span data-ttu-id="94b23-2226">
            <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2226">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="94b23-2227">
            <paramref name="types" />의 요소가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2227">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-2228">가져올 속성의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2228">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="94b23-2229">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2229">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-2230">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2230">-or-</span>
          </span>
          <span data-ttu-id="94b23-2231">0(<see langword="null" />을 반환하는 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2231">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-2232">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 멤버를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2232">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-2233">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2233">-or-</span>
          </span>
          <span data-ttu-id="94b23-2234">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2234">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="94b23-2235">속성의 반환 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2235">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="94b23-2236">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2236">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="94b23-2237">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2237">-or-</span>
          </span>
          <span data-ttu-id="94b23-2238">인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2238">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-2239">
            <c>types</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2239">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="94b23-2240">기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2240">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2241">파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2241">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2242">지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2242">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2243">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2243">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="94b23-2244">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2244">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-2245">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2245">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-2246">중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2246">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="94b23-2247">지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2247">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="94b23-2248">지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2248">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-2249">지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2249">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="94b23-2250">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2250">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-2251">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2251">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-2252">`BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2252">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-2253">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2253">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-2254">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2254">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2255">
            <paramref name="name" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2255">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2256">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2256">-or-</span>
          </span>
          <span data-ttu-id="94b23-2257">
            <paramref name="types" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2257">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2258">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2258">-or-</span>
          </span>
          <span data-ttu-id="94b23-2259">
            <paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2259">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2260">
            <paramref name="types" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2260">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-2261">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2261">-or-</span>
          </span>
          <span data-ttu-id="94b23-2262">
            <paramref name="modifiers" />가 다차원 배열인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2262">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="94b23-2263">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2263">-or-</span>
          </span>
          <span data-ttu-id="94b23-2264">
            <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2264">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-2265">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2265">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-2266">지정된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2266">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-2267">현재 <see cref="T:System.Type" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2267">Gets the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2268">현재 <see cref="T:System.Type" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2268">The current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-2269">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2269">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-2270">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2270">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="94b23-2271">가져올 형식에 대한 어셈블리로 한정된 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2271">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="94b23-2272">
            <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2272">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="94b23-2273">형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2273">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2274">대/소문자 구분 검색하여 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2274">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2275">지정된 이름의 형식이 있으면 이를 반환하고 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2275">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2276">사용할 수는 <xref:System.Type.GetType%2A> 메서드를 <xref:System.Type> 에서 가져올 수 있는 해당 어셈블리의 정규화 된 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체 <xref:System.Type.AssemblyQualifiedName>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2276">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="94b23-2277"><xref:System.Type.GetType%2A> 에 지정 된 어셈블리를 로드 하면 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2277"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="94b23-2278">사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 합니다 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드를 <xref:System.Reflection.Assembly> 클래스를 <xref:System.Type> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2278">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="94b23-2279">형식을 프로그램에 컴파일 타임에 알려진 어셈블리의 경우 것이 보다 효율적으로 C#에서 사용할 <xref:System.Type.GetType%2A> c + + 또는 Visual basic의 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2279">If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2280">하는 경우 `typeName` 찾을 수 없는 호출 합니다 <xref:System.Type.GetType%28System.String%29> 메서드가 반환 되는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2280">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="94b23-2281">예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2281">It does not throw an exception.</span></span> <span data-ttu-id="94b23-2282">제어할 수 있는지 여부는 예외가 발생의 오버 로드를 호출 합니다 <xref:System.Type.GetType%2A> 있는 메서드를 `throwOnError` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2282">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="94b23-2283"><xref:System.Type.GetType%2A> 디스크에서 로드 된 어셈블리 에서만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2283"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="94b23-2284">호출 하는 경우 <xref:System.Type.GetType%2A> 정의 사용 하 여 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스에 일관 되지 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2284">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="94b23-2285">동작을 동적 어셈블리 인지 영구적 이므로, 즉, 사용 하 여 만든 합니다 `RunAndSave` 또는 `Save` 모드 액세스는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2285">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="94b23-2286">동적 어셈블리를 지속적이 고 먼저 디스크에 쓴 경우 `GetType` 는 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2286">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="94b23-2287">어셈블리 경우 디스크에 저장 되지 않은 경우 `GetType` 가 호출 메서드는 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2287">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="94b23-2288">`GetType` 임시 동적 어셈블리를 인식 하지 못합니다 따라서 호출 `GetType` 일시적인에서 형식을 검색 하려면 동적 어셈블리는 다음과 같이 반환 됩니다. `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2288">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="94b23-2289">사용 하도록 `GetType` 구독할 동적 모듈의 경우에 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2289">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="94b23-2290">이 고, 그렇지 메모리에 어셈블리의 두 복사본을 가져오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2290">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="94b23-2291">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2291">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-2292">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2292">Member Type</span></span>|<span data-ttu-id="94b23-2293">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-2293">Static</span></span>|<span data-ttu-id="94b23-2294">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-2294">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-2295">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-2295">Constructor</span></span>|<span data-ttu-id="94b23-2296">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2296">No</span></span>|<span data-ttu-id="94b23-2297">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2297">No</span></span>|  
|<span data-ttu-id="94b23-2298">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-2298">Field</span></span>|<span data-ttu-id="94b23-2299">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2299">No</span></span>|<span data-ttu-id="94b23-2300">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2300">Yes.</span></span> <span data-ttu-id="94b23-2301">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2301">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2302">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-2302">Event</span></span>|<span data-ttu-id="94b23-2303">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2303">Not applicable</span></span>|<span data-ttu-id="94b23-2304">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2304">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2305">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2305">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2306">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2306">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-2307">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-2307">Method</span></span>|<span data-ttu-id="94b23-2308">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2308">No</span></span>|<span data-ttu-id="94b23-2309">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2309">Yes.</span></span> <span data-ttu-id="94b23-2310">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2310">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2311">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2311">Nested Type</span></span>|<span data-ttu-id="94b23-2312">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2312">No</span></span>|<span data-ttu-id="94b23-2313">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2313">No</span></span>|  
|<span data-ttu-id="94b23-2314">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2314">Property</span></span>|<span data-ttu-id="94b23-2315">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2315">Not applicable</span></span>|<span data-ttu-id="94b23-2316">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2316">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2317">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2317">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2318">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2318">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-2319">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2319">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-2320">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2320">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-2321">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2321">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2322">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2322">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-2323">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2323">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-2324">배열 또는 COM 형식을 검색할 수 없습니다는 이미 사용할 수 있는 클래스의 테이블에 로드 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2324">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="94b23-2325">`typeName` 수 형식 이름으로 한정 되어야 해당 네임 스페이스 또는 어셈블리 이름 사양에 포함 된 어셈블리의 정규화 된 이름.</span><span class="sxs-lookup"><span data-stu-id="94b23-2325">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="94b23-2326"><xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2326">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="94b23-2327">경우 `typeName` 네임 스페이스만 어셈블리 이름이 아니라 포함이 메서드를 호출 하는 개체의 어셈블리 및 Mscorlib.dll만 순서 대로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2327">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="94b23-2328">TypeName 부분 또는 전체 어셈블리 이름의 정규화 된 경우이 메서드는 지정된 된 어셈블리에서 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2328">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="94b23-2329">어셈블리에 강력한 이름이 있으면 전체 어셈블리 이름은 필수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2329">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="94b23-2330"><xref:System.Type.AssemblyQualifiedName%2A> 속성에는 중첩 된 형식, 어셈블리 이름 및 제네릭 형식 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2330">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="94b23-2331">공용 언어 런타임에서 지 원하는 모든 컴파일러 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2331">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2332">.NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2332">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="94b23-2333">예를 들어, "ProcessorArchitecture = msil"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2333">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="94b23-2334">그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2334">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="94b23-2335">형식을 만들어 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-2335">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="94b23-2336">사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2336">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="94b23-2337"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="94b23-2337">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="94b23-2338">구분 기호</span><span class="sxs-lookup"><span data-stu-id="94b23-2338">Delimiter</span></span>|<span data-ttu-id="94b23-2339">의미</span><span class="sxs-lookup"><span data-stu-id="94b23-2339">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="94b23-2340">백슬래시(\\)</span><span class="sxs-lookup"><span data-stu-id="94b23-2340">Backslash (\\)</span></span>|<span data-ttu-id="94b23-2341">이스케이프 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2341">Escape character.</span></span>|  
|<span data-ttu-id="94b23-2342">억음 악센트 기호 (')</span><span class="sxs-lookup"><span data-stu-id="94b23-2342">Backtick (\`)</span></span>|<span data-ttu-id="94b23-2343">형식 매개 변수를 제네릭 형식 이름의 끝에 있는 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2343">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="94b23-2344">대괄호 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-2344">Brackets ([])</span></span>|<span data-ttu-id="94b23-2345">생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록을 내는 어셈블리의 정규화 된 유형을 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2345">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="94b23-2346">쉼표 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-2346">Comma (,)</span></span>|<span data-ttu-id="94b23-2347">어셈블리 이름을 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2347">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="94b23-2348">마침표 (입니다.)</span><span class="sxs-lookup"><span data-stu-id="94b23-2348">Period (.)</span></span>|<span data-ttu-id="94b23-2349">네임 스페이스 식별자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2349">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="94b23-2350">더하기 기호 (+)</span><span class="sxs-lookup"><span data-stu-id="94b23-2350">Plus sign (+)</span></span>|<span data-ttu-id="94b23-2351">중첩된 된 클래스 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2351">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="94b23-2352">예를 들어, 클래스에 대 한 정규화 된 이름을이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2352">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="94b23-2353">네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 더하기 기호 (+) 이스케이프 문자를 사용 해야 합니다. (\\) 중첩 구분 기호로 해석 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2353">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="94b23-2354">리플렉션 다음과 같이이 문자열을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2354">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="94b23-2355">"+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2355">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="94b23-2356">이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2356">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="94b23-2357">찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2357">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="94b23-2358"><xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서.</span><span class="sxs-lookup"><span data-stu-id="94b23-2358"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="94b23-2359"><xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2359"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="94b23-2360">형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2360">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="94b23-2361">형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2361">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="94b23-2362">공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2362">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="94b23-2363">어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2363">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="94b23-2364">제네릭 형식의 이름을 억음 악센트 기호 끝납니다 (\`), 제네릭 형식 인수 개수를 나타내는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2364">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="94b23-2365">이 이름 꾸미기의 목적은 컴파일러에서 제네릭 형식을 지원 형식 매개 변수 수가 다른 하지만 같은 이름의 동일한 범위에서 발생 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2365">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="94b23-2366">리플렉션 바뀐된 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 하 고 `Tuple(Of T0, T1)` Visual basic의 경우 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#.</span><span class="sxs-lookup"><span data-stu-id="94b23-2366">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="94b23-2367">제네릭 형식의 형식 인수 목록을 괄호로 묶고 형식 인수는 쉼표로 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2367">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="94b23-2368">예를 들어 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2368">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="94b23-2369">A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 <xref:System.String> 다음과 같이 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2369">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="94b23-2370">형식 인수 목록에는 어셈블리의 정규화 된 형식을 지정 하려면 어셈블리의 정규화 된 형식을 대괄호로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2370">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="94b23-2371">이 고, 그렇지 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표는 추가 형식 인수를 구분 기호로 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2371">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="94b23-2372">예를 들어를 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 fromMyAssembly.dll <xref:System.String>를 다음과 같이 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2372">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2373">형식 매개 변수 목록에 표시 되는 경우에 어셈블리의 정규화 된 형식에는 대괄호로 묶을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2373">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="94b23-2374">형식 매개 변수 목록에서 어셈블리 정규화 형식에 대 한 검색에 대 한 규칙을 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2374">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="94b23-2375">Nullable 형식은 제네릭 형식의 특수 한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2375">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="94b23-2376">예를 들어, null 허용 <xref:System.Int32> "System.Nullable'1[System.Int32]" 문자열에 의해 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2376">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2377">C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2377">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="94b23-2378">예를 들어, null 허용 <xref:System.Boolean> 형식을 반환한 `typeof(Nullable<bool>)` C#으로 하 여 `Nullable<Boolean>::typeid` c + +에서 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2378">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="94b23-2379">다음 표에서 사용 하 여 사용 하는 구문을 `GetType` 다양 한 형식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2379">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="94b23-2380">가져오려는</span><span class="sxs-lookup"><span data-stu-id="94b23-2380">To Get</span></span>|<span data-ttu-id="94b23-2381">사용</span><span class="sxs-lookup"><span data-stu-id="94b23-2381">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="94b23-2382">Null 허용 <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="94b23-2382">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="94b23-2383">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2383">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="94b23-2384">에 대 한 관리 되지 않는 포인터입니다. `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2384">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="94b23-2385">에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2385">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="94b23-2386">관리 되는 포인터 또는 참조 `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2386">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="94b23-2387">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="94b23-2387">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="94b23-2388">포인터와 달리 참조는 한 수준으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2388">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="94b23-2389">부모 클래스 및 중첩된 클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-2389">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="94b23-2390">하한값으로 0 사용 하 여 1 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2390">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="94b23-2391">알 수 없는 하한값을 사용 하 여 1 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2391">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="94b23-2392">N 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2392">An n-dimensional array</span></span>|<span data-ttu-id="94b23-2393">총 n-1 번 대괄호 안에 쉼표 (,)입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2393">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="94b23-2394">예를 들어 `System.Object[,,]` 나타내는 3 차원 `Object` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2394">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="94b23-2395">1 차원 배열의 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2395">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="94b23-2396">알 수 없는 하위 범위를 사용 하 여 사각형 2 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2396">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="94b23-2397">하나의 형식 인수가 있는 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2397">A generic type with one type argument</span></span>|<span data-ttu-id="94b23-2398">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2398">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="94b23-2399">두 개의 형식 인수를 사용 하 여 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2399">A generic type with two type arguments</span></span>|<span data-ttu-id="94b23-2400">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2400">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="94b23-2401">두 어셈블리의 정규화 된 형식 인수가 있는 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2401">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="94b23-2402">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2402">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="94b23-2403">어셈블리의 정규화 된 형식 인수를 사용 하 여 어셈블리의 정규화 된 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2403">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="94b23-2404">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2404">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="94b23-2405">두 형식 인수가 있는 제네릭 형식인 형식 인수로 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2405">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="94b23-2406">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="94b23-2406">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="94b23-2407">다음 예제에서는 검색 유형을 `System.Int32` 형식 개체를 사용 하 여 표시 하 고는 <xref:System.Type.FullName%2A> 의 속성 `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="94b23-2407">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2408">
            <paramref name="typeName" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2408">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-2409">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2409">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2410">
            <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2410">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2411">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2411">-or-</span>
          </span>
          <span data-ttu-id="94b23-2412">
            <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2412">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2413">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2413">-or-</span>
          </span>
          <span data-ttu-id="94b23-2414">
            <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2414">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-2415">
            <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2415">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="94b23-2416">
                <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.</span>
              <span class="sxs-lookup">
                <span data-stu-id="94b23-2416">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="94b23-2417">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2417">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="94b23-2418">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2418">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="94b23-2419">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2419">-or-</span>
          </span>
          <span data-ttu-id="94b23-2420">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2420">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-2421">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2421">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="94b23-2422">가져올 형식에 대한 어셈블리로 한정된 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2422">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="94b23-2423">
            <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2423">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="94b23-2424">형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2424">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-2425">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2425">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2426">또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2426">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="94b23-2427">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2427">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2428">대/소문자를 구분하여 검색하고 형식이 없으면 예외를 throw할지를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2428">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2429">지정된 이름의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2429">The type with the specified name.</span>
          </span>
          <span data-ttu-id="94b23-2430">형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2430">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="94b23-2431">경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2431">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="94b23-2432">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2432">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2433">사용할 수는 <xref:System.Type.GetType%2A> 메서드를 <xref:System.Type> 에서 가져올 수 있는 해당 어셈블리의 정규화 된 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체 <xref:System.Type.AssemblyQualifiedName>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2433">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="94b23-2434"><xref:System.Type.GetType%2A> 에 지정 된 어셈블리를 로드 하면 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2434"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="94b23-2435">사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 합니다 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드를 <xref:System.Reflection.Assembly> 클래스를 <xref:System.Type> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2435">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="94b23-2436">형식을 프로그램에 컴파일 타임에 알려진 어셈블리의 경우 것이 보다 효율적으로 사용할 `typeof` C# <xref:System.Type.GetType%2A> Visual basic의 경우 또는 `typeid` c + +에서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2436">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="94b23-2437">`GetType` 디스크에서 로드 된 어셈블리 에서만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2437">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="94b23-2438">호출 하는 경우 `GetType` 정의 사용 하 여 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스에 일관 되지 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2438">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="94b23-2439">동작을 동적 어셈블리 인지 영구적 이므로, 즉, 사용 하 여 만든 합니다 `RunAndSave` 또는 `Save` 모드 액세스는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2439">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="94b23-2440">동적 어셈블리를 지속적이 고 먼저 디스크에 쓴 경우 `GetType` 는 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2440">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="94b23-2441">어셈블리 경우 디스크에 저장 되지 않은 경우 `GetType` 가 호출 메서드는 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2441">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="94b23-2442">`GetType` 임시 동적 어셈블리를 인식 하지 못합니다 따라서 호출 `GetType` 일시적인에서 형식을 검색 하려면 동적 어셈블리는 다음과 같이 반환 됩니다. `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2442">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="94b23-2443">사용 하도록 `GetType` 구독할 동적 모듈의 경우에 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2443">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="94b23-2444">이 고, 그렇지 메모리에 어셈블리의 두 복사본을 가져오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2444">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="94b23-2445">`throwOnError` 되나요 유형을 찾을 수 없습니다 하 고 특정 한 다른 예외 조건을 표시 하지 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2445">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="94b23-2446">값에 관계 없이 일부 예외가 throw 됩니다 `throwOnError`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2446">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="94b23-2447">예를 들어 형식을 찾았지만 로드할 수 없습니다는 <xref:System.TypeLoadException> 이 throw 경우에 `throwOnError` 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2447">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="94b23-2448">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2448">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-2449">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2449">Member Type</span></span>|<span data-ttu-id="94b23-2450">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-2450">Static</span></span>|<span data-ttu-id="94b23-2451">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-2451">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-2452">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-2452">Constructor</span></span>|<span data-ttu-id="94b23-2453">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2453">No</span></span>|<span data-ttu-id="94b23-2454">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2454">No</span></span>|  
|<span data-ttu-id="94b23-2455">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-2455">Field</span></span>|<span data-ttu-id="94b23-2456">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2456">No</span></span>|<span data-ttu-id="94b23-2457">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2457">Yes.</span></span> <span data-ttu-id="94b23-2458">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2458">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2459">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-2459">Event</span></span>|<span data-ttu-id="94b23-2460">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2460">Not applicable</span></span>|<span data-ttu-id="94b23-2461">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2461">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2462">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2462">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2463">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2463">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-2464">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-2464">Method</span></span>|<span data-ttu-id="94b23-2465">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2465">No</span></span>|<span data-ttu-id="94b23-2466">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2466">Yes.</span></span> <span data-ttu-id="94b23-2467">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2467">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2468">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2468">Nested Type</span></span>|<span data-ttu-id="94b23-2469">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2469">No</span></span>|<span data-ttu-id="94b23-2470">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2470">No</span></span>|  
|<span data-ttu-id="94b23-2471">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2471">Property</span></span>|<span data-ttu-id="94b23-2472">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2472">Not applicable</span></span>|<span data-ttu-id="94b23-2473">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2473">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2474">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2474">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2475">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2475">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-2476">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2476">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-2477">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2477">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-2478">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2478">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2479">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2479">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-2480">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2480">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-2481">배열 또는 COM 형식을 검색할 수 없습니다는 이미 사용할 수 있는 클래스의 테이블에 로드 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2481">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="94b23-2482">`typeName` 수 형식 이름으로 한정 되어야 해당 네임 스페이스 또는 어셈블리 이름 사양에 포함 된 어셈블리의 정규화 된 이름.</span><span class="sxs-lookup"><span data-stu-id="94b23-2482">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="94b23-2483"><xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2483">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="94b23-2484">경우 `typeName` 네임 스페이스만 어셈블리 이름이 아니라 포함이 메서드를 호출 하는 개체의 어셈블리 및 Mscorlib.dll만 순서 대로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2484">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="94b23-2485">TypeName 부분 또는 전체 어셈블리 이름의 정규화 된 경우이 메서드는 지정된 된 어셈블리에서 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2485">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="94b23-2486">어셈블리에 강력한 이름이 있으면 전체 어셈블리 이름은 필수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2486">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="94b23-2487"><xref:System.Type.AssemblyQualifiedName%2A> 속성에는 중첩 된 형식, 어셈블리 이름 및 제네릭 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2487">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="94b23-2488">공용 언어 런타임에서 지 원하는 모든 컴파일러 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2488">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2489">.NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2489">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="94b23-2490">예를 들어, "ProcessorArchitecture = msil"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2490">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="94b23-2491">그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2491">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="94b23-2492">형식을 만들어 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-2492">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="94b23-2493">사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2493">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="94b23-2494"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="94b23-2494">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="94b23-2495">구분 기호</span><span class="sxs-lookup"><span data-stu-id="94b23-2495">Delimiter</span></span>|<span data-ttu-id="94b23-2496">의미</span><span class="sxs-lookup"><span data-stu-id="94b23-2496">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="94b23-2497">백슬래시(\\)</span><span class="sxs-lookup"><span data-stu-id="94b23-2497">Backslash (\\)</span></span>|<span data-ttu-id="94b23-2498">이스케이프 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2498">Escape character.</span></span>|  
|<span data-ttu-id="94b23-2499">억음 악센트 기호 (')</span><span class="sxs-lookup"><span data-stu-id="94b23-2499">Backtick (\`)</span></span>|<span data-ttu-id="94b23-2500">형식 매개 변수를 제네릭 형식 이름의 끝에 있는 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2500">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="94b23-2501">대괄호 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-2501">Brackets ([])</span></span>|<span data-ttu-id="94b23-2502">생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록을 내는 어셈블리의 정규화 된 유형을 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2502">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="94b23-2503">쉼표 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-2503">Comma (,)</span></span>|<span data-ttu-id="94b23-2504">어셈블리 이름을 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2504">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="94b23-2505">마침표 (입니다.)</span><span class="sxs-lookup"><span data-stu-id="94b23-2505">Period (.)</span></span>|<span data-ttu-id="94b23-2506">네임 스페이스 식별자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2506">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="94b23-2507">더하기 기호 (+)</span><span class="sxs-lookup"><span data-stu-id="94b23-2507">Plus sign (+)</span></span>|<span data-ttu-id="94b23-2508">중첩된 된 클래스 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2508">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="94b23-2509">예를 들어, 클래스에 대 한 정규화 된 이름을이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2509">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="94b23-2510">네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 더하기 기호 (+) 이스케이프 문자를 사용 해야 합니다. (\\) 중첩 구분 기호로 해석 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2510">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="94b23-2511">리플렉션 다음과 같이이 문자열을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2511">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="94b23-2512">"+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2512">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="94b23-2513">이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2513">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="94b23-2514">찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2514">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="94b23-2515"><xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서.</span><span class="sxs-lookup"><span data-stu-id="94b23-2515"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="94b23-2516"><xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2516"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="94b23-2517">형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2517">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="94b23-2518">형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2518">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="94b23-2519">공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2519">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="94b23-2520">어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2520">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="94b23-2521">제네릭 형식의 이름을 억음 악센트 기호 끝납니다 (\`), 제네릭 형식 인수 개수를 나타내는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2521">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="94b23-2522">이 이름 꾸미기의 목적은 컴파일러에서 제네릭 형식을 지원 형식 매개 변수 수가 다른 하지만 같은 이름의 동일한 범위에서 발생 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2522">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="94b23-2523">리플렉션 바뀐된 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 하 고 `Tuple(Of T0, T1)` Visual basic의 경우 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#.</span><span class="sxs-lookup"><span data-stu-id="94b23-2523">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="94b23-2524">제네릭 형식의 형식 인수 목록을 괄호로 묶고 형식 인수는 쉼표로 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2524">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="94b23-2525">예를 들어 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2525">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="94b23-2526">A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 <xref:System.String> 다음과 같이 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2526">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="94b23-2527">형식 인수 목록에는 어셈블리의 정규화 된 형식을 지정 하려면 어셈블리의 정규화 된 형식을 대괄호로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2527">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="94b23-2528">이 고, 그렇지 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표는 추가 형식 인수를 구분 기호로 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2528">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="94b23-2529">예를 들어를 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 MyAssembly.dll에서 <xref:System.String>, 다음과 같이 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2529">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2530">형식 매개 변수 목록에 표시 되는 경우에 어셈블리의 정규화 된 형식에는 대괄호로 묶을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2530">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="94b23-2531">형식 매개 변수 목록에서 어셈블리 정규화 형식에 대 한 검색에 대 한 규칙을 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2531">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="94b23-2532">Nullable 형식은 제네릭 형식의 특수 한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2532">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="94b23-2533">예를 들어, null 허용 <xref:System.Int32> "System.Nullable'1[System.Int32]" 문자열에 의해 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2533">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2534">C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2534">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="94b23-2535">예를 들어, null 허용 <xref:System.Boolean> 형식을 반환한 `typeof(Nullable<bool>)` C#으로 하 여 `Nullable<Boolean>::typeid` c + +에서 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2535">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="94b23-2536">다음 표에서 사용 하 여 사용 하는 구문을 `GetType` 다양 한 형식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2536">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="94b23-2537">가져오려는</span><span class="sxs-lookup"><span data-stu-id="94b23-2537">To Get</span></span>|<span data-ttu-id="94b23-2538">사용</span><span class="sxs-lookup"><span data-stu-id="94b23-2538">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="94b23-2539">Null 허용 <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="94b23-2539">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="94b23-2540">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2540">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="94b23-2541">에 대 한 관리 되지 않는 포인터입니다. `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2541">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="94b23-2542">에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2542">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="94b23-2543">관리 되는 포인터 또는 참조 `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2543">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="94b23-2544">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="94b23-2544">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="94b23-2545">포인터와 달리 참조는 한 수준으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2545">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="94b23-2546">부모 클래스 및 중첩된 클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-2546">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="94b23-2547">하한값으로 0 사용 하 여 1 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2547">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="94b23-2548">알 수 없는 하한값을 사용 하 여 1 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2548">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="94b23-2549">N 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2549">An n-dimensional array</span></span>|<span data-ttu-id="94b23-2550">총 n-1 번 대괄호 안에 쉼표 (,)입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2550">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="94b23-2551">예를 들어 `System.Object[,,]` 나타내는 3 차원 `Object` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2551">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="94b23-2552">2 차원 배열의 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2552">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="94b23-2553">알 수 없는 하위 범위를 사용 하 여 사각형 2 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2553">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="94b23-2554">하나의 형식 인수가 있는 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2554">A generic type with one type argument</span></span>|<span data-ttu-id="94b23-2555">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2555">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="94b23-2556">두 개의 형식 인수를 사용 하 여 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2556">A generic type with two type arguments</span></span>|<span data-ttu-id="94b23-2557">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2557">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="94b23-2558">두 어셈블리의 정규화 된 형식 인수가 있는 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2558">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="94b23-2559">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2559">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="94b23-2560">어셈블리의 정규화 된 형식 인수를 사용 하 여 어셈블리의 정규화 된 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2560">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="94b23-2561">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2561">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="94b23-2562">두 형식 인수가 있는 제네릭 형식인 형식 인수로 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2562">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="94b23-2563">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="94b23-2563">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="94b23-2564">다음 예제에서는 검색 유형을 `System.Int32` 형식 개체를 사용 하 여 표시 하 고는 <xref:System.Type.FullName%2A> 의 속성 `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="94b23-2564">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="94b23-2565">이 예제에서는 형식 개체를 존재 하지 않는 어셈블리를 가리키는 경우 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2565">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2566">
            <paramref name="typeName" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2566">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-2567">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2567">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-2568">
            <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2568">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="94b23-2569">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2569">-or-</span>
          </span>
          <span data-ttu-id="94b23-2570">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2570">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="94b23-2571">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2571">-or-</span>
          </span>
          <span data-ttu-id="94b23-2572">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2572">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="94b23-2573">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2573">-or-</span>
          </span>
          <span data-ttu-id="94b23-2574">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2574">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="94b23-2575">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2575">-or-</span>
          </span>
          <span data-ttu-id="94b23-2576">
            <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2576">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2577">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문을 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2577">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="94b23-2578">예를 들어 "MyType[,\*,]"입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2578">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="94b23-2579">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2579">-or-</span>
          </span>
          <span data-ttu-id="94b23-2580">
            <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2580">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2581">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2581">-or-</span>
          </span>
          <span data-ttu-id="94b23-2582">
            <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2582">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2583">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2583">-or-</span>
          </span>
          <span data-ttu-id="94b23-2584">
            <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2584">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="94b23-2585">
            <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2585">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="94b23-2586">
                <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.</span>
              <span class="sxs-lookup">
                <span data-stu-id="94b23-2586">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="94b23-2587">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2587">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="94b23-2588">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2588">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="94b23-2589">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2589">-or-</span>
          </span>
          <span data-ttu-id="94b23-2590">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2590">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-2591">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2591">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="94b23-2592">가져올 형식에 대한 어셈블리로 한정된 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2592">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="94b23-2593">
            <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2593">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="94b23-2594">형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2594">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-2595">형식을 찾을 수 없어 예외를 throw하는 경우 <see langword="true" />이고 <see langword="false" />를 반환하는 경우 <see langword="null" />입니다. <see langword="false" />를 지정하면 일부 다른 예외 조건을 표시하지 않지만 모두 그렇지는 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2595">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="94b23-2596">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2596">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="94b23-2597">
            <c>typeName</c>에 대해 대/소문자를 구분하지 않는 검색을 수행하려면 <see langword="true" />이고, <c>typeName</c>에 대해 대/소문자를 구분하는 검색을 수행하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2597">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2598">대/소문자를 구분하여 검색할지 여부와 형식이 없으면 예외를 throw할지 여부를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2598">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2599">지정된 이름의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2599">The type with the specified name.</span>
          </span>
          <span data-ttu-id="94b23-2600">형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2600">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="94b23-2601">경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2601">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="94b23-2602">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2602">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2603">사용할 수는 <xref:System.Type.GetType%2A> 메서드를 <xref:System.Type> 에서 가져올 수 있는 해당 어셈블리의 정규화 된 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체 <xref:System.Type.AssemblyQualifiedName>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2603">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="94b23-2604"><xref:System.Type.GetType%2A> 에 지정 된 어셈블리를 로드 하면 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2604"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="94b23-2605">사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 합니다 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드를 <xref:System.Reflection.Assembly> 클래스를 <xref:System.Type> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2605">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="94b23-2606">형식을 프로그램에 컴파일 타임에 알려진 어셈블리의 경우 것이 보다 효율적으로 사용할 `typeof` C# <xref:System.Type.GetType%2A> Visual basic의 경우 또는 `typeid` c + +에서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2606">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="94b23-2607">`GetType` 디스크에서 로드 된 어셈블리 에서만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2607">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="94b23-2608">호출 하는 경우 `GetType` 정의 사용 하 여 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스에 일관 되지 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2608">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="94b23-2609">동작을 동적 어셈블리 인지 영구적 이므로, 즉, 사용 하 여 만든 합니다 `RunAndSave` 또는 `Save` 모드 액세스는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2609">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="94b23-2610">동적 어셈블리를 지속적이 고 먼저 디스크에 쓴 경우 `GetType` 는 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2610">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="94b23-2611">어셈블리 경우 디스크에 저장 되지 않은 경우 `GetType` 가 호출 메서드는 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2611">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="94b23-2612">`GetType` 임시 동적 어셈블리를 인식 하지 못합니다 따라서 호출 `GetType` 일시적인에서 형식을 검색 하려면 동적 어셈블리는 다음과 같이 반환 됩니다. `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2612">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="94b23-2613">사용 하도록 `GetType` 구독할 동적 모듈의 경우에 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2613">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="94b23-2614">이 고, 그렇지 메모리에 어셈블리의 두 복사본을 가져오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2614">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="94b23-2615">`throwOnError` 되나요 유형을 찾을 수 없습니다 하 고 특정 한 다른 예외 조건을 표시 하지 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2615">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="94b23-2616">값에 관계 없이 일부 예외가 throw 됩니다 `throwOnError`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2616">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="94b23-2617">예를 들어 형식을 찾았지만 로드할 수 없습니다는 <xref:System.TypeLoadException> 이 throw 경우에 `throwOnError` 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2617">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="94b23-2618">다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2618">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="94b23-2619">멤버 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2619">Member Type</span></span>|<span data-ttu-id="94b23-2620">정적</span><span class="sxs-lookup"><span data-stu-id="94b23-2620">Static</span></span>|<span data-ttu-id="94b23-2621">Static이 아니고</span><span class="sxs-lookup"><span data-stu-id="94b23-2621">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="94b23-2622">생성자</span><span class="sxs-lookup"><span data-stu-id="94b23-2622">Constructor</span></span>|<span data-ttu-id="94b23-2623">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2623">No</span></span>|<span data-ttu-id="94b23-2624">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2624">No</span></span>|  
|<span data-ttu-id="94b23-2625">필드</span><span class="sxs-lookup"><span data-stu-id="94b23-2625">Field</span></span>|<span data-ttu-id="94b23-2626">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2626">No</span></span>|<span data-ttu-id="94b23-2627">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2627">Yes.</span></span> <span data-ttu-id="94b23-2628">필드는 항상 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2628">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2629">이벤트(event)</span><span class="sxs-lookup"><span data-stu-id="94b23-2629">Event</span></span>|<span data-ttu-id="94b23-2630">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2630">Not applicable</span></span>|<span data-ttu-id="94b23-2631">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2631">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2632">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2632">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2633">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2633">See note 2 below.</span></span>|  
|<span data-ttu-id="94b23-2634">메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-2634">Method</span></span>|<span data-ttu-id="94b23-2635">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2635">No</span></span>|<span data-ttu-id="94b23-2636">예.</span><span class="sxs-lookup"><span data-stu-id="94b23-2636">Yes.</span></span> <span data-ttu-id="94b23-2637">(가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2637">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="94b23-2638">중첩된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2638">Nested Type</span></span>|<span data-ttu-id="94b23-2639">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2639">No</span></span>|<span data-ttu-id="94b23-2640">아니요</span><span class="sxs-lookup"><span data-stu-id="94b23-2640">No</span></span>|  
|<span data-ttu-id="94b23-2641">속성</span><span class="sxs-lookup"><span data-stu-id="94b23-2641">Property</span></span>|<span data-ttu-id="94b23-2642">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="94b23-2642">Not applicable</span></span>|<span data-ttu-id="94b23-2643">공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2643">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="94b23-2644">리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2644">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2645">참고 2 아래를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2645">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="94b23-2646">이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2646">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="94b23-2647">이것은 이진 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2647">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="94b23-2648">리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2648">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="94b23-2649">기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2649">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="94b23-2650">사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2650">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="94b23-2651">배열 또는 COM 형식을 검색할 수 없습니다는 이미 사용할 수 있는 클래스의 테이블에 로드 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2651">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="94b23-2652">`typeName` 수 형식 이름으로 한정 되어야 해당 네임 스페이스 또는 어셈블리 이름 사양에 포함 된 어셈블리의 정규화 된 이름.</span><span class="sxs-lookup"><span data-stu-id="94b23-2652">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="94b23-2653"><xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-2653">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="94b23-2654">경우 `typeName` 네임 스페이스만 어셈블리 이름이 아니라 포함이 메서드를 호출 하는 개체의 어셈블리 및 Mscorlib.dll만 순서 대로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2654">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="94b23-2655">TypeName 부분 또는 전체 어셈블리 이름의 정규화 된 경우이 메서드는 지정된 된 어셈블리에서 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2655">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="94b23-2656">어셈블리에 강력한 이름이 있으면 전체 어셈블리 이름은 필수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2656">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="94b23-2657"><xref:System.Type.AssemblyQualifiedName%2A> 속성에는 중첩 된 형식, 어셈블리 이름 및 형식 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2657">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="94b23-2658">공용 언어 런타임에서 지 원하는 모든 컴파일러 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2658">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2659">.NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2659">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="94b23-2660">예를 들어, "ProcessorArchitecture = msil"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2660">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="94b23-2661">그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2661">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="94b23-2662">형식을 만들어 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-2662">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="94b23-2663">사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2663">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="94b23-2664"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="94b23-2664">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="94b23-2665">구분 기호</span><span class="sxs-lookup"><span data-stu-id="94b23-2665">Delimiter</span></span>|<span data-ttu-id="94b23-2666">의미</span><span class="sxs-lookup"><span data-stu-id="94b23-2666">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="94b23-2667">백슬래시(\\)</span><span class="sxs-lookup"><span data-stu-id="94b23-2667">Backslash (\\)</span></span>|<span data-ttu-id="94b23-2668">이스케이프 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2668">Escape character.</span></span>|  
|<span data-ttu-id="94b23-2669">억음 악센트 기호 (')</span><span class="sxs-lookup"><span data-stu-id="94b23-2669">Backtick (\`)</span></span>|<span data-ttu-id="94b23-2670">형식 매개 변수를 제네릭 형식 이름의 끝에 있는 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2670">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="94b23-2671">대괄호 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-2671">Brackets ([])</span></span>|<span data-ttu-id="94b23-2672">생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록을 내는 어셈블리의 정규화 된 유형을 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2672">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="94b23-2673">쉼표 ()</span><span class="sxs-lookup"><span data-stu-id="94b23-2673">Comma (,)</span></span>|<span data-ttu-id="94b23-2674">어셈블리 이름을 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2674">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="94b23-2675">마침표 (입니다.)</span><span class="sxs-lookup"><span data-stu-id="94b23-2675">Period (.)</span></span>|<span data-ttu-id="94b23-2676">네임 스페이스 식별자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2676">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="94b23-2677">더하기 기호 (+)</span><span class="sxs-lookup"><span data-stu-id="94b23-2677">Plus sign (+)</span></span>|<span data-ttu-id="94b23-2678">중첩된 된 클래스 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2678">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="94b23-2679">예를 들어, 클래스에 대 한 정규화 된 이름을이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2679">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="94b23-2680">네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 더하기 기호 (+) 이스케이프 문자를 사용 해야 합니다. (\\) 중첩 구분 기호로 해석 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2680">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="94b23-2681">리플렉션 다음과 같이이 문자열을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2681">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="94b23-2682">"+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2682">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="94b23-2683">이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2683">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="94b23-2684">찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2684">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="94b23-2685"><xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서.</span><span class="sxs-lookup"><span data-stu-id="94b23-2685"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="94b23-2686"><xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2686"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="94b23-2687">형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2687">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="94b23-2688">형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2688">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="94b23-2689">공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2689">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="94b23-2690">어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2690">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="94b23-2691">제네릭 형식의 이름을 억음 악센트 기호 끝납니다 (\`), 제네릭 형식 인수 개수를 나타내는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2691">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="94b23-2692">이 이름 꾸미기의 목적은 컴파일러에서 제네릭 형식을 지원 형식 매개 변수 수가 다른 하지만 같은 이름의 동일한 범위에서 발생 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2692">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="94b23-2693">리플렉션 바뀐된 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 하 고 `Tuple(Of T0, T1)` Visual basic의 경우 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#.</span><span class="sxs-lookup"><span data-stu-id="94b23-2693">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="94b23-2694">제네릭 형식의 형식 인수 목록을 괄호로 묶고 형식 인수는 쉼표로 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2694">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="94b23-2695">예를 들어 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2695">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="94b23-2696">A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 <xref:System.String> 다음과 같이 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2696">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="94b23-2697">형식 인수 목록에는 어셈블리의 정규화 된 형식을 지정 하려면 어셈블리의 정규화 된 형식을 대괄호로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2697">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="94b23-2698">이 고, 그렇지 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표는 추가 형식 인수를 구분 기호로 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2698">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="94b23-2699">예를 들어를 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 MyAssembly.dll에서 <xref:System.String>, 다음과 같이 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2699">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2700">형식 매개 변수 목록에 표시 되는 경우에 어셈블리의 정규화 된 형식에는 대괄호로 묶을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2700">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="94b23-2701">형식 매개 변수 목록에서 어셈블리 정규화 형식에 대 한 검색에 대 한 규칙을 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2701">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="94b23-2702">Nullable 형식은 제네릭 형식의 특수 한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2702">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="94b23-2703">예를 들어, null 허용 <xref:System.Int32> "System.Nullable'1[System.Int32]" 문자열에 의해 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2703">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2704">C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2704">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="94b23-2705">예를 들어, null 허용 <xref:System.Boolean> 형식을 반환한 `typeof(Nullable<bool>)` C#으로 하 여 `Nullable<Boolean>::typeid` c + +에서 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2705">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="94b23-2706">다음 표에서 사용 하 여 사용 하는 구문을 `GetType` 다양 한 형식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2706">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="94b23-2707">가져오려는</span><span class="sxs-lookup"><span data-stu-id="94b23-2707">To Get</span></span>|<span data-ttu-id="94b23-2708">사용</span><span class="sxs-lookup"><span data-stu-id="94b23-2708">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="94b23-2709">Null 허용 <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="94b23-2709">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="94b23-2710">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2710">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="94b23-2711">에 대 한 관리 되지 않는 포인터입니다. `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2711">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="94b23-2712">에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2712">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="94b23-2713">관리 되는 포인터 또는 참조 `MyType`</span><span class="sxs-lookup"><span data-stu-id="94b23-2713">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="94b23-2714">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="94b23-2714">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="94b23-2715">포인터와 달리 참조는 한 수준으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2715">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="94b23-2716">부모 클래스 및 중첩된 클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-2716">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="94b23-2717">하한값으로 0 사용 하 여 1 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2717">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="94b23-2718">알 수 없는 하한값을 사용 하 여 1 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2718">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="94b23-2719">N 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2719">An n-dimensional array</span></span>|<span data-ttu-id="94b23-2720">총 n-1 번 대괄호 안에 쉼표 (,)입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2720">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="94b23-2721">예를 들어 `System.Object[,,]` 나타내는 3 차원 `Object` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2721">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="94b23-2722">2 차원 배열의 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2722">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="94b23-2723">알 수 없는 하위 범위를 사용 하 여 사각형 2 차원 배열</span><span class="sxs-lookup"><span data-stu-id="94b23-2723">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="94b23-2724">하나의 형식 인수가 있는 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2724">A generic type with one type argument</span></span>|<span data-ttu-id="94b23-2725">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2725">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="94b23-2726">두 개의 형식 인수를 사용 하 여 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2726">A generic type with two type arguments</span></span>|<span data-ttu-id="94b23-2727">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2727">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="94b23-2728">두 어셈블리의 정규화 된 형식 인수가 있는 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2728">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="94b23-2729">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2729">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="94b23-2730">어셈블리의 정규화 된 형식 인수를 사용 하 여 어셈블리의 정규화 된 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2730">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="94b23-2731">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span><span class="sxs-lookup"><span data-stu-id="94b23-2731">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="94b23-2732">두 형식 인수가 있는 제네릭 형식인 형식 인수로 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2732">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="94b23-2733">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="94b23-2733">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2734">
            <paramref name="typeName" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2734">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-2735">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2735">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-2736">
            <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2736">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="94b23-2737">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2737">-or-</span>
          </span>
          <span data-ttu-id="94b23-2738">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2738">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="94b23-2739">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2739">-or-</span>
          </span>
          <span data-ttu-id="94b23-2740">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2740">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="94b23-2741">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2741">-or-</span>
          </span>
          <span data-ttu-id="94b23-2742">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2742">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="94b23-2743">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2743">-or-</span>
          </span>
          <span data-ttu-id="94b23-2744">
            <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2744">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2745">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문을 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2745">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="94b23-2746">예를 들어 "MyType[,\*,]"입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2746">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="94b23-2747">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2747">-or-</span>
          </span>
          <span data-ttu-id="94b23-2748">
            <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2748">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2749">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2749">-or-</span>
          </span>
          <span data-ttu-id="94b23-2750">
            <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2750">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2751">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2751">-or-</span>
          </span>
          <span data-ttu-id="94b23-2752">
            <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2752">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="94b23-2753">
            <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2753">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="94b23-2754">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2754">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="94b23-2755">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2755">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="94b23-2756">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2756">-or-</span>
          </span>
          <span data-ttu-id="94b23-2757">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2757">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-2758">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2758">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="94b23-2759">가져올 형식의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2759">The name of the type to get.</span>
          </span>
          <span data-ttu-id="94b23-2760">
            <c>typeResolver</c> 매개 변수가 제공되는 경우 형식 이름은 <c>typeResolver</c>에서 확인 가능한 임의의 문자열일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2760">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="94b23-2761">
            <c>assemblyResolver</c> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <c>typeName</c>은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2761">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="94b23-2762">
            <c>typeName</c>에 지정된 어셈블리를 찾고 반환하는 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2762">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="94b23-2763">어셈블리 이름이 <c>assemblyResolver</c>에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2763">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="94b23-2764">
            <c>typeName</c>에 어셈블리의 이름이 포함되어 있지 않으면 <c>assemblyResolver</c>가 호출되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2764">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="94b23-2765">
            <c>assemblyResolver</c>가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2765">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="94b23-2766">주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2766">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="94b23-2767">그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2767">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="94b23-2768">제공하는 메서드 또는 친숙한 메서드만 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2768">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="94b23-2769">
            <c>assemblyResolver</c> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <c>typeName</c>에 지정된 형식을 찾고 반환하는 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2769">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="94b23-2770">어셈블리가 제공되지 않는 경우 <c>typeResolver</c> 메서드에서 어셈블리를 제공할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2770">If no assembly is provided, the <c>typeResolver</c> method can provide one.</span>
          </span>
          <span data-ttu-id="94b23-2771">이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <see langword="false" />가 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2771">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="94b23-2772">주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2772">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2773">어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2773">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2774">지정된 이름을 가진 형식이거나, 형식이 없으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2774">The type with the specified name, or <see langword="null" /> if the type is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2775">이 메서드와 대 한 세부 정보에 대 한 사용 시나리오는 `assemblyResolver` 하 고 `typeResolver` 에서 매개 변수를 찾을 수 있습니다는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2775">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2776">하는 경우 `typeName` 찾을 수 없는 호출 합니다 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 메서드가 반환 되는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2776">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="94b23-2777">예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2777">It does not throw an exception.</span></span> <span data-ttu-id="94b23-2778">제어할 수 있는지 여부는 예외가 발생의 오버 로드를 호출 합니다 <xref:System.Type.GetType%2A> 있는 메서드를 `throwOnError` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2778">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="94b23-2779">이 메서드 오버 로드는 호출 동일 합니다 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 `false` 에 대 한 합니다 `throwOnError` 및 `ignoreCase` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="94b23-2779">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2780">
            <paramref name="typeName" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2780">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-2781">클래스 이니셜라이저가 호출되고 예외를 throw합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2781">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2782">
            <paramref name="typeName" />이 형식 이름과 어셈블리 이름(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자를 포함하는 경우)에 구문 분석할 때 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2782">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="94b23-2783">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2783">-or-</span>
          </span>
          <span data-ttu-id="94b23-2784">
            <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2784">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2785">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2785">-or-</span>
          </span>
          <span data-ttu-id="94b23-2786">
            <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2786">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2787">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2787">-or-</span>
          </span>
          <span data-ttu-id="94b23-2788">
            <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2788">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-2789">
            <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2789">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="94b23-2790">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2790">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="94b23-2791">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2791">-or-</span>
          </span>
          <span data-ttu-id="94b23-2792">
            <paramref name="typeName" />에 잘못된 어셈블리 이름이 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2792">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="94b23-2793">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2793">-or-</span>
          </span>
          <span data-ttu-id="94b23-2794">
            <paramref name="typeName" />은 형식 이름이 없는 유효한 어셈블리 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2794">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="94b23-2795">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2795">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="94b23-2796">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2796">-or-</span>
          </span>
          <span data-ttu-id="94b23-2797">어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2797">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="94b23-2798">가져올 형식의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2798">The name of the type to get.</span>
          </span>
          <span data-ttu-id="94b23-2799">
            <c>typeResolver</c> 매개 변수가 제공되는 경우 형식 이름은 <c>typeResolver</c>에서 확인 가능한 임의의 문자열일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2799">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="94b23-2800">
            <c>assemblyResolver</c> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <c>typeName</c>은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2800">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="94b23-2801">
            <c>typeName</c>에 지정된 어셈블리를 찾고 반환하는 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2801">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="94b23-2802">어셈블리 이름이 <c>assemblyResolver</c>에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2802">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="94b23-2803">
            <c>typeName</c>에 어셈블리의 이름이 포함되어 있지 않으면 <c>assemblyResolver</c>가 호출되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2803">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="94b23-2804">
            <c>assemblyResolver</c>가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2804">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="94b23-2805">주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2805">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="94b23-2806">그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2806">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="94b23-2807">제공하는 메서드 또는 친숙한 메서드만 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2807">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="94b23-2808">
            <c>assemblyResolver</c> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <c>typeName</c>에 지정된 형식을 찾고 반환하는 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2808">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="94b23-2809">어셈블리가 제공되지 않는 경우 이 메서드에서 어셈블리를 제공할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2809">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="94b23-2810">이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <see langword="false" />가 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2810">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="94b23-2811">주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2811">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-2812">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2812">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2813">또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2813">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="94b23-2814">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2814">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2815">형식을 찾을 수 없는 경우 예외를 throw할지를 지정하고 어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2815">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2816">지정된 이름의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2816">The type with the specified name.</span>
          </span>
          <span data-ttu-id="94b23-2817">형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2817">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="94b23-2818">경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2818">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="94b23-2819">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2819">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2820">이 메서드와 대 한 세부 정보에 대 한 사용 시나리오는 `assemblyResolver` 하 고 `typeResolver` 에서 매개 변수를 찾을 수 있습니다는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2820">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="94b23-2821">이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 `false` 에 대 한는 `ignoreCase` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2821">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-2822">
            <paramref name="typeName" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2822">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-2823">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2823">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-2824">
            <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2824">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="94b23-2825">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2825">-or-</span>
          </span>
          <span data-ttu-id="94b23-2826">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2826">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="94b23-2827">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2827">-or-</span>
          </span>
          <span data-ttu-id="94b23-2828">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2828">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="94b23-2829">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2829">-or-</span>
          </span>
          <span data-ttu-id="94b23-2830">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2830">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="94b23-2831">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2831">-or-</span>
          </span>
          <span data-ttu-id="94b23-2832">
            <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2832">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-2833">
            <paramref name="typeName" />이 형식 이름과 어셈블리 이름(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자를 포함하는 경우)에 구문 분석할 때 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2833">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="94b23-2834">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2834">-or-</span>
          </span>
          <span data-ttu-id="94b23-2835">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />에 잘못된 구문이 포함된 경우(예: "MyType[,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2835">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="94b23-2836">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2836">-or-</span>
          </span>
          <span data-ttu-id="94b23-2837">
            <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2837">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2838">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2838">-or-</span>
          </span>
          <span data-ttu-id="94b23-2839">
            <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2839">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="94b23-2840">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2840">-or-</span>
          </span>
          <span data-ttu-id="94b23-2841">
            <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2841">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="94b23-2842">
            <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2842">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
          <span data-ttu-id="94b23-2843">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2843">-or-</span>
          </span>
          <span data-ttu-id="94b23-2844">
            <paramref name="typeName" />에 잘못된 어셈블리 이름이 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2844">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="94b23-2845">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2845">-or-</span>
          </span>
          <span data-ttu-id="94b23-2846">
            <paramref name="typeName" />은 형식 이름이 없는 유효한 어셈블리 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2846">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="94b23-2847">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2847">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="94b23-2848">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2848">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="94b23-2849">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2849">-or-</span>
          </span>
          <span data-ttu-id="94b23-2850">어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2850">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="94b23-2851">가져올 형식의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2851">The name of the type to get.</span>
          </span>
          <span data-ttu-id="94b23-2852">
            <c>typeResolver</c> 매개 변수가 제공되는 경우 형식 이름은 <c>typeResolver</c>에서 확인 가능한 임의의 문자열일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2852">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="94b23-2853">
            <c>assemblyResolver</c> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <c>typeName</c>은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2853">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="94b23-2854">
            <c>typeName</c>에 지정된 어셈블리를 찾고 반환하는 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2854">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="94b23-2855">어셈블리 이름이 <c>assemblyResolver</c>에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2855">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="94b23-2856">
            <c>typeName</c>에 어셈블리의 이름이 포함되어 있지 않으면 <c>assemblyResolver</c>가 호출되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2856">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="94b23-2857">
            <c>assemblyResolver</c>가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2857">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="94b23-2858">주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2858">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="94b23-2859">그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2859">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="94b23-2860">제공하는 메서드 또는 친숙한 메서드만 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2860">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="94b23-2861">
            <c>assemblyResolver</c> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <c>typeName</c>에 지정된 형식을 찾고 반환하는 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2861">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="94b23-2862">어셈블리가 제공되지 않는 경우 이 메서드에서 어셈블리를 제공할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2862">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="94b23-2863">이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <c>ignoreCase</c>의 값이 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2863">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <c>ignoreCase</c> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="94b23-2864">주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2864">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-2865">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2865">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-2866">또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2866">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="94b23-2867">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2867">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="94b23-2868">
            <c>typeName</c>에 대해 대/소문자를 구분하지 않는 검색을 수행하려면 <see langword="true" />이고, <c>typeName</c>에 대해 대/소문자를 구분하는 검색을 수행하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2868">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-2869">형식을 찾을 수 없는 경우 대/소문자를 구분하는 검색을 수행할지 여부 및 예외를 throw할지를 지정하고 어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2869">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-2870">지정된 이름의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2870">The type with the specified name.</span>
          </span>
          <span data-ttu-id="94b23-2871">형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2871">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="94b23-2872">경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2872">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="94b23-2873">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-2873">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-2874">이 메서드 오버 로드 및 연결 된 오버 로드를 사용 하 여 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 하 고 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>)의 기본 구현을 바꿀는 <xref:System.Type.GetType%2A> 유연한 구현 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-2874">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="94b23-2875">형식 이름 및 포함 하는 어셈블리의 이름을 확인 하는 사용자 고유의 메서드를 제공 하 여 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2875">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="94b23-2876">형식에서 로드 되는 어셈블리의 버전을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2876">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="94b23-2877">어셈블리 이름을 포함 하지 않는 형식 이름을 검색할 수 있는 다른 위치를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2877">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="94b23-2878">부분 어셈블리 이름을 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2878">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="94b23-2879">서브 클래스를 반환 <xref:System.Type?displayProperty=nameWithType> 는 CLR (공용 언어 런타임)에서 만들어지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2879">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="94b23-2880">예를 들어 버전 독립적 serialization에서이 메서드를 사용 하면 부분 이름을 사용 하 여 "최적" 어셈블리를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2880">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="94b23-2881">다른 오버 로드는 <xref:System.Type.GetType%2A> 메서드 버전 번호를 포함 하는 어셈블리의 정규화 된 형식 이름이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2881">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="94b23-2882">형식 시스템의 대체 구현을의 서브 클래스를 반환 해야 할 수 있습니다 <xref:System.Type?displayProperty=nameWithType> CLR에서 만들어지지 않은; 모든 형식에 다른 오버 로드에 의해 반환 되는 <xref:System.Type.GetType%2A> 메서드는 런타임 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2882">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="94b23-2883">사용 정보</span><span class="sxs-lookup"><span data-stu-id="94b23-2883">Usage Notes</span></span>  
 <span data-ttu-id="94b23-2884">이 메서드 오버 로드 및 연결 된 오버 로드를 구문 분석 `typeName` 어셈블리의 이름 및 형식 이름으로 한 다음 이름을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2884">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="94b23-2885">어셈블리 이름 확인 형식 이름을 어셈블리의 컨텍스트에서 해결 해야 하기 때문에 형식 이름 확인 하기 전에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2885">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2886">어셈블리의 정규화 된 형식 이름에 대 한 개념을 잘 모르는 경우 참조는 <xref:System.Type.AssemblyQualifiedName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2886">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="94b23-2887">경우 `typeName` 어셈블리의 정규화 된 이름이 아닙니다. 어셈블리 확인을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2887">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="94b23-2888">Mscorlib.dll 또는 현재 실행 중인 어셈블리의 컨텍스트에서 정규화 되지 않은 형식 이름을 확인할 수 있습니다 또는 어셈블리를 선택적으로 제공할 수는 `typeResolver` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2888">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="94b23-2889">영향 포함 하거나 다른 종류의 이름 확인을 테이블로 표시 되는 어셈블리 이름을 생략 합니다 [혼합 된 이름 확인](#mixed_name_resolution) 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2889">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="94b23-2890">일반적인 사용법 정보:</span><span class="sxs-lookup"><span data-stu-id="94b23-2890">General usage notes:</span></span>  
  
-   <span data-ttu-id="94b23-2891">메서드를 전달 하지 마세요 `assemblyResolver` 또는 `typeResolver` 알 수 없거나 신뢰할 수 없는 호출자를 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2891">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="94b23-2892">제공하는 메서드 또는 친숙한 메서드만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2892">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="94b23-2893">알 수 없거나 신뢰할 수 없는 호출자의 메서드를 사용 하 여 악성 코드에 대 한 권한 상승 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2893">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="94b23-2894">생략 하면는 `assemblyResolver` 및/또는 `typeResolver` 매개 변수, 값은 `throwOnError` 매개 변수는 기본 확인을 수행 하는 메서드에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2894">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="94b23-2895">경우 `throwOnError` 됩니다 `true`,이 메서드가 throw를 <xref:System.TypeLoadException> 때 `typeResolver` 반환 `null`, 및 <xref:System.IO.FileNotFoundException> 때 `assemblyResolver` 반환 `null`.</span><span class="sxs-lookup"><span data-stu-id="94b23-2895">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="94b23-2896">이 메서드에 의해 throw 된 예외를 catch 하지 않습니다 `assemblyResolver` 고 `typeResolver`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2896">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="94b23-2897">확인자 메서드에 의해 throw 되는 모든 예외에 대 한 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2897">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="94b23-2898">어셈블리 확인</span><span class="sxs-lookup"><span data-stu-id="94b23-2898">Resolving Assemblies</span></span>  
 <span data-ttu-id="94b23-2899">합니다 `assemblyResolver` 메서드는 수신를 <xref:System.Reflection.AssemblyName> 개체에 포함 된 어셈블리 이름 문자열을 구문 분석 하 여 생성 되는 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2899">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="94b23-2900">하는 경우 `typeName` 는 어셈블리 이름을 포함 하지 않는 `assemblyResolver` 가 호출 되지 않습니다 및 `null` 넘어갑니다 `typeResolver`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2900">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="94b23-2901">경우 `assemblyResolver` 제공 되는 표준 어셈블리가 아닌 어셈블리를 찾는 데 사용 됩니다 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2901">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="94b23-2902">경우 `assemblyResolver` 제공 되는 <xref:System.Type.GetType%2A> 메서드는 표준 검색을 수행 하지 않으면 경우 확인 해야 프로그램 `assemblyResolver` 을 전달 하는 모든 어셈블리를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2902">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="94b23-2903">합니다 `assemblyResolver` 메서드는 반환 해야 `null` 어셈블리를 확인할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2903">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="94b23-2904">경우 `assemblyResolver` 반환 `null`, `typeResolver` 가 호출 되지 않습니다 발생 추가로 처리할 필요가 없습니다; 또한 경우 `throwOnError` 됩니다 `true`, <xref:System.IO.FileNotFoundException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2904">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="94b23-2905">경우는 <xref:System.Reflection.AssemblyName> 에 전달 된 `assemblyResolver` 이 부분 이름, 하나 이상의 파트 중 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2905">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="94b23-2906">예를 들어 없는 버전이 있을 경우 합니다 <xref:System.Reflection.AssemblyName.Version%2A> 속성은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2906">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="94b23-2907">경우는 <xref:System.Reflection.AssemblyName.Version%2A> 속성을 <xref:System.Reflection.AssemblyName.CultureInfo%2A> 속성을 및 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> 메서드가 모두 반환 `null`만 어셈블리의 단순한 이름을 제공한 다음.</span><span class="sxs-lookup"><span data-stu-id="94b23-2907">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="94b23-2908">`assemblyResolver` 메서드 사용 하거나 어셈블리 이름의 모든 부분을 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2908">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="94b23-2909">다른 어셈블리 해결 옵션의 효과 테이블로 표시 됩니다는 [혼합 된 이름 확인](#mixed_name_resolution) 섹션을 간단 하 고 어셈블리의 정규화 된 형식 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2909">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="94b23-2910">형식 확인</span><span class="sxs-lookup"><span data-stu-id="94b23-2910">Resolving Types</span></span>  
 <span data-ttu-id="94b23-2911">하는 경우 `typeName` 는 어셈블리 이름을 지정 하지 않습니다 `typeResolver` 가 항상 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2911">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="94b23-2912">하는 경우 `typeName` 어셈블리 이름 지정 `typeResolver` 어셈블리 이름을 성공적으로 확인 하는 경우에 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2912">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="94b23-2913">하는 경우 `assemblyResolver` 또는 표준 어셈블리 검색 반환 `null`, `typeResolver` 호출 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2913">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="94b23-2914">`typeResolver` 메서드 3 개 인수를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2914">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="94b23-2915">검색할 어셈블리 또는 `null` 경우 `typeName` 어셈블리 이름이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2915">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="94b23-2916">단순한 이름 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2916">The simple name of the type.</span></span> <span data-ttu-id="94b23-2917">중첩된 된 형식의 경우 가장 바깥쪽 포함 하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2917">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="94b23-2918">제네릭 형식의 경우 제네릭 형식의 단순 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2918">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="94b23-2919">부울 값이 `true` 형식 이름의 대/소문자가 구분 되지 않을 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2919">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="94b23-2920">이러한 인수를 사용 하는 방법을 결정 하는 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2920">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="94b23-2921">합니다 `typeResolver` 메서드는 반환 해야 `null` 형식을 확인할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2921">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="94b23-2922">경우 `typeResolver` 반환 `null` 및 `throwOnError` 됩니다 `true`,이 오버 로드 <xref:System.Type.GetType%2A> throw를 <xref:System.TypeLoadException>입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2922">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="94b23-2923">다른 형식 확인 옵션의 효과 테이블로 표시 됩니다는 [혼합 된 이름 확인](#mixed_name_resolution) 섹션을 간단 하 고 어셈블리의 정규화 된 형식 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2923">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="94b23-2924">중첩된 형식 확인</span><span class="sxs-lookup"><span data-stu-id="94b23-2924">Resolving Nested Types</span></span>  
 <span data-ttu-id="94b23-2925">하는 경우 `typeName` 는 중첩 형식이 가장 바깥쪽의 이름만 포함 하는 형식 전달 됩니다 `typeResolver`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2925">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="94b23-2926">때 `typeResolver` 이 형식을 반환 합니다 <xref:System.Type.GetNestedType%2A> 메서드 가장 안쪽의 중첩 된 형식이 확인 될 때까지 재귀적으로 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2926">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="94b23-2927">제네릭 형식 확인</span><span class="sxs-lookup"><span data-stu-id="94b23-2927">Resolving Generic Types</span></span>  
 <span data-ttu-id="94b23-2928"><xref:System.Type.GetType%2A> 재귀적으로 제네릭 형식을 확인 하기 위해 호출 됩니다: 제네릭 형식 자체를 해결 하려면 먼저 해당 형식 인수를 해결 하려면 다음입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2928">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="94b23-2929">형식 인수 제네릭인 경우 <xref:System.Type.GetType%2A> 그 형식 인수를 해결 하는 재귀적으로 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2929">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="94b23-2930">조합 `assemblyResolver` 및 `typeResolver` 모든 수준의이 재귀를 해결할 수 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2930">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="94b23-2931">예를 들어, 제공 하는 `assemblyResolver` 로드를 제어 하는 `MyAssembly`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2931">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="94b23-2932">제네릭 형식을 확인 하려고 한다고 가정해 보겠습니다 `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-2932">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="94b23-2933">다음 제네릭 형식 이름을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2933">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="94b23-2934">`MyType` 만 어셈블리의 정규화 된 유형 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2934">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="94b23-2935">이름을 합니다 <xref:System.Collections.Generic.Dictionary%602> 및 <xref:System.String> 클래스 정규화 된 어셈블리는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2935">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="94b23-2936">프로그램 `typeResolver` 어셈블리로 하거나 처리할 수 있어야 또는 `null`이므로 받을 `null` 에 대 한 <xref:System.Collections.Generic.Dictionary%602> 및 <xref:System.String>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2936">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="94b23-2937">이런 경우의 오버 로드를 호출 하 여 처리할 수는 <xref:System.Type.GetType%2A> 정규화 되지 않은 형식 이름을 모두 mscorlib.dll에서 때문에 문자열을 사용 하는 메서드:</span><span class="sxs-lookup"><span data-stu-id="94b23-2937">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="94b23-2938">`assemblyResolver` 없기 때문에 해당 형식 이름이 어셈블리의 정규화 된 사전 형식 및 문자열 형식에 대 한 메서드가 호출 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2938">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="94b23-2939">이제 대신 가정 `System.String`에 첫 번째 제네릭 인수 형식이 `YourType`에서 `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="94b23-2939">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="94b23-2940">해결할 수 없는이 어셈블리 Mscorlib.dll 또는 현재 실행 중인 어셈블리 이므로 `YourType` 어셈블리의 정규화 된 이름이 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2940">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="94b23-2941">때문에 `assemblyResolve` 됩니다 재귀적으로 호출 있어야이 경우를 처리 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2941">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="94b23-2942">반환 하는 대신 `null` 이외의 어셈블리에 대 한 `MyAssembly`, 이제 제공 된 어셈블리를 로드 수행 <xref:System.Reflection.AssemblyName> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2942">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="94b23-2943">돌아가기 [사용량 정보](#usage_notes)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2943">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="94b23-2944">특수 문자가 포함 된 형식 이름 확인</span><span class="sxs-lookup"><span data-stu-id="94b23-2944">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="94b23-2945">특정 문자 어셈블리의 정규화 된 이름에서 특별 한 의미를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2945">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="94b23-2946">이러한 문자를 포함 하는 단순 형식 이름, 단순한 이름 어셈블리의 정규화 된 이름의 일부인 경우 문자 구문 분석 오류를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2946">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="94b23-2947">구문 분석 오류를 방지 하려면 이스케이프 처리 해야 백슬래시를 사용 하 여 특수 문자를 정규화 된 어셈블리 이름을 전달 하기 전에 <xref:System.Type.GetType%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-2947">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="94b23-2948">예를 들어 형식 이름은 `Strange]Type`, 다음과 같은 이스케이프 문자가 대괄호 미리 추가 해야 합니다: `Strange\]Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2948">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-2949">이러한 특수 문자를 사용 하 여 이름을 Visual Basic 또는 C#에서 만들 수 없지만 동적 어셈블리 내보내기를 또는 MSIL (Microsoft intermediate language)을 사용 하 여 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2949">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="94b23-2950">다음 표에서 형식 이름에 대 한 특수 문자를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2950">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="94b23-2951">문자</span><span class="sxs-lookup"><span data-stu-id="94b23-2951">Character</span></span>|<span data-ttu-id="94b23-2952">의미</span><span class="sxs-lookup"><span data-stu-id="94b23-2952">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="94b23-2953">`,` (쉼표)</span><span class="sxs-lookup"><span data-stu-id="94b23-2953">`,` (comma)</span></span>|<span data-ttu-id="94b23-2954">어셈블리의 정규화 된 이름에 대 한 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2954">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="94b23-2955">`[]` (대괄호)</span><span class="sxs-lookup"><span data-stu-id="94b23-2955">`[]` (square brackets)</span></span>|<span data-ttu-id="94b23-2956">접미사 쌍을 나타내는 배열 형식입니다. 구분 기호 쌍을 제네릭 인수 목록 및 어셈블리의 정규화 된 이름을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2956">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="94b23-2957">`&` (앰퍼샌드)</span><span class="sxs-lookup"><span data-stu-id="94b23-2957">`&` (ampersand)</span></span>|<span data-ttu-id="94b23-2958">접미사로, 형식이 참조 형식 인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2958">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="94b23-2959">`*` (별표)</span><span class="sxs-lookup"><span data-stu-id="94b23-2959">`*` (asterisk)</span></span>|<span data-ttu-id="94b23-2960">를 접미사로 형식이 포인터 형식 인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2960">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="94b23-2961">`+` (더하기)</span><span class="sxs-lookup"><span data-stu-id="94b23-2961">`+` (plus)</span></span>|<span data-ttu-id="94b23-2962">중첩 된 형식에 대 한 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2962">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="94b23-2963">`\` (백슬래시)</span><span class="sxs-lookup"><span data-stu-id="94b23-2963">`\` (backslash)</span></span>|<span data-ttu-id="94b23-2964">이스케이프 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2964">Escape character.</span></span>|  
  
 <span data-ttu-id="94b23-2965">와 같은 속성 <xref:System.Type.AssemblyQualifiedName%2A> 올바르게 이스케이프 된 문자열 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2965">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="94b23-2966">올바르게 이스케이프 된 문자열을 전달 해야 합니다는 <xref:System.Type.GetType%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-2966">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="94b23-2967">차례로 합니다 <xref:System.Type.GetType%2A> 메서드를 올바르게 이스케이프 이름을 전달 `typeResolver` 및 기본 형식 확인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2967">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="94b23-2968">이스케이프 되지 않은 이름에 이름을 비교 해야 하는 경우 `typeResolver`, 이스케이프 문자를 제거 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2968">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="94b23-2969">돌아가기 [사용량 정보](#usage_notes)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2969">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="94b23-2970">혼합된 이름 확인</span><span class="sxs-lookup"><span data-stu-id="94b23-2970">Mixed Name Resolution</span></span>  
 <span data-ttu-id="94b23-2971">다음 표에서 간의 상호 작용 `assemblyResolver`, `typeResolver`, 및의 형식 이름과 어셈블리의 모든 조합에 대 한 기본 이름 확인 `typeName`:</span><span class="sxs-lookup"><span data-stu-id="94b23-2971">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="94b23-2972">콘텐츠 형식 이름</span><span class="sxs-lookup"><span data-stu-id="94b23-2972">Contents of type name</span></span>|<span data-ttu-id="94b23-2973">어셈블리 확인자 메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-2973">Assembly resolver method</span></span>|<span data-ttu-id="94b23-2974">형식 확인 자가 메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-2974">Type resolver method</span></span>|<span data-ttu-id="94b23-2975">결과</span><span class="sxs-lookup"><span data-stu-id="94b23-2975">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="94b23-2976">형식, 어셈블리</span><span class="sxs-lookup"><span data-stu-id="94b23-2976">type, assembly</span></span>|<span data-ttu-id="94b23-2977">null</span><span class="sxs-lookup"><span data-stu-id="94b23-2977">null</span></span>|<span data-ttu-id="94b23-2978">null</span><span class="sxs-lookup"><span data-stu-id="94b23-2978">null</span></span>|<span data-ttu-id="94b23-2979">호출에 해당 하는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2979">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="94b23-2980">형식, 어셈블리</span><span class="sxs-lookup"><span data-stu-id="94b23-2980">type, assembly</span></span>|<span data-ttu-id="94b23-2981">제공</span><span class="sxs-lookup"><span data-stu-id="94b23-2981">provided</span></span>|<span data-ttu-id="94b23-2982">null</span><span class="sxs-lookup"><span data-stu-id="94b23-2982">null</span></span>|<span data-ttu-id="94b23-2983">`assemblyResolver` 어셈블리를 반환 하거나 반환 `null` 어셈블리를 확인할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2983">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="94b23-2984">어셈블리가 확인 되는 경우는 <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 메서드 오버 로드 되 고, 그렇지 않으면 있습니다 형식을 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2984">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="94b23-2985">형식, 어셈블리</span><span class="sxs-lookup"><span data-stu-id="94b23-2985">type, assembly</span></span>|<span data-ttu-id="94b23-2986">null</span><span class="sxs-lookup"><span data-stu-id="94b23-2986">null</span></span>|<span data-ttu-id="94b23-2987">제공</span><span class="sxs-lookup"><span data-stu-id="94b23-2987">provided</span></span>|<span data-ttu-id="94b23-2988">해당 어셈블리 이름을 변환 하는 <xref:System.Reflection.AssemblyName> 개체와 호출은 <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> 메서드 오버 로드 된 어셈블리를 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2988">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="94b23-2989">에 전달한 어셈블리 해결 되 면 `typeResolver`이 고, 그렇지 않으면 `typeResolver` 호출 되지 않습니다 추가 시도가 형식을 확인 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2989">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="94b23-2990">형식, 어셈블리</span><span class="sxs-lookup"><span data-stu-id="94b23-2990">type, assembly</span></span>|<span data-ttu-id="94b23-2991">제공</span><span class="sxs-lookup"><span data-stu-id="94b23-2991">provided</span></span>|<span data-ttu-id="94b23-2992">제공</span><span class="sxs-lookup"><span data-stu-id="94b23-2992">provided</span></span>|<span data-ttu-id="94b23-2993">`assemblyResolver` 어셈블리를 반환 하거나 반환 `null` 어셈블리를 확인할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-2993">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="94b23-2994">에 전달한 어셈블리 해결 되 면 `typeResolver`이 고, 그렇지 않으면 `typeResolver` 호출 되지 않습니다 추가 시도가 형식을 확인 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2994">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="94b23-2995">형식</span><span class="sxs-lookup"><span data-stu-id="94b23-2995">type</span></span>|<span data-ttu-id="94b23-2996">null, 제공</span><span class="sxs-lookup"><span data-stu-id="94b23-2996">null, provided</span></span>|<span data-ttu-id="94b23-2997">null</span><span class="sxs-lookup"><span data-stu-id="94b23-2997">null</span></span>|<span data-ttu-id="94b23-2998">호출에 해당 하는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2998">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="94b23-2999">어셈블리 이름, 제공 되지 않았으므로 Mscorlib.dll 및 현재 실행 중인 어셈블리가 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-2999">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="94b23-3000">경우 `assemblyResolver` 제공 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3000">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="94b23-3001">type</span><span class="sxs-lookup"><span data-stu-id="94b23-3001">type</span></span>|<span data-ttu-id="94b23-3002">null, 제공</span><span class="sxs-lookup"><span data-stu-id="94b23-3002">null, provided</span></span>|<span data-ttu-id="94b23-3003">제공</span><span class="sxs-lookup"><span data-stu-id="94b23-3003">provided</span></span>|<span data-ttu-id="94b23-3004">`typeResolver` 호출 되 고 `null` 어셈블리에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3004">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="94b23-3005">`typeResolver` 이 목적을 위해 로드 하는 어셈블리를 포함 하 여 모든 어셈블리에서 형식을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3005">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="94b23-3006">경우 `assemblyResolver` 제공 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3006">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="94b23-3007">어셈블리</span><span class="sxs-lookup"><span data-stu-id="94b23-3007">assembly</span></span>|<span data-ttu-id="94b23-3008">null, 제공</span><span class="sxs-lookup"><span data-stu-id="94b23-3008">null, provided</span></span>|<span data-ttu-id="94b23-3009">null, 제공</span><span class="sxs-lookup"><span data-stu-id="94b23-3009">null, provided</span></span>|<span data-ttu-id="94b23-3010"><xref:System.IO.FileLoadException> throw 되는 어셈블리의 정규화 된 유형 이름 처럼 어셈블리 이름을 구문 분석 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3010">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="94b23-3011">이 인해 잘못 된 어셈블리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3011">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="94b23-3012">다시: [사용 메모](#usage_notes), [어셈블리를 확인할](#resolving_assemblies)를 [형식을 확인](#resolving_types)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3012">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-3013">
            <paramref name="typeName" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3013">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-3014">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3014">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-3015">
            <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3015">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="94b23-3016">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3016">-or-</span>
          </span>
          <span data-ttu-id="94b23-3017">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3017">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="94b23-3018">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3018">-or-</span>
          </span>
          <span data-ttu-id="94b23-3019">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3019">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="94b23-3020">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3020">-or-</span>
          </span>
          <span data-ttu-id="94b23-3021">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3021">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="94b23-3022">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3022">-or-</span>
          </span>
          <span data-ttu-id="94b23-3023">
            <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3023">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3024">
            <paramref name="typeName" />이 형식 이름과 어셈블리 이름(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자를 포함하는 경우)에 구문 분석할 때 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3024">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="94b23-3025">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3025">-or-</span>
          </span>
          <span data-ttu-id="94b23-3026">
            <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />에 잘못된 구문이 포함된 경우(예: "MyType[,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3026">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="94b23-3027">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3027">-or-</span>
          </span>
          <span data-ttu-id="94b23-3028">
            <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3028">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="94b23-3029">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3029">-or-</span>
          </span>
          <span data-ttu-id="94b23-3030">
            <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3030">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="94b23-3031">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3031">-or-</span>
          </span>
          <span data-ttu-id="94b23-3032">
            <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3032">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="94b23-3033">
            <paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3033">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="94b23-3034">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3034">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="94b23-3035">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3035">-or-</span>
          </span>
          <span data-ttu-id="94b23-3036">
            <paramref name="typeName" />에 잘못된 어셈블리 이름이 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3036">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="94b23-3037">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3037">-or-</span>
          </span>
          <span data-ttu-id="94b23-3038">
            <paramref name="typeName" />은 형식 이름이 없는 유효한 어셈블리 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3038">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="94b23-3039">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3039">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="94b23-3040">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3040">-or-</span>
          </span>
          <span data-ttu-id="94b23-3041">어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3041">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="94b23-3042">형식을 확인할 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3042">An array of objects whose types to determine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3043">지정된 배열의 개체 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3043">Gets the types of the objects in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3044">
            <see cref="T:System.Type" />의 해당 요소에 대한 형식을 나타내는 <paramref name="args" /> 개체의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3044">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="94b23-3045">다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Type.GetTypeArray%2A> 배열 요소의 형식을 나열 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3045">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-3046">
            <paramref name="args" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3046">
              <paramref name="args" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-3047">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3047">-or-</span>
          </span>
          <span data-ttu-id="94b23-3048">
            <paramref name="args" />의 요소 중 하나가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3048">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-3049">클래스 이니셜라이저가 호출되고 하나 이상이 예외를 throw합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3049">The class initializers are invoked and at least one throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="94b23-3050">내부 형식 코드를 가져올 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3050">The type whose underlying type code to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3051">지정된 <see cref="T:System.Type" />의 내부 형식 코드를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3051">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3052">지정된 형식의 코드이거나, <see cref="F:System.TypeCode.Empty" />이 <paramref name="type" />인 경우는 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3052">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3053">상속 하는 경우 <xref:System.Type>를 재정의 하 여이 메서드의 동작을 변경할 수는 <xref:System.Type.GetTypeCodeImpl%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3053">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3054">다음 코드 예제에서는 방법을 <xref:System.TypeCode> 열거형을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3054">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="94b23-3055">의사 결정 블록 내에서 `WriteObjectInfo` 메서드를 <xref:System.TypeCode> 의 <xref:System.Object> 매개 변수를 검사 하 고 적절 한 메시지를 콘솔에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3055">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3056">이 <see cref="T:System.Type" /> 인스턴스에 대한 내부 형식 코드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3056">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3057">내부 형식의 형식 코드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3057">The type code of the underlying type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3058">이 메서드는 구현을 제공 합니다 `static` (C#에서) 또는 `Shared` (Visual Basic)에서는 <xref:System.Type.GetTypeCode%28System.Type%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3058">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="94b23-3059">상속 하는 경우 <xref:System.Type>의 고유한 구현을 제공 하려면이 메서드를 재정의할 수 있습니다 <xref:System.Type.GetTypeCode%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3059">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3060">지정된 CLSID(클래스 식별자)와 연관된 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3060">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="94b23-3061">가져올 형식의 CLSID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3061">The CLSID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3062">지정된 CLSID(클래스 식별자)와 연관된 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3062">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3063">CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3063">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3064"><xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-3064">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="94b23-3065">COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3065">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="94b23-3066">값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3066">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="94b23-3067">호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3067">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="94b23-3068">CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3068">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="94b23-3069">가져오기는 <xref:System.Type> 나타내는 개체를`__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3069">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="94b23-3070">호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3070">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="94b23-3071">에 대 한 예제를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3071">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="94b23-3072"><xref:System.Type.GetTypeFromCLSID%28System.Guid%29> 인스턴스화할 때 발생할 수 있는 모든 예외를 무시 하는 오버 로드를 <xref:System.Type> 기준으로 개체를 `clsid` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3072">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="94b23-3073">예외가 없는 경우 throw 되는 참고 `clsid` 는 레지스트리에서 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3073">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3074">다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3074">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="94b23-3075">다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3075">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="94b23-3076">이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3076">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="94b23-3077">관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3077">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="94b23-3078">메서드가 <see cref="T:System.Type" /> 개체 GUID에 해당 하는.NET framework는 개체에 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3078">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="94b23-3079">[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3079">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="94b23-3080">대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3080">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="94b23-3081">가져올 형식의 CLSID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3081">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-3082">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3082">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="94b23-3083">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3083">-or-</span>
          </span>
          <span data-ttu-id="94b23-3084">
            <see langword="false" />는 발생하는 예외를 모두 무시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3084">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3085">지정된 CLSID(클래스 식별자)와 연관된 형식을 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3085">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3086">CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3086">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3087"><xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-3087">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="94b23-3088">COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3088">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="94b23-3089">값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3089">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="94b23-3090">호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3090">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="94b23-3091">CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3091">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="94b23-3092">가져오기는 <xref:System.Type> 나타내는 개체를 `__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3092">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="94b23-3093">호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3093">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="94b23-3094">에 대 한 예제를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3094">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="94b23-3095">등의 예외도 <xref:System.OutOfMemoryException> 지정 하는 경우 throw 됩니다 `true` 에 대 한 `throwOnError`, 하지만 등록 되지 않은 Clsid에 대 한 실패 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3095">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3096">다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3096">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="94b23-3097">다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3097">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="94b23-3098">형식을 로드 하는 동안 오류가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3098">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="94b23-3099">이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3099">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="94b23-3100">관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3100">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="94b23-3101">메서드가 <see cref="T:System.Type" /> 개체 GUID에 해당 하는.NET framework는 개체에 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3101">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="94b23-3102">[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3102">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="94b23-3103">대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3103">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="94b23-3104">가져올 형식의 CLSID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3104">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="94b23-3105">형식을 로드할 서버입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3105">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="94b23-3106">서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3106">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3107">지정된 CLSID(클래스 식별자)와 연관된 형식을 지정된 서버에서 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3107">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3108">CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3108">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3109"><xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-3109">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="94b23-3110">COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3110">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="94b23-3111">값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3111">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="94b23-3112">호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3112">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="94b23-3113">CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3113">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="94b23-3114">가져오기는 <xref:System.Type> 나타내는 개체를 `__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3114">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="94b23-3115">호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3115">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3116">다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) computer17.central.contoso.com 라는 서버에서 Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3116">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="94b23-3117">다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3117">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="94b23-3118">이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3118">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="94b23-3119">관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3119">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="94b23-3120">메서드가 <see cref="T:System.Type" /> 개체 GUID에 해당 하는.NET framework는 개체에 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3120">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="94b23-3121">[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3121">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="94b23-3122">대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3122">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="94b23-3123">가져올 형식의 CLSID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3123">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="94b23-3124">형식을 로드할 서버입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3124">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="94b23-3125">서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3125">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-3126">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3126">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="94b23-3127">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3127">-or-</span>
          </span>
          <span data-ttu-id="94b23-3128">
            <see langword="false" />는 발생하는 예외를 모두 무시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3128">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3129">지정된 CLSID(클래스 식별자)와 연관된 형식을 지정된 서버에서 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3129">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3130">CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3130">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3131"><xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-3131">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="94b23-3132">COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3132">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="94b23-3133">값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3133">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="94b23-3134">호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3134">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="94b23-3135">CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3135">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="94b23-3136">가져오기는 <xref:System.Type> 나타내는 개체를 `__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3136">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="94b23-3137">호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3137">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="94b23-3138">등의 예외도 <xref:System.OutOfMemoryException> 지정 하는 경우 throw 됩니다 `true` 에 대 한 `throwOnError`, 하지만 등록 되지 않은 Clsid에 대 한 실패 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3138">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3139">다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) computer17.central.contoso.com 라는 서버에서 Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3139">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="94b23-3140">다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3140">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="94b23-3141">형식을 로드 하는 동안 오류가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3141">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="94b23-3142">이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3142">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="94b23-3143">관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3143">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="94b23-3144">있지만 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 메서드가 반환 되는 <see cref="T:System.Type" /> 관리 되는 특정 개체에 대 한 GUID에 해당 하는 개체는 사용할 수 없습니다 <see cref="T:System.Type" /> 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 보여 줍니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3144">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="94b23-3145">[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3145">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="94b23-3146">대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="94b23-3146">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="94b23-3147">형식을 참조하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3147">The object that refers to the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3148">지정된 형식 핸들이 참조하는 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3148">Gets the type referenced by the specified type handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3149">지정된 <see cref="T:System.RuntimeTypeHandle" />에서 참조하는 형식이거나 <see langword="null" />의 <see cref="P:System.RuntimeTypeHandle.Value" /> 속성이 <paramref name="handle" />인 경우 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3149">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3150">핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3150">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3151">다음 예제에서는 합니다 <xref:System.Type.GetTypeFromHandle%2A> 메서드를를 <xref:System.Type> 에서 개체를 <xref:System.RuntimeTypeHandle> 제공한는 <xref:System.Type.GetTypeHandle%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3151">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-3152">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3152">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3153">지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3153">Gets the type associated with the specified program identifier (ProgID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="94b23-3154">가져올 형식의 ProgID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3154">The ProgID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3155">지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져오고 <see cref="T:System.Type" />을 로드하는 동안 오류가 발생하면 null을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3155">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3156">
            <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3156">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3157">이 메서드는 제공 하는 COM 지원에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3157">This method is provided for COM support.</span></span> <span data-ttu-id="94b23-3158">Progid 네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework에서 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3158">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3159">
            <paramref name="progID" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3159">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="94b23-3160">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3160">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="94b23-3161">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3161">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="94b23-3162">가져올 형식의 ProgID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3162">The ProgID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-3163">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3163">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="94b23-3164">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3164">-or-</span>
          </span>
          <span data-ttu-id="94b23-3165">
            <see langword="false" />는 발생하는 예외를 모두 무시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3165">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3166">지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3166">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3167">
            <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3167">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3168">이 메서드는 제공 하는 COM 지원에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3168">This method is provided for COM support.</span></span> <span data-ttu-id="94b23-3169">네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework의 프로그램 Id는 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3169">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3170">다음 예제를 progid가 유효 하지 않은 경우 예외를 throw 할지를 지정 된 ProgID를 전달 하 여 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3170">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="94b23-3171">다음 예제에서는 모든 적절 한 예외 메시지와 함께 ProgID와 관련 된 ClassID를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3171">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3172">
            <paramref name="progID" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3172">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="94b23-3173">지정된 ProgID가 등록되어 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3173">The specified ProgID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="94b23-3174">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3174">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="94b23-3175">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3175">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="94b23-3176">가져올 형식의 ProgID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3176">The progID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="94b23-3177">형식을 로드할 서버입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3177">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="94b23-3178">서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3178">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3179">지정된 ProgID(프로그램 식별자)와 연관된 형식을 지정된 서버에서 가져오고, 형식을 로드하는 동안 오류가 발생하면 null을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3179">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3180">
            <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3180">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3181">이 메서드는 제공 하는 COM 지원에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3181">This method is provided for COM support.</span></span> <span data-ttu-id="94b23-3182">네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework의 프로그램 Id는 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3182">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3183">다음 예에서는 ProgID 및 서버 이름을 전달 하 여 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3183">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="94b23-3184">예제는 다음의 ProgID와 관련 된 ClassID를 표시 또는 ProgID 또는 서버 이름이 유효 하지 않은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3184">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3185">
            <paramref name="prodID" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3185">
              <paramref name="prodID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="94b23-3186">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3186">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="94b23-3187">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3187">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="94b23-3188">가져올 <see cref="T:System.Type" />의 ProgID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3188">The progID of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="94b23-3189">형식을 로드할 서버입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3189">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="94b23-3190">서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3190">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="94b23-3191">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3191">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="94b23-3192">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3192">-or-</span>
          </span>
          <span data-ttu-id="94b23-3193">
            <see langword="false" />는 발생하는 예외를 모두 무시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3193">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3194">지정된 ProgID(프로그램 식별자)와 연관된 형식을 지정된 서버에서 가져오고, 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3194">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3195">
            <paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3195">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3196">이 메서드는 제공 하는 COM 지원에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3196">This method is provided for COM support.</span></span> <span data-ttu-id="94b23-3197">네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework의 프로그램 Id는 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3197">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3198">다음 예에서는 ProgID 및 서버 이름을 전달 하 여 형식을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3198">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="94b23-3199">다음 예제를 ProgID 또는 서버 이름이 유효 하지 않은 경우 예외를 throw 할지를 지정 된 ProgID와 관련 된 ClassID를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3199">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3200">
            <paramref name="progID" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3200">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="94b23-3201">지정된 ProgID가 등록되어 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3201">The specified progID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="94b23-3202">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3202">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="94b23-3203">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3203">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="94b23-3204">Type 핸들을 가져올 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3204">The object for which to get the type handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3205">지정된 개체의 <see cref="T:System.Type" />에 대한 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3205">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3206">지정된 <see cref="T:System.Type" />의 <see cref="T:System.Object" />에 대한 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3206">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3207">핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3207">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3208">다음 예제에서는 클래스 정의 `MyClass1`인스턴스를 가져오고 개체의 런타임 핸들을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3208">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-3209">
            <paramref name="o" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3209">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3210">
            <see cref="T:System.Type" />과 관련된 GUID를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3210">Gets the GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3211">
            <see cref="T:System.Type" />과 관련된 GUID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3211">The GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3212">GUID가 사용 하 여 형식을 사용 하 여 연결 된 <xref:System.Runtime.InteropServices.GuidAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3212">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3213">다음 예제에서는 클래스를 만듭니다 `MyClass1` 공용 메서드를 사용 하 여 만듭니다를 `Type` 개체에 해당 하 `MyClass1`, 가져옵니다를 <xref:System.Guid> 구조체를 사용 하 여를 `GUID` 의 속성을 `Type` 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-3213">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3214">현재 <see cref="T:System.Type" />이 다른 형식을 포함하거나 참조하는지 여부, 즉 현재 <see cref="T:System.Type" />이 배열 또는 포인터이거나 참조로 전달되는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3214">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3215">
            <see langword="true" />이 배열 또는 포인터이거나 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3215">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3216">예를 들어 Type.GetType("Int32[]") 합니다. HasElementType 반환 `true`, 하지만 Type.GetType("Int32") 합니다. HasElementType 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3216">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="94b23-3217">HasElementType 반환 `true` "Int32 \*"에 대 한 및 "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="94b23-3217">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="94b23-3218">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수에이 속성은 항상 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3218">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3219">다음 예제에서는 반환 `true` 또는 `false` 개체의 배열, 참조 형식 또는 포인터 인지 여부에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3219">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3220">파생 클래스에서 재정의되면, <see cref="P:System.Type.HasElementType" /> 속성을 구현하고 현재 <see cref="T:System.Type" />이 다른 형식을 포함하거나 참조하는지 여부, 즉 현재 <see cref="T:System.Type" />이 배열 또는 포인터이거나 참조로 전달되는지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3220">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3221">
            <see langword="true" />이 배열 또는 포인터이거나 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3221">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3222">예를 들어 Type.GetType("Int32[]") 합니다. 에서는 반환 `true`, 하지만 Type.GetType("Int32") 합니다. 에서는 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3222">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="94b23-3223">에서는 또한 반환 `true` "Int32 \*"에 대 한 및 "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="94b23-3223">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3224">다음 예제에서는 클래스를 정의 `MyTypeDelegator`를 재정의 하는 `HasElementTypeImpl` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3224">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="94b23-3225">기본 클래스에 대 한 검사는 `HasElementType` 요소 입력 속성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3225">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3226">현재 <see cref="T:System.Type" />의 특정 멤버를 호출합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3226">Invokes a specific member of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-3227">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3227">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="94b23-3228">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3228">-or-</span>
          </span>
          <span data-ttu-id="94b23-3229">기본 멤버를 호출하는 빈 문자열("")입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3229">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="94b23-3230">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3230">-or-</span>
          </span>
          <span data-ttu-id="94b23-3231">
            <see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3231">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="94b23-3232">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3232">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-3233">액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3233">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="94b23-3234">조회 형식을 지정할 필요가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3234">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="94b23-3235">조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3235">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-3236">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3236">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-3237">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3237">-or-</span>
          </span>
          <span data-ttu-id="94b23-3238">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3238">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="94b23-3239">변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3239">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="94b23-3240">지정한 멤버를 호출할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3240">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="94b23-3241">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3241">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3242">지정된 바인딩 제약 조건과 인수 목록을 사용하여 지정된 멤버를 호출합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3242">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3243">호출된 멤버의 반환 값을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3243">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3244">사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3244">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="94b23-3245">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3245">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-3246">지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3246">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-3247">지정 `BindingFlags.NonPublic` 검색에서 (즉, private 및 protected 멤버) public이 아닌 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3247">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-3248">지정 `BindingFlags.FlattenHierarchy` 계층 정적 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3248">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="94b23-3249">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3249">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-3250">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3250">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-3251">`BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3251">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-3252">다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버를 사용 하 여 수행할 작업을 나타내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3252">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="94b23-3253">`CreateInstance` 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3253">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="94b23-3254">`name` 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3254">`name` is ignored.</span></span> <span data-ttu-id="94b23-3255">다른 호출 플래그를 사용 하 여 유효 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3255">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="94b23-3256">`InvokeMethod` 생성자 또는 형식 이니셜라이저가 없습니다 메서드를 하지만 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3256">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="94b23-3257">잘못 된 `SetField` 또는 `SetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3257">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="94b23-3258">하는 경우 `InvokeMethod` 자체에 의해 지정 됩니다 `BindingFlags.Public`를 `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3258">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="94b23-3259">`GetField` 에 필드의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3259">`GetField` to get the value of a field.</span></span> <span data-ttu-id="94b23-3260">잘못 된 `SetField`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3260">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="94b23-3261">`SetField` 필드의 값을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3261">`SetField` to set the value of a field.</span></span> <span data-ttu-id="94b23-3262">잘못 된 `GetField`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3262">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="94b23-3263">`GetProperty` 속성을 가져오기 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3263">`GetProperty` to get a property.</span></span> <span data-ttu-id="94b23-3264">잘못 된 `SetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3264">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="94b23-3265">`SetProperty` 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3265">`SetProperty` to set a property.</span></span> <span data-ttu-id="94b23-3266">잘못 된 `GetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3266">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="94b23-3267">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3267">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-3268">메서드는 다음 조건이 모두 참인 경우 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3268">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="94b23-3269">메서드 선언에서 매개 변수 수가 같음의 인수 개수는 `args` 배열 (기본 인수는 멤버에 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).</span><span class="sxs-lookup"><span data-stu-id="94b23-3269">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="94b23-3270">매개 변수의 형식 바인더를 통해 각 인수의 형식을 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3270">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="94b23-3271">바인더 모든 일치 하는 메서드를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3271">The binder will find all of the matching methods.</span></span> <span data-ttu-id="94b23-3272">요청 된 바인딩 형식에 따라 이러한 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등).</span><span class="sxs-lookup"><span data-stu-id="94b23-3272">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="94b23-3273">메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3273">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="94b23-3274">메서드를 선택한 후 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3274">After the method is selected, it is invoked.</span></span> <span data-ttu-id="94b23-3275">이때에 내게 필요한 옵션 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3275">Accessibility is checked at that point.</span></span> <span data-ttu-id="94b23-3276">검색은 메서드를 사용 하 여 연결 된 내게 필요한 옵션 특성에 따라 검색할 메서드의 집합을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3276">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="94b23-3277">합니다 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 메서드를 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3277">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="94b23-3278">기본 바인더를 가장 구체적으로 일치를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3278">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="94b23-3279">완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 무시 됩니다. 즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수를 통해 호출 <xref:System.Reflection> 때마다 코드는 완전히 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3279">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="94b23-3280">사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 하려면 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3280">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="94b23-3281">예를 들어, 클래스 C F에 F 라는 공용 인스턴스 필드를 설정 하려는 경우는 `String`와 같은 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3281">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="94b23-3282">F가는 `String[]`와 같은 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3282">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="94b23-3283">이 새 배열 F 필드가 초기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3283">which will initialize the field F to this new array.</span></span> <span data-ttu-id="94b23-3284">사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:</span><span class="sxs-lookup"><span data-stu-id="94b23-3284">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="94b23-3285">이 문자열 "z" F "b" 문자열을 포함 하는 배열에서 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3285">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="94b23-3286">호출 하는 경우는 `IDispatch` 멤버의 경우 DispID 멤버 이름 대신 문자열 형식을 사용 하 여 지정할 수 있습니다 "[DispID = # #]"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3286">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="94b23-3287">예를 들어 MyComMethod dispid가 3 인 경우 문자열을 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3287">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="94b23-3288">DispID로 멤버를 호출 하는 것은 멤버 이름으로 조회 보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3288">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="94b23-3289">복잡 한 집계 시나리오의 경우 DispID의 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3289">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3290">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3290">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="94b23-3291">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="94b23-3291">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="94b23-3292">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3292">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3293">다음 예제에서는 `InvokeMember` 형식의 멤버에 액세스 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3293">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-3294">
            <paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3294">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3295">
            <paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3295">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="94b23-3296">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3296">-or-</span>
          </span>
          <span data-ttu-id="94b23-3297">
            <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3297">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3298">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3298">-or-</span>
          </span>
          <span data-ttu-id="94b23-3299">
            <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3299">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3300">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3300">-or-</span>
          </span>
          <span data-ttu-id="94b23-3301">
            <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3301">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="94b23-3302">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3302">-or-</span>
          </span>
          <span data-ttu-id="94b23-3303">
            <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3303">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3304">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3304">-or-</span>
          </span>
          <span data-ttu-id="94b23-3305">
            <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3305">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3306">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3306">-or-</span>
          </span>
          <span data-ttu-id="94b23-3307">
            <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3307">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="94b23-3308">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3308">-or-</span>
          </span>
          <span data-ttu-id="94b23-3309">이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3309">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3310">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3310">-or-</span>
          </span>
          <span data-ttu-id="94b23-3311">명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3311">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="94b23-3312">지정된 멤버가 클래스 이니셜라이저입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3312">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="94b23-3313">필드 또는 속성을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3313">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="94b23-3314">
            <paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3314">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="94b23-3315">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3315">-or-</span>
          </span>
          <span data-ttu-id="94b23-3316">현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3316">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="94b23-3317">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3317">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-3318">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3318">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-3319">.NET Compact Framework에서는 현재 이 메서드를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3319">The .NET Compact Framework does not currently support this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-3320">
            <paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3320">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="94b23-3321">즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3321">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="94b23-3322">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3322">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="94b23-3323">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3323">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="94b23-3324">비관리 코드를 호출 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3324">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="94b23-3325">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3325">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-3326">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3326">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="94b23-3327">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3327">-or-</span>
          </span>
          <span data-ttu-id="94b23-3328">기본 멤버를 호출하는 빈 문자열("")입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3328">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="94b23-3329">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3329">-or-</span>
          </span>
          <span data-ttu-id="94b23-3330">
            <see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3330">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="94b23-3331">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3331">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-3332">액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3332">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="94b23-3333">조회 형식을 지정할 필요가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3333">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="94b23-3334">조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3334">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-3335">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3335">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-3336">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3336">-or-</span>
          </span>
          <span data-ttu-id="94b23-3337">
            <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3337">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="94b23-3338">변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3338">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="94b23-3339">지정한 멤버를 호출할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3339">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="94b23-3340">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3340">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="94b23-3341">사용할 전역화 로캘을 나타내는 개체입니다. 이 개체는 숫자 <see cref="T:System.String" />을 <see cref="T:System.Double" />로 변환하는 등의 로캘별 변환에 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3341">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span>
          </span>
          <span data-ttu-id="94b23-3342">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3342">-or-</span>
          </span>
          <span data-ttu-id="94b23-3343">현재 스레드의 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="T:System.Globalization.CultureInfo" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3343">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3344">지정된 바인딩 제약 조건과 지정된 인수 목록 및 문화권을 사용하여 지정된 멤버를 호출합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3344">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3345">호출된 멤버의 반환 값을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3345">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3346">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Globalization.CultureInfo> (합니다 `culture` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `culture`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3346">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3347">사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3347">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="94b23-3348">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3348">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-3349">지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3349">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-3350">지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3350">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-3351">지정 `BindingFlags.FlattenHierarchy` 계층 정적 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3351">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="94b23-3352">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3352">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-3353">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3353">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-3354">`BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3354">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-3355">다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버를 사용 하 여 수행할 작업을 나타내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3355">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="94b23-3356">`CreateInstance` 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3356">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="94b23-3357">`name` 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3357">`name` is ignored.</span></span> <span data-ttu-id="94b23-3358">다른 호출 플래그를 사용 하 여 유효 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3358">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="94b23-3359">`InvokeMethod` 생성자 또는 형식 이니셜라이저가 없습니다 메서드를 하지만 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3359">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="94b23-3360">잘못 된 `SetField` 또는 `SetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3360">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="94b23-3361">하는 경우 `InvokeMethod` 자체에 의해 지정 됩니다 `BindingFlags.Public`를 `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3361">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="94b23-3362">`GetField` 에 필드의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3362">`GetField` to get the value of a field.</span></span> <span data-ttu-id="94b23-3363">잘못 된 `SetField`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3363">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="94b23-3364">`SetField` 필드의 값을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3364">`SetField` to set the value of a field.</span></span> <span data-ttu-id="94b23-3365">잘못 된 `GetField`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3365">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="94b23-3366">`GetProperty` 속성을 가져오기 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3366">`GetProperty` to get a property.</span></span> <span data-ttu-id="94b23-3367">잘못 된 `SetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3367">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="94b23-3368">`SetProperty` 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3368">`SetProperty` to set a property.</span></span> <span data-ttu-id="94b23-3369">잘못 된 `GetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3369">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="94b23-3370">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3370">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-3371">메서드는 다음 조건이 모두 참인 경우 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3371">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="94b23-3372">메서드 선언에서 매개 변수 수가 같음의 인수 개수는 `args` 배열 (기본 인수는 멤버에 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).</span><span class="sxs-lookup"><span data-stu-id="94b23-3372">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="94b23-3373">매개 변수의 형식 바인더를 통해 각 인수의 형식을 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3373">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="94b23-3374">바인더 모든 일치 하는 메서드를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3374">The binder will find all of the matching methods.</span></span> <span data-ttu-id="94b23-3375">요청 된 바인딩 형식에 따라 이러한 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등).</span><span class="sxs-lookup"><span data-stu-id="94b23-3375">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="94b23-3376">메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3376">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="94b23-3377">메서드를 선택한 후 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3377">After the method is selected, it is invoked.</span></span> <span data-ttu-id="94b23-3378">이때에 내게 필요한 옵션 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3378">Accessibility is checked at that point.</span></span> <span data-ttu-id="94b23-3379">검색은 메서드를 사용 하 여 연결 된 내게 필요한 옵션 특성에 따라 검색할 메서드의 집합을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3379">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="94b23-3380">합니다 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 메서드를 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3380">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="94b23-3381">기본 바인더를 가장 구체적으로 일치를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3381">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="94b23-3382">완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 무시 됩니다. 즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 통해 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3382">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="94b23-3383">사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 하려면 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3383">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="94b23-3384">예를 들어, 클래스 C F에 F 라는 공용 인스턴스 필드를 설정 하려는 경우는 `String` 와 같은 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3384">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="94b23-3385">F가는 `String[]`와 같은 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3385">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="94b23-3386">이 새 배열 F 필드가 초기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3386">which will initialize the field F to this new array.</span></span> <span data-ttu-id="94b23-3387">사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:</span><span class="sxs-lookup"><span data-stu-id="94b23-3387">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="94b23-3388">이 문자열 "z" F "b" 문자열을 포함 하는 배열에서 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3388">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="94b23-3389">호출 하는 경우는 `IDispatch` 멤버의 경우 DispID 멤버 이름 대신 문자열 형식을 사용 하 여 지정할 수 있습니다 "[DispID = # #]"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3389">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="94b23-3390">예를 들어 MyComMethod dispid가 3 인 경우 문자열을 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3390">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="94b23-3391">DispID로 멤버를 호출 하는 것은 멤버 이름으로 조회 보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3391">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="94b23-3392">복잡 한 집계 시나리오의 경우 DispID의 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3392">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3393">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3393">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="94b23-3394">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="94b23-3394">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="94b23-3395">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3395">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-3396">
            <paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3396">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3397">
            <paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3397">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="94b23-3398">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3398">-or-</span>
          </span>
          <span data-ttu-id="94b23-3399">
            <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3399">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3400">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3400">-or-</span>
          </span>
          <span data-ttu-id="94b23-3401">
            <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3401">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3402">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3402">-or-</span>
          </span>
          <span data-ttu-id="94b23-3403">
            <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3403">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="94b23-3404">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3404">-or-</span>
          </span>
          <span data-ttu-id="94b23-3405">
            <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3405">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3406">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3406">-or-</span>
          </span>
          <span data-ttu-id="94b23-3407">
            <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3407">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3408">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3408">-or-</span>
          </span>
          <span data-ttu-id="94b23-3409">
            <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3409">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="94b23-3410">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3410">-or-</span>
          </span>
          <span data-ttu-id="94b23-3411">이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3411">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3412">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3412">-or-</span>
          </span>
          <span data-ttu-id="94b23-3413">명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3413">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="94b23-3414">지정된 멤버가 클래스 이니셜라이저입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3414">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="94b23-3415">필드 또는 속성을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3415">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="94b23-3416">
            <paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3416">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="94b23-3417">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3417">-or-</span>
          </span>
          <span data-ttu-id="94b23-3418">현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3418">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="94b23-3419">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3419">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-3420">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3420">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-3421">
            <paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3421">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="94b23-3422">즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3422">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="94b23-3423">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3423">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="94b23-3424">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3424">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="94b23-3425">비관리 코드를 호출 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3425">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="94b23-3426">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="94b23-3427">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3427">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="94b23-3428">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3428">-or-</span>
          </span>
          <span data-ttu-id="94b23-3429">기본 멤버를 호출하는 빈 문자열("")입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3429">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="94b23-3430">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3430">-or-</span>
          </span>
          <span data-ttu-id="94b23-3431">
            <see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3431">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="94b23-3432">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3432">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="94b23-3433">액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3433">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="94b23-3434">조회 형식을 지정할 필요가 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3434">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="94b23-3435">조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3435">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="94b23-3436">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3436">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="94b23-3437">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3437">-or-</span>
          </span>
          <span data-ttu-id="94b23-3438">
            <see cref="P:System.Type.DefaultBinder" />를 사용할 null 참조(Visual Basic에는 없음)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3438">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="94b23-3439">변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3439">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="94b23-3440">지정한 멤버를 호출할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3440">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="94b23-3441">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3441">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="94b23-3442">
            <c>args</c> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3442">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="94b23-3443">매개 변수의 관련 특성은 해당 멤버의 시그니처에 저장됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3443">A parameter's associated attributes are stored in the member's signature.</span>
          </span>
          <span data-ttu-id="94b23-3444">기본 바인더는 COM 구성 요소를 호출하는 경우에만 이 매개 변수를 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3444">The default binder processes this parameter only when calling a COM component.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="94b23-3445">사용할 전역화 로캘을 나타내는 <see cref="T:System.Globalization.CultureInfo" /> 개체입니다. 이 개체는 숫자 String을 Double로 변환하는 등의 로캘 관련 변환에 사용할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3445">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span>
          </span>
          <span data-ttu-id="94b23-3446">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3446">-or-</span>
          </span>
          <span data-ttu-id="94b23-3447">현재 스레드의 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="T:System.Globalization.CultureInfo" />)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3447">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="94b23-3448">
            <c>args</c> 배열의 값이 전달될 매개 변수의 이름이 있는 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3448">An array containing the names of the parameters to which the values in the <c>args</c> array are passed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3449">파생 클래스에서 재정의되면, 지정된 바인딩 제약 조건과 지정된 인수 목록, 한정자 및 문화권을 사용하여 지정된 멤버를 호출합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3449">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3450">호출된 멤버의 반환 값을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3450">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3451">`InvokeMember` 생성자 멤버 또는 메서드 멤버를 호출, 가져옵니다 또는 속성 멤버를 설정, 또는 데이터 필드 멤버, 집합 또는 가져옵니다 가져오거나 배열 멤버의 요소.</span><span class="sxs-lookup"><span data-stu-id="94b23-3451">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3452">사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3452">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="94b23-3453">호출 하는 경우는 `IDispatch` 멤버의 경우 DispID 멤버 이름 대신 문자열 형식을 사용 하 여 지정할 수 있습니다 "[DispID = # #]"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3453">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="94b23-3454">예를 들어 MyComMethod dispid가 3 인 경우 문자열을 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3454">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="94b23-3455">DispID로 멤버를 호출 하는 것은 멤버 이름으로 조회 보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3455">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="94b23-3456">복잡 한 집계 시나리오의 경우 DispID의 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3456">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="94b23-3457">기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> 또는 <xref:System.Globalization.CultureInfo> (합니다 `modifiers` 및 `culture` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스에서 처리 하는 사용자 지정 바인더를 작성할 `modifiers` 및 `culture`.</span><span class="sxs-lookup"><span data-stu-id="94b23-3457">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="94b23-3458">`ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3458">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="94b23-3459">`namedParameters` 배열의 각 매개 변수는 `args` 배열에 있는 해당 요소의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3459">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="94b23-3460">`args`의 길이가 `namedParameters`의 길이보다 크면 나머지 인수 값은 순서대로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3460">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="94b23-3461">`namedParameters` 배열 입력 배열의 인수 순서를 변경 하려면 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3461">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="94b23-3462">예를 들어 메서드를 제공 `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` Visual Basic의) 및 입력된 배열의 `{ 42, "x" }`, 입력된 배열이 변경 되지 않고 전달 될 수 있습니다 `args` 경우 배열 `{ "b", "a" }` 제공 되어 `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="94b23-3462">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="94b23-3463">다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3463">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="94b23-3464">지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3464">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="94b23-3465">지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3465">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="94b23-3466">지정 `BindingFlags.FlattenHierarchy` 계층 정적 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3466">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="94b23-3467">다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3467">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="94b23-3468">`BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3468">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="94b23-3469">`BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3469">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="94b23-3470">다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버를 사용 하 여 수행할 작업을 나타내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3470">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="94b23-3471">`CreateInstance` 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3471">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="94b23-3472">`name` 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3472">`name` is ignored.</span></span> <span data-ttu-id="94b23-3473">다른 호출 플래그를 사용 하 여 유효 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3473">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="94b23-3474">`InvokeMethod` 생성자 또는 형식 이니셜라이저가 없습니다 메서드를 하지만 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3474">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="94b23-3475">잘못 된 `SetField` 또는 `SetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3475">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="94b23-3476">하는 경우 `InvokeMethod` 자체에 의해 지정 됩니다 `BindingFlags.Public`를 `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3476">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="94b23-3477">`GetField` 에 필드의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3477">`GetField` to get the value of a field.</span></span> <span data-ttu-id="94b23-3478">잘못 된 `SetField`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3478">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="94b23-3479">`SetField` 필드의 값을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3479">`SetField` to set the value of a field.</span></span> <span data-ttu-id="94b23-3480">잘못 된 `GetField`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3480">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="94b23-3481">`GetProperty` 속성을 가져오기 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3481">`GetProperty` to get a property.</span></span> <span data-ttu-id="94b23-3482">잘못 된 `SetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3482">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="94b23-3483">`SetProperty` 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3483">`SetProperty` to set a property.</span></span> <span data-ttu-id="94b23-3484">잘못 된 `GetProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3484">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="94b23-3485">자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3485">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="94b23-3486">메서드는 다음 조건이 모두 참인 경우 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3486">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="94b23-3487">메서드 선언에서 매개 변수 수가 같음의 인수 개수는 `args` 배열 (기본 인수는 멤버에 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).</span><span class="sxs-lookup"><span data-stu-id="94b23-3487">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="94b23-3488">매개 변수의 형식 바인더를 통해 각 인수의 형식을 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3488">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="94b23-3489">바인더 모든 일치 하는 메서드를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3489">The binder will find all of the matching methods.</span></span> <span data-ttu-id="94b23-3490">요청 된 바인딩 형식에 따라 이러한 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등).</span><span class="sxs-lookup"><span data-stu-id="94b23-3490">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="94b23-3491">메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3491">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="94b23-3492">메서드를 선택한 후 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3492">After the method is selected, it is invoked.</span></span> <span data-ttu-id="94b23-3493">이때에 내게 필요한 옵션 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3493">Accessibility is checked at that point.</span></span> <span data-ttu-id="94b23-3494">검색은 메서드를 사용 하 여 연결 된 내게 필요한 옵션 특성에 따라 검색할 메서드의 집합을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3494">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="94b23-3495">합니다 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 메서드를 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3495">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="94b23-3496">기본 바인더를 가장 구체적으로 일치를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3496">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="94b23-3497">`InvokeMember` 기본값이 있는 매개 변수를 사용 하 여 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3497">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="94b23-3498">이러한 메서드에 바인딩할 리플렉션 해야 <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> 를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3498">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="94b23-3499">기본값이 있는 매개 변수에 다른 값을 제공 하거나 제공 <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> 에 기본값을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3499">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="94b23-3500">예를 들어 MyMethod와 같은 메서드 (int x, y float 2.0 =) 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3500">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="94b23-3501">MyMethod(4)로 첫 번째 인수에만 사용 하 여이 메서드를 호출 하려면 위의 바인딩 플래그 중 하나를 전달 하 고 첫 번째 인수에 대 한 4 즉, 두 가지 인수를 전달 하 고 `Missing.Value` 두 번째 인수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3501">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="94b23-3502">사용 하지 않는 경우 `Missing.Value`를 사용 하 여 선택적 매개 변수를 생략할 수 없습니다는 `Invoke` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3502">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="94b23-3503">이렇게 해야 하는 경우 사용 하 여 `InvokeMember` 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3503">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="94b23-3504">완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 무시 됩니다. 즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수를 통해 호출 <xref:System.Reflection> 때마다 코드는 완전히 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3504">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="94b23-3505">사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 하려면 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3505">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="94b23-3506">예를 들어, 클래스 C F에 F 라는 공용 인스턴스 필드를 설정 하려는 경우는 `String`와 같은 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3506">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="94b23-3507">F가는 `String[]`와 같은 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3507">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="94b23-3508">이 새 배열 F 필드가 초기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3508">which will initialize the field F to this new array.</span></span> <span data-ttu-id="94b23-3509">사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:</span><span class="sxs-lookup"><span data-stu-id="94b23-3509">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="94b23-3510">이 문자열 "z" F "b" 문자열을 포함 하는 배열에서 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3510">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3511">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3511">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="94b23-3512">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="94b23-3512">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="94b23-3513">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3513">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-3514">
            <paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3514">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3515">
            <paramref name="args" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3515">
              <paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
          <span data-ttu-id="94b23-3516">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3516">-or-</span>
          </span>
          <span data-ttu-id="94b23-3517">
            <paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3517">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="94b23-3518">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3518">-or-</span>
          </span>
          <span data-ttu-id="94b23-3519">
            <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3519">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3520">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3520">-or-</span>
          </span>
          <span data-ttu-id="94b23-3521">
            <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3521">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3522">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3522">-or-</span>
          </span>
          <span data-ttu-id="94b23-3523">
            <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3523">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="94b23-3524">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3524">-or-</span>
          </span>
          <span data-ttu-id="94b23-3525">
            <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3525">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3526">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3526">-or-</span>
          </span>
          <span data-ttu-id="94b23-3527">
            <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3527">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3528">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3528">-or-</span>
          </span>
          <span data-ttu-id="94b23-3529">
            <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3529">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="94b23-3530">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3530">-or-</span>
          </span>
          <span data-ttu-id="94b23-3531">명명된 매개 변수 배열이 인수 배열보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3531">The named parameter array is larger than the argument array.</span>
          </span>
          <span data-ttu-id="94b23-3532">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3532">-or-</span>
          </span>
          <span data-ttu-id="94b23-3533">이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3533">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="94b23-3534">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3534">-or-</span>
          </span>
          <span data-ttu-id="94b23-3535">명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3535">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="94b23-3536">지정된 멤버가 클래스 이니셜라이저입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3536">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="94b23-3537">필드 또는 속성을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3537">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="94b23-3538">
            <paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3538">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="94b23-3539">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3539">-or-</span>
          </span>
          <span data-ttu-id="94b23-3540">인수 이름이 제공된 멤버를 <paramref name="namedParameters" />에서 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3540">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span>
          </span>
          <span data-ttu-id="94b23-3541">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3541">-or-</span>
          </span>
          <span data-ttu-id="94b23-3542">현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3542">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="94b23-3543">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3543">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="94b23-3544">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3544">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-3545">
            <paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3545">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="94b23-3546">즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3546">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="94b23-3547">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3547">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="94b23-3548">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3548">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="94b23-3549">비관리 코드를 호출 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3549">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="94b23-3550">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3550">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3551">
            <see cref="T:System.Type" />이 추상이며 재정의되어야 하는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3551">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3552">
            <see cref="T:System.Type" />이 추상이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3552">
              <see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3553">합니다 <xref:System.Type.IsAbstract%2A> 속성이 반환 `true` 다음과 같은 경우:</span><span class="sxs-lookup"><span data-stu-id="94b23-3553">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="94b23-3554">현재 형식이 추상; 즉, 인스턴스화할 수 없으며, 되지만 파생된 클래스에 대 한 기본 클래스로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3554">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="94b23-3555">C#에서 추상 클래스는 표시 됩니다는 [추상](~/docs/csharp/language-reference/keywords/abstract.md) 키워드를 사용 하 여 표시 된 Visual basic에서는 합니다 [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) 키워드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3555">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="94b23-3556">현재 형식이 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3556">The current type is an interface.</span></span>  
  
 <span data-ttu-id="94b23-3557">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3558">다음 예제에서는 배열을 <xref:System.Type> 다음 형식을 나타내는 개체: 형식 반환을 포함 `true` 지정 된 개체가 `abstract`이 고, 그렇지 않으면 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3558">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="94b23-3559">`AbstractClass`추상 클래스 (클래스로 표시 `abstract` C# 및 `MustInherit` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-3559">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="94b23-3560">`DerivedClass`를 클래스에서 상속 되는 `AbstractClass`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3560">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="94b23-3561">`SingleClass`에서 상속할 수 없는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3561">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="94b23-3562">로 정의 되어 있으므로 `sealed` C# 및 `NotInheritable` Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3562">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="94b23-3563">`ITypeInfo`에 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3563">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="94b23-3564">`ImplementingClass`를 구현 하는 클래스는 `ITypeInfo` 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3564">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="94b23-3565">메서드는 반환 `true` 동안만 `AbstractClass`, 추상 클래스 및 `ITypeInfo`, 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3565">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3566">
            <see langword="AnsiClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3566">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3567">
            <see langword="true" />에 대해 문자열 형식 특성 <see langword="AnsiClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3567">
              <see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3568"><xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3568">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="94b23-3569">문자열을 해석할 방법을 정의 하 여 상호 운용성을 개선 하는 문자열 형식 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3569">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="94b23-3570">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3570">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3571">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3571">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-3572">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3572">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3573">다음 예에서는 필드 정보를 가져와 확인 된 `AnsiClass` 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3573">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3574">유형이 배열인지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3574">Gets a value that indicates whether the type is an array.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3575">현재 유형이 배열이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3575">
              <see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3576">합니다 <xref:System.Type.IsArray%2A> 속성이 반환 `false` 에 대 한는 <xref:System.Array> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3576">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="94b23-3577">또한 반환 `false` 현재 인스턴스가 <xref:System.Type> 컬렉션 형식 또는 컬렉션과 같은 작동 하도록 디자인 된 인터페이스를 나타내는 개체입니다 <xref:System.Collections.IEnumerable> 또는 <xref:System.Collections.Generic.IEnumerable%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3577">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="94b23-3578">배열에 대해 검사할 코드를 같이 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3578">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="94b23-3579">이 속성은 항상 현재 형식이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수나 제네릭 형식을 나타내면 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3579">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3580">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3580">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3581">다음 예제는 <xref:System.Type.IsArray%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3581">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3582">파생 클래스에서 재정의되면, <see cref="P:System.Type.IsArray" /> 속성을 구현하고 <see cref="T:System.Type" />이 배열인지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3582">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3583">
            <see langword="true" />이 배열이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3583">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3584">인스턴스를 <xref:System.Array> 클래스를 반환 해야 `false` 배열이 아닌 개체 이기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3584">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3585">다음 예제에서는 재정의 `IsArrayImpl` 의 메서드는 `MyTypeDelegator` 클래스 변수 배열 및 결과 표시 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3585">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="94b23-3586">현재 형식과 비교할 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3586">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3587">지정한 형식의 인스턴스를 현재 형식의 인스턴스에 할당할 수 있는지 여부를 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3587">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3588">다음 조건 중 하나 이상이 true일 경우 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3588">
              <see langword="true" /> if any of the following conditions is true:</span>
          </span>
          <span data-ttu-id="94b23-3589">
-   <paramref name="c" /> 및 현재 인스턴스가 동일한 형식으로 나타납니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3589">
-   <paramref name="c" /> and the current instance represent the same type.</span>
          </span>
          <span data-ttu-id="94b23-3590">
-   <paramref name="c" />가 현재 인스턴스에서 직접 또는 간접으로 파생됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3590">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span>
          </span>
          <span data-ttu-id="94b23-3591">현재 인스턴스에서 상속하는 경우 <paramref name="c" />는 현재 인스턴스에서 직접 파생되며 현재 인스턴스에서 상속하는 하나 이상의 클래스의 연속에서 상속하는 경우 <paramref name="c" />는 현재 인스턴스에서 직접 파생됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3591">
              <paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span>
          </span>
          <span data-ttu-id="94b23-3592">-  현재 인스턴스는 <paramref name="c" />를 구현하는 인터페이스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3592">-   The current instance is an interface that <paramref name="c" /> implements.</span>
          </span>
          <span data-ttu-id="94b23-3593">
-   <paramref name="c" />는 제네릭 형식 매개 변수이며, 현재 인스턴스는 <paramref name="c" />의 제약 조건 중 하나를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3593">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span>
          </span>
          <span data-ttu-id="94b23-3594">다음 예제에서 현재 인스턴스는 <see cref="T:System.IO.Stream" /> 클래스를 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3594">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span>
          </span>
          <span data-ttu-id="94b23-3595">
            <c>GenericWithConstraint</c>는 제네릭 형식 매개 변수가 <see cref="T:System.IO.Stream" /> 형식이어야 하는 제네릭 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3595">
              <c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span>
          </span>
          <span data-ttu-id="94b23-3596">
            <see cref="M:System.Type.IsAssignableFrom(System.Type)" />에 제네릭 형식 매개 변수를 전달하는 것은 제네릭 형식 매개 변수의 인스턴스를 <see cref="T:System.IO.Stream" /> 개체에 할당할 수 있음을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3596">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span>
          </span>
          <span data-ttu-id="94b23-3597">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3597">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span>
          </span>
          <span data-ttu-id="94b23-3598">
-   <paramref name="c" />는 값 유형을 나타내며 현재 인스턴스는 <c>Nullable&lt;c&gt;</c>(Visual Basic에서 <c>Nullable(Of c)</c>)를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3598">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span>
          </span>
          <span data-ttu-id="94b23-3599">이러한 조건에 해당하지 않거나 <paramref name="c" />가 <see langword="false" />이면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3599">
              <see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3600">합니다 <xref:System.Type.IsAssignableFrom%2A> 인스턴스의 여부를 확인 하려면 메서드를 사용할 수 `c` 할당할 수 있습니다 현재 형식의 인스턴스에 메서드 디자인 타임에 형식이 알려지지 않은 개체를 처리 하는 경우 가장 유용 하 고 조건부 허용 다음 예제와 같이 할당을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3600">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="94b23-3601">이 메서드 따라서를 사용 하면 다음이 런타임에 throw 하지 않고 실행 됩니다와 같은 코드 줄을 <xref:System.InvalidCastException> 예외 또는 유사한 예외:</span><span class="sxs-lookup"><span data-stu-id="94b23-3601">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="94b23-3602">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3602">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3603">제네릭 형식 정의 폐쇄형된 생성된 형식에서 할당할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-3603">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="94b23-3604">즉, 폐쇄형된 생성된 형식을 할당할 수 없습니다 `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual basic에서) 형식의 변수에 `MyGenericList<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3604">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="94b23-3605">경우는 `c` 매개 변수는 형식 <xref:System.Reflection.Emit.TypeBuilder>, 결과 빌드하는 형식에 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3605">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="94b23-3606">다음 코드 예제에서는이 라는 기본 제공된 형식을 사용 하 여 `B`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3606">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3607">다음 예제는 `IsAssignableFrom` 정의 된 클래스, 정수 배열 및 제네릭 메서드를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3607">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3608">
            <see langword="AutoClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3608">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3609">
            <see langword="true" />에 대해 문자열 형식 특성 <see langword="AutoClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3609">
              <see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3610"><xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3610">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="94b23-3611">문자열을 해석할 방법을 정의 하 여 상호 운용성을 개선 하는 문자열 형식 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3611">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="94b23-3612">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3612">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3613">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3613">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-3614">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3614">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3615">현재 형식의 필드가 공용 언어 런타임에 의해 자동으로 배치되는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3615">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3616">현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3616">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3617">이 속성은 편의 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3617">This property is provided as a convenience.</span></span> <span data-ttu-id="94b23-3618">사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 열거형 값 형식 레이아웃 특성 및 다음 테스트를 여부 선택 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3618">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="94b23-3619"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드는 메모리에 배치 하는 방법을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3619">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="94b23-3620">동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 유형을 만들 때.</span><span class="sxs-lookup"><span data-stu-id="94b23-3620">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="94b23-3621">코드에 적용 합니다 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성을 <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> 클래스의 레이아웃에 적절 한 방법을 결정 하는 런타임 수 있도록 형식에 열거형 값입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3621">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3622">사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 결정 하는 방법 여부를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3622">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="94b23-3623">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3623">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3624">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="94b23-3624">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="94b23-3625">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3625">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3626">다음 예제에서는 형식의 인스턴스를 만들고 표시는 <xref:System.Type.IsAutoLayout%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3626">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">
          <span data-ttu-id="94b23-3627">메타데이터 및 자동 기술 구성 요소</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3627">Metadata and Self-Describing Components</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3628">
            <see cref="T:System.Type" />이 참조로 전달되는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3628">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3629">
            <see langword="true" />이 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3629">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3630">실제 형식으로 가져오려고 역참조 참조로 전달 된 형식 및 호출 <xref:System.Type.GetElementType%2A> 해당 형식에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3630">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3631">다음 예제를 사용 하는 방법을 보여 줍니다는 `IsByRef` 속성을 지정된 된 형식 참조로 전달 되는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3631">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="94b23-3632">이 예제에서는 클래스를 정의 `MyTypeDelegator`를 재정의 하는 `HasElementTypeImpl` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3632">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="94b23-3633">기본 클래스에 대 한 검사는 `HasElementType` 요소 입력 속성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3633">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3634">파생 클래스에서 재정의되면, <see cref="P:System.Type.IsByRef" /> 속성을 구현하고 <see cref="T:System.Type" />이 참조로 전달되는지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3634">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3635">
            <see langword="true" />이 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3635">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3636">
            <see cref="T:System.Type" />이 클래스 혹은 대리자인지, 즉 값 형식 또는 인터페이스가 아닌지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3636">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3637">
            <see langword="true" />이 클래스이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3637">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3638">이 속성은 반환 `true` 대리자 뿐만 아니라 클래스에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3638">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="94b23-3639">반환 `false` 형식에 대해 값 (구조 및 enumeration) boxed 됩니다 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3639">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="94b23-3640">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `true`합니다. 하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 생성된 된 제네릭 형식을 나타내는 `true` 제네릭 형식 정의가 클래스 정의; 경우 즉, 정의 하지 않습니다 인터페이스 또는 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3640">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3641">이 속성은 반환 `true` 에 대 한 `Type` 나타내는 인스턴스를 <xref:System.Enum> 및 <xref:System.ValueType> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3641">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="94b23-3642">이러한 두 클래스는 각각 된 열거형에 대 한 기본 형식 및 값 형식에 있지만 열거형 또는 값 형식 자체는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3642">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="94b23-3643">자세한 내용은 참조는 <xref:System.Type.IsValueType%2A> 및 <xref:System.Type.IsEnum%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3643">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="94b23-3644"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 클래스 또는 인터페이스 형식 선언의 구별 하는 열거형 값입니다. 그러나 클래스 및 값 형식이 둘 다로 표시 됩니다는는 <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3644">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="94b23-3645">형식의 특성 속성을 사용 하 여 값을 검색 하는 경우는 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 도 호출 해야 합니다는 형식이 값 형식이 아닌 클래스 인지 확인 하는 값을 <xref:System.Type.IsValueType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3645">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="94b23-3646">에 대 한 예제는 <xref:System.Reflection.TypeAttributes> 열거형 anexample 뿐만 아니라 추가 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3646">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="94b23-3647">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3647">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3648">다음 예제에서는 형식의 인스턴스를 만들고이 형식이 클래스 인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3648">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3649">
            <see cref="T:System.Type" />이 COM 개체인지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3649">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3650">
            <see langword="true" />이 COM 개체이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3650">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3651">이 메서드가 반환 `false` 개체 하지 않기 때문에 COM 인터페이스에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3651">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="94b23-3652">Microsoft.NET Framework 개체에서 COM 인터페이스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3652">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="94b23-3653">또한 COM 클래스를 로드 하 고 받을 수는 `Type` 를 사용 하 여 해당 COM 클래스에 대 한 개체를 [Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구.</span><span class="sxs-lookup"><span data-stu-id="94b23-3653">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="94b23-3654">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3654">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3655">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int`> (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3655">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-3656">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3656">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3657">파생 클래스에서 재정의되면, <see cref="P:System.Type.IsCOMObject" /> 속성을 구현하고 <see cref="T:System.Type" />이 COM 개체인지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3657">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3658">
            <see langword="true" />이 COM 개체이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3658">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3659">이 메서드가 반환 `false` 개체 하지 않기 때문에 COM 인터페이스에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3659">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="94b23-3660">Microsoft.NET Framework 개체에서 COM 인터페이스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3660">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3661">이 개체가 생성된 제네릭 형식을 나타내는지를 지정하는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3661">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
          <span data-ttu-id="94b23-3662">생성된 제네릭 형식의 인스턴스를 만들 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3662">You can create instances of a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3663">이 개체가 생성된 제네릭 형식을 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3663">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3664">생성된 된 제네릭 형식을 명시적 형식을 해당 제네릭 형식 매개 변수를 모두 제공 했습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3664">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="94b23-3665">이 닫힌된 제네릭 형식을 라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3665">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="94b23-3666">이 속성이 `true`, 현재 형식의 인스턴스를 만들 수 있습니다. 즉, 경우 `false`를 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3666">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3667">
            <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3667">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3668">
            <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3668">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3669">컨텍스트는 클래스 멤버에 대 한 호출을 가로채서 동기화와 같이 클래스에 적용 되는 정책을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3669">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="94b23-3670">원격 컨텍스트에 대 한 정보를 자세한 참조 <xref:System.Runtime.Remoting.Contexts.Context>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3670">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="94b23-3671">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3671">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3672">다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성을 <xref:System.Type> 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-3672">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="94b23-3673">그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 인지 컨텍스트에서 지정된 된 형식의 호스팅할 수 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3673">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3674">
            <see cref="P:System.Type.IsContextful" /> 속성을 구현하고, <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있는지 여부를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3674">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3675">
            <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3675">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3676">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3676">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="94b23-3677">컨텍스트는 클래스 멤버에 대 한 호출을 가로채서 동기화와 같이 클래스에 적용 되는 정책을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3677">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3678">다음 예제를 사용 하는 방법을 보여 줍니다는 `IsContextfulImpl` 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3678">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3679">
            <see cref="T:System.Type" />이 열거형을 나타내는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3679">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3680">현재 <see langword="true" />이 열거형을 나타내면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3680">
              <see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3681">이 속성은 반환 `true` 열거형에 대 한는 <xref:System.Enum> 자체를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3681">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="94b23-3682">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3682">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3683">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3683">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-3684">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3684">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3685">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3685">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3686">다음 예제에서는 사용 하는 방법에 설명 합니다 `IsEnum` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3686">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="94b23-3687">테스트할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3687">The value to be tested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3688">현재 열거형 형식에 지정된 값이 있는지를 나타내는 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3688">Returns a value that indicates whether the specified value exists in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3689">지정된 값이 현재 열거형 형식의 멤버이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3689">
              <see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-3690">현재 형식은 열거형이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3690">The current type is not an enumeration.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-3691">
            <paramref name="value" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3691">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-3692">
            <paramref name="value" />는 열거형의 내부 형식이 될 수 없는 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3692">
              <paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="94b23-3693">현재 형식과 같은지 테스트되는 COM 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3693">The COM type that is tested for equivalence with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3694">두 COM 형식이 같은 ID를 갖고 동일 형식이 될 수 있는지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3694">Determines whether two COM types have the same identity and are eligible for type equivalence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3695">COM 형식이 현재 형식과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3695">
              <see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="94b23-3696">한 형식은 실행하기 위해 로드된 어셈블리에 있고 나머지 형식은 리플렉션 전용 컨텍스트로 로드된 어셈블리에 있는 경우에도 이 메서드는 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3696">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3697">부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], interop에서 COM 형식에 대 한 형식 정보를 얻기 위해 관리 되는 어셈블리를 요구 하는 대신 관리 되는 어셈블리에 직접 COM 형식에 대 한 형식 정보를 포함 하는 공용 언어 런타임 지원 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3697">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="94b23-3698">포함된 형식 정보에는 관리되는 어셈블리에서 실제로 사용되는 형식 및 멤버만 포함되므로 두 개의 관리되는 어셈블리에서 동일한 COM 형식이 전혀 다르게 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3698">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="94b23-3699">관리되는 어셈블리마다 COM 형식의 해당 보기를 나타내는 다른 <xref:System.Type> 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3699">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="94b23-3700">공용 언어 런타임은 인터페이스, 구조체, 열거형 및 대리자에 대한 이러한 다양한 보기 간에 형식 동등을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3700">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="94b23-3701">형식 동등은 관리되는 어셈블리 간에 전달되는 COM 개체를 수신 어셈블리에서 적절한 관리되는 형식으로 캐스팅할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3701">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="94b23-3702"><xref:System.Type.IsEquivalentTo%2A> 메서드 다른 어셈블리에서 가져온 COM 개체에 첫 번째 어셈블리의 자체 포함 된 interop 형식 중 하나로 동일한 COM id를 확인 하려면 어셈블리를 사용 하도록 설정 하 고 있으므로 해당 형식으로 캐스팅 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3702">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="94b23-3703">자세한 내용은 [형식 동등 및 포함 된 Interop 형식](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3703">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3704">현재 형식의 필드가 명시적으로 지정된 오프셋에 배치되는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3704">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3705">현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3705">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3706">이 속성은 편의 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3706">This property is provided as a convenience.</span></span> <span data-ttu-id="94b23-3707">사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 열거형 값 형식 레이아웃 특성 및 다음 테스트를 여부 선택 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3707">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="94b23-3708"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드는 메모리에 배치 하는 방법을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3708">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="94b23-3709">동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 유형을 만들 때.</span><span class="sxs-lookup"><span data-stu-id="94b23-3709">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="94b23-3710">코드에 적용 합니다 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성과 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 열거형 값을 필드에서 시작할 오프셋을 명시적으로 지정 되어 있는지를 지정 하는 형식으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3710">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3711">사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 결정 하는 방법 여부를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3711">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="94b23-3712">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3712">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3713">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3713">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-3714">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3714">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3715">다음 예제에서는 형식의 인스턴스를 만들고 값을 표시는 <xref:System.Type.IsExplicitLayout%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3715">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="94b23-3716">사용 된 `MySystemTime` 클래스에 대 한 코드 예제는 <xref:System.Runtime.InteropServices.StructLayoutAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3716">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">
          <span data-ttu-id="94b23-3717">메타데이터 및 자동 기술 구성 요소</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3717">Metadata and Self-Describing Components</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3718">현재 <see cref="T:System.Type" />이 제네릭 형식 또는 메서드 정의의 형식 매개 변수를 나타내는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3718">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3719">
            <see cref="T:System.Type" /> 개체가 제네릭 형식 정의나 메서드 정의의 형식 매개 변수를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3719">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3720"><xref:System.Type> 제네릭 형식 매개 변수를 나타내는 개체를 호출 하 여 얻을 수 있습니다는 <xref:System.Type.GetGenericArguments%2A> 메서드를 <xref:System.Type> 제네릭 형식 정의 나타내는 개체 또는 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> 메서드의 <xref:System.Reflection.MethodInfo> 제네릭 메서드를 나타내는 개체 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3720"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="94b23-3721">제네릭 형식 또는 메서드 정의 <xref:System.Type.IsGenericParameter%2A> 속성이 반환 `true` 결과 배열의 모든 요소에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3721">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="94b23-3722">폐쇄형된 생성된 형식 또는 메서드를 실행 하는 것에 대 한 합니다 <xref:System.Type.IsGenericParameter%2A> 속성이 반환 `false` 에서 반환 된 배열의 모든 요소에 대 한는 <xref:System.Type.GetGenericArguments%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3722">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="94b23-3723">개방형 생성된 형식 또는 메서드를 실행 하는 것에 대 한 몇 가지 배열 요소의 특정 형식일 수 있습니다 및 형식 매개 변수를 되기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3723">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="94b23-3724"><xref:System.Type.IsGenericParameter%2A> 반환 `false` 유형에 대 한 및 `true` 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3724"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="94b23-3725">에 대 한 코드 예제는 <xref:System.Type.ContainsGenericParameters%2A> 속성 형식 및 형식 매개 변수 혼합 하 여 제네릭 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3725">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="94b23-3726">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3726">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3727">다음 예제에서는 <xref:System.Type.IsGenericParameter%2A> 제네릭 형식에 제네릭 형식 매개 변수에 대해 테스트할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3727">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-3728">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3728">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-3729">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3729">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3730">현재 형식이 제네릭 형식인지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3730">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3731">
            <see langword="true" /> 현재 형식이 제네릭 형식의 경우 그렇지 않으면 <see langword="false" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3731">
              <see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3732">사용 하 여는 <xref:System.Type.IsGenericType%2A> 속성을 여부를 <xref:System.Type> 개체 제네릭 형식을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3732">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="94b23-3733">사용 하 여는 <xref:System.Type.ContainsGenericParameters%2A> 속성을 확인 하는지 여부를 <xref:System.Type> 개방형 생성된 형식 또는 폐쇄형된 생성된 형식 개체를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3733">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3734">합니다 <xref:System.Type.IsGenericType%2A> 속성이 반환 `false` 직접적인 형식 제네릭이 아닌 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-3734">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="94b23-3735">예를 들어 형식 요소가 들어 있는 배열을 `A<int>` (`A(Of Integer)` Visual Basic의)이 자체는 제네릭 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3735">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="94b23-3736">다음 표에서 제네릭 리플렉션에 사용 되는 일반적인 용어에 대 한 고정 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3736">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="94b23-3737">용어</span><span class="sxs-lookup"><span data-stu-id="94b23-3737">Term</span></span>|<span data-ttu-id="94b23-3738">고정</span><span class="sxs-lookup"><span data-stu-id="94b23-3738">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="94b23-3739">제네릭 형식 정의(generic type definition)</span><span class="sxs-lookup"><span data-stu-id="94b23-3739">generic type definition</span></span>|<span data-ttu-id="94b23-3740"><xref:System.Type.IsGenericTypeDefinition%2A> 속성은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3740">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3741">제네릭 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3741">Defines a generic type.</span></span> <span data-ttu-id="94b23-3742">생성된 된 형식을 호출 하 여 만든 합니다 <xref:System.Type.MakeGenericType%2A> 메서드는 <xref:System.Type> 제네릭 형식 정의 나타내는 개체를 형식 인수의 배열을 지정 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3742">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="94b23-3743"><xref:System.Type.MakeGenericType%2A> 제네릭 형식 정의에 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3743"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="94b23-3744">모든 제네릭 형식 정의 제네릭 형식 (합니다 <xref:System.Type.IsGenericType%2A> 속성은 `true`), 그 반대도 마찬가지로 true 이지만 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3744">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="94b23-3745">제네릭 형식(generic type)</span><span class="sxs-lookup"><span data-stu-id="94b23-3745">generic type</span></span>|<span data-ttu-id="94b23-3746"><xref:System.Type.IsGenericType%2A> 속성은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3746">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3747">제네릭 형식 정의 개방형 생성된 형식, 또는 폐쇄형된 생성된 형식 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3747">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="94b23-3748">배열 형식은 요소 형식이 제네릭 인지는 제네릭 형식 자체가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3748">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="94b23-3749">마찬가지는 <xref:System.Type> 제네릭 형식에 대 한 포인터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3749">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="94b23-3750">개방형 생성된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-3750">open constructed type</span></span>|<span data-ttu-id="94b23-3751"><xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3751">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3752">할당 되지 않은 형식 매개 변수는 제네릭 형식, 제네릭 형식 정의 또는 개방형 생성된 형식, 중첩 된 형식 또는는 형식 인수가 있는 제네릭 형식을 예로 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3752">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3753">개방형 생성된 형식 인스턴스의 생성 하는 것이 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3753">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="94b23-3754">모든 열려 있지 않은 생성 된 형식 제네릭는 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3754">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="94b23-3755">예를 들어, 요소 형식이 제네릭 형식 정의 배열을 제네릭인 및 개방형 생성된 형식에 대 한 포인터는 제네릭이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3755">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="94b23-3756">폐쇄형된 생성된 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-3756">closed constructed type</span></span>|<span data-ttu-id="94b23-3757"><xref:System.Type.ContainsGenericParameters%2A> 속성은 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3757">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="94b23-3758">재귀적으로 검사 형식에 할당 되지 않은 제네릭 매개 변수가 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-3758">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="94b23-3759">제네릭 형식 매개 변수(generic type parameter)</span><span class="sxs-lookup"><span data-stu-id="94b23-3759">generic type parameter</span></span>|<span data-ttu-id="94b23-3760"><xref:System.Type.IsGenericParameter%2A> 속성은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3760">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3761"><xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3761">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3762">제네릭 형식 정의 나중에 할당할 수 있는 형식에 대 한 자리 표시자입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3762">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="94b23-3763">제네릭 형식 인수(generic type argument)</span><span class="sxs-lookup"><span data-stu-id="94b23-3763">generic type argument</span></span>|<span data-ttu-id="94b23-3764">제네릭 형식 매개 변수를 포함 하 여 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3764">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="94b23-3765">형식 인수 배열을 <xref:System.Type> 에 전달 된 개체는 <xref:System.Type.MakeGenericType%2A> 메서드 생성된 된 제네릭 형식을 만들 때.</span><span class="sxs-lookup"><span data-stu-id="94b23-3765">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="94b23-3766">결과 형식의 인스턴스를 만들 경우 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성 이어야 `false` 모든 형식 인수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3766">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="94b23-3767">다음 코드 예제 및 테이블을 고정과 이러한 조건 중 일부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3767">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="94b23-3768">`Derived` 해당 기본 형식이 해당 형식 인수 목록에 형식 및 형식 매개 변수 혼합 되어 생성 된 형식 이므로 클래스는 특히 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3768">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="94b23-3769">다음 표에서 클래스의 빌드 및 사용 하는 예를 보여 줍니다 `Base`, `Derived`, 및 `G`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3769">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="94b23-3770">C + + 및 C# 코드가 동일 하면 항목이 하나만 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3770">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="94b23-3771">예</span><span class="sxs-lookup"><span data-stu-id="94b23-3771">Example</span></span>|<span data-ttu-id="94b23-3772">고정</span><span class="sxs-lookup"><span data-stu-id="94b23-3772">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="94b23-3773">이 유형의 경우:</span><span class="sxs-lookup"><span data-stu-id="94b23-3773">For this type:</span></span><br /><br /> <span data-ttu-id="94b23-3774"><xref:System.Type.IsGenericType%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3774"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3775"><xref:System.Type.IsGenericTypeDefinition%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3775"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3776"><xref:System.Type.ContainsGenericParameters%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3776"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="94b23-3777">이 유형의 경우:</span><span class="sxs-lookup"><span data-stu-id="94b23-3777">For this type:</span></span><br /><br /> <span data-ttu-id="94b23-3778"><xref:System.Type.IsGenericType%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3778"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3779"><xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3779"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="94b23-3780"><xref:System.Type.ContainsGenericParameters%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3780"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="94b23-3781">변수의 형식에 대 한 `d`:</span><span class="sxs-lookup"><span data-stu-id="94b23-3781">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="94b23-3782"><xref:System.Type.IsGenericType%2A> 됩니다 `false` 있으므로 `d` 배열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3782"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="94b23-3783"><xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3783"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="94b23-3784"><xref:System.Type.ContainsGenericParameters%2A>가 `false`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3784"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="94b23-3785">`T`하십시오 `U`, 및 `V` (everywhere 표시 됨)</span><span class="sxs-lookup"><span data-stu-id="94b23-3785">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="94b23-3786"><xref:System.Type.IsGenericParameter%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3786"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3787"><xref:System.Type.IsGenericType%2A> `false` 제네릭 형식에 형식 매개 변수를 제한할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3787"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="94b23-3788"><xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3788"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="94b23-3789"><xref:System.Type.ContainsGenericParameters%2A> 됩니다 `true` 때문에 `T`를 `U`, 및 `V` 은 그 자체가 제네릭 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3789"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="94b23-3790">이 의미 하지 않습니다 나중에 할당 되는 형식 인수에 대 한 모든 것.</span><span class="sxs-lookup"><span data-stu-id="94b23-3790">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="94b23-3791">필드의 형식 `F`</span><span class="sxs-lookup"><span data-stu-id="94b23-3791">The type of field `F`</span></span>|<span data-ttu-id="94b23-3792"><xref:System.Type.IsGenericType%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3792"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="94b23-3793"><xref:System.Type.IsGenericTypeDefinition%2A> 됩니다 `false` 의 형식 매개 변수에 할당 된 형식 때문에 `G`입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3793"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="94b23-3794">이 호출한 것과 동일 합니다 <xref:System.Type.MakeGenericType%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-3794">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="94b23-3795"><xref:System.Type.ContainsGenericParameters%2A> 됩니다 `true` 때문에 필드의 형식을 `F` 형식 인수가 개방형 생성된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3795"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="94b23-3796">생성 된 형식이 공개 형식임 때문에 해당 형식 인수 (즉, `Base`)은 제네릭 형식 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3796">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="94b23-3797">이의 재귀적 특성을 보여 줍니다는 <xref:System.Type.IsGenericType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3797">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="94b23-3798">중첩된 클래스 `Nested`</span><span class="sxs-lookup"><span data-stu-id="94b23-3798">The nested class `Nested`</span></span>|<span data-ttu-id="94b23-3799"><xref:System.Type.IsGenericType%2A> 됩니다 `true`경우에는 `Nested` 클래스 제네릭 형식 매개 변수가 없는 자체에 대 한 제네릭 형식에 중첩 되어 있으므로.</span><span class="sxs-lookup"><span data-stu-id="94b23-3799"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="94b23-3800"><xref:System.Type.IsGenericTypeDefinition%2A>가 `true`인 경우</span><span class="sxs-lookup"><span data-stu-id="94b23-3800"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="94b23-3801">즉, 호출할 수 있습니다 합니다 <xref:System.Type.MakeGenericType%2A> 메서드와 공급 바깥쪽 형식의 형식 매개 변수 `Derived`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3801">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="94b23-3802"><xref:System.Type.ContainsGenericParameters%2A> 됩니다 `true` 바깥쪽 형식 `Derived`, 제네릭 형식 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3802"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="94b23-3803">이의 재귀적 특성을 보여 줍니다는 <xref:System.Type.ContainsGenericParameters%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3803">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3804">다음 코드 예제에서는 값을 표시 합니다 <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, 및 <xref:System.Type.ContainsGenericParameters%2A> 주의 섹션에서 설명한 형식에 대 한 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3804">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="94b23-3805">속성 값에 대 한 설명에 함께 제공 되는 테이블을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3805">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-3806">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3806">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-3807">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3807">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3808">현재 <see cref="T:System.Type" />이 다른 제네릭 형식을 생성하는 데 사용될 수 있는 제네릭 형식 정의를 나타내는지를 가리키는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3808">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3809">
            <see langword="true" /> 개체가 제네릭 형식 정의를 나타내면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3809">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3810">제네릭 형식 정의 다른 형식을 생성 하는 데 사용 될 수 있는 템플릿입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3810">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="94b23-3811">예를 들어, 제네릭 형식 정의에서 `G<T>` (C# 구문;으로 표현 합니다. `G(Of T)` Visual Basic의 또는 `generic <typename T> ref class G` c + +에서)를 생성 하 고 형식을 인스턴스화할 수 있습니다 `G<int>` (`G(Of Integer)` Visual Basic의)를 호출 하 여를 <xref:System.Type.MakeGenericType%2A> 포함 하는 제네릭 인수 목록을 사용 하 여 메서드를 <xref:System.Int32> 형식.</span><span class="sxs-lookup"><span data-stu-id="94b23-3811">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="94b23-3812">지정 된을 <xref:System.Type> 생성 된 형식을이 나타내는 개체를 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드 제네릭 형식 정의 다시 가져옵니다 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3812">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="94b23-3813">사용 된 <xref:System.Type.IsGenericTypeDefinition%2A> 속성을 현재 형식에서 새 형식을 만들 수 있는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3813">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="94b23-3814">경우는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성이 반환 `true`를 호출할 수 있습니다는 <xref:System.Type.MakeGenericType%2A> 새 제네릭 형식을 만드는 방법.</span><span class="sxs-lookup"><span data-stu-id="94b23-3814">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="94b23-3815">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3815">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3816">다음 예제에서는 제네릭 형식 정의 인 여부를 포함 하 여 형식에 대 한 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3816">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="94b23-3817">생성된 된 형식, 제네릭 형식 정의 및 일반 형식에 대 한 정보가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3817">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-3818">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3818">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-3819">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3819">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3820">
            <see cref="T:System.Type" />에 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 특성이 적용되어 있는지 여부를 나타내는 값을 가져옵니다. 이 특성은 해당 형식이 COM 형식 라이브러리에서 가져온 것임을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3820">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3821">
            <see langword="true" />에 <see cref="T:System.Type" />가 있으면 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3821">
              <see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3822">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3822">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3823">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="94b23-3823">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="94b23-3824">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3824">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="94b23-3825">현재 형식과 비교할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3825">The object to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-3826">지정된 개체가 현재 <see cref="T:System.Type" />의 인스턴스인지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3826">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3827">현재 <see langword="Type" />이 <paramref name="o" />가 나타내는 개체의 상속 계층 구조에 속하거나 현재 <see langword="Type" />이 <paramref name="o" />가 구현하는 인터페이스이면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3827">
              <see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span>
          </span>
          <span data-ttu-id="94b23-3828">이러한 조건에 해당하지 않거나 <paramref name="o" />가 <see langword="null" />이거나 현재 <see langword="Type" />이 개방형 제네릭 형식(즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" /> 반환)이면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3828">
              <see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3829">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3829">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3830">생성된 된 형식을 해당 제네릭 형식 정의의 인스턴스가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3830">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="94b23-3831">즉, `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual basic에서)의 인스턴스가 아닙니다 `MyGenericList<T>` (`MyGenericList(Of T)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-3831">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3832">다음 예제에서는 `IsInstanceOfType` 메서드를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3832">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3833">
            <see cref="T:System.Type" />이 인터페이스인지, 즉 클래스 또는 값 형식이 아닌지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3833">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3834">
            <see langword="true" />이 인터페이스이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3834">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3835"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask> 형식 선언을 클래스, 인터페이스 또는 값 형식으로 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3835">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="94b23-3836">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3836">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3837">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3837">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3838">다음 예제에서는 인터페이스를 만듭니다 인터페이스 형식을 확인 하 고 클래스에 있는지 여부를 나타냅니다는 `IsInterface` 속성 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3838">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3839">메타데이터에 정의되고 내보낸 순서로 현재 형식의 필드가 순차적으로 배치되는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3839">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3840">현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3840">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3841">이 속성은 편의 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3841">This property is provided as a convenience.</span></span> <span data-ttu-id="94b23-3842">사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 열거형 값 형식 레이아웃 특성 및 다음 테스트를 여부 선택 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3842">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="94b23-3843"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드는 메모리에 배치 하는 방법을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3843">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="94b23-3844">동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 유형을 만들 때.</span><span class="sxs-lookup"><span data-stu-id="94b23-3844">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="94b23-3845">코드에 적용 합니다 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성과 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 열거형 값을 해당 레이아웃은 순차를 지정 하는 형식으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3845">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3846">사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 결정 하는 방법 여부를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3846">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="94b23-3847">자세한 내용은 "파티션 II: 메타 데이터 정의 및 의미" 공용 언어 인프라 (CLI) 설명서에 대 한 사양의 9.1.2 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3847">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="94b23-3848">이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](http://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](http://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3848">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="94b23-3849">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3849">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-3850">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3850">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-3851">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3851">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3852">다음 예제는 클래스의 인스턴스를 만듭니다를 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 열거 값을 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 클래스 설정 된 경우 확인를 <xref:System.Type.IsLayoutSequential%2A> 속성을 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3852">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">
          <span data-ttu-id="94b23-3853">메타데이터 및 자동 기술 구성 요소</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3853">Metadata and Self-Describing Components</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3854">
            <see cref="T:System.Type" />이 참조로 마샬링되는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3854">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3855">
            <see langword="true" />이 참조에 의해 마샬링되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3855">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="94b23-3856">다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성을 <xref:System.Type> 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-3856">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="94b23-3857">그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 인지 컨텍스트에서 지정된 된 형식의 호스팅할 수 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3857">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3858">
            <see cref="P:System.Type.IsMarshalByRef" /> 속성을 구현하고, <see cref="T:System.Type" />이 참조에 의해 마샬링되는지 여부를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3858">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3859">
            <see langword="true" />이 참조에 의해 마샬링되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3859">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3860">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3860">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3861">다음 예제에서는 지정된 된 형식 참조로 마샬링되 및 결과 표시 하는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3861">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3862">현재 <see cref="T:System.Type" /> 개체가 다른 형식의 정의 안에 중첩된 정의를 가진 형식을 나타내는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3862">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3863">
            <see langword="true" />이 다른 형식 안에 중첩되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3863">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3864"><xref:System.Type.IsNested%2A> 속성이 반환 `true` 모두에 대 한 표시 여부에 관계 없이 형식에 중첩 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3864">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="94b23-3865">동시에 중첩 및 표시 유형에 대해 테스트 하려면 관련된 속성을 사용 <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>를 <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>를 <xref:System.Type.IsNestedPrivate%2A>, 또는 <xref:System.Type.IsNestedPublic%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3865">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3866"><xref:System.Reflection.TypeAttributes.VisibilityMask> 열거형 멤버 유형에 대 한 표시 유형 특성을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3866">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3867">다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3867">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="94b23-3868">다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3868">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3869">
            <see cref="T:System.Type" />이 중첩되었으며 자체 어셈블리 내에서만 표시되는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3869">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3870">
            <see langword="true" />이 중첩되어 있고 자체 어셈블리 내에서만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3870">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3871">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3871">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3872"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3872"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3873">다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3873">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="94b23-3874">다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3874">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3875">
            <see cref="T:System.Type" />이 중첩되었으며 자체 패밀리와 자체 어셈블리 모두에 속하는 클래스에만 표시되는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3875">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3876">
            <see langword="true" />이 중첩되어 있고 자체 패밀리와 자체 어셈블리 모두에 속하는 클래스에만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3876">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3877">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3877">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3878"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3878"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-3879">C# 및 Visual Basic 언어는 고유한 어셈블리에서 보호 된 형식에만 표시 되는 중첩 된 형식을 정의할 수 있도록 하는 의미 체계를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3879">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="94b23-3880">`protected internal` C#의 표시 유형 및 `Protected Friend` Visual Basic의 가시성을 보호 된 형식 및 동일한 어셈블리의 형식에 표시 되는 중첩된 형식을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3880">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="94b23-3881">A <xref:System.Type> 개체의 제품군의 모든 개체로 정의 됩니다 <xref:System.Type> 및 해당 하위 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3881">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3882">다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3882">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="94b23-3883">다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3883">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3884">
            <see cref="T:System.Type" />이 중첩되었으며 자체 패밀리 내에서만 표시되는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3884">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3885">
            <see langword="true" />이 중첩되어 있고 자체 패밀리 내에서만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3885">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3886">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3886">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3887"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3887"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="94b23-3888">A <xref:System.Type> 개체의 제품군의 정확한 모든 개체로 정의 됩니다 동일한 <xref:System.Type> 및 해당 하위 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3888">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3889">다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3889">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="94b23-3890">다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3890">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3891">
            <see cref="T:System.Type" />이 중첩되었으며 자체 패밀리와 자체 어셈블리 중 하나에 속하는 클래스에만 표시되는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3891">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3892">
            <see langword="true" />이 중첩되어 있고 자체 패밀리 또는 자체 어셈블리에 속하는 클래스에만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3892">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3893">형식의 표시 되 면 `protected internal` C# 또는 `Protected Friend` Visual Basic의 경우에 <xref:System.Type.IsNestedFamORAssem%2A> 속성에서 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3893">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="94b23-3894">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3894">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3895"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3895"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="94b23-3896">A <xref:System.Type> 개체의 제품군의 정확한 모든 개체로 정의 됩니다 동일한 <xref:System.Type> 및 해당 하위 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3896">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3897">다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3897">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="94b23-3898">다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3898">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3899">
            <see cref="T:System.Type" />이 중첩되어 있고 private 형식으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3899">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3900">
            <see langword="true" />이 중첩되어 있고 private 형식으로 선언되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3900">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3901">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3901">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3902"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3902"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3903">다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3903">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="94b23-3904">다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3904">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3905">클래스가 중첩되어 있고 public 형식으로 선언되어 있는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3905">Gets a value indicating whether a class is nested and declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3906">클래스가 중첩되어 있고 public 형식으로 선언되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3906">
              <see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3907">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3907">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3908"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3908"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3909">다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3909">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="94b23-3910">다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3910">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3911">
            <see cref="T:System.Type" />이 public으로 선언되어 있지 않은지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3911">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3912">
            <see langword="true" />이 public으로 선언되어 있지 않고 중첩 형식이 아니면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3912">
              <see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3913">중첩 된 형식을 사용 하 여이 속성을 사용 하지 마십시오 사용 된 <xref:System.Type.IsNestedPublic%2A> 속성 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3913">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="94b23-3914">하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3914">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3915">이 예제에서는 용도 `IsNotPublic` 속성 형식의 가시성을 확보 하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-3915">This example usesthe `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="94b23-3916">다음 코드 예제에서는 사용할 수 없습니다는 이유는 방법을 보여 줍니다 `IsPublic` 고 `IsNotPublic` 중첩된 클래스에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3916">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="94b23-3917">중첩 된 클래스에 대 한 결과를 무시 `IsPublic` 하 고 `IsNotPublic` 결과에 주의 하 고 `IsNestedPublic` 및 `IsNestedPrivate`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3917">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="94b23-3918">이 코드 조각에 대 한 리플렉션을 출력은 다음과 같을 수: 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3918">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="94b23-3919">클래스</span><span class="sxs-lookup"><span data-stu-id="94b23-3919">Class</span></span>|<span data-ttu-id="94b23-3920">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="94b23-3920">IsNotPublic</span></span>|<span data-ttu-id="94b23-3921">IsPublic</span><span class="sxs-lookup"><span data-stu-id="94b23-3921">IsPublic</span></span>|<span data-ttu-id="94b23-3922">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="94b23-3922">IsNestedPublic</span></span>|<span data-ttu-id="94b23-3923">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="94b23-3923">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="94b23-3924">A</span><span class="sxs-lookup"><span data-stu-id="94b23-3924">A</span></span>|<span data-ttu-id="94b23-3925">false</span><span class="sxs-lookup"><span data-stu-id="94b23-3925">FALSE</span></span>|<span data-ttu-id="94b23-3926">true</span><span class="sxs-lookup"><span data-stu-id="94b23-3926">TRUE</span></span>|<span data-ttu-id="94b23-3927">FALSE</span><span class="sxs-lookup"><span data-stu-id="94b23-3927">FALSE</span></span>|<span data-ttu-id="94b23-3928">false</span><span class="sxs-lookup"><span data-stu-id="94b23-3928">FALSE</span></span>|  
|<span data-ttu-id="94b23-3929">B</span><span class="sxs-lookup"><span data-stu-id="94b23-3929">B</span></span>|<span data-ttu-id="94b23-3930">false</span><span class="sxs-lookup"><span data-stu-id="94b23-3930">FALSE</span></span>|<span data-ttu-id="94b23-3931">false</span><span class="sxs-lookup"><span data-stu-id="94b23-3931">FALSE</span></span>|<span data-ttu-id="94b23-3932">true</span><span class="sxs-lookup"><span data-stu-id="94b23-3932">TRUE</span></span>|<span data-ttu-id="94b23-3933">FALSE</span><span class="sxs-lookup"><span data-stu-id="94b23-3933">FALSE</span></span>|  
|<span data-ttu-id="94b23-3934">C</span><span class="sxs-lookup"><span data-stu-id="94b23-3934">C</span></span>|<span data-ttu-id="94b23-3935">false</span><span class="sxs-lookup"><span data-stu-id="94b23-3935">FALSE</span></span>|<span data-ttu-id="94b23-3936">false</span><span class="sxs-lookup"><span data-stu-id="94b23-3936">FALSE</span></span>|<span data-ttu-id="94b23-3937">false</span><span class="sxs-lookup"><span data-stu-id="94b23-3937">FALSE</span></span>|<span data-ttu-id="94b23-3938">true</span><span class="sxs-lookup"><span data-stu-id="94b23-3938">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3939">
            <see cref="T:System.Type" />이 포인터인지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3939">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3940">
            <see langword="true" />이 포인터이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3940">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3941">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수에이 속성은 항상 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3941">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="94b23-3942">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3942">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3943">다음 예제에서는 사용 하 여 `IsPointer` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3943">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3944">파생 클래스에서 재정의되면, <see cref="P:System.Type.IsPointer" /> 속성을 구현하고 <see cref="T:System.Type" />이 포인터인지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3944">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3945">
            <see langword="true" />이 포인터이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3945">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3946">
            <see cref="T:System.Type" />이 기본 형식 중 하나인지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3946">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3947">
            <see langword="true" />이 기본 형식 중 하나이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3947">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3948">기본 형식은 <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>를 <xref:System.Int32>, <xref:System.UInt32>를 <xref:System.Int64>, <xref:System.UInt64>를 <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, 및 <xref:System.Single>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3948">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="94b23-3949">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수에이 속성은 항상 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3949">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3950">다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성을 <xref:System.Type> 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-3950">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="94b23-3951">그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 인지 컨텍스트에서 지정된 된 형식의 호스팅할 수 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3951">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3952">파생 클래스에서 재정의되면, <see cref="P:System.Type.IsPrimitive" /> 속성을 구현하고 <see cref="T:System.Type" />이 기본 형식 중 하나인지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3952">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-3953">
            <see langword="true" />이 기본 형식 중 하나이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3953">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3954">기본 형식은 <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>를 <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>를 <xref:System.Char>, <xref:System.Double>, 및 <xref:System.Single>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3954">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3955">다음 예제에서는 지정된 된 형식의 기본 형식이 고 결과 표시 하는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3955">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3956">
            <see cref="T:System.Type" />이 public으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3956">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3957">
            <see langword="true" />이 public으로 선언되어 있고 중첩 형식이 아니면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3957">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3958">중첩 된 형식을 사용 안 함 사용 하 여 <xref:System.Type.IsNestedPublic%2A> 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3958">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="94b23-3959">하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 제네릭 형식의 형식 매개 변수를 나타내는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3959">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="94b23-3960"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3960"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3961">다음 예제에서는 인스턴스를 만듭니다 `MyTestClass`, 확인을 `IsPublic` 속성 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3961">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="94b23-3962">중첩 된 클래스에 대 한 결과를 무시 `IsPublic` 하 고 `IsNotPublic` 결과에 주의 하 고 <xref:System.Type.IsNestedPublic%2A> 및 <xref:System.Type.IsNestedPrivate%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3962">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3963">
            <see cref="T:System.Type" />이 봉인된 형식으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3963">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3964">
            <see langword="true" />이 봉인된 형식으로 선언되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3964">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3965">하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3965">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-3966">다음 예제에서는 인스턴스를 만듭니다는 `sealed` 클래스에 대 한 검사는 `IsSealed` 속성 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3966">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3967">현재 형식이 현재 신뢰 수준에서 보안에 중요한 형식이거나 보안 안전에 중요한 형식이어서 중요한 작업을 수행할 수 있는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3967">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3968">현재 형식이 보안에 중요한 형식이거나 보안 안전에 중요한 형식인 경우 <see langword="true" />이고 투명 형식인 경우 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3968">
              <see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3969">합니다 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3969">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="94b23-3970">이러한 속성의 조합도 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3970">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="94b23-3971">보안 수준</span><span class="sxs-lookup"><span data-stu-id="94b23-3971">Security level</span></span>|<span data-ttu-id="94b23-3972">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="94b23-3972">IsSecurityCritical</span></span>|<span data-ttu-id="94b23-3973">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="94b23-3973">IsSecuritySafeCritical</span></span>|<span data-ttu-id="94b23-3974">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="94b23-3974">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="94b23-3975">위험</span><span class="sxs-lookup"><span data-stu-id="94b23-3975">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="94b23-3976">안전 중요</span><span class="sxs-lookup"><span data-stu-id="94b23-3976">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="94b23-3977">투명</span><span class="sxs-lookup"><span data-stu-id="94b23-3977">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="94b23-3978">이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3978">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="94b23-3979">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3979">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="94b23-3980">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3980">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="94b23-3981">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3981">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="94b23-3982">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3982">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="94b23-3983">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3983">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="94b23-3984">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3984">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="94b23-3985">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3985">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="94b23-3986">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3986">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">
          <span data-ttu-id="94b23-3987">리플렉션의 보안 고려 사항</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3987">Security Considerations for Reflection</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">
          <span data-ttu-id="94b23-3988">.NET Framework의 보안 변경 내용</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3988">Security Changes in the .NET Framework</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-3989">현재 형식이 현재 신뢰 수준에서 보안 안전에 중요한 형식인지 즉, 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3989">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-3990">현재 형식이 현재 신뢰 수준에서 보안에 중요한 형식인 경우 <see langword="true" />이고 보안에 중요한 형식이거나 투명 형식인 경우 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-3990">
              <see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-3991">합니다 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3991">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="94b23-3992">이러한 속성의 조합도 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-3992">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="94b23-3993">보안 수준</span><span class="sxs-lookup"><span data-stu-id="94b23-3993">Security level</span></span>|<span data-ttu-id="94b23-3994">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="94b23-3994">IsSecurityCritical</span></span>|<span data-ttu-id="94b23-3995">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="94b23-3995">IsSecuritySafeCritical</span></span>|<span data-ttu-id="94b23-3996">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="94b23-3996">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="94b23-3997">위험</span><span class="sxs-lookup"><span data-stu-id="94b23-3997">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="94b23-3998">안전 중요</span><span class="sxs-lookup"><span data-stu-id="94b23-3998">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="94b23-3999">투명</span><span class="sxs-lookup"><span data-stu-id="94b23-3999">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="94b23-4000">이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4000">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="94b23-4001">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4001">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="94b23-4002">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4002">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="94b23-4003">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4003">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="94b23-4004">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4004">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="94b23-4005">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4005">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="94b23-4006">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4006">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="94b23-4007">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4007">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="94b23-4008">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4008">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">
          <span data-ttu-id="94b23-4009">리플렉션의 보안 고려 사항</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4009">Security Considerations for Reflection</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">
          <span data-ttu-id="94b23-4010">.NET Framework의 보안 변경 내용</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4010">Security Changes in the .NET Framework</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4011">현재 형식이 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4011">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4012">형식이 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4012">
              <see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4013">이 속성을 반환 하는 경우 `true`는 <xref:System.Type.IsSecurityCritical%2A> 하 고 <xref:System.Type.IsSecuritySafeCritical%2A> 속성 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4013">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="94b23-4014">합니다 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4014">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="94b23-4015">이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4015">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="94b23-4016">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4016">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="94b23-4017">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4017">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="94b23-4018">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4018">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="94b23-4019">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4019">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="94b23-4020">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4020">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="94b23-4021">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4021">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="94b23-4022">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4022">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="94b23-4023">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4023">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">
          <span data-ttu-id="94b23-4024">리플렉션의 보안 고려 사항</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4024">Security Considerations for Reflection</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">
          <span data-ttu-id="94b23-4025">.NET Framework의 보안 변경 내용</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4025">Security Changes in the .NET Framework</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4026">
            <see cref="T:System.Type" />의 serialization 가능 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4026">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4027">
            <see cref="T:System.Type" />을 serialize할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4027">
              <see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="94b23-4028">.NET 표준에 정의 된 형식으로 표시 되어 있지 <xref:System.SerializableAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4028">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="94b23-4029">대신, 각.NET 구현 형식이 직렬화 가능 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4029">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="94b23-4030">런타임에 사용할 수는 <xref:System.Type.IsSerializable%2A> 구현에는 형식 인스턴스의 serialization을 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4030">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="94b23-4031">자세한 내용 및 예제를 참조 하세요 [.NET Standard 개체를 직렬화 가능 인지 확인 하는 방법을](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4031">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="94b23-4032">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4032">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-4033">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4033">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-4034">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4034">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4035">다음 예제에서는 인스턴스를 만듭니다 `MyTestClass` 클래스 [Serializable] 특성을 설정 하 고 확인 합니다 `IsSerializable` 속성에 대 한 `true` 또는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4035">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4036">별도의 처리가 필요한 이름이 형식에 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4036">Gets a value indicating whether the type has a name that requires special handling.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4037">별도의 처리가 필요한 이름이 형식에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4037">
              <see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4038">로 시작 하거나 밑줄 문자 (_), 속성 접근자 및 메서드를 오버 로드할 연산자를 포함 하는 이름은 일부 컴파일러에서 특수 한 처리가 필요할 수 있는 형식의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4038">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="94b23-4039">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4039">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-4040">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4040">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-4041">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4041">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="94b23-4042">현재 형식과 비교할 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4042">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4043">현재 <see cref="T:System.Type" />이 지정된 <see cref="T:System.Type" />에서 파생되는지 여부를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4043">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4044">현재 <see langword="true" />이 <see langword="Type" />에서 파생되면 <paramref name="c" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4044">
              <see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="94b23-4045">이 메서드는 <see langword="false" /> 및 현재 <paramref name="c" />이 동일한 경우에도 <see langword="Type" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4045">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4046">호출할 수 있습니다는 <xref:System.Type.IsSubclassOf%2A> 메서드 중 하나를 확인 하려면:</span><span class="sxs-lookup"><span data-stu-id="94b23-4046">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="94b23-4047">여부 하나의 클래스는 다른에서 파생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4047">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="94b23-4048">형식에서 파생 되는 여부를 <xref:System.ValueType>입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4048">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="94b23-4049">그러나는 <xref:System.Type.IsValueType%2A> 는 형식이 값 형식 인지 여부를 결정 하는 보다 효율적인 방법이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4049">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="94b23-4050">형식에서 파생 되는 여부를 <xref:System.Enum>입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4050">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="94b23-4051">그러나는 <xref:System.Type.IsEnum%2A> 메서드는 형식이 열거형 인지 여부를 결정 하는 데 보다 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4051">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="94b23-4052">형식 인지 대리자, 중 하나에서 파생 되므로 여부 <xref:System.Delegate> 또는 <xref:System.MulticastDelegate>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4052">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="94b23-4053"><xref:System.Type.IsSubclassOf%2A> 인터페이스가 다른 인터페이스에서 파생 되는 여부 또는 클래스에서 인터페이스를 구현 하는 여부를 결정 하는 메서드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4053">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="94b23-4054">사용 된 <xref:System.Type.IsAssignableFrom%2A> 다음 예와 같이를 위해서는 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-4054">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="94b23-4055">하는 경우 현재 <xref:System.Type> 형식 매개 변수 또는 해당 클래스 제약 조건에서 파생 된 제네릭 형식 또는 제네릭 메서드 정의에서 <xref:System.Object?displayProperty=nameWithType> 클래스 제약 조건이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-4055">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-4056">인터페이스를 사용 하는 경우를 제외 하 고 <xref:System.Type.IsSubclassOf%2A> 의 반대입니다 <xref:System.Type.IsAssignableFrom%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4056">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="94b23-4057">즉, 경우 `t1.IsSubclassOf(t2)` 됩니다 `true`, 한 다음 `t2.IsAssignableFrom(t1)` 이기도 `true`.</span><span class="sxs-lookup"><span data-stu-id="94b23-4057">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="94b23-4058">이 메서드는 파생된 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4058">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4059">다음 예에서는 이라는 클래스를 만듭니다 `Class1` 및 파생된 클래스가 `DerivedC1`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4059">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="94b23-4060">호출 된 <xref:System.Type.IsSubclassOf%2A> 표시 하는 방법 `DerivedC1` 서브 클래스입니다 `Class1`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4060">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-4061">
            <paramref name="c" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4061">
              <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4062">
            <see langword="UnicodeClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4062">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4063">
            <see langword="true" />에 대해 문자열 형식 특성 <see langword="UnicodeClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4063">
              <see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4064"><xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4064">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="94b23-4065">문자열을 해석할 방법을 정의 하 여 상호 운용성을 개선 하는 문자열 형식 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4065">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="94b23-4066">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4066">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-4067">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4067">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-4068">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4068">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4069">
            <see cref="T:System.Type" />이 값 형식인지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4069">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4070">
            <see langword="true" />이 값 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4070">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4071">값 형식은 비트; 시퀀스로 표현 되는 형식 값 형식은 클래스 또는 인터페이스 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4071">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="94b23-4072">값 형식 이라고 "구조체" 일부 프로그래밍 언어에서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4072">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="94b23-4073">열거형은 값 형식의 특수 한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4073">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="94b23-4074">이 속성은 반환 `false` 에 대 한 합니다 <xref:System.ValueType> 클래스 <xref:System.ValueType> 자체 값 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4074">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="94b23-4075">모든 값 형식에 대 한 기본 클래스 이므로에 모든 값 형식에 할당할 수 있으므로.</span><span class="sxs-lookup"><span data-stu-id="94b23-4075">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="94b23-4076">하지 않는 것이 가능한 경우 <xref:System.ValueType> 값 형식 자체 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4076">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="94b23-4077">형식의 필드에 할당 될 때 값 형식이 boxed <xref:System.ValueType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4077">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="94b23-4078">이 속성은 반환 `true` 열거형에 대 한는 <xref:System.Enum> 자체를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4078">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="94b23-4079">이 동작을 보여 주는 예제를 참조 하세요. <xref:System.Type.IsEnum%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4079">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="94b23-4080">이 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4080">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4081">다음 예제에서는 형식의 변수를 만듭니다 `MyEnum`를 확인는 `IsValueType` 속성 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4081">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4082">
            <see cref="P:System.Type.IsValueType" /> 속성을 구현하고 <see cref="T:System.Type" />이 값 형식인지 여부, 즉 클래스 또는 인터페이스가 아닌지 여부를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4082">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4083">
            <see langword="true" />이 값 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4083">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4084">이 메서드는 다른 형식 시스템의 구현을 사용할 수 있도록 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4084">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="94b23-4085">일반적으로 응용 프로그램 코드에서 사용 되지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4085">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4086">
            <see cref="T:System.Type" />을 어셈블리 외부의 코드에서 액세스할 수 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4086">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4087">현재 <see langword="true" />이 public 형식이거나 바깥쪽 형식이 모두 public인 public 중첩 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4087">
              <see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4088">이 속성을 사용 하 여 형식을 구성 요소 어셈블리의 공용 인터페이스의 일부 인지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4088">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4089">다음 코드 예제에서는 두 개의 클래스를 하나씩만 어셈블리 외부에 표시 되는지 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4089">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4090">현재 형식의 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4090">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4091">하한이 0인 현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4091">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4092">하한이 0인 현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4092">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4093"><xref:System.Type.MakeArrayType%2A> 메서드 요소 형식이 런타임 시 계산 되는 배열 형식을 생성 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4093">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="94b23-4094">**참고** 공용 언어 런타임 구별 벡터 (즉, 1 차원 배열에 항상 0부터 시작) 및 다차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4094">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="94b23-4095">항상 하나의 차원에 있는 벡터에 차원이 하나만 발생 하는 다차원 배열로 같지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4095">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="94b23-4096">벡터 형식을 만드는 경우에이 메서드 오버 로드를 데 수 이며 벡터 형식 만들기 위한 유일한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4096">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="94b23-4097">사용 된 <xref:System.Type.MakeArrayType%28System.Int32%29> 다차원 배열 형식을 만들려면 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4097">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4098">다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-4098">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-4099">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4099">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="94b23-4100">파생 클래스에서 구현을 제공해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4100">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-4101">현재 형식이 <see cref="T:System.TypedReference" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4101">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="94b23-4102">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4102">-or-</span>
          </span>
          <span data-ttu-id="94b23-4103">현재 형식이 <see langword="ByRef" /> 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4103">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="94b23-4104">즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4104">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="94b23-4105">배열의 차수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4105">The number of dimensions for the array.</span>
          </span>
          <span data-ttu-id="94b23-4106">이 수는 32보다 작거나 같아야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4106">This number must be less than or equal to 32.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4107">지정된 차수의 현재 형식 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4107">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4108">지정된 차수의 현재 형식 배열을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4108">An object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4109"><xref:System.Type.MakeArrayType%2A> 메서드 요소 형식이 런타임 시 계산 되는 배열 형식을 생성 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4109">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-4110">공용 언어 런타임 구별 벡터 (즉, 1 차원 배열에 항상 0부터 시작) 및 다차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4110">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="94b23-4111">항상 하나의 차원에 있는 벡터에 차원이 하나만 발생 하는 다차원 배열로 같지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4111">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="94b23-4112">벡터 형식; 키를 만들려면이 메서드 오버 로드를 사용할 수 없습니다. 경우 `rank` 이 1 이면이 메서드 오버 로드에는 차원 수가 발생 하는 다차원 배열 형식을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4112">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="94b23-4113">사용 된 <xref:System.Type.MakeArrayType> 형식을 만들려면 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4113">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4114">다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-4114">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="94b23-4115">
            <paramref name="rank" />이 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4115">
              <paramref name="rank" /> is invalid.</span>
          </span>
          <span data-ttu-id="94b23-4116">예를 들면, 0 또는 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4116">For example, 0 or negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-4117">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4117">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-4118">현재 형식이 <see cref="T:System.TypedReference" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4118">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="94b23-4119">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4119">-or-</span>
          </span>
          <span data-ttu-id="94b23-4120">현재 형식이 <see langword="ByRef" /> 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4120">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="94b23-4121">즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4121">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
          <span data-ttu-id="94b23-4122">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4122">-or-</span>
          </span>
          <span data-ttu-id="94b23-4123">
            <paramref name="rank" />이(가) 32보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4123">
              <paramref name="rank" /> is greater than 32.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4124">
            <see cref="T:System.Type" />(Visual Basic의 경우 <see langword="ref" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see langword="ByRef" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4124">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4125">
            <see cref="T:System.Type" />(Visual Basic의 경우 <see langword="ref" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see langword="ByRef" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4125">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4126">합니다 <xref:System.Type.MakeByRefType%2A> 메서드를 생성 하는 방법을 제공 `ref` 형식 (`ByRef` Visual basic에서) 매개 변수를 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4126">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="94b23-4127">경우 MSIL (Microsoft intermediate language), 구문을 사용 하 여 현재 <xref:System.Type> 개체가 나타내는 <xref:System.Int32>,이 메서드는 반환을 <xref:System.Type> 개체를 나타내는 `Int32&`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4127">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4128">다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-4128">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-4129">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4129">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-4130">현재 형식이 <see cref="T:System.TypedReference" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4130">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="94b23-4131">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4131">-or-</span>
          </span>
          <span data-ttu-id="94b23-4132">현재 형식이 <see langword="ByRef" /> 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4132">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="94b23-4133">즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4133">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="94b23-4134">현재 제네릭 형식의 형식 매개 변수로 대체할 형식 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4134">An array of types to be substituted for the type parameters of the current generic type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4135">형식 배열의 요소를 현재 제네릭 형식 정의의 형식 매개 변수로 대체하며 생성된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4135">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4136">
            <see cref="T:System.Type" />의 요소를 현재 제네릭 형식의 형식 매개 변수로 대체하여 생성된 형식을 나타내는 <paramref name="typeArguments" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4136">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4137">합니다 <xref:System.Type.MakeGenericType%2A> 메서드를 사용 하면 특정 형식을 만들어 제네릭 형식 정의의 형식 매개 변수에 할당 하는 코드를 작성할 수 있습니다는 <xref:System.Type> 생성된 된 특정 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4137">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="94b23-4138">이 사용 하 여 <xref:System.Type> 개체는 생성 된 형식의 런타임 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4138">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="94b23-4139">형식을 사용 하 여 생성 하는 <xref:System.Type.MakeGenericType%2A> 열 수, 즉, 바깥쪽 형식 또는 제네릭 메서드 형식 매개 변수를 해당 형식 인수 중 일부가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4139">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="94b23-4140">동적 어셈블리를 생성할 때 이러한 개방형 생성된 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4140">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="94b23-4141">예를 들어, 클래스는 것이 좋습니다 `Base` 고 `Derived` 다음 코드에서입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4141">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="94b23-4142">생성할 `Derived` 동적 어셈블리의 기본 형식을 생성 하는 데 필요한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4142">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="94b23-4143">이 위해 호출 합니다 <xref:System.Type.MakeGenericType%2A> 메서드를 <xref:System.Type> 클래스를 나타내는 개체 `Base`, 제네릭 형식 인수를 사용 하 여 <xref:System.Int32> 형식 매개 변수 `V` 에서 `Derived`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4143">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="94b23-4144">형식 및 제네릭 형식 매개 변수는 모두로 표시 되므로 <xref:System.Type> 개체를 모두 포함 된 배열을 전달할 수는 <xref:System.Type.MakeGenericType%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-4144">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-4145">생성 된 형식으로 `Base<int, V>` 코드를 내보낼 때 유용 하지만 호출할 수 없습니다는 <xref:System.Type.MakeGenericType%2A> 이 형식에 메서드를 제네릭 형식 정의 하지 않기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4145">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="94b23-4146">인스턴스화할 수 있는 폐쇄형된 생성된 형식을 만들려면 먼저 호출 합니다 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드를를 <xref:System.Type> 제네릭 형식 정의 나타내는 개체를 호출 <xref:System.Type.MakeGenericType%2A> 원하는 형식 인수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4146">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="94b23-4147"><xref:System.Type> 에서 반환 된 개체 <xref:System.Type.MakeGenericType%2A> 와 같습니다는 <xref:System.Type> 호출 하 여 가져올를 <xref:System.Object.GetType%2A> 생성 된 형식, 메서드 결과 또는 <xref:System.Object.GetType%2A> 모든 메서드의 생성 된 제네릭 같은 생성 된 형식 동일한 형식 인수를 사용 하 여 정의 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4147">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94b23-4148">제네릭 형식의 배열 자체는 제네릭 형식이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4148">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="94b23-4149">호출할 수 없습니다 <xref:System.Type.MakeGenericType%2A> 같은 배열을 입력 `C<T>[]` (`Dim ac() As C(Of T)` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-4149">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="94b23-4150">닫힌된 제네릭 형식을 생성 하려면 `C<T>[]`, 호출 <xref:System.Type.GetElementType%2A> 제네릭 형식 정의를 가져오는 `C<T>`; 호출 <xref:System.Type.MakeGenericType%2A> 생성 된 형식; 만들고 마지막으로 호출 하는 제네릭 형식 정의에 <xref:System.Type.MakeArrayType%2A> 메서드 배열 형식을 만들려면 생성 된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4150">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="94b23-4151">포인터 형식의 마찬가지 및 `ref` 형식 (`ByRef` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="94b23-4151">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="94b23-4152">제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-4152">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="94b23-4153">중첩 형식</span><span class="sxs-lookup"><span data-stu-id="94b23-4153">Nested Types</span></span>  
 <span data-ttu-id="94b23-4154">C#, c + + 또는 Visual Basic을 사용 하 여 제네릭 형식 정의 된 경우 해당 중첩된 형식 모두 제네릭 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4154">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="94b23-4155">3 가지 언어 중첩 형식의 형식 매개 변수 목록이 바깥쪽 형식의 형식 매개 변수를 포함 하기 때문에 자체의 형식 매개 변수 없이 중첩된 된 형식에 있는 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4155">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="94b23-4156">다음 클래스를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4156">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="94b23-4157">중첩된 된 클래스의 형식 매개 변수 목록 `Inner` 두 개의 형식 매개 변수가 `T` 및 `U`는 첫 번째는 바깥쪽 클래스의 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4157">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="94b23-4158">마찬가지로, 중첩된 된 클래스의 형식 매개 변수 목록 `Innermost1` 세 가지 형식 매개 변수가 `T`, `U`, 및 `V`를 사용 하 여 `T` 및 `U` 는 바깥쪽 클래스에서 제공 될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4158">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="94b23-4159">중첩된 클래스 `Innermost2` 두 개의 형식 매개 변수가 `T` 고 `U`는 바깥쪽 클래스에서 제공 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4159">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="94b23-4160">바깥쪽 형식의 매개 변수 목록에 둘 이상의 형식 매개 변수의 경우 순서로 모든 형식 매개 변수는 중첩 형식의 형식 매개 변수 목록에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4160">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="94b23-4161">중첩 형식의 제네릭 형식 정의에서 제네릭 형식을 생성을 호출 합니다 <xref:System.Type.MakeGenericType%2A> 모든 바깥쪽 형식의부터 가장 바깥쪽 제네릭 형식 및로 끝나는 형식 인수 배열을 연결 하 여 형성 된 배열 사용 하 여 메서드를 자체의 형식 매개 변수가 있는 경우에 중첩된 형식 자체의 인수 배열을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4161">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="94b23-4162">인스턴스를 만드는 `Innermost1`를 호출 합니다 <xref:System.Type.MakeGenericType%2A> T, U 및 V를 할당할 수는 세 가지 형식이 포함 된 배열 사용 하 여 메서드. 인스턴스를 만드는 `Innermost2`를 호출 합니다 <xref:System.Type.MakeGenericType%2A> 할당할 T 및 u입니다. 두 형식이 포함 된 배열 사용 하 여 메서드</span><span class="sxs-lookup"><span data-stu-id="94b23-4162">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="94b23-4163">언어는 중첩 된 형식의 필드를 정의 하는 바깥쪽 형식의 형식 매개 변수를 사용할 수 있도록이 방식으로 바깥쪽 형식의 형식 매개 변수를 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4163">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="94b23-4164">이 고, 그렇지 형식 매개 변수는 범위는 중첩 형식의 본문 내에서 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4164">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="94b23-4165">동적 어셈블리에서 코드를 생성 하거나 사용 하 여 바깥쪽 형식의 형식 매개 변수를 전파 하지 않고 중첩된 형식을 정의 하는 것이 불가능 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4165">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="94b23-4166">MSIL 어셈블러에 대해 다음 코드를 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="94b23-4166">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="94b23-4167">이 예제에서는 수 없는 형식의 필드를 정의 하려면 `T` 나 `U` 클래스에서 `Innermost`이므로 해당 형식 매개 변수 범위에 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4167">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="94b23-4168">다음 어셈블러 코드를 c + +, Visual Basic 및 C#에 정의 된 경우 방식으로 작동 하는 중첩된 클래스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4168">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="94b23-4169">사용할 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 고급 언어에 정의 된 중첩 된 클래스를 검사 하 고이 명명 스키마를 확인할입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4169">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4170">다음 예제에서는 합니다 <xref:System.Type.MakeGenericType%2A> 에 대 한 제네릭 형식 정의에서 생성된 된 형식을 만드는 방법의 <xref:System.Collections.Generic.Dictionary%602> 형식.</span><span class="sxs-lookup"><span data-stu-id="94b23-4170">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="94b23-4171">생성 된 형식은 <xref:System.Collections.Generic.Dictionary%602> 의 `Test` 문자열 키를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4171">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="94b23-4172">현재 형식이 제네릭 형식의 정의를 나타내지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4172">The current type does not represent a generic type definition.</span>
          </span>
          <span data-ttu-id="94b23-4173">즉, <see cref="P:System.Type.IsGenericTypeDefinition" />이 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4173">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-4174">
            <paramref name="typeArguments" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4174">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-4175">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4175">-or-</span>
          </span>
          <span data-ttu-id="94b23-4176">
            <paramref name="typeArguments" />의 요소가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4176">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-4177">
            <paramref name="typeArguments" />의 요소 수가 현재 제네릭 형식 정의의 형식 매개 변수 수와 같지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4177">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span>
          </span>
          <span data-ttu-id="94b23-4178">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4178">-or-</span>
          </span>
          <span data-ttu-id="94b23-4179">
            <paramref name="typeArguments" />의 요소가 현재 제네릭 형식의 해당 형식 매개 변수에 지정된 제약 조건을 충족하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4179">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span>
          </span>
          <span data-ttu-id="94b23-4180">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4180">-or-</span>
          </span>
          <span data-ttu-id="94b23-4181">
            <paramref name="typeArguments" />는 포인터 형식(<see cref="P:System.Type.IsPointer" />는 <see langword="true" />를 반환), 참조로 전달되는 형식(<see cref="P:System.Type.IsByRef" />는 <see langword="true" />를 반환) 또는 <see cref="T:System.Void" />인  요소를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4181">
              <paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-4182">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4182">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="94b23-4183">파생 클래스에서 구현을 제공해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4183">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="94b23-4184">리플렉션 및 제네릭 형식</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4184">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="94b23-4185">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4185">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4186">현재 형식에 대한 포인터를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4186">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4187">현재 형식에 대한 포인터를 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4187">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4188"><xref:System.Type.MakePointerType%2A> 메서드 매개 변수 목록에 대 한 포인터 형식을 생성 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4188">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="94b23-4189">경우 MSIL (Microsoft intermediate language), 구문을 사용 하 여 현재 <xref:System.Type> 개체가 나타내는 <xref:System.Int32>,이 메서드는 반환을 <xref:System.Type> 개체를 나타내는 `Int32*`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4189">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4190">다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.</span><span class="sxs-lookup"><span data-stu-id="94b23-4190">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-4191">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4191">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-4192">현재 형식이 <see cref="T:System.TypedReference" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4192">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="94b23-4193">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4193">-or-</span>
          </span>
          <span data-ttu-id="94b23-4194">현재 형식이 <see langword="ByRef" /> 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4194">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="94b23-4195">즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4195">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4196">이 멤버가 형식 또는 중첩 형식임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4196">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4197">이 멤버가 형식 또는 중첩 형식임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4197">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4198">이 속성을 재정의 <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4198">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="94b23-4199">따라서 집합을 조사할 때 <xref:System.Reflection.MemberInfo> 개체-예를 들어, 반환 된 배열 <xref:System.Type.GetMembers%2A>-는 <xref:System.Reflection.MemberInfo.MemberType%2A> 속성에서 반환 <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> 지정된 된 멤버 중첩 된 형식인 경우.</span><span class="sxs-lookup"><span data-stu-id="94b23-4199">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects—for example, the array returned by <xref:System.Type.GetMembers%2A>—the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="94b23-4200">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4200">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="94b23-4201">예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4201">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="94b23-4202">하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4202">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4203">다음 코드 예제는 `MemberType` 필드에 대 한 매개 변수로 `GetMember` 메서드:</span><span class="sxs-lookup"><span data-stu-id="94b23-4203">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4204">
            <see cref="T:System.Type" /> 정보의 손실된 값을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4204">Represents a missing value in the <see cref="T:System.Type" /> information.</span>
          </span>
          <span data-ttu-id="94b23-4205">이 필드는 읽기 전용입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4205">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4206">사용 된 `Missing` 매개 변수의 기본 값을 가져오려면 리플렉션을 통해 호출에 대 한 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4206">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="94b23-4207">경우는 `Missing` 필드 매개 변수 값에 대 한 전달 되며 해당 매개 변수에 대해 기본값이 <xref:System.ArgumentException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4207">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4208">다음 코드 예제에서는 `Missing` 기본 인수를 사용 하 여 메서드를 호출 하는 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4208">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="94b23-4209">이 코드의 결과는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4209">This code produces the following output:</span></span>  
  
 <span data-ttu-id="94b23-4210">a = 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="94b23-4210">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="94b23-4211">10 = b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="94b23-4211">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="94b23-4212">10 = b 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="94b23-4212">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4213">현재 <see cref="T:System.Type" />이 정의된 모듈(DLL)을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4213">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4214">현재 <see cref="T:System.Type" />이 정의된 모듈입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4214">The module in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4215">하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 제네릭 형식 정의가 정의 된 모듈을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4215">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="94b23-4216">예를 들어의 인스턴스를 만듭니다 `MyGenericStack<int>`는 <xref:System.Type.Module%2A> 생성 된 형식에 대 한 속성에는 모듈을 반환 합니다. `MyGenericStack<T>` 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4216">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="94b23-4217">마찬가지로, 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식이 포함 된 어셈블리를 반환 합니다. `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4217">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4218">다음 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Type.Namespace%2A> 하 고 `Module` 속성 및 <xref:System.Type.ToString%2A> 메서드의 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4218">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4219">
            <see cref="T:System.Type" />의 네임스페이스를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4219">Gets the namespace of the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4220">
            <see cref="T:System.Type" />의 네임스페이스입니다. 현재 인스턴스가 제네릭 매개 변수를 나타내거나 네임스페이스가 없으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4220">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4221">네임 스페이스는 논리적 디자인 타임 명명 편리 하 게 하는 데 주로 응용 프로그램에서 범위를 정의 하 고 클래스와 기타 형식을 단일 계층 구조에서를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4221">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="94b23-4222">런타임의 측면에서 보면 네임 스페이스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4222">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="94b23-4223">하는 경우 현재 <xref:System.Type> 은 생성 된 제네릭 형식을 나타내며,이 속성은 제네릭 형식 정의가 포함 된 네임 스페이스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4223">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="94b23-4224">마찬가지로, 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식 정의 포함 하는 네임 스페이스를 반환 합니다. `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4224">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="94b23-4225">하는 경우 현재 <xref:System.Type> 개체는 제네릭 매개 변수를 나타내는 경우이 속성은 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4225">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4226">다음 예제를 사용 하는 방법을 보여 줍니다 합니다 `Namespace` 하 고 <xref:System.Type.Module%2A> 속성 및 <xref:System.Type.ToString%2A> 메서드의 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4226">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-4227">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4227">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="94b23-4228">비교할 첫 번째 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4228">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="94b23-4229">비교할 두 번째 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4229">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4230">두 <see cref="T:System.Type" /> 개체가 같은지를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4230">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4231">
            <see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4231">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="94b23-4232">비교할 첫 번째 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4232">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="94b23-4233">비교할 두 번째 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4233">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4234">두 <see cref="T:System.Type" /> 개체가 같지 않은지를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4234">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4235">
            <see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4235">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4236">이 멤버를 얻는 데 사용된 클래스 개체를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4236">Gets the class object that was used to obtain this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4237">이 <see langword="Type" /> 개체를 얻는 데 사용된 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4237">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4238">에 대 한 <xref:System.Type> 개체의 경우이 속성의 값은 항상 동일한 값으로는 <xref:System.Type.DeclaringType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4238">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4239">이 예제에 중첩된 된 클래스의 리플렉션된 형식과 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4239">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="94b23-4240">가져올 <see cref="T:System.Type" />의 어셈블리로 한정된 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4240">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="throwIfNotFound">
          <span data-ttu-id="94b23-4241">형식을 찾을 없는 경우 <see langword="true" />을 throw하려면 <see cref="T:System.TypeLoadException" />이고, 형식을 찾을 수 없는 경우 <see langword="false" />을 반환하려면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4241">
              <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span>
          </span>
          <span data-ttu-id="94b23-4242">또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4242">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="94b23-4243">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4243">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="94b23-4244">
            <c>typeName</c>에 대해 대/소문자를 구분하지 않는 검색을 수행하려면 <see langword="true" />이고, <c>typeName</c>에 대해 대/소문자를 구분하는 검색을 수행하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4244">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>; <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4245">대/소문자를 구분하여 검색할지 여부와 형식이 없으면 예외를 throw할지를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4245">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span>
          </span>
          <span data-ttu-id="94b23-4246">형식은 실행을 위해서가 아니라 리플렉션을 위해서만 로드됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4246">The type is loaded for reflection only, not for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4247">지정된 이름의 형식이 있으면 이를 반환하고 그렇지 않으면 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4247">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="94b23-4248">형식을 찾을 수 없는 경우에는 <paramref name="throwIfNotFound" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4248">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="94b23-4249">경우에 따라서는 <paramref name="throwIfNotFound" /> 값과 상관없이 예외가 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4249">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span>
          </span>
          <span data-ttu-id="94b23-4250">예외 섹션을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4250">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4251">형식을 포함 하는 어셈블리 없는 경우 리플렉션 전용 컨텍스트에 로드를 사용 하는 <xref:System.Type.ReflectionOnlyGetType%2A> 메서드는 먼저 해당 어셈블리를 로드 리플렉션 위해서만 사용 하 여를 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 메서드를 호출 하 여 형식을 로드 한 다음는 어셈블리의 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-4251">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="94b23-4252">어셈블리의 정규화 된 이름에 대 한 자세한 내용은 참조는 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4252">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="94b23-4253">형식 이름 지정에 대 한 자세한 내용은 참조는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4253">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="94b23-4254">어셈블리가 이미 실행에 대 한 로드를 다른 복사본 리플렉션 전용 컨텍스트로 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4254">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="94b23-4255">`throwIfNotFound` 되나요 유형을 찾을 수 없습니다 하 고 특정 한 다른 예외 조건을 표시 하지 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4255">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="94b23-4256">값에 관계 없이 일부 예외가 throw 됩니다 `throwIfNotFound`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4256">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="94b23-4257">예를 들어, 어셈블리 유효 하지 않은 경우는 <xref:System.BadImageFormatException> 이 throw 경우에 `throwIfNotFound` 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4257">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="94b23-4258">리플렉션 전용 컨텍스트를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [방법: 리플렉션 전용 컨텍스트에 어셈블리 로드](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4258">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="94b23-4259">
            <paramref name="typeName" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4259">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="94b23-4260">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4260">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="94b23-4261">
            <paramref name="throwIfNotFound" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4261">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="94b23-4262">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4262">-or-</span>
          </span>
          <span data-ttu-id="94b23-4263">
            <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4263">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="94b23-4264">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4264">-or-</span>
          </span>
          <span data-ttu-id="94b23-4265">
            <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4265">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="94b23-4266">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4266">-or-</span>
          </span>
          <span data-ttu-id="94b23-4267">
            <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4267">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="94b23-4268">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4268">-or-</span>
          </span>
          <span data-ttu-id="94b23-4269">
            <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 개체의 배열을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4269">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="94b23-4270">
            <paramref name="typeName" />에 어셈블리 이름이 포함되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4270">
              <paramref name="typeName" /> does not include the assembly name.</span>
          </span>
          <span data-ttu-id="94b23-4271">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4271">-or-</span>
          </span>
          <span data-ttu-id="94b23-4272">
            <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문(예: "MyType[,\*,]")을 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4272">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="94b23-4273">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4273">-or-</span>
          </span>
          <span data-ttu-id="94b23-4274">
            <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4274">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="94b23-4275">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4275">-or-</span>
          </span>
          <span data-ttu-id="94b23-4276">
            <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4276">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="94b23-4277">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4277">-or-</span>
          </span>
          <span data-ttu-id="94b23-4278">
            <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4278">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="94b23-4279">
            <paramref name="throwIfNotFound" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4279">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="94b23-4280">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4280">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="94b23-4281">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4281">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="94b23-4282">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4282">-or-</span>
          </span>
          <span data-ttu-id="94b23-4283">어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4283">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="94b23-4284">정규화된 형식 이름 지정</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4284">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">
          <span data-ttu-id="94b23-4285">방법: 리플렉션 전용 컨텍스트에 어셈블리 로드</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4285">How to: Load Assemblies into the Reflection-Only Context</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4286">현재 형식의 레이아웃을 설명하는 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4286">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4287">현재 형식의 전체 레이아웃 기능을 설명하는 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4287">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4288"><xref:System.Runtime.InteropServices.StructLayoutAttribute> 반환 하지 않습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="94b23-4288"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="94b23-4289">대신,이 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4289">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4290">다음 코드 예제는 먼저 클래스, 구조체 및 특별 한 레이아웃이 특성 (구조 내에 중첩 된 클래스)를 사용 하 여 구조를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4290">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="94b23-4291">이 예제에서는 다음 사용 합니다 <xref:System.Type.StructLayoutAttribute%2A> 속성을를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 각 형식과 표시 특성의 속성에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4291">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-4292">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4292">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="94b23-4293">나중에 사용하기 위해 예약되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4293">Reserved for future use.</span>
          </span>
          <span data-ttu-id="94b23-4294">IID_NULL이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4294">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="94b23-4295">매핑할 전달된 이름의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4295">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="94b23-4296">매핑할 이름의 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4296">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="94b23-4297">이름을 해석할 로캘 컨텍스트입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4297">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="94b23-4298">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4298">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4299">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4299">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4300">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4300">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="94b23-4301">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4301">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="94b23-4302">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4302">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="94b23-4303">반환할 형식 정보입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4303">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="94b23-4304">형식 정보의 로캘 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4304">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="94b23-4305">요청된 형식 정보 개체에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4305">A pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4306">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4306">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4307">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4307">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="94b23-4308">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4308">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="94b23-4309">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4309">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="94b23-4310">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4310">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4311">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4311">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4312">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4312">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="94b23-4313">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4313">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="94b23-4314">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4314">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="94b23-4315">멤버를 식별합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4315">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="94b23-4316">나중에 사용하기 위해 예약되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4316">Reserved for future use.</span>
          </span>
          <span data-ttu-id="94b23-4317">IID_NULL이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4317">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="94b23-4318">인수를 해석할 로캘 컨텍스트입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4318">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="94b23-4319">호출의 컨텍스트를 설명하는 플래그입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4319">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="94b23-4320">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4320">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="94b23-4321">결과를 저장할 위치에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4321">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="94b23-4322">예외 정보가 포함된 구조체에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4322">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="94b23-4323">오류가 있는 첫 번째 인수의 인덱스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4323">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="94b23-4324">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4324">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4325">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4325">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="94b23-4326">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4326">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="94b23-4327">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4327">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4328">현재 <see langword="String" />의 이름을 나타내는 <see langword="Type" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4328">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="94b23-4329">현재 <see cref="T:System.String" />의 이름을 나타내는 <see cref="T:System.Type" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4329">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4330">이 메서드는 모든 기본 형식에 대 한 이름과 정규화 된 공용 언어 런타임 네임 스페이스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4330">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="94b23-4331">예를 들어 C# 명령 `(long)0.Type().ToString()` 단순히 "Int64" 대신 "System.Int64"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4331">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="94b23-4332">하는 경우 현재 <xref:System.Type> 네임 스페이스 및 중첩 된 형식으로는 어셈블리가 아니라 제네릭 형식, 형식 및 형식 인수는 정규화 된 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4332">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="94b23-4333">하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수는 형식 매개 변수의 정규화 되지 않은 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4333">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4334">다음 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Type.Namespace%2A> 하 고 <xref:System.Type.Module%2A> 속성 및 `ToString` 메서드의 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4334">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="94b23-4335">다음 예제에서 반환 된 문자열을 비교 합니다 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="94b23-4335">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4336">현재 <see cref="T:System.Type" />에 대한 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4336">Gets the handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4337">현재 <see cref="T:System.Type" />에 대한 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4337">The handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4338">`TypeHandle` 형식을 나타내는 내부 데이터 구조에 대 한 포인터를 캡슐화 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4338">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="94b23-4339">이 핸들은 프로세스 수명 동안 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4339">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="94b23-4340">핸들을 얻은 응용 프로그램 도메인에만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4340">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94b23-4341">다음 예제에서는 해당 유형의 핸들을 반환 하 고 핸들에서 형식을 가져옵니다을 표시 하는 메서드 핸들을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4341">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="94b23-4342">.NET Compact Framework에서는 현재 이 속성을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4342">The .NET Compact Framework does not currently support this property.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4343">형식에 대한 이니셜라이저를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4343">Gets the initializer for the type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4344">
            <see cref="T:System.Type" />에 대한 클래스 생성자의 이름이 들어 있는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4344">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94b23-4345">클래스 이니셜라이저를 통해 사용할 수도 있습니다는 <xref:System.Type.FindMembers%2A> 메서드를 또는 오버 로드를 통해 합니다 <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, 및 <xref:System.Type.GetConstructors%2A> 메서드를 <xref:System.Reflection.BindingFlags> 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4345">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="94b23-4346">하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="94b23-4346">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="94b23-4347">이 형식을 나타내는 공용 언어 런타임에서 제공되는 형식을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4347">Indicates the type provided by the common language runtime that represents this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="94b23-4348">
            <see cref="T:System.Type" />의 내부 시스템 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="94b23-4348">The underlying system type for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>