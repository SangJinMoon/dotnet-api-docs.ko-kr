<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3ab234edad8a65f7b4b6688da32990c9642f79d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731667" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>응용 프로그램이 실행되는 격리된 환경인 응용 프로그램 도메인을 나타냅니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 으로 표시 되는 응용 프로그램 도메인, <xref:System.AppDomain> 개체를 관리 코드를 실행 하는 격리, 언로드 및 보안 경계를 제공할 수 있습니다.  
  
-   응용 프로그램 도메인을 사용 하 여 프로세스를 중단 시킬 수 있는 작업을 격리 합니다. 하는 경우의 상태는 <xref:System.AppDomain> 작업을 실행 하는 불안정는 <xref:System.AppDomain> 언로드할 수는 프로세스에 영향을 주지 않고 합니다. 프로세스 다시 시작 하지 않고 오래 동안 실행 해야 하는 경우에 유용 합니다. 또한 데이터를 공유 해야 하는 작업을 격리 하려면 응용 프로그램 도메인을 사용할 수 있습니다.  
  
-   어셈블리가 있는 경우 기본 응용 프로그램 도메인에 로드, 프로세스가 실행 되는 동안 메모리에서 언로드할 수 없습니다. 그러나 로드 하 고 어셈블리를 실행 하는 두 번째 응용 프로그램 도메인을 열면 해당 응용 프로그램 도메인이 언로드될 때 어셈블리 로드 않습니다. 이 기술을 사용 하 여 때 큰 Dll을 사용 하 여 장기 실행 프로세스의 작업 집합을 최소화 합니다.  
  
 여러 응용 프로그램 도메인은 단일 프로세스;에서 실행할 수 있습니다. 그러나 응용 프로그램 도메인과 스레드 간에 일대일 상관 하지 않습니다. 여러 스레드는 단일 응용 프로그램 도메인에 속할 수 있습니다 및 단일 응용 프로그램 도메인에 스레드를 실행 하는 동안 지정된 된 스레드가 지정된 된 시간에는 단일 응용 프로그램 도메인으로 제한 되지 않습니다.  
  
 사용 하 여 응용 프로그램 도메인이 만들어집니다는 <xref:System.AppDomain.CreateDomain%2A> 메서드. <xref:System.AppDomain> 인스턴스 로드 하 고 어셈블리를 실행 하는 데 사용 됩니다 (<xref:System.Reflection.Assembly>). 경우는 <xref:System.AppDomain> 은 더 이상 사용 중인 것 언로드할 수 없습니다.  
  
 <xref:System.AppDomain> 클래스 응용 프로그램 도메인 로드, 됩니다 때 어셈블리를 로드할 때 또는 처리 되지 않은 예외가 throw 될 때 응답 하도록 응용 프로그램을 사용할 수 있는 이벤트의 집합을 구현 합니다.  
  
 응용 프로그램 도메인 사용에 대 한 자세한 내용은 참조 하십시오. [응용 프로그램 도메인](~/docs/framework/app-domains/application-domains.md)합니다.  
  
 이 클래스가 구현 하는 <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, 및 <xref:System.Security.IEvidenceFactory> 인터페이스입니다.  
  
 에 대 한 원격 가능 래퍼를 만들지 마십시오는 <xref:System.AppDomain> 개체입니다. 이렇게 하는에 대 한 원격 참조를 게시할 수 <xref:System.AppDomain>와 같은 메서드를 노출 <xref:System.AppDomain.CreateInstance%2A> 원격 액세스 및에 대 한 코드 액세스 보안을 효과적으로 제거 <xref:System.AppDomain>합니다. 면 원격에 연결 되는 악성 클라이언트 <xref:System.AppDomain> 모든 리소스에 대 한 액세스 권한을 얻을 수는 <xref:System.AppDomain> 자체에 액세스할 수 있습니다. 확장 하는 모든 형식에 대 한 원격 가능 래퍼를 만들지 마십시오 <xref:System.MarshalByRefObject> 보안 시스템을 무시 하는 악의적인 클라이언트가 사용할 수 있는 메서드를 구현 하 고 있습니다.  
  
> [!CAUTION]
>  기본값은 <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> 속성은 `false`합니다. 이 설정은 서비스에 대 한 안전 하지 않습니다. 서비스에서 부분적으로 신뢰할 수 있는 코드가 다운로드를 방지 하려면이 속성을 설정 `true`합니다.  
  
   
  
## Examples  
 이 예제에서는 새 <xref:System.AppDomain>, 새로운의 형식을 인스턴스화할 <xref:System.AppDomain>, 해당 형식의 개체와 통신 합니다. 또한이 예제에서는 언로드할 수는 <xref:System.AppDomain> 개체가 가비지 수집 합니다.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 응용 프로그램 도메인의 활성화 컨텍스트를 가져옵니다.</summary>
        <value>현재 응용 프로그램 도메인의 활성화 컨텍스트를 나타내는 개체이거나, 이 도메인에 활성화 컨텍스트가 없는 경우 <see langword="null" />입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">전용 경로에 추가되는 디렉터리 이름입니다.</param>
        <summary>지정된 디렉터리 이름을 전용 경로 목록에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 사용에 이미 로드 된 후 어셈블리 검색 경로 변경 될 수 있으므로 권장 되지 않습니다. 대신 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 속성을 사용하세요.  
  
 전용 경로 또는 상대 검색 경로 어셈블리 확인자에서 전용 어셈블리를 조사 하는 위치는 기본 디렉터리에 상대적인 경로입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인에서 응용 프로그램의 ID를 가져옵니다.</summary>
        <value>응용 프로그램 도메인에서 응용 프로그램을 식별하는 개체입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램에 부여된 권한 및 해당 응용 프로그램을 실행할 수 있는 신뢰 수준이 있는지를 설명하는 정보를 가져옵니다.</summary>
        <value>응용 프로그램 도메인의 응용 프로그램에 대한 권한과 신뢰 정보를 캡슐화하는 개체입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="P:System.Reflection.Assembly.FullName" /> 속성에서 제공하는 형식의 어셈블리 표시 이름입니다.</param>
        <summary>정책이 적용된 후 어셈블리 표시 이름을 반환합니다.</summary>
        <returns>정책이 적용된 후의 어셈블리 표시 이름이 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A> 메서드는 어셈블리 표시 이름, 사후 정책 표시 이름을 반환 합니다. 리플렉션 전용 컨텍스트에 정책을 적용 하지 않습니다 때문에 정책을 사용 하 여 어셈블리를 로드 해야 할 경우에 유용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리가 로드될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler> 대리자이 이벤트는 어떤 어셈블리가 로드 되었는지 나타냅니다.  
  
 이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.AssemblyLoad> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리를 확인하지 못할 경우 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 책임은 <xref:System.ResolveEventHandler> 는 어셈블리를 반환 하 여 지정 된이 이벤트는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성을 또는 어셈블리가 인식 되지 않으면 null을 반환 합니다. 어셈블리는 실행 컨텍스트에 로드 해야 합니다. 리플렉션 전용 컨텍스트에 로드 하는 경우이 이벤트를 발생 시킨 로드는 실패 합니다.  
  
 이 이벤트의 사용에 대 한 지침을 참조 하십시오. [어셈블리 로드 해결](~/docs/framework/app-domains/resolve-assembly-loads.md)합니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성을 확인할 수 없는 어셈블리 로드를 요청한 어셈블리를 반환 합니다. 예를 들어 로더 수 요청 어셈블리와 해당 종속성 검색 경로에 없기 때문에 요청한 어셈블리의 종속성을 로드할 수 없습니다. 요청한 어셈블리의 id를 알면 종속성의 둘 이상의 버전을 사용할 수 있는 경우 올바른 버전을 확인 또는 종속성을 찾거나에 유용할 수 있습니다. 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.  
  
> [!IMPORTANT]
>  부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler> 리소스 어셈블리를 포함 하는 모든 어셈블리에 대 한 이벤트가 발생 합니다. 이전 버전에서는 리소스 어셈블리에 대 한 이벤트가 발생 하지 않습니다. 운영 체제에 지역화 된 처리기에 여러 번 호출할 수 있습니다: 대체 (fallback) 체인의 각 문화권에 대해 한 번씩입니다.  
  
 이 이벤트는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성 정책 적용 하기 전에 어셈블리 이름을 반환 합니다.  
  
> [!IMPORTANT]
>  둘 이상의 이벤트 처리기가이 이벤트에 대 한 등록을 하는 경우 이벤트 처리기는 값을 반환할 때까지 순서 대로 이벤트 handlersarecalled 반드시 그럴 `null`합니다. 후속 이벤트 처리기는 무시 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리를 가져옵니다.</summary>
        <value>어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 해당 하는 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> 속성입니다. 또한 검색할 수 있습니다를 사용 하는 <xref:System.AppDomain.GetData%2A> 메서드에 "APPBASE" 문자열입니다.  
  
   
  
## Examples  
 다음 코드 예제를 도메인에 로드를 어셈블리를 검색할 때 사용할 기본 디렉터리를 지정 하는 새 응용 프로그램 도메인을 만듭니다. 이 예제에서는 다음 사용 하 여는 <xref:System.AppDomain.BaseDirectory%2A> 속성을 콘솔에 표시 하기 위해 기본 디렉터리 경로 가져옵니다.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 자체의 정보에 대 한 액세스를 if 비롯 하 여 경로 "file://" 형태로 또는 \\\UNC\dir 또는 "c:\\"입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>전용 어셈블리의 위치를 지정하는 경로를 빈 문자열("")로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 전용 경로 공용 언어 런타임에서 전용 어셈블리를 찾는 검색 하는 기본 디렉터리의 상대 경로입니다.  
  
 자세한 내용은 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>을 참조하십시오.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.AppDomain.ClearPrivatePath%2A> 메서드를 검색할 어셈블리를 로드할 때 전용 경로 목록에서 모든 항목을 제거 합니다.  
  
 이 메서드는 이전 이제 하며 새로운 개발에 사용할 수 없습니다.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>섀도 복사된 어셈블리를 포함하는 디렉터리 목록을 빈 문자열("")로 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 섀도 복사본 경로가 어셈블리 섀도 복사 디렉터리의 목록이 저장 됩니다.  
  
 자세한 내용은 참조 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> 및 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 COM 형식의 새 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</param>
        <param name="typeName">요청된 형식의 이름입니다.</param>
        <summary>지정한 COM 형식의 새 인스턴스를 만듭니다. 매개 변수는 형식 및 형식 이름을 포함하는 어셈블리가 포함된 파일 이름을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 형식을 로컬로 로드할 필요 없이 개체를 원격으로 만들려는 합니다.  
  
 반환 값은 래핑되지 실제 개체에 액세스 해야 합니다.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> 의 값을 가진 특성 `true` ; 해당 형식의 인스턴스를 만들려면이 메서드에 대 한 COM 형식으로 명시적으로 나 기본적으로 적용할 해야 그렇지 않으면 <xref:System.TypeLoadException> throw 됩니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.TypeLoadException">형식을 로드할 수 없는 경우.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.MissingMethodException">매개 변수가 없는 public 생성자를 찾지 못한 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />가 없는 경우</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" />는 추상 클래스입니다.  
  
 또는  
  
 이 멤버가 런타임에 바인딩된 메커니즘을 사용하여 호출되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NullReferenceException">참조되는 COM 개체가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</param>
        <param name="typeName">요청된 형식의 이름입니다.</param>
        <param name="hashValue">계산된 해시 코드의 값을 나타냅니다.</param>
        <param name="hashAlgorithm">어셈블리 매니페스트에 사용되는 해시 알고리즘을 나타냅니다.</param>
        <summary>지정한 COM 형식의 새 인스턴스를 만듭니다. 매개 변수는 형식 및 형식 이름을 포함하는 어셈블리가 포함된 파일 이름을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 형식을 로컬로 로드할 필요 없이 개체를 원격으로 만들려는 합니다.  
  
 반환 값은 래핑되지 실제 개체에 액세스 해야 합니다.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> 의 값을 가진 특성 `true` ; 해당 형식의 인스턴스를 만들려면이 메서드에 대 한 COM 형식으로 명시적으로 나 기본적으로 적용할 해야 그렇지 않으면 <xref:System.TypeLoadException> throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.TypeLoadException">형식을 로드할 수 없는 경우.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.MissingMethodException">매개 변수가 없는 public 생성자를 찾지 못한 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />가 없는 경우</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" />는 추상 클래스입니다.  
  
 또는  
  
 이 멤버가 런타임에 바인딩된 메커니즘을 사용하여 호출되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" />가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NullReferenceException">참조되는 COM 개체가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 응용 프로그램 도메인을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">도메인의 이름입니다.</param>
        <summary>지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다.</summary>
        <returns>새로 만든 응용 프로그램 도메인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName` 매개 변수는 사용자에 게 의미 있는 방식으로 도메인을 식별 하기 위한 것이 있습니다. 이 문자열은 사용자 인터페이스에 표시 하기에 적합 해야 합니다.  
  
 이 메서드 오버 로드는 <xref:System.AppDomainSetup> 기본 응용 프로그램 도메인의 정보입니다.  
  
   
  
## Examples  
 다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">도메인의 이름입니다. 이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다. 자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</param>
        <param name="securityInfo">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다. 현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</param>
        <summary>제공된 증명 정보를 사용하여 지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다.</summary>
        <returns>새로 만든 응용 프로그램 도메인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드는 <xref:System.AppDomainSetup> 기본 응용 프로그램 도메인의 정보입니다.  
  
 경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 사용 됩니다.  
  
> [!IMPORTANT]
>  샌드 박싱된 응용 프로그램 도메인을 만드는이 메서드 오버 로드를 사용 하지 마십시오. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]을 위해 제공 된 증거 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다. 사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 메서드 오버 로드를 샌드 박싱된 응용 프로그램 도메인을 만듭니다.  
  
   
  
## Examples  
 다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">도메인의 이름입니다. 이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다. 자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</param>
        <param name="securityInfo">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다. 현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</param>
        <param name="info">응용 프로그램 도메인 초기화 정보를 포함하는 개체입니다.</param>
        <summary>지정한 이름, 증명 정보 및 응용 프로그램 도메인 설치 정보를 사용하여 새 응용 프로그램 도메인을 만듭니다.</summary>
        <returns>새로 만든 응용 프로그램 도메인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `info` 가 제공 되지 않으면이 메서드 오버 로드 사용 하 여는 <xref:System.AppDomainSetup> 기본 응용 프로그램 도메인의 정보입니다.  
  
 경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 사용 됩니다.  
  
> [!IMPORTANT]
>  샌드 박싱된 응용 프로그램 도메인을 만드는이 메서드 오버 로드를 사용 하지 마십시오. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]을 위해 제공 된 증거 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다. 사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 메서드 오버 로드를 샌드 박싱된 응용 프로그램 도메인을 만듭니다.  
  
   
  
## Examples  
 다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">도메인의 이름입니다. 이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다. 자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />의 설명을 참조하세요.</param>
        <param name="securityInfo">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다. 현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</param>
        <param name="info">응용 프로그램 도메인 초기화 정보를 포함하는 개체입니다.</param>
        <param name="grantSet">새 응용 프로그램 도메인에 로드된 특정 권한이 없는 모든 어셈블리에 부여된 기본 권한 집합입니다.</param>
        <param name="fullTrustAssemblies">새 응용 프로그램 도메인에서 완전히 신뢰할 수 있는 것으로 간주할 어셈블리를 나타내는 강력한 이름의 배열입니다.</param>
        <summary>지정한 이름, 증명 정보, 응용 프로그램 도메인 설치 정보, 기본 권한 집합 및 완전히 신뢰할 수 있는 어셈블리의 배열을 사용하여 새 응용 프로그램 도메인을 만듭니다.</summary>
        <returns>새로 만든 응용 프로그램 도메인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 해야 합니다는 <xref:System.AppDomainSetup.ApplicationBase%2A> 의 속성은 <xref:System.AppDomainSetup> 에 대해 제공 하는 개체 `info`합니다. 그러지 않으면 예외가 throw됩니다.  
  
 경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 사용 됩니다.  
  
 에 제공 된 정보의 `grantSet` 및 `fullTrustAssemblies` 만드는 데 사용 되는 <xref:System.Security.Policy.ApplicationTrust> 새 응용 프로그램 도메인에 대 한 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">응용 프로그램 도메인이 <see langword="null" />인 경우  
  
 또는  
  
 <see cref="P:System.AppDomainSetup.ApplicationBase" /> 속성은 <paramref name="info" />에 대해 공급되는 <see cref="T:System.AppDomainSetup" /> 개체에 설정되지 않습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">만들고 응용 프로그램 도메인을 조작할 수 있습니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">도메인의 이름입니다. 이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다. 자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</param>
        <param name="securityInfo">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다. 현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</param>
        <param name="appBasePath">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리입니다. 자세한 내용은 <see cref="P:System.AppDomain.BaseDirectory" />을 참조하세요.</param>
        <param name="appRelativeSearchPath">어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리에 대한 상대 경로입니다. 자세한 내용은 <see cref="P:System.AppDomain.RelativeSearchPath" />을 참조하세요.</param>
        <param name="shadowCopyFiles">
          <see langword="true" />인 경우 어셈블리의 섀도 복사본이 이 응용 프로그램 도메인에 로드됩니다.</param>
        <summary>어셈블리의 섀도 복사본이 응용 프로그램 도메인에 로드되는지를 지정하는 매개 변수, 증명 정보, 응용 프로그램 기본 경로 및 상대 검색 경로를 사용하여 지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다.</summary>
        <returns>새로 만든 응용 프로그램 도메인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 사용 됩니다.  
  
 섀도 복사 하는 방법에 대 한 자세한 내용은 참조 <xref:System.AppDomain.ShadowCopyFiles%2A> 및 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
> [!IMPORTANT]
>  샌드 박싱된 응용 프로그램 도메인을 만드는이 메서드 오버 로드를 사용 하지 마십시오. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]을 위해 제공 된 증거 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다. 사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 메서드 오버 로드를 샌드 박싱된 응용 프로그램 도메인을 만듭니다.  
  
   
  
## Examples  
 다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">도메인의 이름입니다. 이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다. 자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</param>
        <param name="securityInfo">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다. 현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</param>
        <param name="appBasePath">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리입니다. 자세한 내용은 <see cref="P:System.AppDomain.BaseDirectory" />을 참조하세요.</param>
        <param name="appRelativeSearchPath">어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리에 대한 상대 경로입니다. 자세한 내용은 <see cref="P:System.AppDomain.RelativeSearchPath" />을 참조하세요.</param>
        <param name="shadowCopyFiles">
          어셈블리의 섀도 복사본을 응용 프로그램 도메인에 로드하려면 <see langword="true" />입니다.</param>
        <param name="adInit">새 <see cref="T:System.AppDomain" /> 개체가 초기화될 때 호출할 콜백 메서드를 나타내는 <see cref="T:System.AppDomainInitializer" /> 대리자입니다.</param>
        <param name="adInitArgs">새 <see cref="T:System.AppDomain" /> 개체가 초기화될 때 <c>adInit</c>에서 나타내는 콜백으로 전달할 문자열 인수의 배열입니다.</param>
        <summary>어셈블리의 섀도 복사본이 응용 프로그램 도메인에 로드되는지를 지정하는 매개 변수, 증명 정보, 응용 프로그램 기본 경로 및 상대 검색 경로를 사용하여 지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다. 응용 프로그램 도메인이 초기화될 때 호출되는 콜백 메서드와 콜백 메서드를 전달할 문자열 인수의 배열을 지정합니다.</summary>
        <returns>새로 만든 응용 프로그램 도메인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가 나타내는 메서드로 `adInit` 새로 만든된 응용 프로그램 도메인의 컨텍스트에서 실행 됩니다.  
  
 경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 사용 됩니다.  
  
 섀도 복사 하는 방법에 대 한 자세한 내용은 참조 <xref:System.AppDomain.ShadowCopyFiles%2A> 및 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
> [!IMPORTANT]
>  샌드 박싱된 응용 프로그램 도메인을 만드는이 메서드 오버 로드를 사용 하지 마십시오. 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]을 위해 제공 된 증거 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다. 사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 메서드 오버 로드를 샌드 박싱된 응용 프로그램 도메인을 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 어셈블리에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <summary>지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.  
  
 호출 하려는 경우 <xref:System.AppDomain.CreateInstance%2A> 응용 프로그램 도메인은 현재 어플리케이션 도메인에 없는 대상에 대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 로드 발생 합니다. 이후는 <xref:System.Reflection.Assembly> 않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 부하 실패할 수 있습니다. 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 대리자의 인스턴스를 만들 때 비관리 코드를 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다. 매개 변수에서는 활성화 특성의 배열을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.  
  
 호출 하려는 경우 <xref:System.AppDomain.CreateInstance%2A> 응용 프로그램 도메인은 현재 어플리케이션 도메인에 없는 대상에 대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 로드 발생 합니다. 이후는 <xref:System.Reflection.Assembly> 않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 부하 실패할 수 있습니다. 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 대리자의 인스턴스를 만들 때 비관리 코드를 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">
          <c>typeName</c> 생성자에 대해 선언된 공식적인 형식에 <c>args</c>를 강제로 적용하는 것을 제어하는 문화권별 정보입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다. 매개 변수는 바인더, 바인딩 플래그, 생성자 인수, 인수 해석에 사용되는 문화권별 정보 및 선택적 활성화 특성을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.  
  
 호출 하려는 경우 <xref:System.AppDomain.CreateInstance%2A> 응용 프로그램 도메인은 현재 어플리케이션 도메인에 없는 대상에 대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 로드 발생 합니다. 이후는 <xref:System.Reflection.Assembly> 않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 부하 실패할 수 있습니다. 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 <paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 대리자의 인스턴스를 만들 때 비관리 코드를 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">
          <c>typeName</c> 생성자에 대해 선언된 공식적인 형식에 <c>args</c>를 강제로 적용하는 것을 제어하는 문화권별 정보입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <param name="securityAttributes">
          <c>typeName</c>의 생성을 인증하는 데 사용하는 정보입니다.</param>
        <summary>지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다. 매개 변수에서는 바인더, 바인딩 플래그, 생성자 인수, 인수 해석에 사용되는 문화권별 정보, 활성화 특성 및 형식을 만들기 위한 인증을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.  
  
 호출 하려는 경우 <xref:System.AppDomain.CreateInstance%2A> 응용 프로그램 도메인은 현재 어플리케이션 도메인에 없는 대상에 대상 응용 프로그램 도메인에 있는 어셈블리의 성공적인 로드 발생 합니다. 이후는 <xref:System.Reflection.Assembly> 않습니다 <xref:System.MarshalByRefObject>이 메서드를 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 은 현재 어플리케이션 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임은 하려고은 현재 어플리케이션 도메인에 어셈블리를 로드 및 부하 실패할 수 있습니다. 현재 어플리케이션 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 먼저 로드 된 어셈블리와 다를 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.  
  
 또는  
  
 <paramref name="securityAttributes" />이 <see langword="null" />가 아닙니다. 레거시 CAS 정책을 사용하지 않을 때는 <paramref name="securityAttributes" />는 <see langword="null." />이 되어야 합니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 형식의 새 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <summary>지정한 형식의 새 인스턴스를 만듭니다. 매개 변수에서는 형식이 정의되는 어셈블리와 해당 형식의 이름을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다. 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다. 참조는 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성의 형식에 대 한 `typeName`합니다.  
  
> [!NOTE]
>  메서드에 대 한 초기 바인딩 호출을 변경한 경우 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 고, 해당 메서드 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 이외의 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다. 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다. 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 다른 응용 프로그램 도메인에 있는 코드를 실행 하는 가장 간단한 방법은 보여 줍니다. 이 예제에서는 클래스를 정의 `Worker` 에서 상속 되는 <xref:System.MarshalByRefObject>합니다. `Worker` 클래스 실행 되는 응용 프로그램 도메인의 이름을 표시 하는 메서드를 정의 합니다. 인스턴스를 만듭니다 `Worker` 기본 응용 프로그램 도메인에 새 응용 프로그램 도메인입니다.  
  
> [!NOTE]
>  포함 된 어셈블리 `Worker` 두 응용 프로그램 도메인에 로드 해야 하지만 새 응용 프로그램 도메인에만 존재 하는 다른 어셈블리를 로드할 수 있습니다.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있는 기능에 대 한 모듈 매니페스트 파일이 아닌에서 형식을 만드는 경우 또는 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>지정한 형식의 새 인스턴스를 만듭니다. 매개 변수에서는 형식이 정의되는 어셈블리, 해당 형식의 이름 및 활성화 특성의 배열을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다. 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다. 참조는 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성의 형식에 대 한 `typeName`합니다.  
  
> [!NOTE]
>  메서드에 대 한 초기 바인딩 호출을 변경한 경우 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 고, 해당 메서드 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 이외의 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다. 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다. 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 대리자의 인스턴스를 만들 때 비관리 코드를 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 문화권별 개체입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see langword="CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다. 원격 개체를 활성화하는 데 필요한 URL을 지정합니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>형식 이름의 대/소문자를 구분할지 여부, 만들 형식을 선택하는 데 사용되는 바인더와 바인딩 특성, 생성자의 인수, 문화권 및 활성화 특성을 지정하여, 지정한 어셈블리에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다.  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다. 참조는 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성의 형식에 대 한 `typeName`합니다.  
  
> [!NOTE]
>  메서드에 대 한 초기 바인딩 호출을 변경한 경우 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 고, 해당 메서드 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 이외의 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다. 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다. 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다.  
  
   
  
## Examples  
 다음 샘플의 사용법을 보여줍니다는 `ignoreCase` 매개 변수입니다.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 <paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 대리자의 인스턴스를 만들 때 비관리 코드를 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 문화권별 개체입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see langword="CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <param name="securityAttributes">
          <c>typeName</c>의 생성을 인증하는 데 사용하는 정보입니다.</param>
        <summary>지정한 형식의 새 인스턴스를 만듭니다. 매개 변수에서는 형식의 이름 및 형식을 찾고 만들 수 있는 방법을 지정합니다.</summary>
        <returns>
          <paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다.  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다. 참조는 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성의 형식에 대 한 `typeName`합니다.  
  
> [!NOTE]
>  메서드에 대 한 초기 바인딩 호출을 변경한 경우 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 고, 해당 메서드 형식의 개체의 메서드에 대 한 초기 바인딩 호출 `T2` 어셈블리에 `C` 이외의 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 은 현재 어플리케이션 도메인에 로드 됩니다. 이 로드에 대 한 초기 바인딩 호출 하는 경우에 발생 `T1.M()` 의 본문에서는 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다. 현재 도메인 어셈블리는 기본 도메인 인지 `C` 프로세스가 끝날 때까지 언로드할 수 없습니다. 현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 하지만 실패 합니다.  
  
   
  
## Examples  
 다음 샘플의 사용법을 보여줍니다는 `ignoreCase` 매개 변수입니다.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다. 어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 기본 생성자 `typeName` 가 호출 됩니다.  
  
 자세한 내용은 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드를 호출 하는 응용 프로그램 도메인 외에 대상 응용 프로그램 도메인에 인스턴스를 만드는 데 사용 됩니다, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다. 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.  
  
-   동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.  
  
-   호출 응용 프로그램 도메인 인스턴스 유형으로 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> 메서드 오버 로드를 대상 응용 프로그램 도메인에 있는 개체의 인스턴스를 만들고 해당 메서드를 호출 합니다.  
  
 이 예제에서는 정의 `MarshallableExample` 응용 프로그램 도메인 경계를 넘어 마샬링할 수 있는 클래스입니다. 이 예제에서는 현재 실행 중인 어셈블리에 대 한 경로, 대상 응용 프로그램 도메인을 만들고 사용 하 여 <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> 메서드 오버 로드를 대상 응용 프로그램 도메인에 예제에서는 어셈블리를 로드 하 고의 인스턴스를 만들 `MarshallableExample`합니다.  
  
> [!NOTE]
>  경로 절대이 예제에서는 상대 경로 때문에 작동 하지만 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 어셈블리를 로드 하려는 메서드를 사용 합니다.  
  
 개체 핸들, 래핑을 해제 한 후 대상 응용 프로그램 도메인에 개체를 사용 하는 데 세 가지 방법을 보여 줍니다.  
  
-   런타임에 바인딩을 사용할 경우 리플렉션을 사용 하 여 메서드를 호출 합니다. 이렇게 하면 어셈블리는 호출자의 응용 프로그램 도메인에 로드 되는 형식 정보가 필요 합니다. (이 예제에서는 이미 로드 됩니다.)  
  
-   호출자와 호출 수신자 모두에 알려진 인터페이스에는 개체를 캐스팅 합니다. 인터페이스 또는 호출자와 호출 수신자가 모두 참조 하는 세 번째 어셈블리 호출 어셈블리에 정의 된 경우 호출된 된 어셈블리는 호출자의 응용 프로그램 도메인에 로드있지 않습니다.  
  
-   개체를 직접 호출자에 게 해당 형식이 알려진 경우 사용 합니다. 어셈블리는 호출자의 응용 프로그램 도메인에 로드 되어야 합니다.  
  
 파생 되는 호출자가 호출된 되는 어셈블리는 호출자의 응용 프로그램 도메인에 로드 되지 않도록 방지 하는 다른 방법은는 <xref:System.MarshalByRefObject> 클래스 및 대상 응용 프로그램 도메인에서 실행 될 수 있는 메서드를 정의 합니다. 해당 메서드에 수 리플렉션을 사용 하 여 대상 어셈블리를 검사할 대상 어셈블리가 이미 대상 응용 프로그램 도메인에 로드 하기 때문에 있습니다. 예를 참조는 <xref:System.AppDomain.DynamicDirectory%2A> 속성입니다.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.MissingMethodException">매개 변수가 없는 public 생성자를 찾지 못한 경우</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다. 어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 기본 생성자 `typeName` 가 호출 됩니다.  
  
 이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.  
  
 경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드를 호출 하는 응용 프로그램 도메인 외에 대상 응용 프로그램 도메인에 인스턴스를 만드는 데 사용 됩니다, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다. 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.  
  
-   동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.  
  
-   호출 응용 프로그램 도메인 인스턴스 유형으로 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다. 어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">
          <c>typeName</c> 생성자에 대해 선언된 공식적인 형식에 <c>args</c>를 강제로 적용하는 것을 제어하는 문화권별 정보입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드를 호출 하는 응용 프로그램 도메인 외에 대상 응용 프로그램 도메인에 인스턴스를 만드는 데 사용 됩니다, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다. 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.  
  
-   동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.  
  
-   호출 응용 프로그램 도메인 인스턴스 유형으로 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 <paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다. 어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">
          <c>typeName</c> 생성자에 대해 선언된 공식적인 형식에 <c>args</c>를 강제로 적용하는 것을 제어하는 문화권별 정보입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <param name="securityAttributes">
          <c>typeName</c>의 생성을 인증하는 데 사용하는 정보입니다.</param>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다. 실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.  
  
 경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드를 호출 하는 응용 프로그램 도메인 외에 대상 응용 프로그램 도메인에 인스턴스를 만드는 데 사용 됩니다, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다. 그러나 인스턴스가 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 래핑 해제 된 인스턴스를 사용 하 여 다양 한 방식으로 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다. 예를 들어, 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다. 어셈블리를 호출 응용 프로그램 도메인에 로드 하는 경우 예외가 발생할 수 있습니다.  
  
-   동일한 어셈블리의 다른 버전이 이전에 호출 응용 프로그램 도메인에 로드 또는 호출 응용 프로그램 도메인의 로드 경로 같은 다른 예외 대상 응용 프로그램 도메인의 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.  
  
-   호출 응용 프로그램 도메인 인스턴스 유형으로 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.  
  
 또는  
  
 <paramref name="securityAttributes" />이 <see langword="null" />가 아닙니다. 레거시 CAS 정책을 사용하지 않을 때는 <paramref name="securityAttributes" />는 <see langword="null" />이 되어야 합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NullReferenceException">이 인스턴스가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다. 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.  
  
 자세한 내용은 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">매개 변수가 없는 public 생성자를 찾지 못한 경우</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름입니다(<see cref="P:System.Type.FullName" /> 속성 참조).</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다. 이 메서드 호출에 대 한 기본 생성자 `typeName`합니다.  
  
 이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">매개 변수가 없는 public 생성자를 찾지 못한 경우</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">
          <c>typeName</c> 생성자에 대해 선언된 공식적인 형식에 <c>args</c>를 강제로 적용하는 것을 제어하는 문화권별 정보입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>형식 이름의 대/소문자를 구분할지 여부, 만들 형식을 선택하는 데 사용되는 바인더와 바인딩 특성, 생성자의 인수, 문화권 및 활성화 특성을 지정하여, 지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다.  
  
 이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 <paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</param>
        <param name="typeName">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</param>
        <param name="ignoreCase">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</param>
        <param name="bindingAttr">
          <c>typeName</c> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다. <c>bindingAttr</c>이 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다. <c>binder</c>가 null이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달할 인수입니다. 이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <c>args</c>가 빈 배열이거나 null이어야 합니다.</param>
        <param name="culture">
          <c>typeName</c> 생성자에 대해 선언된 공식적인 형식에 <c>args</c>를 강제로 적용하는 것을 제어하는 문화권별 정보입니다. <c>culture</c>가 <see langword="null" />인 경우 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  
  
 이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <param name="securityAttributes">
          <c>typeName</c>의 생성을 인증하는 데 사용하는 정보입니다.</param>
        <summary>지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</summary>
        <returns>요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>합니다.  
  
 이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 public 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">어셈블리 매니페스트가 포함 된 파일을 읽을 수 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Threading.Thread" />에 대한 현재 응용 프로그램 도메인을 가져옵니다.</summary>
        <value>현재 응용 프로그램 도메인입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 새 응용 프로그램 도메인을 만듭니다. <xref:System.AppDomain.CurrentDomain%2A> 속성은 가져오는 데는 <xref:System.AppDomain> 현재 응용 프로그램 도메인을 나타내는 개체입니다. <xref:System.AppDomain.FriendlyName%2A> 속성은 다음 명령줄에 표시 되는 현재 응용 프로그램 도메인의 이름을 제공 합니다.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 응용 프로그램 도메인에서 동적 어셈블리를 정의합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리의 액세스 모드입니다.</param>
        <summary>지정한 이름 및 액세스 모드를 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 액세스 모드를 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에 `refusedPermissions`. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리의 액세스 모드입니다.</param>
        <param name="assemblyAttributes">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</param>
        <summary>지정한 이름, 액세스 모드 및 사용자 지정 특성을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute> 및 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 이 제한에 대 한 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
 이 메서드는 오버 로드는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 동적 어셈블리를 만드는 방법을 보여 줍니다는 <xref:System.Security.SecurityTransparentAttribute>합니다. 배열의 요소와 특성을 지정 해야 합니다 <xref:System.Reflection.Emit.CustomAttributeBuilder> 개체입니다.  
  
 만들 때 첫 번째 단계는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 을 가져오는 특성에 대 한 생성자입니다. 생성자에 매개 변수가 사용 되지 않으므로 <xref:System.Type.GetConstructor%2A> 메서드는 빈 배열을 사용 하 여 <xref:System.Type> 유형의 매개 변수를 나타내는 개체를 합니다. 결과 전달 하는 두 번째 단계는 <xref:System.Reflection.ConstructorInfo> 개체의 생성자에는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 클래스 형식의 빈 배열 함께 <xref:System.Object> 인수를 나타내는입니다.  
  
 결과 <xref:System.Reflection.Emit.CustomAttributeBuilder> 에 전달 되는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드는 배열의 유일한 요소입니다.  
  
 예제 코드는 새 동적 어셈블리의 모듈과 형식을 정의 하 고 어셈블리의 특성을 표시 합니다.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="evidence">동적 어셈블리에 제공된 증명 정보입니다. 증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</param>
        <summary>지정한 이름, 액세스 모드 및 증명 정보를 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다. 런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하기 위해 보안 정책을 통해 합니다. 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 해결 된 것으로 표시 합니다.  
  
 경우 동적 <xref:System.Reflection.Assembly> 은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에 `refusedPermissions`. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 코드 예제에서는의 인스턴스를 만들려고 시도 하는 첫째, `MyDynamicType` 호출 하 여는 <xref:System.AppDomain.CreateInstance%2A> 메서드가 잘못 된 어셈블리 이름이 결과 예외를 catch 합니다.  
  
 에 대 한 이벤트 처리기를 다음 추가 하는 코드 예제는 <xref:System.AppDomain.AssemblyResolve> 이벤트를 다시 시도의 인스턴스를 만드는`MyDynamicType`합니다. 호출 하는 동안 <xref:System.AppDomain.CreateInstance%2A>, <xref:System.AppDomain.AssemblyResolve> 잘못 된 어셈블리에 대 한 이벤트가 발생 합니다. 이벤트 처리기 이라는 형식을 포함 하는 동적 어셈블리를 만듭니다 `MyDynamicType`매개 변수가 없는 생성자를 제공 하 고 새 동적 어셈블리를 반환 합니다. 에 대 한 호출 <xref:System.AppDomain.CreateInstance%2A> 성공적으로 완료 되 고에 대 한 생성자 `MyDynamicType` 콘솔에서 메시지를 표시 합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="dir">어셈블리가 저장될 디렉터리 이름입니다. <c>dir</c>이 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</param>
        <summary>지정한 이름, 액세스 모드 및 저장소 디렉터리를 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에 `refusedPermissions`. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리의 액세스 모드입니다.</param>
        <param name="assemblyAttributes">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</param>
        <param name="securityContextSource">보안 컨텍스트의 소스입니다.</param>
        <summary>지정한 이름, 액세스 모드 및 사용자 지정 특성과 보안 컨텍스트에 대해 지정한 소스를 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute> 및 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 이 제한에 대 한 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" />의 값이 열거형 값 중 하나가 아니었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="dir">어셈블리가 저장될 디렉터리 이름입니다. <c>dir</c>이 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</param>
        <param name="evidence">동적 어셈블리에 제공된 증명 정보입니다. 증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</param>
        <summary>지정한 이름, 액세스 모드, 저장소 디렉터리 및 증명 정보를 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다. 런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하기 위해 보안 정책을 통해 합니다. 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 해결 된 것으로 표시 합니다.  
  
 경우 동적 <xref:System.Reflection.Assembly> 은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에 `refusedPermissions`. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="requiredPermissions">필수 권한 요청입니다.</param>
        <param name="optionalPermissions">선택적 권한 요청입니다.</param>
        <param name="refusedPermissions">거부된 권한 요청입니다.</param>
        <summary>지정한 이름, 액세스 모드 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 동적 어셈블리 저장 되 고 메모리에 다시 로드 하지 않는 한 사용 되지 않습니다. 임시 어셈블리의 오버 로드를 사용 하는 디스크에 저장 되지 않은 대 한 권한 요청을 지정 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 요청 된 사용 권한 및 공급으로 증명 정보를 지정 하는 메서드는 <xref:System.Security.Policy.Evidence> 개체입니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에 `refusedPermissions`. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="dir">동적 어셈블리를 저장할 디렉터리 이름입니다. <c>dir</c>이 <see langword="null" />인 경우 현재 디렉터리가 사용됩니다.</param>
        <param name="isSynchronized">
          동적 어셈블리에서 모듈, 형식 및 멤버 만들기를 동기화하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="assemblyAttributes">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</param>
        <summary>지정한 이름, 액세스 모드, 저장소 디렉터리 및 동기화 옵션을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute> 및 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.  
  
 경우 `isSynchronized` 은 `true`, 결과 다음과 같은 방법을 <xref:System.Reflection.Emit.AssemblyBuilder> 동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>합니다. 이러한 방법 중 두 가지 서로 다른 스레드에서 호출 하는 경우 다른 완료 될 때까지 차단 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="evidence">동적 어셈블리에 제공된 증명 정보입니다. 증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</param>
        <param name="requiredPermissions">필수 권한 요청입니다.</param>
        <param name="optionalPermissions">선택적 권한 요청입니다.</param>
        <param name="refusedPermissions">거부된 권한 요청입니다.</param>
        <summary>지정한 이름, 액세스 모드, 증명 정보 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 `evidence` 에서도 제공 되는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우 또는 합니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다 포함 하는 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`합니다. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
 호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다. 런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하기 위해 보안 정책을 통해 합니다. 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 해결 된 것으로 표시 합니다.  
  
 경우 동적 <xref:System.Reflection.Assembly> 은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="dir">어셈블리가 저장될 디렉터리 이름입니다. <c>dir</c>이 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</param>
        <param name="requiredPermissions">필수 권한 요청입니다.</param>
        <param name="optionalPermissions">선택적 권한 요청입니다.</param>
        <param name="refusedPermissions">거부된 권한 요청입니다.</param>
        <summary>지정한 이름, 액세스 모드, 저장소 디렉터리 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 동적 어셈블리 저장 되 고 메모리에 다시 로드 하지 않는 한 사용 되지 않습니다. 임시 어셈블리의 오버 로드를 사용 하는 디스크에 저장 되지 않은 대 한 권한 요청을 지정 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 요청 된 사용 권한 및 공급으로 증명 정보를 지정 하는 메서드는 <xref:System.Security.Policy.Evidence> 개체입니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 증명 정보 및 사용 권한을 지정 하는 메서드를 포함 하는 동적 어셈블리를 개발할 때는 제공 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에 `refusedPermissions`. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="dir">어셈블리가 저장될 디렉터리 이름입니다. <c>dir</c>이 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</param>
        <param name="evidence">동적 어셈블리에 제공된 증명 정보입니다. 증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</param>
        <param name="requiredPermissions">필수 권한 요청입니다.</param>
        <param name="optionalPermissions">선택적 권한 요청입니다.</param>
        <param name="refusedPermissions">거부된 권한 요청입니다.</param>
        <summary>지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 `evidence` 에서도 제공 되는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우 또는 합니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다 포함 하는 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`합니다. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
 호출자가 제공할 수를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다. 런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하기 위해 보안 정책을 통해 합니다. 호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 해결 된 것으로 표시 합니다.  
  
 경우 동적 <xref:System.Reflection.Assembly> 은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에 사용 해야 합니다. 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="dir">동적 어셈블리를 저장할 디렉터리 이름입니다. <c>dir</c>이 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</param>
        <param name="evidence">동적 어셈블리에 제공된 증명 정보입니다. 증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</param>
        <param name="requiredPermissions">필수 권한 요청입니다.</param>
        <param name="optionalPermissions">선택적 권한 요청입니다.</param>
        <param name="refusedPermissions">거부된 권한 요청입니다.</param>
        <param name="isSynchronized">
          동적 어셈블리에서 모듈, 형식 및 멤버 만들기를 동기화하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보, 권한 요청 및 동기화 옵션을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 지정 된 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 `evidence` 에서도 제공 되는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우 또는 합니다.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다 포함 하는 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`합니다. 포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL이 확인 됩니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드와 함께 사용할 경우에 throw 됩니다.  
  
 동적 정의할 때 완전히 신뢰할 수 있는 호출자의 증명 정보를 제공할 수만 <xref:System.Reflection.Assembly>합니다. 런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하기 위해 보안 정책을 통해 합니다. 호출자를 부분적으로 신뢰할 수 있는 `null` 에 대 한는 `evidence` 매개 변수입니다. 경우 `evidence` 은 `null`, 런타임에서 사용 권한 집합을 복사, 즉, 현재 허용 / 거부 호출자의에서 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 해결 된 것으로 표시 합니다.  
  
 경우 동적 <xref:System.Reflection.Assembly> 은 디스크에 저장 다음 로드 받아볼 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.  
  
 경우 `isSynchronized` 은 `true`, 결과 다음과 같은 방법을 <xref:System.Reflection.Emit.AssemblyBuilder> 동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>합니다. 이러한 방법 중 두 가지 서로 다른 스레드에서 호출 하는 경우 다른 완료 될 때까지 차단 됩니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">동적 어셈블리의 고유 ID입니다.</param>
        <param name="access">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</param>
        <param name="dir">동적 어셈블리를 저장할 디렉터리 이름입니다. <c>dir</c>이 <see langword="null" />인 경우 현재 디렉터리가 사용됩니다.</param>
        <param name="evidence">동적 어셈블리에 제공된 증명 정보입니다. 증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</param>
        <param name="requiredPermissions">필수 권한 요청입니다.</param>
        <param name="optionalPermissions">선택적 권한 요청입니다.</param>
        <param name="refusedPermissions">거부된 권한 요청입니다.</param>
        <param name="isSynchronized">
          동적 어셈블리에서 모듈, 형식 및 멤버 만들기를 동기화하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="assemblyAttributes">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</param>
        <summary>지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보, 권한 요청, 동기화 옵션 및 사용자 지정 특성을 사용하여 동적 어셈블리를 정의합니다.</summary>
        <returns>지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다. 예를 들어 같은 보안 특성 <xref:System.Security.SecurityTransparentAttribute> 및 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후에 추가 된 경우 제대로 작동 하지 않습니다.  
  
 에 대 한 지정 된 권한 요청은 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 되는 매개 변수는 `evidence` 매개 변수도 제공한, 또는 동적 어셈블리를 저장 하 고 다시 메모리에 로드 하는 경우.  
  
> [!NOTE]
>  동적 어셈블리를 내보내는 코드를 개발 하는 경우 포함 하는 것이 좋습니다는 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 플래그는 `refusedPermissions` 매개 변수입니다. 이 플래그를 포함 하면 Microsoft MSIL (intermediate language)를 확인 합니다. 이 기술은 있는 파악 하기가 매우 어렵습니다 비안정형 코드의 의도 하지 않게 생성을 검색 합니다. 이 방법의 제한 사항은은 <xref:System.Security.SecurityException> 를 완전 신뢰를 요청 하는 코드를 함께 사용 하는 경우.  
  
 동적 정의할 때 증명 정보를 제공할 수 있습니다 완전히 신뢰할 수 있는 호출자만 <xref:System.Reflection.Assembly>합니다. 런타임에 매핑되는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하기 위해 보안 정책을 통해 합니다. 호출자를 부분적으로 신뢰할 수 있는 `null` 에 대 한는 `evidence` 매개 변수입니다. 경우 `evidence` 은 `null`, 런타임에서 호출자의 어셈블리에서 정의 되 고 확인 된 것으로 고 정책을 표시 하는 동적 어셈블리에 (즉, 즉 현재 부여 및 거부 집합) 사용 권한 집합을 복사 합니다.  
  
 동적 어셈블리 후속 디스크에 저장 됩니다 부하는 동적 어셈블리를 저장할 위치와 연결 된 정책을 기반으로 하는 권한을 부여 받습니다.  
  
 경우 `isSynchronized` 은 `true`, 결과 다음과 같은 방법을 <xref:System.Reflection.Emit.AssemblyBuilder> 동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>합니다. 이러한 방법 중 두 가지 서로 다른 스레드에서 호출 하는 경우 다른 완료 될 때까지 차단 됩니다.  
  
 이 메서드는 오버 로드는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.  
  
 또는  
  
 <paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">호출할 메서드를 지정하는 대리자입니다.</param>
        <summary>지정한 대리자에서 식별한 다른 응용 프로그램 도메인에 있는 코드를 실행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` 마샬링-by-값을 지정할 수 <xref:System.MarshalByRefObject>, 또는 <xref:System.ContextBoundObject>합니다.  
  
   
  
## Examples  
 다음 예제에서는 정적을 사용 하 여 <xref:System.AppDomain.DoCallBack%2A> 메서드.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 다음 샘플에서는 <xref:System.AppDomain.DoCallBack%2A> 값별로 메서드.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 다음 샘플에서는 <xref:System.AppDomain.DoCallBack%2A> 메서드를 참조 합니다.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인이 초기화될 때 호스트에서 제공한 도메인 관리자를 가져옵니다.</summary>
        <value>응용 프로그램 도메인이 초기화될 때 호스트에서 제공한 도메인 관리자를 나타내는 개체이거나, 도메인 관리자가 제공되지 않은 경우 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공용 언어 런타임 (CLR)의 관리 되지 않는 호스트는 도메인 관리자를 제공할 수 있습니다. 도메인 관리자는 새 응용 프로그램 도메인 초기화에 참여할 고와 같은 다른 관리자를 제공할 수는 <xref:System.Security.HostSecurityManager>, 응용 프로그램 도메인의 작업에 참여 하는 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.AppDomain" />이 언로드되려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> 대리자이 이벤트는 응용 프로그램 도메인 로드 되기 전에 종료 동작을 수행할 수 있습니다.  
  
 각 응용 프로그램 도메인에 로드 되지 않았을 때 처리를 수행 해야 하는이 이벤트에 대 한 이벤트 처리기를 등록 해야 합니다. 공유 이벤트 처리기 해야 하지 때문에 사용할 수는 <xref:System.EventHandler> 대리자 언로드되고 도메인을 식별 하지 않습니다.  
  
> [!NOTE]
>  기본 응용 프로그램 도메인에서이 이벤트가 발생 하지 않습니다.  
  
 에 이벤트가 발생 하는 스레드에 대 한 가정을 만들지 마십시오. 호출한 스레드가 아닌 다른 스레드에서 이벤트가 발생할 수 있습니다는 <xref:System.AppDomain.Unload%2A> 메서드.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리 확인자에서 동적으로 만든 어셈블리를 조사하는 데 사용하는 디렉터리를 가져옵니다.</summary>
        <value>어셈블리 확인자에서 동적으로 만든 어셈블리를 조사하는 데 사용하는 디렉터리입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 디렉터리를 설정 하려면 기본 디렉터리 경로를 할당는 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 의 속성은 <xref:System.AppDomainSetup> 새 응용 프로그램 도메인을 만드는 데 사용할 개체입니다. 속성에 할당 하는 기본 디렉터리 경로 단순 이름인에 할당 하는 문자열의 해시 코드 하위 디렉터리를 추가 하 여 수정 되는 <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> 기본 디렉터리의 형식은 속성 *원래 경로* \\ *해시 코드*합니다. 동적 디렉터리에는이 기본 디렉터리의 하위 디렉터리입니다. 간단한 이름은의 값인는 <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> 속성, 해당 형식은입니다 *원래 경로*\\*해시 코드*\\*응용 프로그램 이름*합니다.  
  
   
  
## Examples  
 다음 예제에서는 동적 어셈블리에 대 한 디렉터리와 응용 프로그램 도메인을 만듭니다, 그리고 동적 어셈블리를 내보내 및 동적 디렉터리에 저장 한 다음 새 응용 프로그램 도메인에 어셈블리를 로드 및 사용 합니다.  
  
 이 예에서는 만듭니다는 <xref:System.AppDomainSetup> 개체 및 집합의 <xref:System.AppDomainSetup.ApplicationName%2A> 속성을 "예" 및 해당 <xref:System.AppDomainSetup.DynamicBase%2A> 속성을 "C:\DynamicAssemblyDir"입니다. 이 예제에서는 다음 표시는 <xref:System.AppDomainSetup.DynamicBase%2A> 원래 할당 된 경로의 하위 디렉터리로 응용 프로그램 이름이의 해시 코드를 추가 된 하 합니다.  
  
> [!NOTE]
>  이 예제의 기본 디렉터리는 예제 응용 프로그램에 대 한 검색 경로 이외의 되도록 만들어졌습니다. 다른 위치에 예제를 컴파일하려면 해야 합니다. 기본 디렉터리 및 모든 하위 디렉터리는 예제를 실행할 때마다 삭제 합니다.  
  
 이 예에서는 새 응용 프로그램 도메인을 만듭니다를 사용 하 여 <xref:System.AppDomainSetup> 개체입니다. 이 예제에서는 사용 된 <xref:System.AppDomain.DynamicDirectory%2A> 디렉터리를 만들 수 있도록 디렉터리의 이름을 검색 하는 속성입니다. (이 예제에서는 손쉽게 만들 수는 디렉터리 미리 원래 경로, 응용 프로그램 이름 및 응용 프로그램의 해시 코드를 연결 하 여.)  
  
 이 예제에는 `GenerateDynamicAssembly` 명명 된 어셈블리를 내보내고 메서드 `DynamicHelloWorld.dll` 새 응용 프로그램 도메인의 동적 디렉터리에 저장 합니다. 동적 어셈블리 유형에서는 포함 되어 `HelloWorld`, 하는 정적 메서드 (`Shared` Visual Basic의에서 메서드) 라는 `HelloFromAD`합니다. 이 메서드를 호출 응용 프로그램 도메인의 이름을 표시 합니다.  
  
 `Example` 클래스에서 파생 <xref:System.MarshalByRefObject>예제에서는 새 응용 프로그램 도메인 및 호출에서 클래스의 인스턴스를 만들 수 있으므로 해당 `Test` 메서드. `Test` 메서드 표시 이름을 사용 하 여 동적 어셈블리를 로드 하 고 정적 호출 `HelloFromAD` 메서드.  
  
 이라는 어셈블리에 대 한 코드를 작성 하 여 일반 검색 경로 후 동적 디렉터리 검색 됩니다 표시할 수 있습니다 `DynamicHelloWorld.dll` 및이 예제와 동일한 디렉터리에 컴파일입니다. 어셈블리에는 라는 클래스를 사용 해야 합니다. `HelloWorld` 라는 정적 메서드가 있는 `HelloFromAD`합니다. 이 메서드는 예제;에 있는 것과 동일한 기능을 제공 하지 않아도 콘솔에 문자열을 표시 하기만 하면 것입니다. 어셈블리 있어야는 <xref:System.Reflection.AssemblyVersionAttribute> 특성을 해당 버전을 1.0.0.0으로 설정 합니다. 예제를 실행 하는 경우 현재 디렉터리에 컴파일된 어셈블리가 동적 디렉터리를 검색 하기 전에.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 응용 프로그램 도메인과 관련된 <see cref="T:System.Security.Policy.Evidence" />를 가져옵니다.</summary>
        <value>이 응용 프로그램 도메인과 관련된 증거입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 파일에 포함된 어셈블리를 실행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">실행할 어셈블리가 포함된 파일 이름입니다.</param>
        <summary>지정한 파일에 포함된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드. 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
 만들려는 <xref:System.AppDomain> 로드 하 고 실행을 사용 하 여는 <xref:System.AppDomain.CreateDomain%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">실행할 어셈블리가 포함된 파일 이름입니다.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>지정한 증명 정보를 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다을 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드. 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">실행할 어셈블리가 포함된 파일 이름입니다.</param>
        <param name="args">어셈블리의 진입점에 대한 인수입니다.</param>
        <summary>지정한 인수를 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드. 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 <paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">실행할 어셈블리가 포함된 파일 이름입니다.</param>
        <param name="assemblySecurity">어셈블리에 제공된 증거입니다.</param>
        <param name="args">어셈블리의 진입점에 대한 인수입니다.</param>
        <summary>지정한 증명 정보 및 인수를 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드. 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다. 레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">실행할 어셈블리가 포함된 파일 이름입니다.</param>
        <param name="args">어셈블리의 진입점에 대한 인수입니다.</param>
        <param name="hashValue">계산된 해시 코드의 값을 나타냅니다.</param>
        <param name="hashAlgorithm">어셈블리 매니페스트에 사용되는 해시 알고리즘을 나타냅니다.</param>
        <summary>지정한 인수, 해시 값 및 해시 알고리즘을 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드. 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 <paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">실행할 어셈블리가 포함된 파일 이름입니다.</param>
        <param name="assemblySecurity">어셈블리에 제공된 증거입니다.</param>
        <param name="args">어셈블리의 진입점에 대한 인수입니다.</param>
        <param name="hashValue">계산된 해시 코드의 값을 나타냅니다.</param>
        <param name="hashAlgorithm">어셈블리 매니페스트에 사용되는 해시 알고리즘을 나타냅니다.</param>
        <summary>지정한 증명 정보, 인수, 해시 값 및 해시 알고리즘을 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 이 메서드를 사용 하 여 어셈블리 로드는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드. 사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
   
  
## Examples  
 다음 샘플에서는 오버 로드 중 하나를 사용 하 여 보여 줍니다. <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다. 레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리를 실행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <summary>표시 이름이 지정된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드 비슷한 기능을 제공 된 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치. 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 만들려는 <xref:System.AppDomain> 로드 하 고 실행을 사용 하 여는 <xref:System.AppDomain.CreateDomain%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 경로 자체의 정보에 액세스 하 여 표시 이름을 리디렉션하는 경로 대 한 디렉터리에서 읽기에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">표시 이름 URL로 리디렉션되면 웹 사이트에 액세스 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 이름을 나타내는 <see cref="T:System.Reflection.AssemblyName" /> 개체입니다.</param>
        <param name="args">프로세스를 시작할 때 전달할 명령줄 인수입니다.</param>
        <summary>지정한 인수를 사용하여 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드 비슷한 기능을 제공 된 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치. 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우  
  
 또는  
  
 <paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 경로 자체의 정보에 액세스 하 여 표시 이름을 리디렉션하는 경로 대 한 디렉터리에서 읽기에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">표시 이름 URL로 리디렉션되면 웹 사이트에 액세스 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>지정한 증명 정보를 사용하여 표시 이름이 지정된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드 비슷한 기능을 제공 된 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치. 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다을 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
> [!NOTE]
>  사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 경로 자체의 정보에 액세스 하 여 표시 이름을 리디렉션하는 경로 대 한 디렉터리에서 읽기에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">표시 이름 URL로 리디렉션되면 웹 사이트에 액세스 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="args">프로세스를 시작할 때 전달할 명령줄 인수입니다.</param>
        <summary>지정한 인수를 사용하여 표시 이름이 지정된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드 비슷한 기능을 제공 된 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치. 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우  
  
 또는  
  
 <paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 경로 자체의 정보에 액세스 하 여 표시 이름을 리디렉션하는 경로 대 한 디렉터리에서 읽기에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">표시 이름 URL로 리디렉션되면 웹 사이트에 액세스 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 이름을 나타내는 <see cref="T:System.Reflection.AssemblyName" /> 개체입니다.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <param name="args">프로세스를 시작할 때 전달할 명령줄 인수입니다.</param>
        <summary>지정한 증거와 인수를 사용하여 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드 비슷한 기능을 제공 된 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치. 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
> [!NOTE]
>  사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다. 레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 경로 자체의 정보에 액세스 하 여 표시 이름을 리디렉션하는 경로 대 한 디렉터리에서 읽기에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">표시 이름 URL로 리디렉션되면 웹 사이트에 액세스 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <param name="args">프로세스를 시작할 때 전달할 명령줄 인수입니다.</param>
        <summary>지정한 증명 정보와 인수를 사용하여 표시 이름이 지정된 어셈블리를 실행합니다.</summary>
        <returns>어셈블리의 진입점에서 반환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드 비슷한 기능을 제공 된 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치. 따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 여 어셈블리를 로드는 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.  
  
 이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만듭니까 및 진입점 메서드 새 스레드에서 실행 되지 않습니다.  
  
> [!NOTE]
>  사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수, 증명 정보가 병합 됩니다. 에 대 한 인수로 제공 된 증명 정보를 가지는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다. 레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</exception>
        <exception cref="T:System.MissingMethodException">지정된 어셈블리에 진입점이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 경로 자체의 정보에 액세스 하 여 표시 이름을 리디렉션하는 경로 대 한 디렉터리에서 읽기에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">표시 이름 URL로 리디렉션되면 웹 사이트에 액세스 합니다.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">콘솔 응용 프로그램을 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인에서 런타임이 예외 처리기에 대한 호출 스택을 검색하기 전에 관리 코드에서 예외가 throw될 경우 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 알림만 합니다. 이 이벤트를 처리 해도 예외를 처리 하거나 후속 예외 어떤 식으로든에서 처리 영향을 주지 않습니다. 이벤트가 발생 하 고 이벤트 처리기가 호출 된 후에 공용 언어 런타임 (CLR) 예외에 대 한 처리기를 검색 하기 시작 합니다. <xref:System.AppDomain.FirstChanceException> 관리 되는 모든 예외를 검사 하는 첫 번째 기회에 응용 프로그램 도메인을 제공 합니다.  
  
 응용 프로그램 도메인 별로 이벤트를 처리할 수 있습니다. 스레드를 통과 하면 여러 응용 프로그램 도메인을 통해 호출을 실행 하는 동안 CLR에서 해당 응용 프로그램 도메인에 일치 하는 예외 처리기에 대 한 검색을 시작 하기 전에 이벤트 처리기를 등록 된 각 응용 프로그램 도메인에서 발생 합니다. 이벤트 처리 된 후 해당 응용 프로그램 도메인에 일치 하는 예외 처리기에 대 한 검색이 수행 됩니다. 검색 된 항목이 없는 경우 다음 응용 프로그램 도메인에서 발생 합니다.  
  
 에 대 한 처리기를 이벤트 발생 하는 모든 예외를 처리 해야 합니다는 <xref:System.AppDomain.FirstChanceException> 이벤트입니다. 그렇지 않으면 <xref:System.AppDomain.FirstChanceException> 이 재귀적으로 발생된 합니다. 이 스택 오버플로 및 응용 프로그램이 종료 될 수 있습니다. 메모리 부족 또는 스택 오버플로와 같은 인프라 관련 예외 예외 알림을 처리 되는 동안 가상 컴퓨터에 영향을 주지 않도록 하기 위해 제약이 있는 실행 영역 (Cer)으로이 이벤트에 대 한 이벤트 처리기를 구현 하는 것이 좋습니다.  
  
 이벤트 처리기가 보안에 중요 한 및 하지 않는 한 손상 액세스 위반과 같이 프로세스 상태를 나타내는 예외에 대 한이 이벤트는 <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> 특성입니다.  
  
 스레드 중단 알림 이벤트가이 처리 되는 동안 일시 중단 하는 공용 언어 런타임.  
  
   
  
## Examples  
 다음 예제에서는 일련의 명명 된 응용 프로그램 도메인 `AD0` 통해 `AD3`와 `Worker` 각 응용 프로그램 도메인의 개체입니다. 각 `Worker` 개체에 대 한 참조에는 `Worker` 을 제외 하 고 다음 응용 프로그램 도메인의 개체는 `Worker` 마지막 응용 프로그램 도메인입니다. <xref:System.AppDomain.FirstChanceException> 제외한 모든 응용 프로그램 도메인에서 이벤트를 처리 `AD1`합니다.  
  
> [!NOTE]
>  이 예제에서는 여러 응용 프로그램 도메인에서 첫째 예외 알림을 보여 주는 외에도 간단한 사용 사례에서 찾을 수 있습니다 [하는 방법: 첫째 예외 알림 받기](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)합니다.  
  
 응용 프로그램 도메인을 만든 경우 기본 응용 프로그램 도메인 호출는 `TestException` 첫 번째 응용 프로그램 도메인에 대 한 메서드. 각 `Worker` 호출 개체는 `TestException` 마지막 될 때까지 다음 응용 프로그램 도메인에 대 한 메서드 `Worker` 처리 되거나 처리 되지 않는 예외를 throw 합니다. 따라서, 현재 스레드는 모든 응용 프로그램 도메인을 통해 전달 및 `TestException` 스택을에 각 응용 프로그램 도메인에 추가 됩니다.  
  
 때 마지막 `Worker` 개체에서 예외를 처리는 <xref:System.AppDomain.FirstChanceException> 이벤트는 마지막 응용 프로그램 도메인에만 발생 합니다. 다른 응용 프로그램 도메인에 가져오지 하므로 이벤트는 예외를 처리 하 합니다.  
  
 때 마지막 `Worker` 개체는 예외를 처리 하지 않는 <xref:System.AppDomain.FirstChanceException> 이벤트는 이벤트 처리기가 각 응용 프로그램 도메인에서 발생 합니다. 각 이벤트 처리기가 끝나면 스택을 계속 예외는 기본 응용 프로그램 도메인에서 걸러진 될 때까지 해제 합니다.  
  
> [!NOTE]
>  변경 이벤트가 곧 제공 될 때 스택 디스플레이 증가 하는 방법을 하 고 기본 응용 프로그램 도메인에 가까울수록 서로 볼 `e.Exception.Message` 를 `e.Exception` 에 `FirstChanceHandler` 이벤트 처리기입니다. 때 `TestException` 라고 응용 프로그램 도메인 경계에서 두 번 나타납니다: 프록시에 대해 한 번씩, 한 번 스텁에 대해 합니다.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 응용 프로그램 도메인의 이름을 가져옵니다.</summary>
        <value>이 응용 프로그램 도메인의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 응용 프로그램 도메인의 이름을 프로세스 실행 파일의 파일 이름입니다. 예를 들어 파일을 실행 하는 프로세스를 시작 하는 데는 `"c:\MyAppDirectory\MyAssembly.exe"`, 기본 응용 프로그램 도메인의 대화명은 `"MyAssembly.exe"`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.AppDomain.FriendlyName%2A> 현재 응용 프로그램 도메인의 이름을 가져올 속성입니다. 기본 응용 프로그램 도메인에 대 한 친숙 한 이름이 응용 프로그램의 실행 파일의 이름입니다. 이 코드 예제에는 응용 프로그램 도메인에 대 한 추가 정보가 표시 됩니다.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 응용 프로그램 도메인의 실행 컨텍스트에 로드된 어셈블리를 가져옵니다.</summary>
        <returns>이 응용 프로그램 도메인에 있는 어셈블리의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 <xref:System.AppDomain.GetAssemblies%2A> 메서드 응용 프로그램 도메인에 로드 된 모든 어셈블리의 목록을 가져올 수 있습니다. 그러면 어셈블리가 콘솔에 표시 됩니다.  
  
 이 코드 예제를 실행 하려면 명명 된 어셈블리를 만드는 `CustomLibrary.dll`에 전달 되는 어셈블리 이름을 변경 하거나는 <xref:System.AppDomain.GetAssemblies%2A> 메서드.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드 식별자를 가져옵니다.</summary>
        <returns>현재 스레드의 식별자인 부호 있는 32비트 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 속성을.NET Framework이 지 원하는 파이버 (즉, 경량 스레드) 환경에서 호스트 된 경우에 안정적입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">이 메서드를 호출 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">미리 정의된 응용 프로그램 도메인 속성의 이름 또는 사용자가 정의한 응용 프로그램 도메인 속성의 이름입니다.</param>
        <summary>지정한 이름에 대해 현재 응용 프로그램 도메인에 저장된 값을 가져옵니다.</summary>
        <returns>
          <paramref name="name" /> 속성의 값이거나, 속성이 없을 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 인스턴스의 속성을 설명 하는 이름-데이터 쌍의 내부 캐시에 있는 항목의 값을 검색 하려면이 메서드를 사용 하 여 <xref:System.AppDomain>합니다. 비교 `name` 키-값 쌍의 이름으로는 대/소문자 구분 합니다.  
  
 캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 하는 미리 정의 된 시스템 항목을 포함 합니다. 와 해당 값을 검사할 수는 <xref:System.AppDomain.GetData%2A> 메서드나 해당 하는 <xref:System.AppDomainSetup> 속성입니다.  
  
 삽입 하거나 사용자 정의 이름-데이터 쌍으로 수정할 수는 <xref:System.AppDomain.SetData%2A> 메서드 그 값을 검사 하 고는 <xref:System.AppDomain.GetData%2A> 메서드.  
  
 다음 표에서 `name` 미리 정의 된 각 시스템 항목 및 해당 <xref:System.AppDomainSetup> 속성입니다.  
  
|'Name'의 값|속성|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(속성 없음)<br /><br /> "APP_LAUNCH_URL"는 리디렉션 하기 전에 사용자가 원래 요청한 URL을 나타냅니다. Internet Explorer와 같은 브라우저 응용 프로그램 시작 되었습니다 하는 경우에 사용할 수 있는 유용 합니다. 일부 브라우저는이 값을 제공합니다.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(속성 없음)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" 또는 응용 프로그램별 문자열|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(속성 없음)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" 시스템 항목 아니며 호출 하 여 해당 값을 설정할 수 있습니다는 <xref:System.AppDomain.SetData%2A> 메서드.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 다음 예제에서는 새 응용 프로그램 도메인, 도메인에 대해 시스템에서 제공한 값을 설정 및 도메인에 대 한 새 값 쌍을 추가 합니다. 다음 예제는 사용 하는 방법을 <xref:System.AppDomain.GetData%2A> 메서드를 이러한 값 쌍에서 데이터를 검색 하 고 콘솔에 표시 합니다.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 경로에 속성이 적용 되는 경우 자체에 대 한 정보에 액세스 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 형식을 가져옵니다.</summary>
        <returns>현재 인스턴스의 형식입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스 내 응용 프로그램 도메인을 고유하게 식별하는 정수를 가져옵니다.</summary>
        <value>응용 프로그램 도메인을 식별하는 정수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 두 번째 응용 프로그램 도메인을 만들고 기본 도메인 및 새 도메인에 대 한 정보를 표시 합니다.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>임대가 만들어지는 것을 방지하여 <see cref="T:System.AppDomain" />에 영구적 수명을 제공합니다.</summary>
        <returns>항상 <see langword="null" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">테스트할 호환성 스위치입니다.</param>
        <summary>호환성 스위치가 설정되어 있는지를 확인하고 설정되어 있으면 지정한 호환성 스위치가 설정되어 있는지를 나타내는 nullable 부울 값을 가져옵니다.</summary>
        <returns>호환성 스위치가 설정되어 있으면 <paramref name="value" />에 지정된 호환성 스위치가 설정되어 있는지 여부를 나타내는 부울 값이고, 그러지 않으면 Null 참조(Visual Basic의 경우 <see langword="Nothing" />)입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 응용 프로그램 도메인에 지정한 호환성 스위치가 설정 된 있는지 여부를 테스트 합니다. (예: 방식으로 문자열을 정렬) 호환성 스위치는 동작을 일반적으로 복원 하는.NET Framework의 버전 간에 변경 되었습니다.  호출 하 여 설정 된 <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> 응용 프로그램 도메인을 만들기 전에 메서드.  
  
 다음 표에서 이전 버전의.NET Framework의 동작을 복원할로 설정할 수 있는 호환성 스위치의 예제를 제공 합니다.  
  
|전환|의미|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|에 대 한 코드 액세스 보안 (CA)는 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 합니다. 참조 [ &lt;NetFx40_LegacySecurityPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)합니다.|  
|"NetFx40_Legacy20SortingBehavior"|문자열 정렬에 대 한 기본값은 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 활성화 됩니다. 성공을 sort00001000.dll를 설치 해야 합니다. 참조 [ &lt;CompatSortNLSVersion&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)합니다.|  
|"NetFx40_Legacy40SortingBehavior"|문자열 정렬에 대 한 기본값은 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]유니코드 5.0이 응용 프로그램 도메인에서 사용할 수 있습니다. 성공을 sort00060101.dll를 설치 해야 합니다.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 서식 지정에 대 한 동작의 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 합니다.  참조 [ &lt;TimeSpan_LegacyFormatMode&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) 및의 "레거시 TimeSpan 서식 복원" 섹션에서 <xref:System.TimeSpan> 항목입니다.|  
|"UseRandomizedStringHashAlgorithm"|문자열에 대 한 해시 코드를 계산 하는 런타임에서 응용 프로그램 도메인 간에 일관 된 해시 코드를 생성 하는 단일 해시 알고리즘을 사용 하는 대신 응용 프로그램 도메인 단위로 합니다. 참조 [ &lt;UseRandomizedStringHashAlgorithm&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)합니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램 도메인이 해당 프로세스에 대한 기본 응용 프로그램 도메인인지를 나타내는 값을 반환합니다.</summary>
        <returns>
          현재 <see cref="T:System.AppDomain" /> 개체가 해당 프로세스에 대한 기본 응용 프로그램 도메인을 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 관리 되는 프로세스에 기본 응용 프로그램 도메인을 포함 합니다. 기본 도메인에서 실행을 시작 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 번째 응용 프로그램 도메인을 만들고 기본 도메인 및 새 도메인에 대 한 정보를 표시 합니다.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 응용 프로그램 도메인의 언로드 여부 및 공용 언어 런타임에서 이 응용 프로그램 도메인에 포함된 개체를 종료하고 있는지를 나타냅니다.</summary>
        <returns>
          이 응용 프로그램 도메인의 언로드 작업이 수행되고 공용 언어 런타임에서 이미 종료자를 호출했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개체에 대 한 종료 메서드는 개체가 가비지 수집 되기 전에 필요한 정리 작업을 수행할 수 있습니다를 제공 합니다. 종료 된 후 개체는 액세스할 수 있지만 잘못 된 상태에 있고 사용할 수 없습니다. 결국 가비지 수집을 완료 하 고 개체를 회수 합니다.  
  
 개체의 종료 메서드는 다음과 같은 상황 중 하나에서: 가비지 수집 중 공용 언어 런타임의 종료 될 때 또는 개체가 포함 된 응용 프로그램 도메인이 언로드될 때. <xref:System.AppDomain.IsFinalizingForUnload%2A> 메서드 반환 `true` ; 지난 경우에만 반환 하지 않는 `true` 종료 CLR 종료 또는 일상적인 가비지 수집에서 발생 하는 경우.  
  
> [!NOTE]
>  CLR 종료로 인해 종료 되는지 확인 하려면는 <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> 속성입니다. 반환 `true` 또는 종료 하 고 CLR 응용 프로그램 도메인이 언로드되고으로 인해 종료 되는 경우.  
  
 언로드 작업이 수행 하는 동안 종료 메서드에서 실행을 하는 동안 정적 필드에서 참조 하 고 종료 메서드를 포함 하는 다른 개체에 액세스 하는 것이 좋습니다. 그러나 없습니다 안정적으로 이렇게 하면 액세스 한 개체가 종료 이미 수 있으므로 됩니다.  
  
> [!NOTE]
>  이 규칙의 예외는 <xref:System.Console> 스트림 개체를 참조 하는 정적 필드가 포함 되어 있지만 도메인 언로드하거나 시스템 종료 하는 동안에 시스템 콘솔에 항상 작성할 수 있도록 특별히 구현 되는 클래스입니다.  
  
 개체의 종료 메서드에 개체를 포함 하는 응용 프로그램 도메인이 언로드되고 있는지 여부를 확인 하려면이 메서드를 사용 합니다. 해당 되는 경우 종료 메서드를 포함 하는 정적 필드에서 참조 하는 모든 개체 안정적으로 액세스할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 응용 프로그램 도메인에 로드된 어셈블리가 완전 신뢰로 실행되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 응용 프로그램 도메인에 로드된 어셈블리가 완전 신뢰로 실행되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 항상 반환 `true` 데스크톱에서 실행 하는 응용 프로그램의 기본 응용 프로그램 도메인에 대 한 합니다. 반환 `false` 를 사용 하 여 만든 샌드 박싱된 응용 프로그램 도메인에 대 한는 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 응용 프로그램 도메인에서 부여 된 권한을 완전 신뢰와 동일 하지 않으면 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.AppDomain.IsFullyTrusted%2A> 속성 및 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 부분적으로 신뢰할 수 있고 완전히 신뢰할 수 있는 응용 프로그램 도메인을 사용 하 여 속성입니다. 완전히 신뢰할 수 있는 응용 프로그램 도메인은 응용 프로그램에 대 한 기본 응용 프로그램 도메인입니다. 사용 하 여 부분적으로 신뢰할 수 있는 응용 프로그램 도메인이 만들어집니다는 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.  
  
 이 예제에서는 사용는 `Worker` 에서 파생 된 클래스 <xref:System.MarshalByRefObject>이므로 응용 프로그램 도메인 경계를 넘어 마샬링해야 수 있습니다. 이 예에서는 만듭니다는 `Worker` 기본 응용 프로그램 도메인의 개체입니다. 그런 다음 호출 하는 `TestIsFullyTrusted` 응용 프로그램 도메인에 로드 되는 두 명의 어셈블리 및 응용 프로그램 도메인에 대 한 속성 값을 표시 하는 메서드:.NET Framework 및 예제에서는 어셈블리의 일부인 mscorlib입니다. 응용 프로그램 도메인 완전히 신뢰할 수 있는 이므로 두 어셈블리는 완전히 신뢰 합니다.  
  
 이 예에서는 다른 만듭니다 `Worker` 샌드 박싱된 응용 프로그램 도메인 및 다시 호출 하는 개체는 `TestIsFullyTrusted` 메서드. Mscorlib 항상 신뢰할 수 있는, 부분적으로 신뢰할 수 있는 응용 프로그램 도메인에도 있지만 예제 어셈블리는 부분적으로 신뢰할 수 있는 합니다.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인에 로드된 모든 어셈블리에 부여된 권한 집합이 현재 응용 프로그램 도메인에 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 응용 프로그램 도메인에 형식이 같은 권한 집합이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 `true` 사용 하 여 만든 샌드 박싱된 응용 프로그램 도메인에 대 한는 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버 로드 합니다. 샌드 박싱된 응용 프로그램 도메인에 있고, 한 형식이 같은 권한 집합이 있습니다. 즉, 응용 프로그램 도메인에 로드 되는 부분적으로 신뢰할 수 있는 모든 어셈블리에 동일한 사용 권한 집합이 부여 됩니다. 샌드 박싱된 응용 프로그램 도메인에는 필요에 따라이 사용 권한을 설정 하 고 대신 완전 신뢰로 실행에서 제외 되는 강력한 이름의 어셈블리의 목록을 있습니다.  
  
 완전히 신뢰 하는 코드에서 사용할 수는 <xref:System.AppDomain.PermissionSet%2A> 샌드 박싱된 응용 프로그램 도메인의 형식이 같은 권한 부여 집합을 결정 하는 속성입니다.  
  
 또한이 속성 반환 `true` 는 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인에 대 한 해당 응용 프로그램 도메인은 모든 어셈블리에 완전 신뢰를 부여 하므로 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Assembly" />를 이 용용 프로그램 도메인에 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 <see langword="byte" /> 형식의 배열입니다.</param>
        <summary>내보낸 <see cref="T:System.Reflection.Assembly" />가 들어 있는 COFF(Common Object File Format) 기반 이미지를 사용한 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 되는 어셈블리의 신뢰 수준은 응용 프로그램 도메인의 신뢰 수준을와 같습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드. 다른 응용 프로그램 도메인, 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.  
  
 이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 샘플 원시 어셈블리를 로드 하의 사용을 보여 줍니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">로드할 어셈블리를 설명하는 개체입니다.</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" />이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드. 다른 응용 프로그램 도메인, 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.  
  
 이미 로드 되어 요청된 된 어셈블리의 버전 다른 버전이 요청 된 경우에이 메서드는 로드 된 어셈블리를 반환 합니다.  
  
 에 대 한 부분 어셈블리 이름을 제공 `assemblyRef` 권장 되지 않습니다. (부분 이름은 하나 이상의 culture, 버전, 사용 또는 공개 키 토큰을 생략 하는 데 사용 합니다. 대신 문자열을 허용 하는 오버 로드에 대 한는 <xref:System.Reflection.AssemblyName> 개체를 "MyAssembly, Version = 1.0.0.0"은 이름의 일부의 예 및 "MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken 18ab3442da84b47 ="은 예 전체 이름입니다.) 부분 이름을 사용 하면 성능에 부정적인 영향을 있습니다. 또한 부분 어셈블리 이름을 로드할 수 어셈블리를 전역 어셈블리 캐시에서 응용 프로그램 기본 디렉터리에 있는 어셈블리의 정확한 복사본 필요한 경우에 (<xref:System.AppDomain.BaseDirectory%2A> 또는 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 하는 경우 현재 <xref:System.AppDomain> 개체가 응용 프로그램 도메인을 나타내면 `A`, 및 <xref:System.AppDomain.Load%2A> 메서드는 응용 프로그램 도메인에서 `B`, 어셈블리 두 응용 프로그램 도메인에 로드 됩니다. 예를 들어 다음 코드 로드 `MyAssembly` 새 응용 프로그램 도메인 `ChildDomain` 및 코드를 실행 하는 응용 프로그램 도메인에도 있습니다.  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 어셈블리가 로드 되는 두 도메인에 있으므로 <xref:System.Reflection.Assembly> 에서 파생 되지 않은 <xref:System.MarshalByRefObject>, 따라서의 반환 값과는 <xref:System.AppDomain.Load%2A> 메서드를 마샬링할 수 없습니다. 대신, 공용 언어 런타임 어셈블리 호출 응용 프로그램 도메인에 로드 하려고 시도 합니다. 두 응용 프로그램 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정을 서로 다른 경우 달라질 수 있습니다.  
  
> [!NOTE]
>  모두는 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 속성이 설정 되어, 어셈블리를 로드할 첫 번째 시도 표시 이름을 사용 하 여 (에서 반환 된 버전, 문화권 및 등을 포함 하는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성). 파일이 없는 경우는 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성은 어셈블리를 검색 하는 데 사용 합니다. 사용 하는 어셈블리가 있는 경우 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름은 어셈블리와 일치 합니다. 일치가 실패 하면는 <xref:System.IO.FileLoadException> throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <summary>표시 이름이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드. 다른 응용 프로그램 도메인, 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.  
  
 이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">어셈블리가 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 <see langword="byte" /> 형식의 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 <see langword="byte" /> 형식의 배열입니다.</param>
        <summary>내보낸 <see cref="T:System.Reflection.Assembly" />가 들어 있는 COFF(Common Object File Format) 기반 이미지를 사용한 <see cref="T:System.Reflection.Assembly" />를 로드합니다. <see cref="T:System.Reflection.Assembly" />에 대한 기호를 나타내는 원시 바이트도 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 되는 어셈블리의 신뢰 수준은 응용 프로그램 도메인의 신뢰 수준을와 같습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드. 다른 응용 프로그램 도메인, 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.  
  
 이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 샘플 원시 어셈블리를 로드 하의 사용을 보여 줍니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">로드할 어셈블리를 설명하는 개체입니다.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" />이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드. 다른 응용 프로그램 도메인, 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.  
  
 이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://" 폼에 없는 경로 읽기 위한 또는 "\\\UNC\dir\\" 또는 "c:\\"입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">어셈블리의 표시 이름입니다. <see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>표시 이름이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드. 다른 응용 프로그램 도메인, 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.  
  
 이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보로 어셈블리를 로드 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://" 폼에 없는 경로 읽기 위한 또는 "\\\UNC\dir\\" 또는 "c:\\"입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 <see langword="byte" /> 형식의 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 <see langword="byte" /> 형식의 배열입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>내보낸 <see cref="T:System.Reflection.Assembly" />가 들어 있는 COFF(Common Object File Format) 기반 이미지를 사용한 <see cref="T:System.Reflection.Assembly" />를 로드합니다. <see cref="T:System.Reflection.Assembly" />에 대한 기호를 나타내는 원시 바이트도 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 되는 어셈블리의 신뢰 수준은 응용 프로그램 도메인의 신뢰 수준을와 같습니다.  
  
 이 메서드는 현재 응용 프로그램 도메인에서 어셈블리를 로드에 사용 해야 합니다. 이 메서드는 정적을 호출할 수 없습니다 상호 운용성 호출자에 대 한 편의 위해 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드. 다른 응용 프로그램 도메인, 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.  
  
 이 메서드의 모든 오버 로드에 공통 된 정보를 참조 하십시오.는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 샘플 원시 어셈블리를 로드 하의 사용을 보여 줍니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
 또는  
  
 버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />이 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다. 레거시 CAS 정책을 사용하지 않을 때는 <paramref name="securityEvidence" />는 <see langword="null" />이 되어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 읽고 자체 경로에 대 한 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</permission>
        <permission cref="T:System.Net.WebPermission">"file://" 폼에 없는 경로 읽기 위한 또는 "\\\UNC\dir\\" 또는 "c:\\"입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 프로세스에 응용 프로그램 도메인의 CPU 및 메모리 모니터링을 사용할 수 있는지를 나타내는 값을 가져오거나 설정합니다. 프로세스에 모니터링을 사용할 수 있는 경우 사용하지 못하도록 설정할 수 없습니다.</summary>
        <value>
          모니터링을 사용할 수 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 `static` 속성 (`Shared` Visual Basic에서 속성)의 CPU 및 메모리 모니터링 프로세스의 모든 응용 프로그램 도메인을 제어 합니다.  
  
 이 속성을 설정 하려고 하면 `false`, <xref:System.ArgumentException> 예외가 throw 되는 속성의 현재 값은 경우에 `false`합니다.  
  
 모니터링이 활성화 되 면 사용할 수 있습니다는 <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, 및 <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> 인스턴스 속성을 개별 응용 프로그램 도메인의 CPU 및 메모리 사용을 모니터링 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 프로세스가 이 속성에 값 <see langword="false" />를 할당하려고 했습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 응용 프로그램 도메인에서 참조하도록 알려진 마지막 컬렉션 후에도 유지되는 바이트 수를 가져옵니다.</summary>
        <value>유지되는 바이트 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 통계는 각 가비지 컬렉션으로 업데이트 됩니다. 그러나을 정확 하 게 한 전체 차단 컬렉션 후에 보장 됩니다. 즉, 모든 세대를 포함 하 고 수집 하는 동안 응용 프로그램을 중지 하는 컬렉션에 발생 합니다. 예를 들어는 <xref:System.GC.Collect?displayProperty=nameWithType> 전체 차단 수집을 수행 하는 메서드 오버 로드 합니다. (동시 컬렉션은 백그라운드에서 실행 및 응용 프로그램을 차단 하지 않습니다.)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />(Visual Basic에서는 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성은 <see langword="false" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스의 모든 응용 프로그램 도메인에 대한 마지막 컬렉션에서 유지된 총 바이트 수를 가져옵니다.</summary>
        <value>프로세스의 유지되는 총 바이트 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 힙의 관리 되는 바이트 수가 현재 보유 하에이 숫자 나타냅니다 전체 차단 수집 후 합니다. 보고 된 수에 가까운 것은 <xref:System.GC.GetTotalMemory%2A> 메서드. 임시 컬렉션 후이 수 바이트 수가 현재 저장 나타냅니다 라이브 임시 세대에서입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />(Visual Basic에서는 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성은 <see langword="false" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인이 만들어진 후 실행된 모든 메모리 할당의 총 크기(바이트)를 수집된 메모리의 크기를 제외하지 않고 가져옵니다.</summary>
        <value>모든 메모리 할당의 총 크기입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />(Visual Basic에서는 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성은 <see langword="false" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스가 시작된 후 현재 응용 프로그램 도메인에서 실행되는 동안 모든 스레드에서 사용된 총 프로세서 시간을 가져옵니다.</summary>
        <value>현재 응용 프로그램 도메인의 총 프로세서 시간입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 스레드는 프로세스에서 해당 응용 프로그램 도메인에서 실행에 소요 된 시간을 포함 하는 응용 프로그램 도메인에 대 한 보고 되는 총 시간입니다.  
  
 비관리 코드를 호출 하는 스레드는 응용 프로그램 도메인에 여전히 연결 되며 비관리 코드 생성 되었으므로 호출 응용 프로그램 도메인에 대 한 보고를 실행 하는 데 프로세서 시간이 걸리는 합니다.  
  
 스레드가 차단 또는 중지는 사용 하지 않습니다 프로세서 시간 면 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />(Visual Basic에서는 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성은 <see langword="false" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>샌드박스가 적용된 응용 프로그램 도메인의 권한 집합을 가져옵니다.</summary>
        <value>샌드박스가 적용된 응용 프로그램 도메인의 권한 집합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 만든 샌드 박싱된 응용 프로그램 도메인에서 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버 로드는 형식이 같은 권한 집합이 수 있으며 응용 프로그램 도메인에 로드 되는 부분적으로 신뢰할 수 있는 모든 어셈블리에 동일한 사용 권한 집합이 부여 됩니다 즉, 합니다. 샌드 박싱된 응용 프로그램 도메인에는 필요에 따라이 사용 권한을 설정 하 고 대신 완전 신뢰로 실행에서 제외 되는 강력한 이름의 어셈블리의 목록을 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>기본 응용 프로그램 도메인의 부모 프로세스가 종료하면 이 이벤트가 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> 이 이벤트는 파일 닫기 등의 종료 작업을 수행할 수에 대 한 프로세스가 종료 되기 전에 저장소를 등의 해제 합니다.  
  
 .NET Framework 버전 2.0부터,이 이벤트는 이벤트 처리기를 등록 하는 각 응용 프로그램 도메인에서 발생 합니다.  
  
> [!NOTE]
>  모든의 총 실행 시간 <xref:System.AppDomain.ProcessExit> 모든 종료자의 총 실행 시간 프로세스가 종료 될 때 제한 된 것 처럼 이벤트 처리기 제한 되어 있습니다. 기본값은 2 초입니다. 관리 되지 않는 호스트를 호출 하 여이 실행 시간을 변경할 수는 [iclrpolicymanager:: Settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) 메서드는 [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) 열거형 값입니다.  
  
 .NET Framework 버전 1.0 및 1.1에서는이 이벤트는 기본 응용 프로그램 도메인 에서만 발생 하 고 기본 응용 프로그램 도메인에는 이벤트 처리기가 등록 하는 경우에 합니다.  
  
 이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리 전용 컨텍스트에서 어셈블리 확인이 실패하면 이 이벤트가 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리플렉션 전용 컨텍스트에 종속성 자동으로 확인 되지 않습니다. 미리 로드 되거나이 이벤트 처리기에 의해 반환 될 해야 합니다. 이 이벤트는 어셈블리를 리플렉션 전용 컨텍스트에 로드 되지 않는 종속성에 있을 때 발생 합니다. 누락 된 종속성으로 지정 된 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성입니다. <xref:System.ResolveEventHandler> 이 이벤트는 종속성을 충족 하는 어셈블리를 반환 해야 합니다. 반환 된 어셈블리를 리플렉션 전용 컨텍스트에 로드 해야 합니다.  
  
> [!IMPORTANT]
>  이 이벤트는 리플렉션 전용 컨텍스트에 로드 되는 어셈블리의 종속성이 누락에 대해서만 발생 (사용 하 여 예를 들어는 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 메서드). 로드 하는 어셈블리를 찾을 수 없는 경우에 발생 하지 않습니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성을 확인할 수 없는 어셈블리 로드를 요청한 어셈블리를 반환 합니다. 요청한 어셈블리의 id를 알면 둘 이상의 버전을 사용할 수 있는 경우 올바른 버전의 종속성을 식별할 수 있습니다. 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.  
  
 이 이벤트는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성 정책 적용 하기 전에 어셈블리 이름을 반환 합니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램 도메인의 리플렉션 전용 컨텍스트로 로드된 어셈블리를 반환합니다.</summary>
        <returns>응용 프로그램 도메인의 리플렉션 전용 컨텍스트에 로드된 어셈블리를 나타내는 <see cref="T:System.Reflection.Assembly" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 리플렉션 전용 컨텍스트에 로드 된 어셈블리를 반환 합니다. 실행을 위해 로드 된 어셈블리를 가져오려면는 <xref:System.AppDomain.GetAssemblies%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 실행 컨텍스트를 변환한 다음 리플렉션 전용 컨텍스트에 System.dll 어셈블리를 로드합니다. <xref:System.AppDomain.GetAssemblies%2A> 및 <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> 메서드는 각 컨텍스트로 로드 된 어셈블리를 표시 하는 데 사용 됩니다.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업을 시도한 경우</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리 아래의 경로를 가져옵니다.</summary>
        <value>어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리 아래의 경로입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 전용 어셈블리는 응용 프로그램과 동일한 디렉터리 구조에 배포 됩니다. 경로 지정 하는 경우는 <xref:System.AppDomain.RelativeSearchPath%2A> 속성은 아래에서 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, 무시 됩니다.  
  
 이 속성 값을 사용 하 여 설정 반환 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>리소스가 어셈블리에서 올바르게 링크되거나 포함된 리소스가 아니어서 리소스 확인이 실패하면 이 이벤트가 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler> 에이 이벤트는 리소스가 포함 된 어셈블리를 찾아 반환 시도할 수 있습니다.  
  
> [!IMPORTANT]
>  파일이 없습니다. 올바른 연결 된 리소스에 대 한 있습니다 확인이 실패 하는 경우에이 이벤트가 발생 하지 않습니다. 이 이벤트는 발생 매니페스트 리소스 스트림을 찾을 수 없는 경우는 개별 리소스 키를 찾을 수 없는 경우는 발생 하지 않습니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성에 리소스를 요청한 어셈블리를 포함 합니다. 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.  
  
 이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">보안 정책 수준입니다.</param>
        <summary>이 응용 프로그램 도메인의 보안 정책 수준을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리에 로드 되기 전에이 메서드는 <xref:System.AppDomain> 보안 정책 적용 하기 위해에서 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 <xref:System.AppDomain.SetAppDomainPolicy%2A> 메서드를 응용 프로그램 도메인의 보안 정책 수준을 설정 합니다.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Security.Policy.PolicyException">보안 정책 수준이 이미 설정되어 있는 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">섀도 복사본 위치에 대한 정규화된 경로입니다.</param>
        <summary>지정한 디렉터리 경로를 어셈블리가 섀도 복사되는 위치로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐시 경로 무시 됩니다는 <xref:System.AppDomainSetup.ApplicationName%2A> 속성이 설정 되지 않았습니다. <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 속성을 참조하세요.  
  
 섀도 복사에 대 한 자세한 내용은 참조 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>응용 프로그램 도메인 속성에 값을 할당합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">만들거나 변경할 사용자 정의 응용 프로그램 도메인 속성의 이름입니다.</param>
        <param name="data">속성 값입니다.</param>
        <summary>지정한 응용 프로그램 도메인 속성에 지정한 값을 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 를 삽입 하려면이 메서드를 사용 하거나이 인스턴스의 속성을 설명 하는 이름-데이터 쌍의 내부 캐시에 있는 항목의 값을 수정 <xref:System.AppDomain>합니다.  
  
 캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 하는 미리 정의 된 시스템 항목을 포함 합니다. 삽입 하거나이 메서드를 사용 하 여 시스템 항목을 수정할 수 없습니다. 시스템 항목을 수정 하려고 시도 하는 메서드 호출에 영향을 주지 않습니다. 메서드는 예외를 throw 하지 않습니다. 와 시스템 항목의 값을 검사할 수는 <xref:System.AppDomain.GetData%2A> 메서드나 해당 하는 <xref:System.AppDomainSetup> 속성에 설명 된 <xref:System.AppDomain.GetData%2A>합니다.  
  
 값으로 "REGEX_DEFAULT_MATCH_TIMEOUT" 공급으로 정규식 패턴을 평가 하기 위한 기본 제한 시간 간격의 값을 설정 하려면이 메서드를 호출할 수는 `name` 인수 및 <xref:System.TimeSpan> 제한 시간을 나타내는 값입니다 간격의 값으로는 `data` 인수입니다. 수도 삽입 또는 수정 사용자 정의 이름-데이터 쌍이 방법을 사용 하 고 수와 해당 값을 검사할는 <xref:System.AppDomain.GetData%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> 메서드는 새 값 쌍을 만듭니다. 이 예제에서는 다음 사용 하 여는 <xref:System.AppDomain.GetData%2A> 메서드는 값을 검색 하 고 콘솔에 표시 합니다.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">만들거나 변경할 사용자 정의 응용 프로그램 도메인 속성의 이름입니다.</param>
        <param name="data">속성 값입니다.</param>
        <param name="permission">속성을 검색할 때 호출자의 요청에 대한 권한입니다.</param>
        <summary>속성을 검색할 때 호출자의 요청에 대해 지정된 권한을 사용하여 지정한 응용 프로그램 도메인 속성에 지정한 값을 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 응용 프로그램 도메인의 속성을 설명 하는 이름/데이터 쌍의 내부 캐시에 사용자 고유의 사용자 지정 항목을 삽입 하거나 수정할 합니다. 항목을 삽입 하는 경우 항목을 검색할 때 적용할 권한 요청을 지정할 수 있습니다. 값으로 "REGEX_DEFAULT_MATCH_TIMEOUT" 공급으로 정규식 패턴을 평가 하기 위한 기본 제한 시간 간격의 값을 설정 하려면이 메서드를 호출할 수는 또한는 `name` 인수 및 <xref:System.TimeSpan> 를 나타내는 값은 제한 시간 간격의 값으로는 `data` 인수입니다.  
  
 시스템 정의 속성 문자열을 보안 요청을 할당 하려면이 메서드를 사용할 수 없습니다.  
  
 캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 하는 미리 정의 된 시스템 항목을 포함 합니다. 삽입 하거나이 메서드를 사용 하 여 시스템 항목을 수정할 수 없습니다. 시스템 항목을 수정 하려고 시도 하는 메서드 호출에 영향을 주지 않습니다. 메서드는 예외를 throw 하지 않습니다. 와 시스템 항목의 값을 검사할 수는 <xref:System.AppDomain.GetData%2A> 메서드 또는 해당 <xref:System.AppDomainSetup> 에 대 한 설명 섹션에 설명 된 속성의 <xref:System.AppDomain.GetData%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" />이 시스템 정의 속성 문자열을 지정하고 <paramref name="permission" /> 값이 <see langword="null" />이 아닌 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">동적 어셈블리를 저장하는 하위 디렉터리의 기본 디렉터리인 정규화된 경로입니다.</param>
        <summary>지정한 디렉터리 경로를 동적으로 생성된 파일을 저장하고 액세스하는 하위 디렉터리의 기본 디렉터리로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 설정의 <xref:System.AppDomainSetup.DynamicBase%2A> 속성의 내부 <xref:System.AppDomainSetup> 이 인스턴스와 연결 된입니다.  
  
   
  
## Examples  
 이 메서드는 이전 이제 하며 새로운 개발에 사용할 수 없습니다. 클래스 대신 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 속성입니다. 참조에 대 한 설명은이 예제는 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 속성 또는 <xref:System.AppDomain.DynamicDirectory%2A> 속성입니다.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">스레드에 연결할 Principal 개체의 형식을 지정하는 <see cref="T:System.Security.Principal.PrincipalPolicy" /> 값 중 하나입니다.</param>
        <summary>이 응용 프로그램 도메인에서 실행되는 동안 스레드가 특정 보안 주체에 바인딩하려는 경우 Principal 개체 및 Identity 개체를 스레드에 연결하는 방법을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 값으로 설정만 적용 됩니다 사용 하기 전에 설정 하는 경우는 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성입니다. 예를 들어, 설정한 경우 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 주어진된 주 서버 (예: 일반 사용자)와 다음 사용 하 여는 <xref:System.AppDomain.SetPrincipalPolicy%2A> 설정 하는 메서드는 <xref:System.Security.Principal.PrincipalPolicy> 를 <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, 현재 보안 주체가 제너릭 주체 유지 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 결과 보여 줍니다.는 <xref:System.AppDomain.SetPrincipalPolicy%2A> 메서드를 응용 프로그램 도메인의 주 정책을 변경 합니다. 사용한 결과를 보여 줍니다는 <xref:System.AppDomain.SetThreadPrincipal%2A> 스레드에 응용 프로그램 도메인에 연결할 수 있는 주체를 변경 하려면 메서드.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 주 개체를 조작할 수 있습니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>섀도 복사를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 섀도 복사에 대 한 자세한 내용은 참조 하십시오. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
   
  
## Examples  
 이 메서드는 이전 이제 하며 새로운 개발에 사용할 수 없습니다.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">각 이름이 세미콜론으로 구분되는 디렉터리 이름 목록입니다.</param>
        <summary>지정한 디렉터리 경로를 어셈블리가 섀도 복사되는 위치로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 섀도 복사본을 기본적으로 검색을 통해 발견 된 모든 어셈블리를 포함 합니다. <xref:System.AppDomain.SetShadowCopyPath%2A> 메서드 섀도 복사를 통해 지정 된 디렉터리의 어셈블리에 제한 `path`합니다.  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A> 메서드는 어셈블리에 대 한 검색할 추가 디렉터리를 지정 하지 않습니다. 어셈블리 섀도 복사에 이미 있어야 검색 경로에 예를 들어 아래 <xref:System.AppDomain.BaseDirectory%2A>합니다. <xref:System.AppDomain.SetShadowCopyPath%2A> 메서드는 검색 경로 섀도 복사를 지정 합니다.  
  
 이 메서드는 설정의 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 속성의 내부 <xref:System.AppDomainSetup> 이 인스턴스와 연결 된입니다.  
  
 섀도 복사에 대 한 자세한 내용은 참조 하십시오. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
   
  
## Examples  
 이 메서드는 이전 이제 하며 새로운 개발에 사용할 수 없습니다.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">스레드에 연결할 Principal 개체입니다.</param>
        <summary>이 응용 프로그램 도메인에서 실행되는 동안 스레드가 특정 보안 주체에 바인딩하려는 경우 스레드에 연결되는 기본 Principal 개체를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제를 사용 하 여 결과 보여 줍니다.는 <xref:System.AppDomain.SetThreadPrincipal%2A> 응용 프로그램 도메인에서 실행 하는 스레드에 연결할 수 있는 주체를 변경 하려면 메서드. 또한를 사용 하 여 스레드가에 미치는 영향 표시는 <xref:System.AppDomain.SetPrincipalPolicy%2A> 응용 프로그램 도메인의 보안 주체 정책을 변경 하려면 메서드.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Security.Policy.PolicyException">스레드 보안 주체가 이미 설정되어 있는 경우</exception>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 대 한 주 개체를 조작할 수 있습니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 인스턴스의 응용 프로그램 도메인 구성 정보를 가져옵니다.</summary>
        <value>응용 프로그램 도메인 초기화 정보입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인이 파일을 섀도 복사하도록 구성되어 있는지를 나타내는 표시를 가져옵니다.</summary>
        <value>
          응용 프로그램 도메인이 파일을 섀도 복사하도록 구성되어 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 참조 <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> 및 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터를 받습니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램 도메인과 컨텍스트 정책의 이름이 포함된 문자열 표현을 가져옵니다.</summary>
        <returns>리터럴 문자열 "이름:", 응용 프로그램 도메인의 이름 및 컨텍스트 정책의 문자열 표현 또는 "컨텍스트 정책이 없습니다." 문자열을 연결하여 구성되는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 반환 값을 표시 하는 다음 코드 예제는 <xref:System.AppDomain.ToString%2A> 메서드.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">현재 <see cref="T:System.AppDomain" />으로 표시된 응용 프로그램 도메인이 언로드된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식을 확인하지 못할 경우 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> 이 이벤트는 공용 언어 런타임 요청된 된 형식을 만들 수 있는 어셈블리를 확인할 수 없는 경우 발생 합니다. 이 유형을 동적 어셈블리에 정의 되어 또는 유형을 동적 어셈블리에 정의 되지 않은 있지만 런타임 형식에 정의 되어 있는 어셈블리를 알지 못합니다 발생할 수 있습니다. 후자의 경우에 발생할 수 있습니다 때 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 어셈블리 이름으로 한정 되지 않았습니다. 형식 이름으로 호출 합니다.  
  
 <xref:System.ResolveEventHandler> 에이 이벤트를 찾아 형식을 만드는 시도할 수 있습니다.  
  
 그러나는 <xref:System.AppDomain.TypeResolve> 런타임에서 특정 어셈블리에서 형식을 찾을 수 없는 경우에 이벤트가 발생 하지 않습니다. 예를 들어이 이벤트는 런타임 형식을 정적 어셈블리에 동적으로 추가할 수 없습니다 알기 때문에 형식을 정적 어셈블리에 없는 경우에 발생 하지 않습니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성 유형을 요청 하는 어셈블리를 포함 합니다. 자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.  
  
 이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.TypeResolve> 이벤트입니다.  
  
 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 정규화 된 어셈블리 이름을 확인 하는 방법에 대 한 정보를 참조 하십시오. [어셈블리 이름을](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>예외가 catch되지 않으면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트를 확인할 수 없는 예외에 대 한 알림을 제공합니다. 시스템 기본 처리기는 사용자에 게 예외를 보고 하 고 응용 프로그램이 종료 되기 전에 예외에 대 한 정보를 기록 하도록 응용 프로그램 수 있습니다. 응용 프로그램의 상태에 대 한 충분 한 정보가 표시 되 면 다른 작업을 수행할 수 있습니다-나중에 복구에 대 한 프로그램 데이터를 저장 하는 등입니다. 예외 처리 되지 않은 프로그램 데이터 손상 될 수 있으므로 주의 해야 합니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서는이 이벤트를 발생 시키려면 이후 보다 응용 프로그램 종료 및 디버깅 옵션이 사용자에 게 보고 됩니다.  
  
 이 이벤트는 응용 프로그램 도메인에서 처리할 수 있습니다. 그러나 이벤트 예외가 발생 하는 응용 프로그램 도메인에서 반드시 발생 하지 않습니다. 스레드에 대 한 전체 스택을 정리 된 하므로 이벤트가 발생할 수 있는 첫 번째 위치는 스레드가 생성 된 응용 프로그램 도메인에 적절 한 예외 처리기를 찾지 않고 하는 경우에 예외가 처리 되지 않습니다.  
  
> [!NOTE]
>  이 이벤트는.NET Framework 버전 1.0 및 1.1에서는 응용 프로그램이 시작 될 때 시스템에서 생성 되는 기본 응용 프로그램 도메인에 대해서만 발생 합니다. 응용 프로그램에 추가 응용 프로그램 도메인을 만드는 경우 해당 응용 프로그램 도메인에서이 이벤트에 대 한 대리자를 지정 하 효과가 없습니다.  
  
 경우는 <xref:System.AppDomain.UnhandledException> 발생 처리 되지 않은 응용 프로그램 도메인에 관계 없이 모든 스레드에서 예외 스레드가 시작에 대 한, 기본 응용 프로그램 도메인에서 이벤트를 처리 합니다. 스레드가 대 한 이벤트 처리기가 응용 프로그램 도메인에서 시작 하는 경우 <xref:System.AppDomain.UnhandledException>, 해당 응용 프로그램 도메인에서 이벤트가 발생 합니다. 해당 응용 프로그램 도메인 기본 응용 프로그램 도메인 아니며 기본 응용 프로그램 도메인에서 이벤트 처리기도는 경우이 이벤트는 두 응용 프로그램 도메인에서 발생 합니다.  
  
 예를 들어 가정 스레드를 시작할 응용 프로그램 도메인 "AD1" "AD2" 응용 프로그램 도메인의 메서드를 호출 및 거기서에서 메서드를 호출 하는 "AD3" 응용 프로그램 도메인에서 예외가 throw 되 합니다. 첫 번째 응용 프로그램 도메인에는 <xref:System.AppDomain.UnhandledException> 이벤트가 "AD1" 합니다. 해당 응용 프로그램 도메인의 기본 응용 프로그램 도메인에 있지 않은 경우 이벤트 기본 응용 프로그램 도메인에도 발생할 수 있습니다.  
  
> [!NOTE]
>  공용 언어 런타임 스레드 중단에 대 한 이벤트 처리기는 동안 일시 중단 된 <xref:System.AppDomain.UnhandledException> 이벤트를 실행 합니다.  
  
 이벤트 처리기의 경우는 <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> 특성의 적절 한 플래그를 이벤트 처리기 제약이 있는 실행 영역으로 처리 됩니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 스택 오버플로 같은 프로세스의 상태가 손상 또는 액세스 위반, 이벤트 처리기가 보안에 중요 한 및 경우가 아니면 하는 예외에 대 한이 이벤트는 <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> 특성입니다.  
  
 .NET Framework 버전 1.0 및 1.1에서는 기본 응용 프로그램 스레드를 제외한 스레드에서 발생 하는 처리 되지 않은 예외 런타임에서 발생 하 고 따라서 응용 프로그램이 종료를 발생 하지 않습니다. 즉에 대 한 가능한는 <xref:System.AppDomain.UnhandledException> 이벤트를 응용 프로그램을 종료 하지 않고 발생 합니다. .NET Framework 버전 2.0 이상에서는 자식 스레드에서 처리 되지 않은 예외에 대 한이 백업을 제거 이러한 누적 된 효과가 포함 성능이 저하 되 고 손상 된 데이터는 모두 디버그 하기가 어렵기 때문에 있습니다. 런타임 종료 되지 않는 사례 목록을 비롯 한 자세한 내용은 참조 하십시오. [관리 되는 스레드의 예외](~/docs/standard/threading/exceptions-in-managed-threads.md)합니다.  
  
 이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
## <a name="other-events-for-unhandled-exceptions"></a>처리 되지 않은 예외에 대 한 다른 이벤트  
 특정 응용 프로그램 모델의 <xref:System.AppDomain.UnhandledException> 이벤트 주 응용 프로그램 스레드에서 처리 되지 않은 예외가 발생 하는 경우 다른 이벤트에 의해 선점 될 수 있습니다.  
  
 Windows Forms를 사용 하는 응용 프로그램에서 처리 되지 않은 예외에서 기본 응용 프로그램 스레드는 <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> 이벤트를 발생 합니다. 이 이벤트를 처리 하는 경우 기본 동작은 예외로 인해 응용 프로그램을 종료 하지 않을 응용 프로그램은 알 수 없는 상태로 남아 있지만 합니다. 이 경우에 <xref:System.AppDomain.UnhandledException> 이벤트가 발생 하지 않습니다. 응용 프로그램 구성 파일을 사용 하거나 사용 하 여이 동작을 변경할 수 있습니다는 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> 모드를 변경 하려면 <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> 하기 전에 <xref:System.Windows.Forms.Application.ThreadException> 이벤트 처리기 후크 되어 있습니다. 이 기본 응용 프로그램 스레드에만 적용 됩니다. <xref:System.AppDomain.UnhandledException> 다른 스레드에서 throw 된 처리 되지 않은 예외에 대 한 이벤트가 발생 합니다.  
  
 Microsoft Visual Studio 2005 이상에서는 Visual Basic 응용 프로그램 프레임 워크는 주 응용 프로그램 스레드에서 처리 되지 않은 예외에 대 한 다른 이벤트를 제공 합니다. 참조는 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> 이벤트입니다. 이 이벤트에는 이벤트 인수 개체에서 사용 하는 이벤트 인수 개체와 동일한 이름 가진 <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, 있지만 다른 속성을 사용 합니다. 특히이 이벤트 인수 개체에는 <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> 속성을 사용 하 고 계속 실행, 처리 되지 않은 예외를 무시 합니다. (응용 프로그램 상태를 알 수)을 응용 프로그램입니다. 이 경우에 <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> 이벤트가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예와 보여 줍니다.는 <xref:System.AppDomain.UnhandledException> 이벤트입니다. 이벤트 처리기를 정의 `MyHandler`, 기본 응용 프로그램 도메인에서 처리 되지 않은 예외가 throw 됩니다 때마다 호출 되는 합니다. 다음 두 가지 예외를 throw합니다. 첫 번째는에서 처리 한 **try/catch** 블록입니다. 두 번째는 처리 되지 않으며 호출의 `MyHandle` 응용 프로그램을 종료 하기 전에 루틴입니다.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">언로드할 응용 프로그램 도메인입니다.</param>
        <summary>지정한 응용 프로그램 도메인을 언로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 버전 2.0에에서는 스레드가 없는 응용 프로그램 도메인 언로드 전용입니다. .NET Framework 호스팅되는 경우에 특히 안정성 향상 됩니다. 호출 하면 스레드 <xref:System.AppDomain.Unload%2A>, 언로드되도록 대상 도메인이 표시 됩니다. 전용된 스레드가 도메인의 언로드 하 고 도메인의 모든 스레드가 중단 합니다. 스레드가 중단 되지 않는 예를 들어 비관리 코드를 실행 하는 경우 또는 실행 한 `finally` 일정 기간 후 다음 블록은 <xref:System.CannotUnloadAppDomainException> 원래 호출한 스레드가에서 throw 된 <xref:System.AppDomain.Unload%2A>합니다. 결국 중단 하지 스레드가 종료 되는 경우에 대상 도메인은 언로드되지 않습니다. 따라서.NET Framework 버전 2.0에서에서 `domain` 보장 되지 않는 언로드되도록 것 수 없는 경우에 실행 중인 스레드를 종료할 수 있습니다.  
  
> [!NOTE]
>  경우에 따라 호출 <xref:System.AppDomain.Unload%2A> 즉시 발생할 <xref:System.CannotUnloadAppDomainException>, 예를 들어 종료자에서 메서드를 호출 합니다.  
  
 스레드 `domain` 를 사용 하 여 종료 되는 <xref:System.Threading.Thread.Abort%2A> throw 하는 메서드는 <xref:System.Threading.ThreadAbortException> 스레드에서 합니다. 하지 않은 시간에 실행을 계속할 수 있지만 스레드가 즉시 종료 되어야는 `finally` 절.  
  
## <a name="version-compatibility"></a>버전 호환성  
 .NET framework 버전 1.0 및 1.1를 호출한 스레드가 경우 <xref:System.AppDomain.Unload%2A> 에서 실행 되 고 `domain`, 다른 스레드 언로드 작업을 수행 하기 시작 합니다. 경우 `domain` 언로드할 수 없으며는 <xref:System.CannotUnloadAppDomainException> 를 호출한 원래 스레드가에 없는 해당 스레드에서 throw 되 <xref:System.AppDomain.Unload%2A>합니다. 그러나 호출 하는 스레드가 <xref:System.AppDomain.Unload%2A> 외부에서 실행 되 `domain`, 스레드가 예외를 받습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 응용 프로그램 도메인 언로드 하는 방법을 보여 줍니다.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" />을 언로드할 수 없는 경우</exception>
        <exception cref="T:System.Exception">언로드하는 동안 오류가 발생한 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">이 이벤트에 대 한 이벤트 처리기를 추가 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
      </Docs>
    </Member>
  </Members>
</Type>