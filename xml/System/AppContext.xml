<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="AppContext.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5de2b5eddaaa2bb43dcc7b608c490b41f3a8c1713.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">de2b5eddaaa2bb43dcc7b608c490b41f3a8c1713</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.AppContext">
          <source>Provides members for setting and retrieving data about an application's context.</source>
          <target state="translated">응용 프로그램의 컨텍스트에 대한 데이터를 설정 및 검색하기 위한 멤버를 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> class enables library writers to provide a uniform opt-out mechanism for new functionality for their users.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 클래스를 사용 하면 라이브러리 작성자가 사용자에 게 새로운 기능에 대 한 균일 한 옵트아웃 메커니즘을 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>It establishes a loosely-coupled contract between components in order to communicate an opt-out request.</source>
          <target state="translated">옵트아웃(opt out) 요청을 전달하기 위해 구성 요소 간에 느슨하게 결합된 계약을 설정합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>This capability is typically important when a change is made to existing functionality.</source>
          <target state="translated">이 기능은 일반적으로 기존 기능이 변경될 때 중요합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Conversely, there is already an implicit opt-in for new functionality.</source>
          <target state="translated">반대로, 새로운 기능에 대한 암시적 옵트인(opt in)은 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>AppContext for library developers</source>
          <target state="translated">라이브러리 개발자를 위한 AppContext</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Libraries use  the <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> class to define and expose compatibility switches, while library users can set those switches to affect the library behavior.</source>
          <target state="translated">라이브러리는 사용 된 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 라이브러리 사용자가 해당 스위치를 라이브러리 동작에 영향을 설정할 수 있지만 클래스 정의 하 고 호환성을 노출 전환 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>By default, libraries provide the new functionality, and they only alter it (that is, they provide the previous functionality) if the switch is set.</source>
          <target state="translated">기본적으로 라이브러리는 새로운 기능을 제공하며 스위치가 설정된 경우에만 변경합니다(즉, 이전 기능 제공).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>This allows libraries to provide new behavior for an existing API while continuing to support callers who depend on the previous behavior.</source>
          <target state="translated">이렇게 하면 라이브러리 줄이면서 이전 동작에 의존 하는 호출자를 지원 하도록 기존 API에 대 한 새 동작을 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Defining the switch name</source>
          <target state="translated">스위치 이름 정의</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The most common way to allow consumers of your library to opt out of a change of behavior is to define a named switch.</source>
          <target state="translated">변경 된 동작 컬렉션에서 라이브러리의 소비자를 허용 하는 가장 일반적인 방법은 명명 된 스위치를 정의 하는 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Its <ph id="ph1">`value`</ph> element is a name/value pair that consists of the name of a switch and its <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> value.</source>
          <target state="translated">해당 <ph id="ph1">`value`</ph> 요소는 스위치의 이름으로 구성 된 이름/값 쌍 및 해당 <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>By default, the switch is always implicitly <ph id="ph1">`false`</ph>, which provides the new behavior (and makes the new behavior opt-in by default).</source>
          <target state="translated">기본적으로 스위치는 암시적으로 항상 <ph id="ph1">`false`</ph>이며 새 동작이 제공 (및 새 동작 옵트인 하면 기본적으로).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Setting the switch to <ph id="ph1">`true`</ph> enables it, which provides the legacy behavior.</source>
          <target state="translated">스위치 설정 <ph id="ph1">`true`</ph> 레거시 동작을 제공 하 고 활성화 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Explicitly setting the switch to <ph id="ph1">`false`</ph> also provides the new behavior.</source>
          <target state="translated">는 스위치를 명시적으로 설정 <ph id="ph1">`false`</ph> 또한 새로운 동작을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>It's beneficial to use a consistent format for switch names, since they are a formal contract exposed by a library.</source>
          <target state="translated">라이브러리에 의해 노출 되는 공식 계약 이므로 스위치 이름에 대 한 일관 된 형식을 사용 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The following are two obvious formats.</source>
          <target state="translated">다음은 두 가지 명확한 형식입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>namespace<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>namespace<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>library<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>library<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Once you define and document the switch, callers can use it by using the registry, by adding an  <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>AppContextSwitchOverrides&gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> element to their application configuration file, or by calling the  <ph id="ph2">&lt;xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method programmatically.</source>
          <target state="translated">정의 하 고 스위치 문서화 되 면 호출자가 사용할 수를 추가 하 여 레지스트리를 사용 하 여 프로그램 <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>AppContextSwitchOverrides &gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> 요소를 호출 하거나 해당 응용 프로그램 구성 파일에는 <ph id="ph2">&lt;xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> 메서드 프로그래밍 방식으로 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>See the <bpt id="p1">[</bpt>AppContext for library consumers<ept id="p1">](#ForConsumers)</ept> section for more information about how callers use and set the value of <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> configuration switches.</source>
          <target state="translated">참조는 <bpt id="p1">[</bpt>라이브러리 소비자에 대 한 AppContext<ept id="p1">](#ForConsumers)</ept> 호출자에 게 사용 하 고 값을 설정 하는 방법에 대 한 자세한 내용은 섹션 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 구성 스위치입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>When the common language runtime runs an application, it automatically reads the registry's compatibility settings and loads the application configuration file in order to populate the application's <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> instance.</source>
          <target state="translated">공용 언어 런타임 응용 프로그램을 실행 하는 경우 자동으로 호환성 레지스트리를 읽고 응용 프로그램의 채우기 위해 응용 프로그램 구성 파일을 로드 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Because the <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> instance is populated either programmatically by the caller or by the runtime, you do not have to take any action, such as calling the <ph id="ph2">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> method,  to configure the <ph id="ph3">&lt;xref:System.AppContext&gt;</ph> instance.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 인스턴스 또는 호출자가 프로그래밍 방식으로 런타임에 의해 채워집니다, 호출 등의 어떤 조치도 취할 필요가 없습니다는 <ph id="ph2">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> 메서드를 구성 하는 <ph id="ph3">&lt;xref:System.AppContext&gt;</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Checking the setting</source>
          <target state="translated">설정을 확인 하는 중</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>You can then check if a consumer has declared the value of the switch and act appropriately by calling the <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">소비자가 act 적절 하 게 호출 하 고 스위치의 값을 선언 하는 경우 선택할 수 있습니다는 <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The method returns <ph id="ph1">`true`</ph> if the <ph id="ph2">`switchName`</ph> argument is found, and when the method returns, its <ph id="ph3">`isEnabled`</ph> argument indicates the value of the switch.</source>
          <target state="translated">메서드가 반환 <ph id="ph1">`true`</ph> 경우는 <ph id="ph2">`switchName`</ph> 인수 발견 되 고 메서드가 반환 하는 경우, 해당 <ph id="ph3">`isEnabled`</ph> 인수에 스위치의 값을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Otherwise, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">그렇지 않은 경우 메서드는 <ph id="ph1">`false`</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>An example</source>
          <target state="translated">예</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> class to allow the customer to choose the original behavior of a library method.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 클래스는 고객이 라이브러리 메서드의 원래 동작을 선택할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The following is version 1.0 of a library named <ph id="ph1">`StringLibrary`</ph>.</source>
          <target state="translated">다음은 명명 된 라이브러리의 버전 1.0 <ph id="ph1">`StringLibrary`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>It defines a <ph id="ph1">`SubstringStartsAt`</ph> method that performs an ordinal comparison to determine the starting index of a substring within a larger string.</source>
          <target state="translated">정의 <ph id="ph1">`SubstringStartsAt`</ph> 더 큰 문자열에 부분 문자열의 시작 인덱스를 결정 하는 서 수 비교를 수행 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The following example then uses the library to find the starting index of the substring "archæ" in "The archaeologist".</source>
          <target state="translated">다음 예제에서는 다음 라이브러리를 사용 하 여 "고고학자"에서 "archæ" 부분 문자열의 시작 인덱스를 찾을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Because the method performs an ordinal comparison, the substring cannot be found.</source>
          <target state="translated">메서드는 서 수 비교 수행, 하기 때문에 부분 문자열을 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Version 2 of the library, however, changes the <ph id="ph1">`SubstringStartsAt`</ph> method to use culture-sensitive comparison.</source>
          <target state="translated">하지만 변경 하는 라이브러리의 버전 2는 <ph id="ph1">`SubstringStartsAt`</ph> 문화권 구분 비교를 사용 하는 메서드.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>When the app is recompiled to run against the new version of the library, it now reports that the substring "archæ" is found at index 4 in "The archaeologist".</source>
          <target state="translated">응용 프로그램은 라이브러리의 새 버전에서 실행 되도록 다시 컴파일하면에 이제 "archæ" 하위 문자열은 "고고학자"에서 인덱스 4에서 발견 되었음을 보고 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>This change can be prevented from breaking the applications that depend on the original behavior by defining an <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>AppContextSwitchOverrides&gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> switch.</source>
          <target state="translated">이 변경 내용을 정의 하 여 원래 동작에 종속 된 응용 프로그램을 중단에서 금지할 수 있습니다는 <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>AppContextSwitchOverrides &gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> 전환 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>In this case, the switch is named <ph id="ph1">`StringLibrary.DoNotUseCultureSensitiveComparison`</ph>.</source>
          <target state="translated">이 경우 스위치가 라는 <ph id="ph1">`StringLibrary.DoNotUseCultureSensitiveComparison`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Its default value, <ph id="ph1">`false`</ph>, indicates that the library should perform its version 2.0 culture-sensitive comparison.</source>
          <target state="translated">기본값인 <ph id="ph1">`false`</ph>, 라이브러리 버전 2.0에서 문화권 구분 비교를 수행 해야 한다고 나타냅니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source><ph id="ph1">`true`</ph> indicates that the library should perform its version 1.0 ordinal comparison.</source>
          <target state="translated"><ph id="ph1">`true`</ph> 라이브러리의 버전 1.0 서 수 비교를 수행 해야 한다고 나타냅니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>A slight modification of the previous code allows the library consumer to set the switch to determine the kind of comparison the method performs.</source>
          <target state="translated">앞의 코드를 약간 수정 라이브러리 소비자를 메서드가 수행할 비교의 종류를 결정 하는 스위치를 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>If application can then use the following configuration file to restore the version 1.0 behavior.</source>
          <target state="translated">경우 응용 프로그램 버전 1.0 동작으로 복원 하려면 다음 구성 파일을 유도할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>When the application is run with the configuration file present, it produces the following output:</source>
          <target state="translated">응용 프로그램이 있는 구성 파일에 실행 될 때 다음과 같은 출력이 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>AppContext for library consumers</source>
          <target state="translated">AppContext 라이브러리 소비자에 대 한</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>If you are the consumer of a library, the <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> class  allows you to take advantage of a library or library method's opt-out mechanism for new functionality.</source>
          <target state="translated">소비자는 라이브러리의 경우는 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 클래스 라이브러리 또는 새로운 기능에 대해 라이브러리 메서드 옵트아웃 메커니즘을 활용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Individual methods of the class library that you are calling define particular switches that enable or disable a new behavior.</source>
          <target state="translated">호출 하는 클래스 라이브러리의 개별 메서드는 새로운 동작을 사용할지 여부를 지정 하는 특정 스위치를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The value of the switch  is a Boolean.</source>
          <target state="translated">스위치의 값에는 부울입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>If it is <ph id="ph1">`false`</ph>, which is typically the default value, the new behavior is enabled; if it is <ph id="ph2">`true`</ph>, the new behavior is disabled, and the member behaves as it did previously.</source>
          <target state="translated">이 경우 <ph id="ph1">`false`</ph>, 값은 일반적으로 기본 값, 새 동작 사용 되는 경우 <ph id="ph2">`true`</ph>새로운 동작을 사용 하지 않도록 설정 하 고 멤버와 같은 동작을 이전에 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>You can set the value of a switch in one of three ways:</source>
          <target state="translated">다음 세 가지 방법 중 하나에 스위치의 값을 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>By calling the <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method in your code.</source>
          <target state="translated">호출 하 여는 <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> 코드에서 메서드.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The <ph id="ph1">`switchName`</ph> argument defines the switch name, and the <ph id="ph2">`isEnabled`</ph> property defines the value of the switch.</source>
          <target state="translated"><ph id="ph1">`switchName`</ph> 인수에 스위치 이름 정의 및 <ph id="ph2">`isEnabled`</ph> 속성은 스위치의 값을 정의 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Because <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> is a static class, it is available on a per-application domain basis.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 정적 클래스는 응용 프로그램 도메인 별로 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Calling the <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> has application scope; that is, it affects only the application.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> 응용 프로그램 범위가;만 응용 프로그램에 영향을 주므로, 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>By adding an <ph id="ph1">`&lt;AppContextSwitchOverrides&gt;`</ph> element to the <bpt id="p1">[</bpt><ph id="ph2">\&lt;</ph>runtime&gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> section of your app.config file.</source>
          <target state="translated">추가 하 여는 <ph id="ph1">`&lt;AppContextSwitchOverrides&gt;`</ph> 요소는 <bpt id="p1">[</bpt> <ph id="ph2">\&lt;</ph>런타임 &gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> app.config 파일의 섹션입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The switch has a single attribute, <ph id="ph1">`value`</ph>, whose value is a string that represents a key/value pair containing both the switch name and its value.</source>
          <target state="translated">스위치는 단일 특성을 <ph id="ph1">`value`</ph>, 해당 값은 스위치 이름 및 해당 값을 모두 포함 하는 키/값 쌍을 나타내는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>To define multiple switches, separate each switch's key/value pair in the <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>AppContextSwitchOverrides&gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> element's <ph id="ph2">`value`</ph> attribute with a semicolon.</source>
          <target state="translated">여러 개의 스위치를 정의 하려면의 각 스위치 키/값 쌍을 구분는 <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>AppContextSwitchOverrides &gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> 요소의 <ph id="ph2">`value`</ph> 세미콜론을 사용 하 여 특성입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>In that case, the <ph id="ph1">`&lt;AppContextSwitchOverrides&gt;`</ph> element has the following format:</source>
          <target state="translated">이 경우에 <ph id="ph1">`&lt;AppContextSwitchOverrides&gt;`</ph> 요소 형식은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Using the <ph id="ph1">`&lt;AppContextSwitchOverrides&gt;`</ph> element to define a configuration setting has application scope; that is, it affects only the application.</source>
          <target state="translated">사용 하는 <ph id="ph1">`&lt;AppContextSwitchOverrides&gt;`</ph> 구성 설정을 정의 하는 요소에는 응용 프로그램 범위 않으며 즉, 응용 프로그램만 적용 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>For information on the switches defined by the .NET Framework, see the <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>AppContextSwitchOverrides&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept>.</source>
          <target state="translated">.NET Framework에 정의 하는 스위치에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>AppContextSwitchOverrides &gt; 요소<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>By adding a string value whose name is the name of the switch to the <ph id="ph1">`HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext`</ph> key in the registry.</source>
          <target state="translated">스위치의 이름을 이름은 문자열 값을 추가 하 여에 <ph id="ph1">`HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext`</ph> 레지스트리에서 키입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Its value must be the string representation of a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> that can be parsed by the <ph id="ph2">&lt;xref:System.Boolean.Parse%2A?displayProperty=nameWithType&gt;</ph> method; that is, it must be "True", "true", "False", or "false".</source>
          <target state="translated">변수 값의 문자열 표현 이어야 합니다는 <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> 로 구문 분석할 수는 <ph id="ph2">&lt;xref:System.Boolean.Parse%2A?displayProperty=nameWithType&gt;</ph> 메서드, 즉 것 이어야 합니다 "True", "true", "False" 또는 "false"입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>If the runtime encounters any other value, it ignores the switch.</source>
          <target state="translated">런타임에 다른 값을 발견 하는 경우 스위치를 무시 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>Using the registry to define an <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> switch has machine scope; that is, it affects every application running on the machine.</source>
          <target state="translated">레지스트리를 사용 하 여 정의 하는 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 스위치 컴퓨터 범위에가; 컴퓨터에서 실행 하는 모든 응용 프로그램에 영향을 주므로, 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>If you set the same switch in more than one way, the order of precedence for determining which setting overrides the others is:</source>
          <target state="translated">여러 가지 방법에서 같은 스위치를 설정 하면 다른 어떤 설정은 재정의 확인 하기 위한 우선 순위는:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The programmatic setting.</source>
          <target state="translated">프로그래밍 방식으로 설정 합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The setting in the app config file.</source>
          <target state="translated">응용 프로그램 구성 파일의 설정입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The registry setting.</source>
          <target state="translated">레지스트리 설정입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>The following is a simple application that passes a file URI to the <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">다음은 파일 URI를 전달 하는 간단한 응용 프로그램에는 <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>When run under the .NET Framework 4.6, it throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> because <ph id="ph2">`file://`</ph> is no longer a valid part of a file path.</source>
          <target state="translated">.NET Framework 4.6에서 실행 되는 경우 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> 때문에 <ph id="ph2">`file://`</ph> 은 더 이상 올바른 파일 경로의 일부입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>To restore the method's previous behavior and prevent the exception, you can add the <ph id="ph1">`Switch.System.IO.UseLegacyPathHandling`</ph> switch to the application configuration file for the example:</source>
          <target state="translated">메서드의 이전 동작을 복원 하 고 예외를 방지 하려면 추가할 수 있습니다는 <ph id="ph1">`Switch.System.IO.UseLegacyPathHandling`</ph> 예제에 대 한 응용 프로그램 구성 파일에로 전환 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source>See also</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppContext">
          <source><bpt id="p1">[</bpt>AppContext switch<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>AppContext 스위치<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.AppContext.BaseDirectory">
          <source>Gets the pathname of the base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리의 경로 이름을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppContext.BaseDirectory">
          <source>the pathname of the base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리의 경로 이름입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppContext.BaseDirectory">
          <source>This is a per application domain property.</source>
          <target state="translated">이 한 응용 프로그램 도메인 속성 당 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppContext.BaseDirectory">
          <source>Its value corresponds to the <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A?displayProperty=nameWithType&gt;</ph> property of the current application domain.</source>
          <target state="translated">해당 값에 해당 하는 <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A?displayProperty=nameWithType&gt;</ph> 현재 응용 프로그램 도메인의 속성입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.AppContext.GetData(System.String)">
          <source>The name of the data element.</source>
          <target state="translated">데이터 요소의 이름입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.AppContext.GetData(System.String)">
          <source>Returns the value of the named data element assigned to the current application domain.</source>
          <target state="translated">현재 응용 프로그램 도메인에 할당되어 있는 명명된 데이터 요소의 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.AppContext.GetData(System.String)">
          <source>The value of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, if <ph id="ph2">&lt;paramref name="name" /&gt;</ph> identifies a named value; otherwise, <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph>이 명명된 값을 식별하는 경우 <ph id="ph1">&lt;paramref name="name" /&gt;</ph>의 값이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The name of the switch.</source>
          <target state="translated">스위치의 이름입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The value of the switch.</source>
          <target state="translated">스위치의 값입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>Sets the value of a switch.</source>
          <target state="translated">스위치의 값을 설정합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> class enables library writers to provide a uniform opt-out mechanism for new functionality for their users.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 클래스를 사용 하면 라이브러리 작성자가 사용자에 게 새로운 기능에 대 한 균일 한 옵트아웃 메커니즘을 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>It establishes a loosely-coupled contract between components in order to communicate an opt-out request.</source>
          <target state="translated">옵트아웃(opt out) 요청을 전달하기 위해 구성 요소 간에 느슨하게 결합된 계약을 설정합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>This capability is typically important when a change is made to existing functionality.</source>
          <target state="translated">이 기능은 일반적으로 기존 기능이 변경될 때 중요합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>Conversely, there is already an implicit opt-in for new functionality.</source>
          <target state="translated">반대로, 새로운 기능에 대한 암시적 옵트인(opt in)은 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> method is called by an application (or a library) to declare the value of a switch (which is always a <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> value) that a dependent library defines.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> 스위치의 값을 선언 하는 응용 프로그램 (또는 라이브러리) 메서드는 (항상는 <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> 값)은 종속 라이브러리가 정의 하는 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The switch is always implicitly <ph id="ph1">`false`</ph>, which provides the new behavior.</source>
          <target state="translated">스위치는 항상 암시적으로 <ph id="ph1">`false`</ph>, 새로운 동작을 제공 하는 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>Setting the switch to <ph id="ph1">`true`</ph> enables it, which provides the legacy behavior.</source>
          <target state="translated">스위치 설정 <ph id="ph1">`true`</ph> 레거시 동작을 제공 하 고 활성화 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>Explicitly setting the switch to <ph id="ph1">`false`</ph> also provides the new behavior.</source>
          <target state="translated">는 스위치를 명시적으로 설정 <ph id="ph1">`false`</ph> 또한 새로운 동작을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The dependent library can then check the value of the switch by calling the <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A&gt;</ph> method.</source>
          <target state="translated">종속 라이브러리를 호출 하 여 다음 스위치의 값을 확인할 수는 <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>It's beneficial to use a consistent format for switch names, since they are a formal contract exposed by a library.</source>
          <target state="translated">라이브러리에 의해 노출 되는 공식 계약 이므로 스위치 이름에 대 한 일관 된 형식을 사용 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The following are two obvious formats.</source>
          <target state="translated">다음은 두 가지 명확한 형식입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>namespace<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>namespace<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>library<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Switch<ept id="p1">*</ept>.<bpt id="p2">*</bpt>library<ept id="p2">*</ept>.<bpt id="p3">*</bpt>switchname<ept id="p3">*</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>In addition to setting the value of a switch programmatically, it can also be set:</source>
          <target state="translated">스위치의 값을 프로그래밍 방식으로 설정 외에 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>By adding the switch name and value to the <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>AppContextSwitchOverrides&gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> element in the <bpt id="p2">[</bpt><ph id="ph2">\&lt;</ph>runtime&gt;<ept id="p2">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> section of an application configuration file.</source>
          <target state="translated">스위치 이름 및 값을 추가 하 여는 <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>AppContextSwitchOverrides &gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)</ept> 요소에는 <bpt id="p2">[</bpt> <ph id="ph2">\&lt;</ph>런타임 &gt;<ept id="p2">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> 응용 프로그램 구성 파일의 섹션입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>For example, the following defines a switch named <ph id="ph1">`Libraries.FPLibrary.UseExactFloatingPointComparison`</ph> whose value is <ph id="ph2">`False`</ph>.</source>
          <target state="translated">예를 들어, 다음 정의 라는 스위치 <ph id="ph1">`Libraries.FPLibrary.UseExactFloatingPointComparison`</ph> 값인 <ph id="ph2">`False`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>By adding a string value whose name is the name of the switch to the <ph id="ph1">`HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext`</ph> key in the registry.</source>
          <target state="translated">스위치의 이름을 이름은 문자열 값을 추가 하 여에 <ph id="ph1">`HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext`</ph> 레지스트리에서 키입니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>Its value must be the string representation of a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> that can be parsed by the <ph id="ph2">&lt;xref:System.Boolean.Parse%2A?displayProperty=nameWithType&gt;</ph> method; that is, it must be "True", "true", "False", or "false".</source>
          <target state="translated">변수 값의 문자열 표현 이어야 합니다는 <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> 로 구문 분석할 수는 <ph id="ph2">&lt;xref:System.Boolean.Parse%2A?displayProperty=nameWithType&gt;</ph> 메서드, 즉 것 이어야 합니다 "True", "true", "False" 또는 "false"입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>If <ph id="ph1">`switchName`</ph> already exists, its value is overwritten by the <ph id="ph2">`isEnabled`</ph> argument.</source>
          <target state="translated">경우 <ph id="ph1">`switchName`</ph> 이미 있으면 해당 값을 덮어씁니다는 <ph id="ph2">`isEnabled`</ph> 인수입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>That is, the most recent call to the <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> method overrides the value defined in the registry, in an app configuration file, or by previous calls to the <ph id="ph2">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> method.</source>
          <target state="translated">즉, 가장 최근의에 대 한 호출에서 <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> 응용 프로그램 구성 파일에서 또는 이전 호출에서 레지스트리에 정의 된 값을 재정의 하는 메서드는 <ph id="ph2">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The following line of code sets a switch named <ph id="ph1">`Switch.AmazingLib.ThrowOnException`</ph> to <ph id="ph2">`true`</ph>, which enables a legacy behavior.</source>
          <target state="translated">라는 스위치를 설정 하는 코드의 다음 줄 <ph id="ph1">`Switch.AmazingLib.ThrowOnException`</ph> 를 <ph id="ph2">`true`</ph>, 레거시 동작 수 있습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source>The library can then check whether a library consumer has set the value of the switch by calling the <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A&gt;</ph> method.</source>
          <target state="translated">라이브러리는 라이브러리 소비자를 호출 하 여 스위치의 값 설정 않았는지 여부를 선택할 수는 <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="P:System.AppContext.TargetFrameworkName">
          <source>Gets the name of the framework version targeted by the current application.</source>
          <target state="translated">현재 응용 프로그램의 대상인 프레임워크 버전의 이름을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppContext.TargetFrameworkName">
          <source>The name of the framework version targeted by the current application.</source>
          <target state="translated">현재 응용 프로그램의 대상인 프레임워크 버전의 이름입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppContext.TargetFrameworkName">
          <source>The name of the target framework version corresponds to the value of the <ph id="ph1">&lt;xref:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">값에 해당 하는 대상 프레임 워크 버전 이름은 <ph id="ph1">&lt;xref:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName%2A?displayProperty=nameWithType&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppContext.TargetFrameworkName">
          <source>For a list of target framework names for the .NET Framework, see the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>supportedRuntime<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/startup/supportedruntime-element.md)</ept> element.</source>
          <target state="translated">.NET Framework에 대 한 대상 프레임 워크 이름 목록에 대 한 참조는 <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>supportedRuntime<ph id="ph2">&amp;gt;</ph> 요소<ept id="p1">](~/docs/framework/configure-apps/file-schema/startup/supportedruntime-element.md)</ept> 요소입니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>The name of the switch.</source>
          <target state="translated">스위치의 이름입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>When this method returns, contains the value of <bpt id="p1">&lt;c&gt;</bpt>switchName<ept id="p1">&lt;/c&gt;</ept> if <bpt id="p2">&lt;c&gt;</bpt>switchName<ept id="p2">&lt;/c&gt;</ept> was found, or <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <bpt id="p3">&lt;c&gt;</bpt>switchName<ept id="p3">&lt;/c&gt;</ept> was not found.</source>
          <target state="translated">이 메서드가 반환될 때 <bpt id="p2">&lt;c&gt;</bpt>switchName<ept id="p2">&lt;/c&gt;</ept>을 찾을 없을 경우 <bpt id="p1">&lt;c&gt;</bpt>switchName<ept id="p1">&lt;/c&gt;</ept>의 값, <bpt id="p3">&lt;c&gt;</bpt>switchName<ept id="p3">&lt;/c&gt;</ept>을 찾을 수 없을 없는 경우 <ph id="ph1">&lt;see langword="false" /&gt;</ph>를 포함합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>Tries to get the value of a switch.</source>
          <target state="translated">스위치의 값을 가져오려고 합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="switchName" /&gt;</ph> was set and the <ph id="ph3">&lt;paramref name="isEnabled" /&gt;</ph> argument contains the value of the switch; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="switchName" /&gt;</ph>이 설정되었으며 <ph id="ph3">&lt;paramref name="isEnabled" /&gt;</ph> 인수에 스위치의 값이 포함되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그러지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>The <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> class enables library writers to provide a uniform opt-out mechanism for new functionality for their users.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 클래스를 사용 하면 라이브러리 작성자가 사용자에 게 새로운 기능에 대 한 균일 한 옵트아웃 메커니즘을 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>It establishes a loosely-coupled contract between components in order to communicate an opt-out request.</source>
          <target state="translated">옵트아웃(opt out) 요청을 전달하기 위해 구성 요소 간에 느슨하게 결합된 계약을 설정합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>This capability is typically important when a change is made to existing functionality.</source>
          <target state="translated">이 기능은 일반적으로 기존 기능이 변경될 때 중요합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>Conversely, there is already an implicit opt-in for new functionality.</source>
          <target state="translated">반대로, 새로운 기능에 대한 암시적 옵트인(opt in)은 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>The common language runtime automatically populates the switches assigned to an <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> instance by reading the registry and the application's configuration file.</source>
          <target state="translated">에 할당 하는 스위치를 자동으로 채우려고 하는 공용 언어 런타임에서 <ph id="ph1">&lt;xref:System.AppContext&gt;</ph> 레지스트리 및 응용 프로그램의 구성 파일을 읽어 인스턴스.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>The value of these switches can then be overridden, and new switches added, by calling the <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> method.</source>
          <target state="translated">호출 하 여 새 스위치를 추가 하 고 이러한 스위치의 값을 재정의할 수 다음,는 <ph id="ph1">&lt;xref:System.AppContext.SetSwitch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>A library calls the <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A&gt;</ph> method to check whether its consumers have declared the value of the switch and then act appropriately on it.</source>
          <target state="translated">라이브러리를 호출 하는 <ph id="ph1">&lt;xref:System.AppContext.TryGetSwitch%2A&gt;</ph> 소비자 스위치의 값을 선언 해야 하 고에 적절 하 게 작동 하는지 여부를 확인 하는 메서드.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>By default, if the switch is not defined, the new functionality is enabled..</source>
          <target state="translated">스위치를 정의 하지 않은 경우에 기본적으로 새 기능 사용은...</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>If the switch is defined and its value is <ph id="ph1">`false`</ph>, the new functionality is also enabled.</source>
          <target state="translated">스위치 정의 되어 있고 해당 값이 있으면 <ph id="ph1">`false`</ph>, 새로운 기능에도 사용 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>If its value is <ph id="ph1">`true`</ph>, the legacy behavior is enabled.</source>
          <target state="translated">값이 <ph id="ph1">`true`</ph>, 레거시 동작을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source>The following example determines whether a library consumer has set a switch named <ph id="ph1">`Switch.AmazingLib.ThrowOnException`</ph>.</source>
          <target state="translated">다음 예제에서는 라이브러리 소비자가 라는 스위치를 설정 하는지 여부를 확인 <ph id="ph1">`Switch.AmazingLib.ThrowOnException`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="switchName" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>인 경우</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>