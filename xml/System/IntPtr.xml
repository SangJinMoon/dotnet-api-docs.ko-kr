<Type Name="IntPtr" FullName="System.IntPtr">
  <TypeSignature Language="C#" Value="public struct IntPtr : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit native int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.IntPtr" />
  <TypeSignature Language="VB.NET" Value="Public Structure IntPtr&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class IntPtr : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8084c-101">포인터나 핸들을 나타내는 데 사용되는 플랫폼별 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-101">A platform-specific type that is used to represent a pointer or a handle.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-102"><xref:System.IntPtr> 형식은 필요에 따라 크기가 플랫폼별으로 설정 하는 정수 디자인 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-102">The <xref:System.IntPtr> type is designed to be an integer whose size is platform-specific.</span></span> <span data-ttu-id="8084c-103">즉, 이러한 종류의 인스턴스가 32 비트 하드웨어 및 운영 체제에서 32 비트 및 64 비트 하드웨어 및 운영 체제 64 비트 될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-103">That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</span></span>  
  
 <span data-ttu-id="8084c-104"><xref:System.IntPtr> 형식에서 지 원하는 포인터, 언어 및 수행 하 고 포인터를 지원 하지 않는 언어 사이 데이터를 참조 하는 일반적인 방법으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-104">The <xref:System.IntPtr> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</span></span>  
  
 <span data-ttu-id="8084c-105"><xref:System.IntPtr> 핸들을 보관 하 개체를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-105"><xref:System.IntPtr> objects can also be used to hold handles.</span></span> <span data-ttu-id="8084c-106">예를 들어 인스턴스 <xref:System.IntPtr> 에서 광범위 하 게 사용 되는 <xref:System.IO.FileStream?displayProperty=nameWithType> 파일 핸들을 보관 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-106">For example, instances of <xref:System.IntPtr> are used extensively in the <xref:System.IO.FileStream?displayProperty=nameWithType> class to hold file handles.</span></span>  
  
 <span data-ttu-id="8084c-107"><xref:System.IntPtr> 형식이 CLS 규격이 동안는 <xref:System.UIntPtr> 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-107">The <xref:System.IntPtr> type is CLS-compliant, while the <xref:System.UIntPtr> type is not.</span></span> <span data-ttu-id="8084c-108">만 <xref:System.IntPtr> 에서 공용 언어 런타임 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-108">Only the <xref:System.IntPtr> type is used in the common language runtime.</span></span> <span data-ttu-id="8084c-109"><xref:System.UIntPtr> 형식이 구조적 대칭을 유지 하기 위해 주로 제공는 <xref:System.IntPtr> 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-109">The <xref:System.UIntPtr> type is provided mostly to maintain architectural symmetry with the <xref:System.IntPtr> type.</span></span>  
  
 <span data-ttu-id="8084c-110">이 형식이 구현 하는 <xref:System.Runtime.Serialization.ISerializable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-110">This type implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8084c-111">다음 예제에서는 관리 되는 포인터를 사용 하 여 배열에 문자를 되돌릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-111">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="8084c-112">초기화 한 후 한 <xref:System.String> 개체 및 해당 길이 가져옵니다는 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-112">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
1.  <span data-ttu-id="8084c-113">호출의 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> 메서드를 ANSI (1 바이트) 문자로 관리 되지 않는 메모리에 유니코드 문자열을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-113">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</span></span> <span data-ttu-id="8084c-114">메서드는 <xref:System.IntPtr> 관리 되지 않는 문자열의 시작 부분을 가리키는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-114">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span> <span data-ttu-id="8084c-115">Visual Basic 예제에서는이 포인터를 직접 사용 c + + 및 C# 예제에서 바이트에 대 한 포인터로 캐스팅 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-115">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
2.  <span data-ttu-id="8084c-116">호출의 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> 메서드를 관리 되지 않는 문자열을 차지 하는 대로 동일한 수의 바이트를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-116">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="8084c-117">메서드는 <xref:System.IntPtr> 관리 되지 않는 메모리 블록의 시작 부분을 가리키는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-117">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span> <span data-ttu-id="8084c-118">Visual Basic 예제에서는이 포인터를 직접 사용 c + + 및 C# 예제에서 바이트에 대 한 포인터로 캐스팅 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-118">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
3.  <span data-ttu-id="8084c-119">명명 된 변수를 정의 하는 Visual Basic 예제에서는 `offset` ANSI 문자열의 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-119">The Visual Basic example defines a variable named `offset` that is equal to the length of the ANSI string.</span></span> <span data-ttu-id="8084c-120">이 ANSI 문자열의 다음 기본 문서 복사 되는 관리 되지 않는 메모리에 오프셋을 결정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-120">It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</span></span> <span data-ttu-id="8084c-121">시작 값 문자열의 길이 이므로 복사 작업이 메모리 블록의 끝에 문자를 문자열의 시작 부분부터 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-121">Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</span></span>  
  
     <span data-ttu-id="8084c-122">C# 및 c + + 예제 호출은 <xref:System.IntPtr.ToPointer%2A> 문자열과 관리 되지 않는 메모리 블록의 시작 주소에 대 한 관리 되지 않는 포인터를 가져올 메서드를 하나 더 추가 하 고 ANSI 문자열의 시작 주소에 대 한 문자열의 길이 보다 작아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-122">The C# and C++ examples call the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="8084c-123">관리 되지 않는 문자열 포인터 이제를 가리키므로 문자열의 끝, 복사 작업은 메모리 블록의 시작 부분에 문자를 문자열의 끝에서 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-123">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
4.  <span data-ttu-id="8084c-124">루프를 사용 하 여 관리 되지 않는 메모리 블록을 문자열에서 각 문자를 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-124">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span>  
  
     <span data-ttu-id="8084c-125">Visual Basic 예제에서는 <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 ANSI 문자열로 관리 되는 포인터의 지정된 된 오프셋에서 바이트 (또는 1 바이트 문자)를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-125">The Visual Basic example calls the <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</span></span> <span data-ttu-id="8084c-126">오프셋은 루프가 반복 될 때마다 증가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-126">The offset is incremented with each iteration of the loop.</span></span> <span data-ttu-id="8084c-127">그런 다음 호출 하는 <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> 메모리와 관리 되지 않는 블록의 시작 주소에 정의 된 메모리 주소에 바이트를 쓰려고 메서드 `offset`합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-127">It then calls the <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus `offset`.</span></span> <span data-ttu-id="8084c-128">그런 다음 감소 `offset`합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-128">It then decrements `offset`.</span></span>  
  
     <span data-ttu-id="8084c-129">C# 및 c + + 예제 복사 작업을 수행한 다음 주소를 관리 되지 않는 ANSI 문자열의 다음 위치에 대 한 포인터를 감소 하 고 관리 되지 않는 블록에 다음 주소에 대 한 포인터를 하나씩 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-129">The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</span></span>  
  
5.  <span data-ttu-id="8084c-130">호출 하는 모든 예제는 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> 복사 된 ANSI 문자열을 관리 되는 유니코드를 포함 하는 관리 되지 않는 메모리 블록을 변환할 <xref:System.String> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-130">All examples call the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
6.  <span data-ttu-id="8084c-131">원래 및 역방향 문자열을 표시 한 후 모든 예제는 다음과 같이 호출 됩니다.는 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> 메서드는 관리 되지 않는 ANSI 문자열 및 관리 되지 않는 메모리 블록에 할당 한 메모리를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-131">After displaying the original and reversed strings, all examples call the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.intptr/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr/cs/topointer.cs#1)]
 [!code-vb[System.IntPtr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr/vb/topointer.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="8084c-132">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-132">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.UIntPtr" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8084c-133">
          <see cref="T:System.IntPtr" />의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-133">Initializes a new instance of <see cref="T:System.IntPtr" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-134">32비트의 부호 있는 정수에 들어 있는 포인터나 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-134">A pointer or handle contained in a 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8084c-135">지정된 64비트 포인터나 핸들을 사용하여 <see cref="T:System.IntPtr" />의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-135">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 32-bit pointer or handle.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-136">64비트의 부호 있는 정수에 들어 있는 포인터나 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-136">A pointer or handle contained in a 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8084c-137">지정된 64비트 포인터를 사용하여 <see cref="T:System.IntPtr" />의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-137">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 64-bit pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-138">만 예외가 발생 하는 경우의 값 `value` 현재 플랫폼에서 지 원하는 것 비트가 더 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-138">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8084c-139">32비트 플랫폼에서 <paramref name="value" />가 너무 크거나 너무 작아서 <see cref="T:System.IntPtr" />로 나타낼 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="8084c-139">On a 32-bit platform, <paramref name="value" /> is too large or too small to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Void*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(void* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-140">알 수 없는 형식의 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-140">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="8084c-141">알 수 없는 형식의 지정된 포인터를 사용하여 <see cref="T:System.IntPtr" />의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-141">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified pointer to an unspecified type.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8084c-142">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-142">requires full trust for the immediate caller.</span></span> <span data-ttu-id="8084c-143">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-143">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Void" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static IntPtr Add (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Add(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Add(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="8084c-144">오프셋을 더할 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-144">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="8084c-145">더할 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-145">The offset to add.</span></span></param>
        <summary><span data-ttu-id="8084c-146">포인터의 값에 오프셋을 더합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-146">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="8084c-147"><paramref name="offset" />에 <paramref name="pointer" /> 더하기를 반영하는 새 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-147">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-148"><xref:System.IntPtr.Add%2A> 메서드 결과 너무 커서 지정된 된 플랫폼에 대 한 포인터로 나타낼 수 없는 경우 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-148">The <xref:System.IntPtr.Add%2A> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="8084c-149">대신, 더하기 연산과 unchecked 컨텍스트에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-149">Instead, the addition operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="8084c-150">연산자 오버 로드 또는 사용자 지정 연산자를 지원 하지 않는 언어 포인터의 값에 오프셋을 추가 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-150">Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8084c-151">다음 예제는 <xref:System.IntPtr> 10 개 요소 배열의 시작 부분을 가리키는 한 다음 호출 하는 개체는 <xref:System.IntPtr.Add%2A> 배열의 요소를 반복 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="8084c-151">The following example instantiates an <xref:System.IntPtr> object that points to the beginning of a ten-element array, and then calls the <xref:System.IntPtr.Add%2A> method to iterate the elements in the array.</span></span>  
  
 [!code-csharp[System.IntPtr.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.add/cs/add1.cs#1)]
 [!code-vb[System.IntPtr.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="8084c-152">이 인스턴스와 비교할 개체 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-152">An object to compare with this instance or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8084c-153">이 인스턴스가 지정된 개체와 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-153">Returns a value indicating whether this instance is equal to a specified object.</span></span></summary>
        <returns>
          <span data-ttu-id="8084c-154"><see langword="true" />가 <paramref name="obj" />의 인스턴스이고 이 인스턴스의 값과 같으면 <see cref="T:System.IntPtr" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-154"><see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.IntPtr" /> and equals the value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8084c-155">이 인스턴스의 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-155">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="8084c-156">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-156">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static IntPtr operator + (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Addition(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator +(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="8084c-157">오프셋을 더할 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-157">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="8084c-158">더할 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-158">The offset to add.</span></span></param>
        <summary><span data-ttu-id="8084c-159">포인터의 값에 오프셋을 더합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-159">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="8084c-160"><paramref name="offset" />에 <paramref name="pointer" /> 더하기를 반영하는 새 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-160">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-161"><xref:System.IntPtr.op_Addition%2A> 메서드 정의 대해 더하기 연산을 <xref:System.IntPtr> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-161">The <xref:System.IntPtr.op_Addition%2A> method defines the addition operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="8084c-162">다음과 같은 코드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-162">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/addition1.cs#1)]
 [!code-vb[System.IntPtr.op_Addition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/addition1.vb#1)]  
  
 <span data-ttu-id="8084c-163">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.IntPtr.Add%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-163">Languages that do not support custom operators can call the <xref:System.IntPtr.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="8084c-164">더하기 연산 결과가 너무 커서 지정된 된 플랫폼에 대 한 포인터로 나타낼 수 없는 경우 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-164">The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="8084c-165">Unchecked 컨텍스트에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-165">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="8084c-166">이 연산자는 해당 하는 방법은 <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8084c-166">The equivalent method for this operator is <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="8084c-167">비교할 첫 번째 포인터 또는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-167">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="8084c-168">비교할 두 번째 포인터 또는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-168">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="8084c-169"><see cref="T:System.IntPtr" />의 지정된 두 인스턴스가 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-169">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="8084c-170"><paramref name="value1" />이 <paramref name="value2" />와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-170"><see langword="true" /> if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="8084c-171">이 연산자는 해당 하는 방법은 <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8084c-171">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8084c-172">지정한 데이터 형식을 <see cref="T:System.IntPtr" /> 값으로 변환하거나 <see cref="T:System.IntPtr" /> 값을 지정한 데이터 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-172">Converts a specified data type to an <see cref="T:System.IntPtr" /> value, or an <see cref="T:System.IntPtr" /> value to a specified data type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-173">32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-173">A 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8084c-174">32비트의 부호 있는 정수의 값을 <see cref="T:System.IntPtr" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-174">Converts the value of a 32-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="8084c-175"><paramref name="value" />로 초기화된 <see cref="T:System.IntPtr" />의 새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-175">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-176">64비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-176">A 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8084c-177">64비트의 부호 있는 정수의 값을 <see cref="T:System.IntPtr" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-177">Converts the value of a 64-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="8084c-178"><paramref name="value" />로 초기화된 <see cref="T:System.IntPtr" />의 새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-178">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8084c-179">32비트 플랫폼에서 <paramref name="value" />가 너무 커서 <see cref="T:System.IntPtr" />로 나타낼 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="8084c-179">On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-180">변환할 포인터 또는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-180">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="8084c-181">지정된 <see cref="T:System.IntPtr" />의 값을 32비트의 부호 있는 정수로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-181">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="8084c-182"><paramref name="value" />의 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-182">The contents of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-183">만 예외가 발생 하는 경우의 값 `value` 현재 플랫폼에서 지 원하는 것 비트가 더 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-183">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8084c-184">64비트 플랫폼에서 <paramref name="value" />의 값이 너무 커서 32비트의 부호 있는 정수로 나타낼 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="8084c-184">On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as a 32-bit signed integer.</span></span></exception>
        <altmember cref="M:System.IntPtr.ToInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-185">변환할 포인터 또는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-185">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="8084c-186">지정된 <see cref="T:System.IntPtr" />의 값을 64비트의 부호 있는 정수로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-186">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="8084c-187"><paramref name="value" />의 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-187">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator void* (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname void* op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator void*(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-188">변환할 포인터 또는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-188">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="8084c-189">지정된 <see cref="T:System.IntPtr" />의 값을 알 수 없는 형식의 포인터로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-189">Converts the value of the specified <see cref="T:System.IntPtr" /> to a pointer to an unspecified type.</span></span>  
  
 <span data-ttu-id="8084c-190">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-190">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="8084c-191"><paramref name="value" />의 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-191">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToPointer" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(void* value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8084c-192">알 수 없는 형식의 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-192">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="8084c-193">알 수 없는 형식의 지정된 포인터를 <see cref="T:System.IntPtr" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-193">Converts the specified pointer to an unspecified type to an <see cref="T:System.IntPtr" />.</span></span>  
  
 <span data-ttu-id="8084c-194">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-194">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="8084c-195"><paramref name="value" />로 초기화된 <see cref="T:System.IntPtr" />의 새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-195">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8084c-196">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-196">requires full trust for the immediate caller.</span></span> <span data-ttu-id="8084c-197">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-197">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="8084c-198">비교할 첫 번째 포인터 또는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-198">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="8084c-199">비교할 두 번째 포인터 또는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-199">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="8084c-200"><see cref="T:System.IntPtr" />의 지정된 두 인스턴스가 다른지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-200">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="8084c-201"><paramref name="value1" />이 <paramref name="value2" />와 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-201"><see langword="true" /> if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="8084c-202">이 연산자는 해당 하는 방법은 <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8084c-202">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static IntPtr operator - (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Subtraction(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator -(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="8084c-203">오프셋을 뺄 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-203">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="8084c-204">뺄 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-204">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="8084c-205">포인터의 값에서 오프셋을 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-205">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="8084c-206"><paramref name="offset" />에서 <paramref name="pointer" /> 빼기를 반영하는 새 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-206">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-207"><xref:System.IntPtr.op_Subtraction%2A> 메서드 정의 대해 빼기 연산을 <xref:System.IntPtr> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-207">The <xref:System.IntPtr.op_Subtraction%2A> method defines the subtraction operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="8084c-208">다음과 같은 코드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-208">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/op_subtraction1.cs#2)]
 [!code-vb[System.IntPtr.op_Addition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/op_subtraction1.vb#2)]  
  
 <span data-ttu-id="8084c-209">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.IntPtr.Subtract%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-209">Languages that do not support custom operators can call the <xref:System.IntPtr.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="8084c-210">빼기 연산 결과가 너무 작아서 지정된 된 플랫폼에 대 한 포인터로 나타낼 수 없는 경우 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-210">The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="8084c-211">Unchecked 컨텍스트에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-211">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="8084c-212">이 연산자는 해당 하는 방법은 <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8084c-212">The equivalent method for this operator is <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public static int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.IntPtr.Size" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8084c-213">이 인스턴스의 크기를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-213">Gets the size of this instance.</span></span></summary>
        <value><span data-ttu-id="8084c-214">이 프로세스에서 바이트로 측정된 포인터나 핸들의 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-214">The size of a pointer or handle in this process, measured in bytes.</span></span> <span data-ttu-id="8084c-215">이 속성의 값은 32비트 프로세스에서 4이고, 64비트 프로세스에서 8입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-215">The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</span></span> <span data-ttu-id="8084c-216">코드를 C# 및 Visual Basic 컴파일러로 컴파일할 때 <see langword="/platform" /> 스위치를 설정하여 프로세스 유형을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-216">You can define the process type by setting the <see langword="/platform" /> switch when you compile your code with the C# and Visual Basic compilers.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static IntPtr Subtract (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Subtract(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Subtract(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="8084c-217">오프셋을 뺄 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-217">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="8084c-218">뺄 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-218">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="8084c-219">포인터의 값에서 오프셋을 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-219">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="8084c-220"><paramref name="offset" />에서 <paramref name="pointer" /> 빼기를 반영하는 새 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-220">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-221"><xref:System.IntPtr.Subtract%2A> 메서드 결과 너무 작아서 지정된 된 플랫폼에 대 한 포인터로 나타낼 수 없는 경우 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-221">The <xref:System.IntPtr.Subtract%2A> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="8084c-222">대신, 빼기 연산은 unchecked 컨텍스트에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-222">Instead, the subtraction operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="8084c-223">연산자 오버 로드 또는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 포인터의 값에서 오프셋을 뺄이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-223">Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8084c-224">다음 예제는 <xref:System.IntPtr> 10 개 요소 배열의 끝을 가리키는 한 다음 호출 하는 개체는 <xref:System.IntPtr.Subtract%2A> 배열의 요소를 역순으로 반복 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="8084c-224">The following example instantiates an <xref:System.IntPtr> object that points to the end of a ten-element array, and then calls the <xref:System.IntPtr.Subtract%2A> method to iterate the elements in the array in reverse order.</span></span>  
  
 [!code-csharp[System.IntPtr.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.IntPtr.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.IntPtr&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;IntPtr&gt;.Equals (IntPtr other);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.IntPtr&gt;.Equals(native int other) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#IEquatable&lt;System#IntPtr&gt;#Equals(System.IntPtr)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As IntPtr) As Boolean Implements IEquatable(Of IntPtr).Equals" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.IntPtr&gt;.Equals(IntPtr other) = IEquatable&lt;IntPtr&gt;::Equals;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="8084c-225">데이터로 채울 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-225">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</span></span></param>
        <param name="context"><span data-ttu-id="8084c-226">이 serialization의 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-226">The destination for this serialization.</span></span> <span data-ttu-id="8084c-227">이 매개 변수는 사용되지 않으므로 <see langword="null" />을 지정하세요.</span><span class="sxs-lookup"><span data-stu-id="8084c-227">(This parameter is not used; specify <see langword="null" />.)</span></span></param>
        <summary><span data-ttu-id="8084c-228">현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 serialize하는 데 필요한 데이터로 <see cref="T:System.IntPtr" /> 개체를 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-228">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the current <see cref="T:System.IntPtr" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-229">이 메서드는 `info` 현재 값을 가진 매개 변수 <xref:System.IntPtr> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-229">This method populates the `info` parameter with the value of the current <xref:System.IntPtr> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8084c-230"><paramref name="info" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="8084c-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8084c-231">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-231">requires full trust for the immediate caller.</span></span> <span data-ttu-id="8084c-232">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-232">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public int ToInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ToInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ToInt32();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8084c-233">이 인스턴스의 값을 32비트의 부호 있는 정수로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-233">Converts the value of this instance to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="8084c-234">이 인스턴스의 값과 같은 32비트의 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-234">A 32-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8084c-235">64비트 플랫폼에서 이 인스턴스의 값이 너무 크거나 너무 작아서 32비트의 부호 있는 정수로 나타낼 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="8084c-235">On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public long ToInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToInt64();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8084c-236">이 인스턴스의 값을 64비트의 부호 있는 정수로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-236">Converts the value of this instance to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="8084c-237">이 인스턴스의 값과 같은 64비트의 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-237">A 64-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToPointer">
      <MemberSignature Language="C#" Value="public void* ToPointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void* ToPointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void* ToPointer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8084c-238">이 인스턴스의 값을 알 수 없는 형식의 포인터로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-238">Converts the value of this instance to a pointer to an unspecified type.</span></span></summary>
        <returns><span data-ttu-id="8084c-239"><see cref="T:System.Void" />의 포인터 즉, 알 수 없는 형식의 데이터가 들어 있는 메모리에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-239">A pointer to <see cref="T:System.Void" />; that is, a pointer to memory containing data of an unspecified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8084c-240">다음 예제에서는 관리 되는 포인터를 사용 하 여 배열에 문자를 되돌릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-240">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="8084c-241">초기화 한 후 한 <xref:System.String> 개체 및 해당 길이 가져옵니다는 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-241">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
-   <span data-ttu-id="8084c-242">호출 된 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> 메서드를 ANSI (1 바이트) 문자로 관리 되지 않는 메모리에 유니코드 문자열을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-242">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</span></span> <span data-ttu-id="8084c-243">메서드는 <xref:System.IntPtr> 관리 되지 않는 문자열의 시작 부분을 가리키는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-243">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span>  
  
-   <span data-ttu-id="8084c-244">호출의 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> 메서드를 관리 되지 않는 문자열을 차지 하는 대로 동일한 수의 바이트를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-244">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="8084c-245">메서드는 <xref:System.IntPtr> 관리 되지 않는 메모리 블록의 시작 부분을 가리키는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-245">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span>  
  
-   <span data-ttu-id="8084c-246">호출의 <xref:System.IntPtr.ToPointer%2A> 문자열과 관리 되지 않는 메모리 블록의 시작 주소에 대 한 관리 되지 않는 포인터를 가져올 메서드를 하나 추가 ANSI 문자열의 시작 주소에 대 한 문자열의 길이 보다 작아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-246">Calls the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="8084c-247">관리 되지 않는 문자열 포인터 이제를 가리키므로 문자열의 끝, 복사 작업은 메모리 블록의 시작 부분에 문자를 문자열의 끝에서 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-247">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
-   <span data-ttu-id="8084c-248">루프를 사용 하 여 관리 되지 않는 메모리 블록을 문자열에서 각 문자를 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-248">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span> <span data-ttu-id="8084c-249">각 복사 작업 후 것 감소 관리 되지 않는 ANSI 문자열에서 다음 위치의 주소에 대 한 포인터는 관리 되지 않는 블록에 다음 주소에 대 한 포인터를 증가 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-249">After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</span></span>  
  
-   <span data-ttu-id="8084c-250">호출 된 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> 복사 된 ANSI 문자열을 관리 되는 유니코드를 포함 하는 관리 되지 않는 메모리 블록을 변환할 <xref:System.String> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-250">Calls the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="8084c-251">원래 및 역방향 문자열을 표시 한 후 호출의 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> 메서드는 관리 되지 않는 ANSI 문자열 및 관리 되지 않는 메모리 블록에 할당 한 메모리를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-251">After displaying the original and reversed strings, calls the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr.ToPointer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr.ToPointer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cs/topointer.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8084c-252">현재 <see cref="T:System.IntPtr" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-252">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8084c-253">현재 <see cref="T:System.IntPtr" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-253">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="8084c-254">이 인스턴스 값의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-254">The string representation of the value of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-255">경우의 값은 <xref:System.IntPtr.Size%2A> 이 인스턴스에 대 한 속성은 4,이 메서드가 것과 동일 합니다 <xref:System.Int32.ToString%2A?displayProperty=nameWithType>, 그렇지 않으면이 메서드는 <xref:System.Int64.ToString%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-255">If the value of the <xref:System.IntPtr.Size%2A> property for this instance is 4, then this method is equivalent to <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; otherwise, this method is equivalent to <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="8084c-256">현재 <see cref="T:System.IntPtr" /> 개체를 변환하는 방법을 결정하는 형식 지정 사양입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-256">A format specification that governs how the current <see cref="T:System.IntPtr" /> object is converted.</span></span></param>
        <summary><span data-ttu-id="8084c-257">현재 <see cref="T:System.IntPtr" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-257">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="8084c-258">현재 <see cref="T:System.IntPtr" /> 개체 값의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-258">The string representation of the value of the current <see cref="T:System.IntPtr" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-259">경우는 `format` 매개 변수는 `null` 또는 빈 문자열 (""), 반환 값 ("G")는 일반 형식 지정자와 함께 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-259">If the `format` parameter is `null` or an empty string (""), the return value is formatted with the general format specifier ("G").</span></span> <span data-ttu-id="8084c-260">숫자 서식 지정자에 대 한 자세한 내용은 참조는 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-260">For more information about numeric format specifiers, see the [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) topic.</span></span>  
  
 <span data-ttu-id="8084c-261">고정 문화권을 사용 하 여 반환 값의 서식을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-261">The return value is formatted using the invariant culture.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly IntPtr Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int Zero" />
      <MemberSignature Language="DocId" Value="F:System.IntPtr.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly IntPtr Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8084c-262">0으로 초기화된 포인터나 핸들을 나타내는 읽기 전용 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-262">A read-only field that represents a pointer or handle that has been initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8084c-263">이 필드의 값이 동일 하지 않습니다 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-263">The value of this field is not equivalent to `null`.</span></span> <span data-ttu-id="8084c-264">이 필드를 사용 하 여 효율적으로 지 여부를 결정 인스턴스의 <xref:System.IntPtr> 0이 아닌 값으로 설정 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-264">Use this field to efficiently determine whether an instance of <xref:System.IntPtr> has been set to a value other than zero.</span></span>  
  
 <span data-ttu-id="8084c-265">예를 들어 변수 ip의 인스턴스가 <xref:System.IntPtr>합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-265">For example, assume the variable, ip, is an instance of <xref:System.IntPtr>.</span></span> <span data-ttu-id="8084c-266">예를 들어 한 생성자에 의해 반환 되는 값을 비교 하 여 설정 된 것을 확인할 수 있습니다: " `if ip != new IntPtr(0)...` "입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-266">You can determine if it has been set by comparing it to the value returned by a constructor, for example: " `if ip != new IntPtr(0)...` ".</span></span> <span data-ttu-id="8084c-267">그러나 초기화 포인터를 가져오기 위해 생성자를 호출 비효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-267">However, invoking a constructor to get an unintialized pointer is inefficient.</span></span> <span data-ttu-id="8084c-268">코딩 하는 것이 좋습니다 " `if ip != IntPtr.Zero...` ", 또는 " `if !IntPtr.Zero.Equals(ip)...` "입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-268">It is better to code either " `if ip != IntPtr.Zero...` ", or " `if !IntPtr.Zero.Equals(ip)...` ".</span></span>  
  
 <span data-ttu-id="8084c-269">관리 되는 코드에서 Windows API를 호출할 때 <xref:System.IntPtr.Zero?displayProperty=nameWithType> 대신 `null` 인수 한 포인터 이거나 되도록 예상 되는 경우 또는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-269">When calling the Windows API from managed code, you can pass <xref:System.IntPtr.Zero?displayProperty=nameWithType> instead of `null` if an argument is expected to be either a pointer or a `null`.</span></span> <span data-ttu-id="8084c-270">Windows에서 다음을 호출 하는 예를 들어 `CreateFile` 공급 장치 함수 <xref:System.IntPtr.Zero?displayProperty=nameWithType> 에 대 한는 `pSecurityAttributes` 및 `hTemplateFile` 인수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-270">For example, the following call to the Windows `CreateFile` function supplies <xref:System.IntPtr.Zero?displayProperty=nameWithType> for the `pSecurityAttributes` and `hTemplateFile` argument values.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero4.cs#2)]
 [!code-vb[System.IntPtr.Zero#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero4.vb#2)]  
  
> [!NOTE]
>  <span data-ttu-id="8084c-271">하지만 <xref:System.IntPtr.Zero> 같습니다 `null` 매개 변수 또는 반환 값 중 하나가 포인터 일 수 있는 Windows API 함수에 대 한 또는 `null`, <xref:System.IntPtr.Zero> 동일 하지 않습니다 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-271">Although <xref:System.IntPtr.Zero> is equivalent to `null` for Windows API functions with parameters or return values that can be either pointers or `null`, <xref:System.IntPtr.Zero> is not equivalent to `null`.</span></span> <span data-ttu-id="8084c-272">전달 `null` 에 `IntPtr.Zero.Equals` 메서드는 항상 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-272">Passing `null` to the `IntPtr.Zero.Equals` method always returns `false`.</span></span>  
  
 <span data-ttu-id="8084c-273">에 대 한 테스트할 수도 있습니다는 `null` 대 한 포인터를 반환 하는 Windows API 함수 호출에서 반환 값 또는 `null` 반환 된 값과 비교 하 여 <xref:System.IntPtr.Zero?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-273">You can also test for a `null` return value from Windows API function calls that return either a pointer or a `null` by comparing the returned value with <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8084c-274">예를 들어에 대 한 호출에서 `GetWindow` 없는 창 핸들을 검색 하려고 하면 다음 예제에서 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-274">For example, the call to the `GetWindow` function in the following example tries to retrieve the handle of a non-existent window.</span></span> <span data-ttu-id="8084c-275">경우에 관리 되지 않는 코드에서 호출 된, 함수는 반환 `null`, 하지만 관리 코드에서 호출 될 때 반환 <xref:System.IntPtr.Zero?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="8084c-275">If it were called from unmanaged code, the function would return `null`, but when it is called from managed code, it returns <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero2.cs#1)]
 [!code-vb[System.IntPtr.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>