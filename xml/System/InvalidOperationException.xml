<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="InvalidOperationException.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57eef3c78c550cc2f6c9c891703b21cfbe65f49ec.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7eef3c78c550cc2f6c9c891703b21cfbe65f49ec</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.InvalidOperationException">
          <source>The exception that is thrown when a method call is invalid for the object's current state.</source>
          <target state="translated">메서드 호출이 개체의 현재 상태에 대해 유효하지 않을 때 throw되는 예외입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is used in cases when the failure to invoke a method is caused by reasons other than invalid arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 메서드를 호출 오류는 잘못 된 인수 이외의 이유로 인해 발생 하는 경우에 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Typically, it is thrown when the state of an object cannot support the method call.</source>
          <target state="translated">일반적으로 개체의 상태가 메서드 호출을 지원할 수 없을 때 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>For example, an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception is thrown by methods such as:</source>
          <target state="translated">예를 들어 한 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 와 같은 메서드에서 throw 된 예외:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType&gt;</ph> if objects of a collection are modified after the enumerator is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType&gt;</ph> 개체 컬렉션 후 수정 되는 경우 열거자가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>For more information, see <bpt id="p1">[</bpt>Changing a collection while iterating it<ept id="p1">](#Iterating)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>것을 반복 하는 동안 컬렉션을 변경<ept id="p1">](#Iterating)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><ph id="ph1">&lt;xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType&gt;</ph> if the resource set is closed before the method call is made.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType&gt;</ph> 리소스 집합 하기 전에 닫혀 있으면 메서드 호출이 수행 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType&gt;</ph>, if the object or objects to be added would result in an incorrectly structured XML document.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType&gt;</ph>를 개체 또는 개체를 잘못 구조화 된 XML 문서에서 초래 하는 경우.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>A method that attempts to manipulate the UI from a thread that is not the main or UI thread.</source>
          <target state="translated">UI 아닌 주 스레드나 UI 스레드를 조작 하려고 하는 메서드.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Because the <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception can be thrown in a wide variety of circumstances, it is important to read the exception message returned by the <ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외를 throw 다양 한 상황을 것이 중요 하 여 반환 되는 예외 메시지를 읽을 수는 <ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In this section:</source>
          <target state="translated">섹션 내용</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Some common causes of InvalidOperationException exceptions<ept id="p1">](#Causes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>몇 가지 일반적인 원인은 InvalidOperationException 예외<ept id="p1">](#Causes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Updating a UI thread from a non-UI thread<ept id="p1">](#UI)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>UI가 아닌 스레드에서 UI 스레드를 업데이트합니다.<ept id="p1">](#UI)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Changing a collection while iterating it<ept id="p1">](#Iterating)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>이 반복 하는 동안 컬렉션을 변경<ept id="p1">](#Iterating)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Sorting an array or collection whose objects cannot be compared<ept id="p1">](#Sorting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>해당 개체를 비교할 수 없는 배열 또는 컬렉션 정렬<ept id="p1">](#Sorting)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Casting a Nullable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> that is null to its underlying type<ept id="p1">](#Nullable)</ept><ph id="ph3"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Nullable 캐스팅<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> 내부 형식으로 null이<ept id="p1">](#Nullable)</ept><ph id="ph3"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Calling a System.Linq.Enumerable method on an empty collection<ept id="p1">](#Empty)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>빈 컬렉션에 System.Linq.Enumerable 메서드가 호출<ept id="p1">](#Empty)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Calling Enumerable.Single or Enumerable.SingleOrDefault on a sequence without one element<ept id="p1">](#Single)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>하나의 요소가 없는 시퀀스에서 Enumerable.Single 또는 Enumerable.SingleOrDefault 호출<ept id="p1">](#Single)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Dynamic cross-application domain field access<ept id="p1">](#Emit)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>동적 응용 프로그램 간 도메인 필드 액세스<ept id="p1">](#Emit)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Throwing an InvalidOperationException exception<ept id="p1">](#Throwing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>InvalidOperationException 예외를 throw<ept id="p1">](#Throwing)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">[</bpt>Miscellaneous information<ept id="p1">](#Misc)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>기타 정보<ept id="p1">](#Misc)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Some common causes of InvalidOperationException exceptions</source>
          <target state="translated">몇 가지 일반적인 원인은 InvalidOperationException 예외</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following sections show how some common cases in which in <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception is thrown in an app.</source>
          <target state="translated">다음 섹션에는 몇 가지 일반적인 경우 하는 방법을 보여 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 응용 프로그램에 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>How you handle the issue depends on the specific situation.</source>
          <target state="translated">이 문제를 처리 하는 방법은 특정 상황에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Most commonly, however, the exception results from developer error, and the <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception can be anticipated and avoided.</source>
          <target state="translated">가장 일반적으로 이때 예외에서에서 결과 개발자 오류 및 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외를 예상 하 고 방지할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Updating a UI thread from a non-UI thread</source>
          <target state="translated">UI가 아닌 스레드에서 UI 스레드를 업데이트합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Often, worker threads are used to perform some background work that involves gathering data to be displayed in an application's user interface.</source>
          <target state="translated">종종 작업자 스레드는 응용 프로그램의 사용자 인터페이스에 표시 되는 데이터 수집 관련 된 일부 백그라운드 작업을 수행 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>However.</source>
          <target state="translated">그러나 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>most GUI (graphical user interface) application frameworks for the .NET Framework, such as Windows Forms and Windows Presentation Foundation (WPF),  let you access GUI objects only from the thread that creates and manages the UI (the Main or UI thread).</source>
          <target state="translated">Windows Forms 및 Windows Presentation Foundation (WPF)와 같은.NET Framework에 대 한 대부분 GUI (그래픽 사용자 인터페이스) 응용 프로그램 프레임 워크 수 있도록 스레드를 만들고 관리 UI (주 또는 UI 스레드) 에서만 GUI 개체에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown when you try to access a UI element from a thread other than the UI thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> UI 스레드가 아닌 스레드에서 UI 요소에 액세스 하려고 할 때 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The text of the exception message is shown in the following table.</source>
          <target state="translated">예외 메시지의 텍스트는 다음 표에 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Application Type</source>
          <target state="translated">응용 프로그램 종류</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Message</source>
          <target state="translated">메시지</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>WPF app</source>
          <target state="translated">WPF 응용 프로그램</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>The calling thread cannot access this object because a different thread owns it.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>호출 스레드가 소유 하는 다른 스레드가이 개체를 액세스할 수 없습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>UWP app</source>
          <target state="translated">UWP 앱</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>The application called an interface that was marshalled for a different thread.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>응용 프로그램이 다른 스레드를 위해 된 배열 된 인터페이스를 호출 합니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Windows Forms app</source>
          <target state="translated">Windows Forms 앱</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>Cross-thread operation not valid: Control 'TextBox1' accessed from a thread other than the thread it was created on.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>크로스 스레드 작업이 유효 하지 않습니다. 'TextBox1' 컨트롤이 액세스 자신이 만들어진 스레드가 아닌 스레드에서 합니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>UI frameworks for the .NET Framework implement a <bpt id="p1">*</bpt>dispatcher<ept id="p1">*</ept> pattern that includes a method to check whether a call to a member of a UI element is being executed on the UI thread, and other methods to schedule the call on the UI thread:</source>
          <target state="translated">.NET Framework에 대 한 UI 프레임 워크를 구현는 <bpt id="p1">*</bpt>발송자<ept id="p1">*</ept> UI 요소의 멤버에 대 한 호출이 UI 스레드에서 실행 되는지를 확인 하는 메서드와 UI 스레드에 대 한 호출을 예약 하는 기타 메서드가 포함 된 패턴:</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In WPF apps, call the <ph id="ph1">&lt;xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType&gt;</ph> method to determine if a method is running on a non-UI thread.</source>
          <target state="translated">WPF 앱에서는 호출는 <ph id="ph1">&lt;xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType&gt;</ph> 메서드를 UI가 아닌 스레드에서 메서드를 실행 중인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>It returns <ph id="ph1">`true`</ph> if the method is running on the UI thread and <ph id="ph2">`false`</ph> otherwise.</source>
          <target state="translated">반환 <ph id="ph1">`true`</ph> 메서드가 UI 스레드에서 실행 중인 경우와 <ph id="ph2">`false`</ph> 그렇지 않은 경우.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Call one of the overloads of the <ph id="ph1">&lt;xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType&gt;</ph> method to schedule the call on the UI thread.</source>
          <target state="translated">오버 로드 중 하나를 호출 하는 <ph id="ph1">&lt;xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType&gt;</ph> UI 스레드에서 호출을 예약 하는 메서드.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In UWP apps, call the <bpt id="p1">[</bpt>CoreDispatcher.HasThreadAccess<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx)</ept> method to determine if a method is running on a non-UI thread.</source>
          <target state="translated">UWP 앱에서 호출 된 <bpt id="p1">[</bpt>CoreDispatcher.HasThreadAccess<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx)</ept> UI가 아닌 스레드에서 메서드를 실행 하는 경우를 결정 하는 메서드.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Call the  <bpt id="p1">[</bpt>CoreDispatcher.RunAsync<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx)</ept> method to execute a delegate that updates the UI thread.</source>
          <target state="translated">호출 된 <bpt id="p1">[</bpt>CoreDispatcher.RunAsync<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx)</ept> 메서드를 UI 스레드를 업데이트 하는 대리자를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Use the</source>
          <target state="translated">명령줄에서</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In Windows Forms apps, use the <ph id="ph1">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType&gt;</ph> property to determine if a method is running on a non-UI thread.</source>
          <target state="translated">Windows Forms 앱에서 사용 하 여는 <ph id="ph1">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType&gt;</ph> 속성을 UI가 아닌 스레드에서 메서드를 실행 중인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Call one of the overloads of the <ph id="ph1">&lt;xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType&gt;</ph> method to execute a delegate that updates the UI thread.</source>
          <target state="translated">오버 로드 중 하나를 호출 하는 <ph id="ph1">&lt;xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType&gt;</ph> 메서드를 UI 스레드를 업데이트 하는 대리자를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following examples illustrate the <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception that is thrown when you attempt to update a UI element from a thread other than the thread that created it.</source>
          <target state="translated">다음 예제는 설명의 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 을 만든 스레드가 아닌 스레드에서 UI 요소를 업데이트 하려고 할 때 throw 되는 예외입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Each example requires that you create two controls:</source>
          <target state="translated">각 예제에서는 두 개의 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>A text box control named <ph id="ph1">`textBox1`</ph>.</source>
          <target state="translated">텍스트 상자 컨트롤 이라는 <ph id="ph1">`textBox1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In a Windows Forms app, you should set its <ph id="ph1">&lt;xref:System.Windows.Forms.TextBox.Multiline%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Windows Forms 응용 프로그램에서 설정 해야 해당 <ph id="ph1">&lt;xref:System.Windows.Forms.TextBox.Multiline%2A&gt;</ph> 속성을 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>A button  control named <ph id="ph1">`threadExampleBtn`</ph>.</source>
          <target state="translated">이라는 단추 컨트롤 <ph id="ph1">`threadExampleBtn`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The example provides a handler, <ph id="ph1">`ThreadsExampleBtn_Click`</ph>, for the button's <ph id="ph2">`Click`</ph> event.</source>
          <target state="translated">이 예제는 처리기를 제공 <ph id="ph1">`ThreadsExampleBtn_Click`</ph>, 단추에 대 한 <ph id="ph2">`Click`</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In each case, the <ph id="ph1">`threadExampleBtn_Click`</ph> event handler calls the <ph id="ph2">`DoSomeWork`</ph> method twice.</source>
          <target state="translated">각각의 경우에는 <ph id="ph1">`threadExampleBtn_Click`</ph> 이벤트 처리기 호출의 <ph id="ph2">`DoSomeWork`</ph> 메서드를 두 번입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The first call runs synchronously and succeeds.</source>
          <target state="translated">첫 번째 호출 동기적으로 실행 하 고 성공 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>But the second call, because it runs asynchronously on a thread pool thread, attempts to update the UI from a non-UI thread.</source>
          <target state="translated">하지만 UI가 아닌 스레드에서 UI 업데이트를 시도 스레드 풀 스레드에서 비동기적으로 실행 하기 때문에 두 번째 호출 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>This results in a <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception.</source>
          <target state="translated">이 인해는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>WPF and UWP apps</source>
          <target state="translated">WPF 및 UWP 앱</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following version of the <ph id="ph1">`DoSomeWork`</ph> method eliminates the exception in a WPF app.</source>
          <target state="translated">다음 버전의는 <ph id="ph1">`DoSomeWork`</ph> 메서드 WPF 응용 프로그램에서 예외를 제거 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following version of the <ph id="ph1">`DoSomeWork`</ph> method eliminates the exception in a UWP app.</source>
          <target state="translated">다음 버전의는 <ph id="ph1">`DoSomeWork`</ph> 메서드 UWP 앱에서 예외를 제거 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Windows Forms apps</source>
          <target state="translated">Windows Forms 앱</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following version of the <ph id="ph1">`DoSomeWork`</ph> method eliminates the exception in a Windows Forms app.</source>
          <target state="translated">다음 버전의는 <ph id="ph1">`DoSomeWork`</ph> 메서드는 Windows Forms 응용 프로그램에서 예외를 제거 합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Changing a collection while iterating it</source>
          <target state="translated">이 반복 하는 동안 컬렉션을 변경</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The <ph id="ph1">`foreach`</ph> statement in C# or <ph id="ph2">`For Each`</ph> statement in Visual Basic is used to iterate the members of a collection and to read or modify its individual elements.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> C# 문 또는 <ph id="ph2">`For Each`</ph> Visual Basic의 문을 사용 하 여 컬렉션의 멤버를 반복 읽기 또는 개별 요소를 수정 하 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>However, it can't be used to add or remove items from the collection.</source>
          <target state="translated">그러나 추가 하거나 컬렉션에서 항목을 제거 하려면 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Doing this throws an  <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception with a message that is similar to, "<bpt id="p1">**</bpt>Collection was modified; enumeration operation may not execute.<ept id="p1">**</ept>"</source>
          <target state="translated">이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> , 유사한 메시지와 함께 예외 "<bpt id="p1">**</bpt>컬렉션이 수정 되었습니다. 열거 작업이 실행 되지 않을 수 있습니다. <ept id="p1">**</ept>"</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example iterates a collection of integers attempts to add the square of each integer to the collection.</source>
          <target state="translated">다음 예제에서는 각 정수에 대 한 제곱 컬렉션에 추가 하려고 시도 정수 컬렉션을 반복 합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The example throws an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> with the first call to the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 throw 한 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 에 대 한 첫 번째 호출으로는 <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>You can eliminate the exception in one of two ways, depending on your application logic:</source>
          <target state="translated">응용 프로그램 논리에 따라 두 가지 방법 중 하나에서 예외를 해결할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If elements must be added to the collection while iterating it, you can iterate it by index using the <ph id="ph1">`for`</ph> statement instead of <ph id="ph2">`foreach`</ph> or <ph id="ph3">`For Each`</ph>.</source>
          <target state="translated">것을 반복 하는 동안 컬렉션에 요소를 추가 해야 하는 경우 인덱스를 사용 하 여 반복할 수 있습니다는 <ph id="ph1">`for`</ph> 문 대신 <ph id="ph2">`foreach`</ph> 또는 <ph id="ph3">`For Each`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example uses the for statement to add the square of numbers in the collection to the collection.</source>
          <target state="translated">다음 예제에서는 사용 된 숫자의 제곱을 컬렉션에 컬렉션에 추가 하는 문에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Note that you must establish the number of iterations before iterating the collection either by using a counter inside the loop that will exit the loop appropraitely, by iterating backward, from <ph id="ph1">`Count`</ph> - 1 to 0, or, as the example does, by assigning the number of elements in the array to a variable and using it to establish the upper bound of the loop.</source>
          <target state="translated">루프 appropraitely 뒤로 반복 하 여 종료 됩니다는 루프 내부의 카운터를 사용 하 여 컬렉션을 반복 하기 전에 반복 횟수를 설정 해야 하는 참고에서 <ph id="ph1">`Count`</ph> -0, 1 또는 수를 지정 하 여 예제를 수행 하는 대로 루프의 상한을 설정 하는 데 사용 하는 변수를 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Otherwise, if an element is added to the collection on every iteration, an endless loop results.</source>
          <target state="translated">그렇지 않은 경우 요소는 각 반복에 있는 컬렉션에 추가 되 면 무한 루프가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If it is not necessary to add elements to the collection while iterating it, you can store the elements to be added in a temporary collection that you add when iterating the collection has finished.</source>
          <target state="translated">것을 반복 하는 동안 컬렉션에 요소를 추가할 필요가 없는 경우에 임시 컬렉션에 추가 될 컬렉션을 반복 하 완료 되 면 추가 하는 요소를 저장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example uses this approach to add the square of numbers in a collection to a temporary collection, and then to combine the collections into a single array object.</source>
          <target state="translated">다음 예제에서는이 방법을 사용 하 여 숫자의 제곱 임시 컬렉션을 컬렉션에 추가 한 후 컬렉션을 단일 배열 개체로 결합 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Sorting an array or collection whose objects cannot be compared</source>
          <target state="translated">해당 개체를 비교할 수 없는 배열 또는 컬렉션 정렬</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>General-purpose sorting methods, such as the <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType&gt;</ph> method, usually require that at least one of the objects to be sorted implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> or the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">와 같은 정렬 메서드의 범용는 <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> 메서드 또는 <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType&gt;</ph> 메서드를 일반적으로 필요 적어도 하나의 정렬할 개체의 구현는 <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> 또는 <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If not, the collection or array cannot be sorted, and the method throws an  <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception.</source>
          <target state="translated">컬렉션이 나 배열의 정렬할 수 없으므로 메서드에서 throw 하지,는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class, stores two <ph id="ph2">`Person`</ph> objects in a generic <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object, and attempts to sort them.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`Person`</ph> 두 저장소 클래스 <ph id="ph2">`Person`</ph> 을 일반적인 개체 <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> 개체 및 시도를 정렬 합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>As the output from the example shows, the call to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">예제에 대 한 호출에서 출력으로의 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>You can eliminate the exception in any of three ways:</source>
          <target state="translated">다음 세 가지 방법 중 하나에서 예외를 해결할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If you can own the type that you are trying to sort (that is, if you control its source code), you can modify it to implement the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> or the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">(즉, 제어 하는 경우 해당 소스 코드)를 정렬 하려고 하는 형식을 소유할 수를 구현 하도록를 수정할 수 있습니다는 <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>This requires that you implement either the <ph id="ph1">&lt;xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType&gt;</ph> or the <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> method.</source>
          <target state="translated">중 하나를 구현 하는이 위해서는 <ph id="ph1">&lt;xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Adding an interface implementation to an existing type is not a breaking change.</source>
          <target state="translated">기존 형식에는 인터페이스 구현 추가 주요 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example uses this approach to provide an <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation  for the <ph id="ph2">`Person`</ph> class.</source>
          <target state="translated">다음 예제에서는이 방법을 사용 하 여 제공 된 <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> 에 대 한 구현을 <ph id="ph2">`Person`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>You can still call the collection or array's general sorting method and, as the output from the example shows, the collection sorts successfully.</source>
          <target state="translated">컬렉션이 나 배열의 일반 정렬 메서드를 호출할 수 하 고 컬렉션 성공적으로 정렬 예제의 출력에서 볼 수 있듯이 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If you cannot modify the source code for the type you are trying to sort, you can define a special-purpose sorting class that implements the <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> interface.</source>
          <target state="translated">정렬 하려는 형식에 대 한 소스 코드를 수정할 수 없는 경우 구현 하는 특수 한 용도의 정렬 클래스를 정의할 수 있습니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>You can call an overload of the <ph id="ph1">`Sort`</ph> method that includes an  <ph id="ph2">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> parameter.</source>
          <target state="translated">오버 로드를 호출할 수는 <ph id="ph1">`Sort`</ph> 메서드를 포함 하는 <ph id="ph2">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>This approach is especially useful if you want to develop a specialized sorting class that can sort objects based on multiple criteria.</source>
          <target state="translated">이 방법은 여러 조건을 기준으로 개체를 정렬할 수 있는 특수 한 정렬 클래스를 개발 하려는 경우에 특히 유용 합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example uses the approach by developing a custom <ph id="ph1">`PersonComparer`</ph> class that is used to sort <ph id="ph2">`Person`</ph> collections.</source>
          <target state="translated">다음 예제는 방식을 사용자 지정을 개발 하 여 사용 하 여 <ph id="ph1">`PersonComparer`</ph> 정렬 하는 데 사용 되는 클래스 <ph id="ph2">`Person`</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>It then passes an instance of this class to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">그런 다음이 클래스의 인스턴스를 전달 된 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If you cannot modify the source code for the type you are trying to sort, you can create a  <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> delegate to perform the sorting.</source>
          <target state="translated">정렬 하려고 하는 형식에 대 한 소스 코드를 수정할 수 없는 경우, 만들 수 있습니다는 <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> 정렬을 수행할 대리자입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The delegate signature is</source>
          <target state="translated">대리자 시그니처는</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example uses the approach by defining a  <ph id="ph1">`PersonComparison`</ph> method that matches the  <ph id="ph2">&lt;xref:System.Comparison%601&gt;</ph> delegate signature.</source>
          <target state="translated">다음 예제는 방식을 정의 하 여 사용 하 여 한 <ph id="ph1">`PersonComparison`</ph> 일치 하는 메서드는 <ph id="ph2">&lt;xref:System.Comparison%601&gt;</ph> 대리자 서명입니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>It then passes this delegate to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">그런 다음이 대리자에 전달 된 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Casting a Nullable<ph id="ph1">\&lt;</ph>T&gt; that is null to its underlying type</source>
          <target state="translated">Nullable 캐스팅<ph id="ph1">\&lt;</ph>T &gt;를 기본 형식에 null이</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Attempting to cast a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> value that is <ph id="ph2">`null`</ph> to its underlying type throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph> exception  and displays the error message, "<bpt id="p1">**</bpt>Nullable object must have a value.<ept id="p1">**</ept></source>
          <target state="translated">캐스팅 하려고 한 <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> 값이 <ph id="ph2">`null`</ph> 를 기본 형식 발생는 <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph> 예외 오류 메시지를 표시 하 고 "<bpt id="p1">**</bpt>null 허용 개체 값을 가져야 합니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example throws an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception  when it attempts to iterate an array that includes a <ph id="ph2">`Nullable(Of Integer)`</ph> value.</source>
          <target state="translated">다음 예제에서는 throw 한 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 포함 하는 배열을 반복 하려고 할 때 예외는 <ph id="ph2">`Nullable(Of Integer)`</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>To prevent the exception:</source>
          <target state="translated">방지 하려면 예외:</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Use the <ph id="ph1">&lt;xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType&gt;</ph> property to select only those elements that are not <ph id="ph2">`null`</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType&gt;</ph> 속성을 선택 하지 않은 요소에만 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Call one of the <ph id="ph1">&lt;xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType&gt;</ph> overloads to provide a default value for a <ph id="ph2">`null`</ph> value.</source>
          <target state="translated">하나를 호출 하는 <ph id="ph1">&lt;xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType&gt;</ph> 에 대 한 기본값을 제공 하기 위한 오버 로드는 <ph id="ph2">`null`</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example does both to avoid the  <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception.</source>
          <target state="translated">다음 예제에서는 필요가 없으며는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Calling a System.Linq.Enumerable method on an empty collection</source>
          <target state="translated">빈 컬렉션에 System.Linq.Enumerable 메서드가 호출</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType&gt;</ph>,  <ph id="ph7">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph8">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> methods perform operations on a sequence and return a single result.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph7">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph>, 및 <ph id="ph8">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드 시퀀스에 대 한 작업을 수행 하 고 단일 결과 반환 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Some overloads of these methods throw an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception when the sequence is empty, while other overloads return <ph id="ph2">`null`</ph>.</source>
          <target state="translated">이러한 메서드의 일부 오버 로드를 throw 한 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 시퀀스가 비어 다른 오버 로드를 반환 하는 동안 때 예외 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> method also throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> exception when the sequence contains more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드도 throw는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> 시퀀스에 요소가 둘 이상 포함 하는 동안 예외가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Most of the methods that throw an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception are overloads.</source>
          <target state="translated">throw 하는 메서드의 대부분는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외는 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Be sure that you understand the behavior of the overload that you choose.</source>
          <target state="translated">선택 하는 오버 로드의 동작을 이해 해야 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following table lists the exception messages from the <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception objects thrown by calls to some <ph id="ph2">&lt;xref:System.Linq.Enumerable?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">다음 표에서에서 예외 메시지는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 일부에 대 한 호출에서 throw 된 예외 개체 <ph id="ph2">&lt;xref:System.Linq.Enumerable?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Method</source>
          <target state="translated">메서드</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Message</source>
          <target state="translated">메시지</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>Sequence contains no elements<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>시퀀스에 요소가 없습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>Sequence contains no matching element<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>시퀀스에 일치 하는 요소가 없습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>Sequence contains more than one matching element<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>시퀀스에 둘 이상의 일치 하는 요소<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>How you eliminate or handle the exception depends on your application's assumptions and on the particular method you call.</source>
          <target state="translated">없애거나 예외를 처리 하 고 호출 하는 특정 방법에 응용 프로그램의 가정에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>When you deliberately call one of these methods without checking for an empty sequence, you are assuming that the sequence is not empty, and that an empty sequence is an unexpected occurrence.</source>
          <target state="translated">의도 한 대로 호출할 때 다음이 방법 중 하나는 빈 시퀀스를 검사 하지 않는 경우에 시퀀스가 비어 있지 않으면 이며 빈 시퀀스는 원치 않는 항목입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In this case, catching or rethrowing the exception is appropriate .</source>
          <target state="translated">이 경우는 예외를 다시 throw 또는 catch 할 적절 한입니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If your failure to check for an empty sequence was inadvertent, you can  call one of the overloads of the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType&gt;</ph> overload to determine whether a sequence contains any elements.</source>
          <target state="translated">빈 시퀀스를 확인 하려면 실패를 의도 하지 않은 경우의 오버 로드 중 하나를 호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType&gt;</ph> 오버 로드를 시퀀스에 요소가 하나라도 포함 되어 있는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Calling the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType&gt;</ph> method before generating a sequence can improve performance if the data to be processed might contain a large number of elements or if operation that generates the sequence is expensive.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType&gt;</ph> 많은 수의 요소 또는 시퀀스를 생성 하는 작업은 비용이 많이 드는 경우 포함 된 데이터를 처리할 경우 메서드는 시퀀스를 생성 하기 전에 성능을 향상 시킬 수 있습니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If you've called a method such as <ph id="ph1">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph>, you can substitute an alternate method, such as <ph id="ph4">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType&gt;</ph>, or  <ph id="ph6">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph>, that returns a default value instead of a member of the sequence.</source>
          <target state="translated">와 같은 메서드를 호출 하는 경우 <ph id="ph1">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType&gt;</ph>, 또는 <ph id="ph3">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph>와 같은 다른 방법을 대신 사용할 수 있습니다 <ph id="ph4">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType&gt;</ph>, 또는 <ph id="ph6">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph>, 시퀀스의 구성원이 아닌 기본 값을 반환 하 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The examples provide additional detail.</source>
          <target state="translated">예에서는 추가 세부 정보를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType&gt;</ph> method to compute the average of a sequence whose values are greater than 4.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType&gt;</ph> 메서드는 4 보다 큰 값을 포함 하는 시퀀스의 평균을 계산 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Since no values from the original array exceed 4, no values are included in the sequence, and the method throws an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception.</source>
          <target state="translated">원래 배열에서 값이 없는 초과 4 하 고 값이 없는 시퀀스에 포함 된 메서드에서 throw 된 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The exception can be eliminated by calling the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%2A&gt;</ph> method to determine whether the sequence contains any elements before calling the method that processes the sequence, as the following example shows.</source>
          <target state="translated">예외를 호출 하 여 제거할 수 있습니다는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%2A&gt;</ph> 메서드를 다음 예제와 같이 순서를 처리 하는 메서드를 호출 하기 전에 시퀀스에 요소가 하나라도 있는지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph> method returns the first item in a sequence or the first element in a sequence that satisfies a specified condition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph> 메서드는 시퀀스 또는 지정된 된 조건을 만족 하는 시퀀스의 첫 번째 요소에서 첫 번째 항목을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If the sequence is empty and therefore does not have a first element, it throws an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception.</source>
          <target state="translated">시퀀스가 비어 있고 따라서 없는 첫 번째 요소를 throw 한 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> exception because the dbQueryResults array doesn't contain an element greater than 4.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> 예외 있으므로 dbQueryResults 배열에 4 보다 큰 요소가 포함 되어 있지 않습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>You can call the <ph id="ph1">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph> to return a specified or default value.</source>
          <target state="translated">호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드 대신 <ph id="ph2">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph> 지정 된 반환 값 이나 기본값을 합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If the method does not find a first element in the sequence, it returns  the default value for that data type.</source>
          <target state="translated">메서드는 시퀀스의 첫 번째 요소를 찾지 못하면 해당 데이터 형식에 대 한 기본 값을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The default value is <ph id="ph1">`null`</ph> for a reference type, zero for a numeric data type, and <ph id="ph2">&lt;xref:System.DateTime.MinValue?displayProperty=nameWithType&gt;</ph> for the <ph id="ph3">&lt;xref:System.DateTime&gt;</ph> type.</source>
          <target state="translated">기본값은 <ph id="ph1">`null`</ph> 참조 형식에 대 한 숫자 데이터 형식에 대 한 0 및 <ph id="ph2">&lt;xref:System.DateTime.MinValue?displayProperty=nameWithType&gt;</ph> 에 대 한는 <ph id="ph3">&lt;xref:System.DateTime&gt;</ph> 유형입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Interpreting the value returned by the <ph id="ph1">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType&gt;</ph> method is often complicated by the fact that the default value of the type can be a valid value in the sequence.</source>
          <target state="translated">반환 된 값을 해석는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드는 종종 있기 때문에 복잡해졌습니다 형식의 기본 값 시퀀스의 유효한 값을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In this case, you an call the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the sequence has valid members before calling the <ph id="ph2">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">이 경우는 호출 하는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType&gt;</ph> 시퀀스 호출 하기 전에 유효한 구성원에 있는지 여부를 확인 하는 <ph id="ph2">&lt;xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example calls the  <ph id="ph1">&lt;xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType&gt;</ph> method to prevent the <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> exception thrown in the previous example.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType&gt;</ph> 방지 하기 위해는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> 앞의 예제에서 throw 된 예외입니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Calling Enumerable.Single or Enumerable.SingleOrDefault on a sequence without one element</source>
          <target state="translated">하나의 요소가 없는 시퀀스에서 Enumerable.Single 또는 Enumerable.SingleOrDefault 호출</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> method returns the only element of a sequence, or the only element of a sequence that meets a specified condition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> 메서드는 시퀀스의 유일한 요소 또는 지정된 된 조건을 충족 하는 시퀀스의 유일한 요소를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If there are no elements in the sequence, or if there is more than one element , the method throws an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception.</source>
          <target state="translated">시퀀스에 요소가 있는 경우 또는 둘 이상의 요소가 없는 경우 메서드에서 throw 된 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>You can use the <ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> method to return a default value instead of throwing an exception when the sequence contains no elements.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드를 시퀀스에 요소가 없을 때 예외를 throw 하는 대신 기본값을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>However, the <ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> method still throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> exception  when the sequence contains more than one element.</source>
          <target state="translated">그러나는 <ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드를 여전히 throw는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> 시퀀스에 요소가 둘 이상 포함 하는 동안 예외가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following table lists the exception messages from the <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception objects thrown by calls to the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">다음 표에서에서 예외 메시지는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 호출에 의해 throw 되는 예외 개체는 <ph id="ph2">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Method</source>
          <target state="translated">메서드</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Message</source>
          <target state="translated">메시지</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>Sequence contains no matching element<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>시퀀스에 일치 하는 요소가 없습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><bpt id="p1">**</bpt>Sequence contains more than one matching element<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>시퀀스에 둘 이상의 일치 하는 요소<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>In the following example, the call to the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> exception because the sequence doesn't have an element greater than 4.</source>
          <target state="translated">다음 예제에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> 예외 4 보다 큰 요소가 없으므로 시퀀스입니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The following example attempts to prevent the <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception thrown when a sequence is empty by instead calling the <ph id="ph2">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">방지 하기 위해 다음 예제에서는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 대신 호출 하 여 시퀀스 비어 있을 때 throw 된 예외는 <ph id="ph2">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>However, because this sequence returns multiple elements whose value is greater than 2, it also throws an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception.</source>
          <target state="translated">그러나이 순서 값 2 보다 크면 여러 요소를 반환 하므로 throw 한 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Calling the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> method assumes that either a sequence or the sequence that meets specified criteria contains only one element.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType&gt;</ph> 메서드는 시퀀스 또는 순서 지정 된 조건을 만족 하는 요소가 하나만 포함 되어 있다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> assumes a sequence with zero or one result, but no more.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType&gt;</ph> 0 개 또는 한 결과 하지만 더 이상 포함 하는 순서를 가정합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If this assumption is a deliberate one on your part and these conditions are not met, rethrowing or catching the resulting <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is appropriate.</source>
          <target state="translated">이 가정은 의도적으로 사용자의 이러한 조건이 충족 되지 않는 경우 다시 throw 또는 결과 빠른 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 적합 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Otherwise, or if you expect that invalid conditions will occur with some frequency, you should consider using some other <ph id="ph1">&lt;xref:System.Linq.Enumerable&gt;</ph> method, such as <ph id="ph2">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph>.</source>
          <target state="translated">그렇지 않으면 다른 사용을 고려해 야 무효 상황이 일정 빈도로 발생할 수 있는 예상 되는 경우 또는 <ph id="ph1">&lt;xref:System.Linq.Enumerable&gt;</ph> 메서드를 같은 <ph id="ph2">&lt;xref:System.Linq.Enumerable.FirstOrDefault%2A&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Dynamic cross-application domain field access</source>
          <target state="translated">동적 응용 프로그램 간 도메인 필드 액세스</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType&gt;</ph> Microsoft intermediate language (MSIL) instruction throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> exception if the object containing the field whose address you are trying to retrieve is not within the application domain in which your code is executing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType&gt;</ph> MSIL (intermediate language) 명령 throw Microsoft는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> 예외 코드 실행 되는 응용 프로그램 도메인 내에 없으면 해당 주소는 검색 하려는 필드를 포함 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>The address of a field can only be accessed from the application domain in which it resides.</source>
          <target state="translated">필드의 주소 수만 존재 하는 응용 프로그램 도메인에서 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Throwing an InvalidOperationException exception</source>
          <target state="translated">InvalidOperationException 예외를 throw</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>You should throw an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> exception only when the state of your object for some reason does not support a particular method call.</source>
          <target state="translated">throw 해야는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 몇 가지 이유로 프로그램 개체의 상태는 특정 메서드 호출을 지원 하지 않을 때에 예외입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>That is, the method call is valid in some circumstances or contexts, but is invalid in others.</source>
          <target state="translated">즉, 메서드 호출에 몇 가지 상황 또는 컨텍스트를 올바르지만 다른에서 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>If the method invocation failure is due to invalid arguments, then <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> or one of its derived classes, <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> or <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>, should be thrown instead.</source>
          <target state="translated">다음 메서드 호출이 오류 인수가 잘못 되어이 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> 또는 해당 파생된 클래스 중 하나 <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>, 대신 발생 합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>Miscellaneous information</source>
          <target state="translated">기타 정보</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> uses the HRESULT COR_E_INVALIDOPERATION, which has the value 0x80131509.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 0x80131509 값이 있는 HRESULT COR_E_INVALIDOPERATION를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.InvalidOperationException">
          <source>For a list of initial property values for an instance of <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>, see the <ph id="ph2">&lt;xref:System.InvalidOperationException.%23ctor%2A&gt;</ph> constructors.</source>
          <target state="translated">인스턴스에 대 한 초기 속성 값 목록은 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>, 참조는 <ph id="ph2">&lt;xref:System.InvalidOperationException.%23ctor%2A&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="T:System.InvalidOperationException">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance to a system-supplied message that describes the error, such as "The requested operation cannot be performed."</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> "요청한 작업을 수행할 수 없습니다."와 같은 오류를 설명 하는 시스템 제공 메시지로 새 인스턴스의 속성</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor">
          <source>This message takes into account the current system culture.</source>
          <target state="translated">이 메시지는 현재 시스템 문화권을 고려합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">다음 표에서는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 인스턴스의 초기 속성 값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">null 참조(Visual Basic의 경우 <ph id="ph1">`Nothing`</ph>)</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor">
          <source>The localized error message string.</source>
          <target state="translated">지역화된 오류 메시지 문자열입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>The message that describes the error.</source>
          <target state="translated">@FSHO2@오류를 설명하는 메시지입니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> class with a specified error message.</source>
          <target state="translated">지정된 오류 메시지를 사용하여 <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A?displayProperty=nameWithType&gt;</ph> property of the new exception using the <ph id="ph2">`message`</ph> parameter.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Exception.Message%2A?displayProperty=nameWithType&gt;</ph> 속성을 사용 하 여 새 예외는 <ph id="ph2">`message`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>The content of <ph id="ph1">`message`</ph> is intended to be understood by humans.</source>
          <target state="translated"><ph id="ph1">`message`</ph>의 내용은 사용자의 이해를 돕기 위한 것입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>The caller of this constructor is required to ensure that this string has been localized for the current system culture.</source>
          <target state="translated">이 생성자의 호출자는 이 문자열이 현재 시스템 문화권에 맞게 지역화되었는지 확인하는 데 필요합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">다음 표에서는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 인스턴스의 초기 속성 값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">null 참조(Visual Basic의 경우 <ph id="ph1">`Nothing`</ph>)</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String)">
          <source>The error message string.</source>
          <target state="translated">오류 메시지 문자열</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that holds the serialized object data.</source>
          <target state="translated">serialize된 개체 데이터를 보유하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The contextual information about the source or destination.</source>
          <target state="translated">원본 또는 대상에 대한 컨텍스트 정보입니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> class with serialized data.</source>
          <target state="translated">serialize된 데이터를 사용하여 <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</source>
          <target state="translated">이 생성자는 deserialization을 수행하는 동안 호출되어 스트림을 통해 전송된 예외 개체를 다시 구성합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>XML 및 SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>The error message that explains the reason for the exception.</source>
          <target state="translated">@FSHO2@예외 이유를 설명하는 오류 메시지입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>The exception that is the cause of the current exception.</source>
          <target state="translated">현재 예외의 원인인 예외입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>innerException<ept id="p1">&lt;/c&gt;</ept> parameter is not a null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), the current exception is raised in a <ph id="ph2">&lt;see langword="catch" /&gt;</ph> block that handles the inner exception.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>innerException<ept id="p1">&lt;/c&gt;</ept> 매개 변수가 null 참조(Visual Basic에서는 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)가 아니면, 현재 예외는 내부 예외를 처리하는 <ph id="ph2">&lt;see langword="catch" /&gt;</ph> 블록에서 발생한 것입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> class with a specified error message and a reference to the inner exception that is the cause of this exception.</source>
          <target state="translated">지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property.</source>
          <target state="translated">이전 예외의 직접적인 결과로 throw되는 예외의 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성에는 이전 예외에 대한 참조가 들어 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property returns the same value that is passed into the constructor, or a null reference (<ph id="ph2">`Nothing`</ph> in Visual Basic) if the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property does not supply the inner exception value to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성은 생성자에 전달된 값과 같은 값을 반환하거나 <ph id="ph2">`Nothing`</ph> 속성이 생성자에 내부 예외 값을 제공하지 않는 경우에는 null 참조(Visual Basic의 경우 <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">다음 표에서는 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> 인스턴스의 초기 속성 값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>The inner exception reference.</source>
          <target state="translated">내부 예외 참조</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.InvalidOperationException.#ctor(System.String,System.Exception)">
          <source>The error message string.</source>
          <target state="translated">오류 메시지 문자열</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>