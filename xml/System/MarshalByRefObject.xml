<Type Name="MarshalByRefObject" FullName="System.MarshalByRefObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="581d775aac81241d975e88cf7c586e38dbe64827" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36430085" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MarshalByRefObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarshalByRefObject abstract" />
  <TypeSignature Language="F#" Value="type MarshalByRefObject = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="aac60-101">원격 통신을 지원하는 응용 프로그램에서 응용 프로그램 도메인 경계를 넘어 개체에 액세스할 수 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="aac60-101">Enables access to objects across application domain boundaries in applications that support remoting.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aac60-102">응용 프로그램 도메인은 하나 이상의 응용 프로그램이 있는 운영 체제 프로세스의 파티션입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-102">An application domain is a partition in an operating system process where one or more applications reside.</span></span> <span data-ttu-id="aac60-103">동일한 응용 프로그램 도메인의 개체는 직접 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-103">Objects in the same application domain communicate directly.</span></span> <span data-ttu-id="aac60-104">다른 응용 프로그램 도메인의 개체에는 응용 프로그램 도메인 경계를 넘어 개체의 복사본을 전송 하거나 메시지를 교환 하는 프록시를 사용 하 여 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-104">Objects in different application domains communicate either by transporting copies of objects across application domain boundaries, or by using a proxy to exchange messages.</span></span>  
  
 <span data-ttu-id="aac60-105"><xref:System.MarshalByRefObject> 프록시를 사용 하는 메시지를 교환 하 여 응용 프로그램 도메인 경계에 걸쳐 통신 하는 개체에 대 한 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-105"><xref:System.MarshalByRefObject> is the base class for objects that communicate across application domain boundaries by exchanging messages using a proxy.</span></span> <span data-ttu-id="aac60-106">개체에서 상속 되지 않는 <xref:System.MarshalByRefObject> 으로 암시적으로 값 마샬링됩니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-106">Objects that do not inherit from <xref:System.MarshalByRefObject> are implicitly marshal by value.</span></span> <span data-ttu-id="aac60-107">마샬링을 값 개체에서 참조 하는 원격 응용 프로그램, 응용 프로그램 도메인 경계를 넘어 개체의 복사본이 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-107">When a remote application references a marshal by value object, a copy of the object is passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="aac60-108"><xref:System.MarshalByRefObject> 개체는 로컬 응용 프로그램 도메인의 경계 내에서 직접 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-108"><xref:System.MarshalByRefObject> objects are accessed directly within the boundaries of the local application domain.</span></span> <span data-ttu-id="aac60-109">원격에서 응용 프로그램 처음으로 응용 프로그램 도메인에 액세스 한 <xref:System.MarshalByRefObject>, 프록시 원격 응용 프로그램에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-109">The first time an application in a remote application domain accesses a <xref:System.MarshalByRefObject>, a proxy is passed to the remote application.</span></span> <span data-ttu-id="aac60-110">프록시에 대 한 후속 호출 로컬 응용 프로그램 도메인에 있는 개체로 다시 마샬링됩니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-110">Subsequent calls on the proxy are marshaled back to the object residing in the local application domain.</span></span>  
  
 <span data-ttu-id="aac60-111">형식에서 상속 해야 <xref:System.MarshalByRefObject> 때 응용 프로그램 도메인 경계를 넘어 형식을 사용 하 고 개체의 상태 개체의 멤버가 자신이 만들어진 응용 프로그램 도메인 외부에서 사용할 수 없기 때문에 복사 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-111">Types must inherit from <xref:System.MarshalByRefObject> when the type is used across application domain boundaries, and the state of the object must not be copied because the members of the object are not usable outside the application domain where they were created.</span></span>  
  
 <span data-ttu-id="aac60-112">개체를 파생 시키는 경우 <xref:System.MarshalByRefObject> 응용 프로그램 도메인 경계를 넘어 용도로 하지 재정의 해야 해당 멤버가 나 해야 하는 메서드를 직접 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-112">When you derive an object from <xref:System.MarshalByRefObject> for use across application domain boundaries, you should not override any of its members, nor should you call its methods directly.</span></span> <span data-ttu-id="aac60-113">파생 된 클래스는 런타임에서 인식 <xref:System.MarshalByRefObject> 응용 프로그램 도메인 경계를 넘어 마샬링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-113">The runtime recognizes that classes derived from  <xref:System.MarshalByRefObject> should be marshaled across app domain boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aac60-114">이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-114">This section contains two code examples.</span></span> <span data-ttu-id="aac60-115">첫 번째 코드 예제에는 다른 응용 프로그램 도메인 클래스의 인스턴스를 만드는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-115">The first code example shows how to create an instance of a class in another application domain.</span></span> <span data-ttu-id="aac60-116">두 번째 코드 예제에서는 원격 서비스에 사용할 수 있는 간단한 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-116">The second code example shows a simple class that can be used for remoting.</span></span>  
  
 <span data-ttu-id="aac60-117">**예 1**</span><span class="sxs-lookup"><span data-stu-id="aac60-117">**Example 1**</span></span>  
  
 <span data-ttu-id="aac60-118">다음 코드 예제에서는 다른 응용 프로그램 도메인에 있는 코드를 실행 하는 가장 간단한 방법은 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-118">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="aac60-119">이 예제에서는 클래스를 정의 `Worker` 상속 하 <xref:System.MarshalByRefObject>, 실행 되는 응용 프로그램 도메인의 이름을 표시 하는 메서드로 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-119">The example defines a class named `Worker` that inherits <xref:System.MarshalByRefObject>, with a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="aac60-120">인스턴스를 만듭니다 `Worker` 기본 응용 프로그램 도메인에 새 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-120">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aac60-121">포함 된 어셈블리 `Worker` 두 응용 프로그램 도메인에 로드 해야 하지만 새 응용 프로그램 도메인에만 있는 다른 어셈블리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-121">The assembly that contains `Worker` must be loaded into both application domains, but it could load other assemblies that would exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 <span data-ttu-id="aac60-122">**예제 2**</span><span class="sxs-lookup"><span data-stu-id="aac60-122">**Example 2**</span></span>  
  
 <span data-ttu-id="aac60-123">다음 예제에서 파생 된 클래스 <xref:System.MarshalByRefObject> 즉 나중에 사용 되는 원격 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-123">The following example demonstrates a class derived from <xref:System.MarshalByRefObject> that is used later in remoting.</span></span>  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="aac60-124">
            <see cref="T:System.MarshalByRefObject" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-124">Initializes a new instance of the <see cref="T:System.MarshalByRefObject" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjRef">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.ObjRef CreateObjRef (Type requestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjRef CreateObjRef(class System.Type requestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.CreateObjRef(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjRef (requestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjRef ^ CreateObjRef(Type ^ requestedType);" />
      <MemberSignature Language="F#" Value="abstract member CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef&#xA;override this.CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef" Usage="marshalByRefObject.CreateObjRef requestedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="requestedType">
          <span data-ttu-id="aac60-125">새 <see cref="T:System.Type" />가 참조할 개체의 <see cref="T:System.Runtime.Remoting.ObjRef" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-125">The <see cref="T:System.Type" /> of the object that the new <see cref="T:System.Runtime.Remoting.ObjRef" /> will reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aac60-126">원격 개체와 통신하는 데 사용되는 프록시 생성에 필요한 모든 관련 정보가 들어 있는 개체를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-126">Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aac60-127">프록시를 생성하는 데 필요한 정보입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-127">Information required to generate a proxy.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aac60-128"><xref:System.MarshalByRefObject.CreateObjRef%2A> 메서드는 원격 개체 생성 방법 같은 <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> 및 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-128">The <xref:System.MarshalByRefObject.CreateObjRef%2A> method is called by remote object creation methods such as <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aac60-129">대부분의 경우에서이 메서드를 재정의 하지 않아도가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-129">In most cases, there is no need to override this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <span data-ttu-id="aac60-130">이 인스턴스가 유효한 원격 개체가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-130">This instance is not a valid remoting object.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="aac60-131">직접 실행 호출자에 인프라 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-131">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="aac60-132">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-132">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="aac60-133">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-133">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public object GetLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.GetLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member GetLifetimeService : unit -&gt; obj&#xA;override this.GetLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.GetLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="aac60-134">이 인스턴스의 수명 정책을 제어하는 현재의 수명 서비스 개체를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-134">Retrieves the current lifetime service object that controls the lifetime policy for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aac60-135">
            <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> 형식의 개체는 이 인스턴스의 수명 정책을 제어하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-135">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aac60-136">수명 서비스에 대 한 자세한 내용은 참조는 <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-136">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="aac60-137">직접 실행 호출자에 인프라 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-137">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="aac60-138">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-138">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="aac60-139">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-139">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public virtual object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member InitializeLifetimeService : unit -&gt; obj&#xA;override this.InitializeLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="aac60-140">이 인스턴스의 수명 정책을 제어하는 수명 서비스 개체를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-140">Obtains a lifetime service object to control the lifetime policy for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aac60-141">
            <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> 형식의 개체는 이 인스턴스의 수명 정책을 제어하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-141">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span>
          </span>
          <span data-ttu-id="aac60-142">이 개체는 해당 인스턴스에 대한 현재 수명 서비스 개체이고(있는 경우), 그렇지 않으면 <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> 속성의 값으로 초기화된 새 수명 서비스 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-142">This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aac60-143">수명 서비스에 대 한 자세한 내용은 참조는 <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-143">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aac60-144">다음 코드 예제에서는 임대를 만드는 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-144">The following code example demonstrates creating a lease.</span></span>  
  
 [!code-cpp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CS/source.cs#1)]
 [!code-vb[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="aac60-145">직접 실행 호출자에 인프라 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-145">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="aac60-146">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-146">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="aac60-147">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-147">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberwiseClone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="aac60-148">현재 개체의 부분 복사본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-148">Creates a shallow copy of the current object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject MemberwiseClone (bool cloneIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone (cloneIdentity As Boolean) As MarshalByRefObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject ^ MemberwiseClone(bool cloneIdentity);" />
      <MemberSignature Language="F#" Value="override this.MemberwiseClone : bool -&gt; MarshalByRefObject" Usage="marshalByRefObject.MemberwiseClone cloneIdentity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.MarshalByRefObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cloneIdentity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cloneIdentity">
          <span data-ttu-id="aac60-149">
            <see langword="false" />이면 현재 <see cref="T:System.MarshalByRefObject" /> 개체의 ID를 삭제하여 개체가 원격 경계를 넘어 마샬링될 때 개체에 새 ID가 할당됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-149">
              <see langword="false" /> to delete the current <see cref="T:System.MarshalByRefObject" /> object's identity, which will cause the object to be assigned a new identity when it is marshaled across a remoting boundary.</span>
          </span>
          <span data-ttu-id="aac60-150">대개 <see langword="false" /> 값이 적합합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-150">A value of <see langword="false" /> is usually appropriate.</span>
          </span>
          <span data-ttu-id="aac60-151">
            <see langword="true" />이면 현재 <see cref="T:System.MarshalByRefObject" /> 개체의 ID를 복제본으로 복사하여 원격 클라이언트 호출이 원격 서버 개체로 라우팅됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-151">
              <see langword="true" /> to copy the current <see cref="T:System.MarshalByRefObject" /> object's identity to its clone, which will cause remoting client calls to be routed to the remote server object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aac60-152">현재 <see cref="T:System.MarshalByRefObject" /> 개체의 단순 복사본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-152">Creates a shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aac60-153">
            <see cref="T:System.MarshalByRefObject" /> 개체의 단순 복사본입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aac60-153">A shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aac60-154"><xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> 메서드 새 단순 복사본을 만듭니다. <xref:System.MarshalByRefObject> 개체를 현재의 비정적 필드를 복사 하 여 <xref:System.MarshalByRefObject> 개체를 새 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-154">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method creates a shallow copy by creating a new <xref:System.MarshalByRefObject> object, and then copying the nonstatic fields of the current <xref:System.MarshalByRefObject> object to the new object.</span></span> <span data-ttu-id="aac60-155">필드 값 형식이 필드의 비트 단위로 복사가 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-155">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="aac60-156">필드 참조 형식인 경우 참조를 복사할 수 있지만 참조 된 개체는 필요는 없습니다. 따라서 원래 개체 퓨 터와 복제본 같은 개체를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-156">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="aac60-157">예를 들어 한 <xref:System.MarshalByRefObject> A 개체 및 개체 B를 참조 하는 X를 호출 하는 개체 참조 합니다. 3. 개체 X의 단순 복사본을 만듭니다 개체 A와 B를 참조 하는 새 개체 X2 반면, X의 전체 복사본을 새 개체 X2 A2 및 b 2를 A의 복사본 인 새 개체를 참조 하는 만들고 B. b 2를 참조 합니다. 3. 사용 하 여 구현 하는 클래스 복사본 인 새 개체 c 2는 <xref:System.ICloneable> 전체 또는 단순 c 수행 하는 인터페이스 개체의 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-157">For example, consider a <xref:System.MarshalByRefObject> object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy C. Use a class that implements the <xref:System.ICloneable> interface to perform a deep or shallow copy of an object.</span></span>  
  
 <span data-ttu-id="aac60-158">id는 <xref:System.MarshalByRefObject> 원격 클라이언트 호출의 대상이 되는 원격 서버 개체를 개체 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-158">The identity of a <xref:System.MarshalByRefObject> object is defined as the remote server object that is the target of a remoting client call.</span></span> <span data-ttu-id="aac60-159">멤버 수준 복제를 기본적으로는 <xref:System.MarshalByRefObject> 개체에는 보통 되지 않은 클라이언트 쪽 원격 경계를 넘어 마샬링되는 서버 쪽 개체의 복제본에 대 한 올바른 동작은 원래 개체와 동일한 id입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-159">By default, the memberwise clone of a <xref:System.MarshalByRefObject> object has the same identity as the original object, which is typically not the correct behavior for clones of server-side objects that are marshaled across a remoting boundary to the client side.</span></span> <span data-ttu-id="aac60-160">지정 `false`, 일반적으로 적절 하 게 복제의 id를 삭제 하 고 원격 경계를 넘어 복제본 마샬링될 때 할당 될 새 id를 일으킬 변수인 또는 `true` 원래id유지하도록복제본을<xref:System.MarshalByRefObject> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-160">Specify `false`, which is usually appropriate, to delete the identity of the clone and cause a new identity to be assigned when the clone is marshaled across a remoting boundary, or `true` to cause the clone to retain the identity of the original <xref:System.MarshalByRefObject> object.</span></span> <span data-ttu-id="aac60-161"><xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> 방법은 원격 서버 개체를 구현 하는 개발자가 사용 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aac60-161">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method is intended to be used by developers implementing remote server objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>