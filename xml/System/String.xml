<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7bf2d0223b77d7a3205fcbcc0fc27d643d2e78a8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36432036" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>텍스트를 UTF-16 코드 단위의 시퀀스로 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 문자열은 텍스트를 나타내는 데 사용 되는 문자의 순차적인 컬렉션입니다. A <xref:System.String> 개체의 순차적인 컬렉션을는 <xref:System.Char?displayProperty=nameWithType> 문자열 있으며 나타내는 개체를 개체 <xref:System.Char?displayProperty=nameWithType> utf-16 코드 단위에 해당 하는 개체입니다. 값은 <xref:System.String> 개체의 순차 컬렉션의 콘텐츠는 <xref:System.Char?displayProperty=nameWithType> 개체 및 값은 변경할 수 없습니다 (즉,이 읽기 전용). 문자열의 불변성에 대 한 자세한 내용은 참조는 [불변성 및 StringBuilder 클래스](#Immutability) 이 항목의 뒷부분에 나오는 섹션. 최대 크기는 <xref:System.String> 개체가 메모리에 2 GB 되었거나 약 1 십억 문자입니다.  
  
 섹션 내용  
  
 [문자열 개체 인스턴스화](#Instantiation)   
 [Char 개체 및 유니코드 문자](#Characters)   
 [문자열과 유니코드 표준](#Unicode)   
 [문자열 및 포함 된 null 문자](#EmbeddedNulls)   
 [문자열 및 인덱스](#Indexes)   
 [Null 문자열 및 빈 문자열](#Nulls)   
 [불변성이 및 StringBuilder 클래스](#Immutability)   
 [문화권 구분 작업 및 서 수](#CultureSensitive)   
 [정규화](#Normalization)   
 [범주별으로 문자열 작업](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>문자열 개체 인스턴스화  
 인스턴스화할 수 있습니다는 <xref:System.String> 다음과 같은 방법으로 개체:  
  
-   문자열 리터럴을 할당 하 여 한 <xref:System.String> 변수입니다. 이 문자열을 만들기 위해 자주 사용 하는 방법. 다음 예제에서는 할당을 사용 하 여 여러 문자열을 만들 수 있습니다. 때문에 C#에서 유의 백슬래시 (\\)는 이스케이프 문자, 문자열의 리터럴 백슬래시를 이스케이프 처리 해야 또는 전체 문자열 이어야 합니다 @-quoted합니다.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   호출 하 여 한 <xref:System.String> 클래스 생성자입니다. 다음 예제에서는 여러 클래스 생성자를 호출 하 여 문자열을 인스턴스화합니다. Note 문자 배열 또는 매개 변수로 부호 있는 바이트 배열에 대 한 포인터를 포함 하는 생성자의 일부입니다. Visual Basic에서 이러한 생성자에 대 한 호출을 지원 하지 않습니다. 에 대 한 자세한 내용은 <xref:System.String> 생성자, 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   문자열 연결 연산자를 사용 하 여 (+, C# 및 & 또는 +, Visual basic에서) 조합에서 단일 문자열을 만드는 <xref:System.String> 인스턴스 및 문자열 리터럴을 합니다. 다음 예제에서는 문자열 연결 연산자의 사용을 보여 줍니다.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   한 속성을 검색 하거나 문자열을 반환 하는 메서드를 호출 합니다. 메서드를 사용 하는 다음 예제는 <xref:System.String> 더 큰 문자열에서 하위 문자열을 추출 하는 클래스입니다.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   값 이나 개체를 문자열 표현으로 변환 하는 서식 지정 메서드를 호출 합니다. 다음 예제에서는 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문자열로 두 개체의 문자열 표현을 포함 하는 기능입니다.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char 개체 및 유니코드 문자  
 문자열의 각 문자는 유니코드 코드 포인트 또는 서 수 (숫자) 값의 유니코드 문자를 유니코드 스칼라 값으로 정의 됩니다. Utf-16 인코딩을 사용 하 여 각 코드 포인트를 인코딩하고 인코딩의 각 요소의 숫자 값으로 표시 됩니다는 <xref:System.Char> 개체입니다.  
  
> [!NOTE]
>  때문에 <xref:System.String> utf-16 코드 단위의 순차 컬렉션의 인스턴스 구성 됩니다, 만들 수는 <xref:System.String> 개체는 올바른 형식의 유니코드 문자열입니다. 예를 들어 해당 상위 서로게이트 없이 하위 서로게이트가 포함 된 문자열을 만들 수는 있습니다. 하지만 인코딩 및 디코딩에 있는 개체의 메서드와 같은 일부 메서드는 <xref:System.Text> 네임 스페이스 문자열은 올바른 형식을 갖추도록 되도록 검사를 수행 될 수 있습니다 <xref:System.String> 클래스 멤버는 문자열은 올바른 형식의 보장할 수 없습니다.  
  
 단일 <xref:System.Char> 개체는 일반적으로 단일 나타냅니다 코드 포인트입니다; 즉,의 숫자 값은 <xref:System.Char> 코드 포인트를 같음. 예를 들어, 코드 포인트는 "문자에 대 한 a"는 U + 0061 합니다. 그러나, 코드 포인트에서 인코딩된 요소가 둘 이상 필요할 수 있습니다 (둘 이상의 <xref:System.Char> 개체). 다중 두 가지 유형의 해당 하는 문자를 정의 하는 유니코드 표준 <xref:System.Char> 개체: 제자, 및 유니코드 보조 평면에 있는 문자에 해당 하는 유니코드 보조 문자 코드 포인트입니다.  
  
-   단일 기본 문자 뒤에 하나 이상의 결합 문자가 표시 됩니다. 예를 들어 ä는 문자가 a에서 <xref:System.Char> 코드 포인트가 U + 0061 a가 개체 <xref:System.Char> 코드 포인트가 U + 0308 개체입니다. 이 문자는 단일 정의할 수도 있습니다 <xref:System.Char> 개체는 코드 포인트가 U + 00 e 4 인입니다. 다음 예제와 같이 같음에 대 한 문화권 구분 비교는 서 수 비교 아니지 이러한 두 표현은 이상이 면 있음을 나타냅니다. 그러나 두 문자열을 정규화 하는 경우 서 수 비교 나타내기도 같은지 합니다. (문자열을 정규화 자세한 내용은 참조는 [정규화](#Normalization) 섹션.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   유니코드 보조 문자 코드 포인트 (예: 서로게이트 쌍)으로 표시 됩니다는 <xref:System.Char> 코드 포인트가 high surrogate 인지 개체 뒤는 <xref:System.Char> 개체 코드 포인트가 하위 서로게이트입니다. 높은 서로게이트가 범위 U + d 800에서 U + DBFF의 코드 단위입니다. U + d c 00부터 U + dfff 낮은 서로게이트가 범위의 코드 단위입니다. 서로게이트 쌍이 16 유니코드 보조 평면에 있는 문자를 나타내는 데 사용 됩니다. 다음 예제에서는 서로게이트 문자를 만들고 전달 하는 <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> 메서드는 서로게이트 쌍 인지 확인할 수 있습니다.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>문자열과 유니코드 표준  
 문자열의 문자에 해당 하는 u t F-16으로 인코딩된 코드 단위도 표현 됩니다 <xref:System.Char> 값입니다.  
  
 각 문자는 문자열에 의해.NET Framework에서 표현 되는 연결 된 유니코드 문자 범주에는 <xref:System.Globalization.UnicodeCategory> 열거형입니다. 문자 또는 서로게이트 쌍의 범주를 호출 하 여 확인할 수 있습니다는 <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> 메서드.  
  
 .NET의 문자와 해당 범주에는 특정 버전의 다른 플랫폼에서 실행 되는.NET 구현이 동일한 문자 범주 정보를 반환 하는지 자체 테이블 유지 관리 합니다. 다음 표에서.NET 버전 및 문자 범주에 기반 하는 유니코드 표준의 버전을 나열 합니다.  
  
|.NET Framework 버전|유니코드 표준의 버전|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[유니코드 표준 버전 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[유니코드 표준 버전 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[유니코드 표준 버전 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[유니코드 표준 버전 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[유니코드 표준 6.3.0 버전](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[유니코드 표준 6.3.0 버전](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[유니코드 표준 6.3.0 버전](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[유니코드 표준 6.3.0 버전](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[유니코드 표준 6.3.0 버전](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[유니코드 표준 8.0.0 버전](https://www.unicode.org/versions/Unicode8.0.0/)|  
|.NET core (모든 버전)|[유니코드 표준 8.0.0 버전](https://www.unicode.org/versions/Unicode8.0.0/)|
  
 또한.NET Framework에서는 문자열 비교를 지원 하 고 유니코드 표준에 따라 정렬 합니다. 통해.NET Framework의 버전에는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],.NET Framework에 문자열 데이터의 자체 테이블 유지 관리 합니다. 부터는.NET Framework 버전의 경우에이 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7에서 실행 합니다. 부터는 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Window 8 및 이후 버전의 Windows 운영 체제에서 실행, 런타임 대리자 문자열 비교 및 정렬 작업의 운영 체제입니다. 다음 표에서.NET Framework의 버전 및 문자 비교 및 정렬은 기반으로 하는 유니코드 표준의 버전을 나열 합니다.  
  
|.NET Framework 버전|유니코드 표준의 버전|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[유니코드 표준 버전 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[유니코드 표준 버전 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[유니코드 표준 버전 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[유니코드 표준 버전 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7 이상|[유니코드 표준 버전 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 나중에 Windows 8 및 이상의 Windows 운영 체제와|[유니코드 표준 6.3.0 버전](https://www.unicode.org/versions/Unicode6.3.0/)|  

.NET Core에서는 정렬 및 비교 연산에 따라은 [유니코드 표준의 버전 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)합니다.

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>문자열 및 포함 된 null 문자  
 .NET framework에서는 <xref:System.String> 개체는 문자열 길이의 일부로 계산 포함 된 null 문자를 포함할 수 있습니다. 그러나 C 및 c + +와 같은 일부 언어에서는 null 문자는 문자열의 끝을 나타내는 이며 문자열의 일부로 간주 되지 않습니다는 문자열 길이의 일부로 계산 되지 않습니다. 즉, C 및 c + + 프로그래머 또는 라이브러리 C 또는 c + +로 작성 된 문자열에 대 한 하도록 할 수 있는 다음과 같은 일반적인 가정에 적용 될 때 반드시 유효한 지 <xref:System.String> 개체:  
  
-   반환한 값은 `strlen` 또는 `wcslen` 함수 같지 않을 수도 <xref:System.String.Length%2A?displayProperty=nameWithType>합니다.  
  
-   만든 문자열은 `strcpy_s` 또는 `wcscpy_s` 함수에서 만든 문자열을 반드시 일치 하지 않습니다는 <xref:System.String.Copy%2A?displayProperty=nameWithType> 메서드.  
  
 인스턴스화하는 해당 네이티브 C 및 c + + 코드를 확인 해야 <xref:System.String> 개체 및 전달 되는 코드 <xref:System.String> 플랫폼을 통해 개체 호출을 포함 된 null 문자는 문자열의 끝을 표시 가정 하지 마십시오.  
  
 또한 문자열에 포함 된 null 문자는 문자열은 정렬 또는 (비교)와 문자열을 검색할 경우 다르게 처리 됩니다. 고정 문화권을 사용 하 여 비교를 포함 하 여 두 문자열 간의 문화권 구분 비교를 수행할 때 null 문자는 무시 됩니다. 서 수 또는 대/소문자 비구분 서 수 비교에 대 한 것으로 간주 됩니다. 반면에 포함 된 null 문자를 항상 고려와 같은 방법으로는 문자열을 검색할 때 <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, 및 <xref:System.String.IndexOf%2A>합니다.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>문자열 및 인덱스  
 인덱스는의 위치는 <xref:System.Char> (유니코드 문자)의 개체는 <xref:System.String>합니다. 인덱스는 인덱스 0 위치 하는 문자열의 첫 번째 위치에서 시작 하는 음수가 아닌 숫자 0부터 시작 합니다. 다양 한 검색 메서드는 같은 <xref:System.String.IndexOf%2A> 및 <xref:System.String.LastIndexOf%2A>, 문자의 인덱스를 반환 또는 문자열 인스턴스에서 부분 문자열입니다.  
  
 <xref:System.String.Chars%2A> 속성에 액세스할 수 있게 개별 <xref:System.Char> 문자열의 인덱스 위치에 의해 개체입니다. 때문에 <xref:System.String.Chars%2A> 속성 (Visual Basic)의 기본 속성 또는 인덱서 (C#)은, 개별에 액세스할 수 있습니다 <xref:System.Char> 다음과 같은 코드를 사용 하 여 문자열에 있는 개체입니다. 이 코드 공백 또는 문자열에 단어의 개수를 결정 하는 문자열의 문장 부호 문자를 찾습니다.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 때문에 <xref:System.String> 클래스가 구현 하는 <xref:System.Collections.IEnumerable> 인터페이스를 반복할 수도 있습니다를 통해는 <xref:System.Char> 를 사용 하 여 문자열에서 `foreach` 다음 예제와 같이 구문입니다.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 연속 된 인덱스 값 서로 다를 수 연속 유니코드 문자를 유니코드 문자 수 개 이상의 때문에 <xref:System.Char> 개체입니다. 특히, 문자열로 기본 문자 뒤에 하나 이상의 결합 문자 또는 서로게이트 쌍으로 형성 된 텍스트 단위 여러 문자를 포함할 수 있습니다. 대신 유니코드 문자로 작업 해야 <xref:System.Char> 개체를 사용 하 여는 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 및 <xref:System.Globalization.TextElementEnumerator> 클래스입니다. 다음 예제 코드를 사용 하는 차이점을 보여 줍니다. <xref:System.Char> 개체 및 유니코드 문자를 사용 하는 코드입니다. 문자 또는 문장의 각 단어의 텍스트 요소 수를 비교합니다. 문자열에는 기본 문자 뒤에 결합 문자 시퀀스를 두 개의 포함 됩니다.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 이 예제에서는 텍스트 요소를 사용 하 여 작업의 <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> 메서드 및 <xref:System.Globalization.TextElementEnumerator> 문자열의 모든 텍스트 요소를 열거 하는 클래스입니다. 호출 하 여 각 텍스트 요소의 시작 하는 인덱스를 포함 하는 배열을 검색할 수도 있습니다는 <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> 메서드.  
  
 개별이 아닌 텍스트의 단위를 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Char> 값, 참조는 <xref:System.Globalization.StringInfo> 클래스입니다.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Null 문자열 및 빈 문자열  
 선언 되었지만 값 할당 되지 않았습니다 문자열은 `null`합니다. 해당 문자열의 메서드를 호출 하는 동안 throw 된 <xref:System.NullReferenceException>합니다. Null 문자열은 단일 값이 빈 문자열인 경우 간에 차이가 있는 "" 또는 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 일부 경우에 메서드 호출에서 인수로 null 문자열이 나 빈 문자열로 전달 예외가 throw 됩니다. 예를 들어, null 문자열을 전달는 <xref:System.Int32.Parse%2A?displayProperty=nameWithType> 메서드가 throw는 <xref:System.ArgumentNullException>, throw 빈 문자열을 전달 하는 <xref:System.FormatException>합니다. 다른 경우에 메서드 인수는 null 문자열 또는 빈 문자열일 수 있습니다. 예를 제공 하는 경우는 <xref:System.IFormattable> 클래스에 대 한 구현 하려면 일반 ("G") 형식 지정자와 함께 null 문자열 및 빈 문자열을 모두와 동등 합니다.  
  
 <xref:System.String> 클래스 문자열이 여부를 테스트할 수 있도록 하는 다음 두 개의 편리한 메서드를 포함 `null` 이거나 비어 있습니다.  
  
-   <xref:System.String.IsNullOrEmpty%2A>문자열이 중 하나 인지를 나타내는 `null` 같은 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 이 메서드는 다음과 같은 코드를 사용 하 여 필요가 없습니다.  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>문자열이 인지를 나타내는 `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, 또는 공백 문자로 구성 되어 있습니다. 이 메서드는 다음과 같은 코드를 사용 하 여 필요가 없습니다.  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 다음 예제에서는 <xref:System.String.IsNullOrEmpty%2A> 에서 메서드는 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 사용자 지정 구현의 `Temperature` 클래스입니다. 메서드는 "G", "C", "F" 및 "K" 형식 문자열을 지원합니다. 형식 문자열이 비어 나 형식 문자열 값인 경우 `null` 전달 메서드로 "G" 형식 문자열에 해당 값을 변경 합니다.  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>불변성이 및 StringBuilder 클래스  
 A <xref:System.String> 개체를 변경할 수 없는 호출 (읽기 전용)를 만든 후 해당 값을 수정할 수 없습니다. 수정 하는 메서드는 <xref:System.String> 개체는 실제로 새 반환 <xref:System.String> 해당 수정 사항을 포함 하는 개체입니다.  
  
 문자열은 변경 때문에 수행 하는 문자열 조작 루틴에 추가 또는 삭제 것 처럼 단일 문자열에는 성능이 크게 저하 정확한 수를 반복 합니다. 예를 들어 다음 코드는 0x0001 ~ 0x052F 범위에서 1000 자 문자열을 만드는 난수 생성기를 사용 합니다. 새 문자 이라는 기존 문자열에 추가할 문자열 연결을 사용 하는 코드 표시 되지만 `str`를 실제로 만드는 새 <xref:System.String> 각 연결 작업에 대 한 개체입니다.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 사용할 수는 <xref:System.Text.StringBuilder> 클래스 대신는 <xref:System.String> 문자열의 값에 대 한 여러 가지 변경 작업에 대 한 클래스입니다. 인스턴스와 달리는 <xref:System.String> 클래스 <xref:System.Text.StringBuilder> 개체는 변경할 수, 연결, 추가 또는 문자열에서 하위 문자열을 삭제 작업이 단일 문자열에 대해 수행 됩니다. 값을 수정 완료 했을 때는 <xref:System.Text.StringBuilder> 개체를 호출할 수 있습니다는 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 메서드를 문자열로 변환 합니다. 다음 예제에서는 대체는 <xref:System.String> 0x0001 0x052F ~ 범위에 1000 개의 임의 문자를 연결 하는 앞의 예에서 사용 되는 한 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>문화권 구분 작업 및 서 수  
 멤버는 <xref:System.String> 서 수 또는 문화권 구분 (언어) 작업을 수행 하는 클래스는 <xref:System.String> 개체입니다. 각각의 숫자 값에서 서 수는 작업이 실행 <xref:System.Char> 개체입니다. 값에는 문화권 구분 작업 수행은 <xref:System.String> 개체 및 하나 문화권별 대/소문자, 정렬, 서식 지정 및 구문 분석 규칙을 고려 합니다. 문화권 구분 작업은 명시적으로 선언 된 문화권 이나 현재 문화권 암시적의 컨텍스트에서 실행 됩니다. 두 종류의 작업이 동일한 문자열에 수행 될 때 아주 다른 결과 생성할 수 있습니다.  
  
 또한.NET Framework 고정 문화권을 사용 하 여 문화권을 구분 하지 않는 언어적 문자열 작업을 지원 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), 영어 영역의 독립적인의 culture 설정을 기준으로 하는 느슨하게 합니다. 다른 달리 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 설정, 고정 문화권의 설정 및.NET Framework의 버전에 시스템에 시스템에서 단일 컴퓨터에서 일관성을 유지 하려면 보장 됩니다. 고정 문화권 대기 모든 문화권에서 문자열 비교의 안정성을 보장 하 블랙 박스에의 한 종류로 표시 및 주문 수 있습니다.  
  
> [!IMPORTANT]
>  응용 프로그램 파일 이름과 같은 기호 식별자에 대 한 보안 결정을 내리는 또는 명명 된 파이프 하는 경우 또는 XML 파일에 텍스트 기반 데이터와 같은 지속형된 데이터에 대 한, 작업 대신 문화권 구분 비교는 서 수 비교를 사용 해야 합니다. 비교 된 문자의 이진 값에 따라서만 서 수 비교 결과가 결정 하는 반면 문화권 구분 비교는 실제로 문화권에 따라 다른 결과 생성할 수 때문입니다.  
  
> [!IMPORTANT]
>  형식의 매개 변수를 포함 하는 오버 로드를 포함 하는 문자열 연산을 수행 하는 대부분의 메서드와 <xref:System.StringComparison>, 메서드는 서 수 또는 문화권 구분 작업 수행 여부를 지정할 수 있습니다. 일반적으로 하 게 하려면 메서드 호출을 분명이 오버 로드를 호출 해야 합니다. 모범 사례 및 서 수와 문화권 구분 문자열에 작업을 사용 하기 위한 지침에 대 한 참조 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md)합니다.  
  
 에 대 한 작업 [대/소문자](#casing), [구문 분석 및 서식 지정](#parsing), [비교 및 정렬](#comparison), 및 [같음 테스트](#equality) 수 중 하나가 서 수 또는 문화권을 구분 합니다. 다음 섹션에서는 작업의 각 범주를 설명 합니다.  
  
> [!TIP]
>  메서드 호출을 분명 의도 하는 메서드 오버 로드를 항상 호출 해야 합니다. 예를 들어 호출 하는 대신는 <xref:System.String.Compare%28System.String%2CSystem.String%29> 현재 문화권의 규칙을 사용 하 여 두 문자열의 문화권 구분 비교를 수행 하는 메서드를 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드 값이 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 에 대 한는 `comparisonType` 인수입니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
<a name="casing"></a>   
### <a name="casing"></a>대/소문자 구분  
 대/소문자 규칙에는 유니코드 문자의 대/소문자를 변경 하는 방법 결정 예를 들어 대문자 소문자에서. 종종, 대/소문자 구분 작업 문자열 비교 하기 전에 수행 됩니다. 예를 들어 다른 대문자 문자열로 비교할 수 있도록 문자열을 대문자로 변환 될 수 있습니다. 호출 하 여 소문자로 문자열의에서 문자를 변환할 수는 <xref:System.String.ToLower%2A> 또는 <xref:System.String.ToLowerInvariant%2A> 메서드를 호출 하 여 대문자로 변환할 수는 <xref:System.String.ToUpper%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 또한 사용할 수 있습니다는 <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> 제목 대/소문자를 문자열로 변환 하는 메서드입니다.  
  
 대/소문자 구분 작업은 현재 문화권, 지정 된 문화권 이나 고정 문화권의 규칙 기반 될 수 있습니다. 대/소문자 매핑 사용 되는 문화권에 따라 달라질 수 있으므로 대/소문자 구분 작업의 결과 문화권에 따라 달라질 수 있습니다. 대/소문자의 실제 차이 다음 세 종류가:  
  
-   LATIN CAPITAL LETTER I 대/소문자 매핑의 차이점 (U + 0049), LATIN SMALL LETTER I (U + 0069), LATIN CAPITAL LETTER I (U + 0130), 위에 점 및 LATIN SMALL 문자 점이 없는 I (U + 0131). TR-TR (터키어 (터키)) 및 az-Latn-AZ (아제르바이잔, 라틴 문자) 문화권 및 tr, az, 및 az Latn 중립 문화권의 라틴어 대문자 I 해당 하는 소문자 라틴어 작은 문자 점이 없는 I, 이며 해당 하는 대문자 라틴어 작은 문자 I 라틴어 대문자 I 위의 점입니다. 다른 모든 문화권에서 LATIN SMALL LETTER I 및 LATIN CAPITAL LETTER 소문자, 대문자 해당 항목을 고정 문화권을 포함 합니다.  
  
     다음 예제에서는 방법을 보여 줍니다 설계 하는 문자열 비교 파일 시스템 액세스를 방지 하는 문화권별 대/소문자 구분 비교에 사용 하는 경우 실패할 수 있습니다. (고정 문화권의 대/소문자 규칙을 사용 합니다.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   대/소문자 매핑 고정 문화권 및 다른 모든 문화권 간의 차이입니다. 이러한 경우 고정 문화권의 대/소문자 규칙을 사용 하 여 문자를 대문자 또는 소문자로 변경 하는 동일한 문자를 반환 합니다. 다른 모든 문화권에 대 한 다른 문자를 반환합니다. 일부 영향을 받는 문자는 다음 표에 나열 됩니다.  
  
    |문자|로 변경 된 경우|반환 값|  
    |---------------|-------------------|-------------|  
    |미크론 SIGN (U + 00B5)|대문자|그리스어 대문자 MU (U +-39 C)|  
    |라틴어 대문자 I 점으로 (U + 0130) 위에|소문자|작은 라틴 문자 I (U + 0069)|  
    |라틴어 소문자 점이 없는 I (U + 0131)|대문자|라틴어 대문자 I (U + 0049)|  
    |라틴어 소문자 긴 S (U + 017F)|대문자|LATIN CAPITAL LETTER S (U + 0053)|  
    |파이프 기호 있는 작은 문자 Z로 D 영문 대문자 (U + 01C 5)|소문자|파이프 기호 있는 DZ 영문 소문자 (U + 01C 6)|  
    |결합 그리스어 YPOGEGRAMMENI (U + 0345)|대문자|그리스어 대문자 IOTA (U + 0399)|  
  
-   ASCII 문자 범위에서 두 문자의 소문자가 혼합 된 쌍의 대/소문자 매핑의 차이 제공 합니다. 대부분의 문화권에서 두 문자의 소문자가 혼합 된 쌍은 해당 하는 두 문자의 대문자 또는 소문자 쌍과 같습니다. 이 다음 문화권에서 다음 두 문자 쌍에 대 한 때문에 사실이 아닙니다에 digraph 비교는 각각의 경우:  
  
    -   "lJ" 및 "nJ" HR-HR (크로아티아어 (크로아티아)) 문화권에서.  
  
    -   "cH" CS-CZ (체코어 (체코 공화국)) 및 디스크-디스크 (슬로바키아어 (슬로바키아)) 문화권에서 합니다.  
  
    -   "aA" DA-DK (덴마크어 (덴마크)) 문화권에서.  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" 및 "zS" HU-HU (헝가리어 (헝가리)) 문화권에서  
  
    -   "cH" 및 "lL" es-es_tradnl (스페인어 (스페인, 전통 정렬)) 문화권에서.  
  
    -   "cH", "gI", "kH", "nG" "nH", "pH", "qU',"tH"및"tR"vi-VN (베트남어 (베트남)) 문화권에서.  
  
     그러나 이러한 쌍의 고정된 문자열 또는 식별자에서 일반적이 지 않은 상황에서 이러한 쌍의 문화권 구분 비교 만들어 문제를 발생 하는 데 평소있지 않습니다.  
  
 다음 예제에서는 문화권 문자열을 대문자로 변환 하는 경우 대/소문자 규칙의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>구문 분석 및 서식 지정  
 서식 지정 및 구문 분석은 역 작업입니다. 서식 지정 규칙 구문 분석 규칙 문자열 표현을 같은 날짜 및 시간 값으로 변환 하는 방법을 결정 하는 반면 숫자 및 날짜 또는 시간 등의 값을 문자열 표현으로 변환 하는 방법을 결정 합니다. 서식 지정 및 구문 분석 규칙 둘 다 문화권 규칙에 따라 달라 집니다. 다음 예에서는 culture 관련 날짜 문자열을 해석할 때 발생할 수 있는 모호성을 보여 줍니다. 날짜 문자열을 생성 하는 데 사용 된 문화권의 규칙을 몰라도 2011-03-01, 2011 년 3 월 1 일 및 2011/01/03 2011 년 1 월 3 일 또는 2011 년 3 월 1 일 나타냅니다 있는지 여부를 알 수 없습니다.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 마찬가지로, 다음 예제와 같이 단일 문자열 구문 분석 작업에서 해당 규칙 사용 되는 문화권에 따라 다른 날짜를 생성할 수 있습니다.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>문자열 비교 및 정렬  
 비교 및 정렬 문자열에 대 한 규칙에는 문화권 달라 집니다. 예를 들어 윗주 또는 문자의 시각적 표시 정렬 순서를 기반으로 될 수 있습니다. 동아시아 언어에서는 표의 문자의 부수와 획에 따라 문자가 정렬됩니다. 언어와 문화권이 알파벳에 사용하는 순서에 따라 정렬 순서가 달라지기도 합니다. 예를 들어 덴마크어 알파벳의 "Æ" 문자는 "Z" 다음에 옵니다. 또한 비교는 대/소문자 구분 또는 대/소문자를 구분 될 수 있습니다 및 경우에 따라 대/소문자 규칙 또한 다 문화권에 의해 합니다. 반면에 서 수 비교를 비교 하 고 문자열을 정렬 하는 경우 문자열의 개별 문자의 유니코드 코드 포인트를 사용 합니다.  
  
 정렬 규칙을 서로 비교 하는 두 문자열 및 유니코드 문자의 알파벳 순서를 결정 합니다. 예를 들어는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 메서드를 기반으로 하는 두 개의 문자열 비교는 <xref:System.StringComparison> 매개 변수입니다. 매개 변수 값이 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, 매개 변수 값이 메서드가 현재 문화권의 규칙을 사용 하는 언어 비교를 수행할 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>,이 메서드는 서 수 비교를 수행 합니다. 따라서 다음 예제에서는 현재 문화권이 미국 인 경우 영어, 첫 번째 호출에서 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (문화권 구분 비교를 사용 하 여) 메서드 "A", 보다 작음 "a" 되었지만 두 번째 호출 (서 수 비교를 사용 하 여)는 동일한 메서드로 간주 "a" "A" 보다 큼.  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET Framework에서는 단어, 문자열 및 정렬 서 수 규칙을 지원합니다.  
  
-   특정 영숫자가 아닌 유니코드 문자에 특별 한 가중치 할당 있을 수 있는 문자열의 문화권 구분 비교를 수행 하는 단어 정렬 합니다. 예를 들어, 하이픈 (-)는 매우 작은 가중치가 할당 "coop" 및 "co-op" 정렬된 된 목록에서 서로 인접 표시 되도록 있을 수 있습니다. 목록은 <xref:System.String> 단어 정렬 규칙을 사용 하 여 두 문자열을 비교 하는 방법을 참조는 [문자열 작업을 범주별으로](#ByCategory) 섹션.  
  
-   또한 문자열 정렬 문화권 구분 비교를 수행합니다. 비슷합니다 단어 정렬 없는 특수 한 상황이 영숫자 모든 유니코드 문자 앞에 야 하는 모든 영숫자가 아닌 기호가 된다는 점이 다릅니다. 호출 하 여 문자열 정렬 규칙을 사용 하 여 두 문자열을 비교할 수는 <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> 메서드 오버 로드는 `options` 의 값을 제공 하는 매개 변수를 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>합니다. .NET Framework에서는 문자열 정렬 규칙을 사용 하 여 두 문자열을 비교 하는 유일한 방법은 인지 note 합니다.  
  
-   각각의 숫자 값에 따라 문자열을 비교 하는 서 수 정렬 <xref:System.Char> 문자열에는 개체입니다. 서 수 비교는 대 / 소문자 버전의 문자는 다른 코드 점이 하기 때문에 자동으로 대/소문자 구분 합니다. 그러나 대/소문자는 중요 하지 않습니다, 대/소문자를 무시 하는 서 수 비교를 지정할 수 있습니다. 문자열을 고정 문화권을 사용 하 여 다음 결과에 서 수 비교를 수행 하 여 대문자로 변환 하는 것과 같습니다. 목록은 <xref:System.String> 정렬 서 수 규칙을 사용 하 여 두 문자열을 비교 하는 메서드를 참조는 [문자열 작업을 범주별으로](#ByCategory) 섹션.  
  
 문화권 구분 비교는 명시적 또는 암시적으로 사용 하는 모든 비교는 <xref:System.Globalization.CultureInfo> 를 변수로 지정 된 고정 문화권을 포함 한 개체는 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성입니다. 암시적 문화권은 현재 문화권으로 지정 되는 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성입니다. 영문자의 정렬 순서에서 상당한 변형이 있습니다 (즉, 한 문자는 <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> 속성에서 반환 `true`) 문화권에 걸쳐 합니다. 제공 하 여 특정 문화권의 규칙을 사용 하는 문화권 구분 비교를 지정할 수는 <xref:System.Globalization.CultureInfo> 와 같은 개체는 문자열 비교 메서드를 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>합니다. 제공 하 여 현재 문화권의 규칙을 사용 하는 문화권 구분 비교를 지정할 수 있습니다 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, 또는의 모든 멤버는 <xref:System.Globalization.CompareOptions> 이외의 다른 열거형 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 또는 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 를 적절 한 오버 로드는 <xref:System.String.Compare%2A> 메서드. 문화권 구분 비교는 서 수 비교 하는 반면 정렬에 대 한 일반적으로 적합 합니다. 서 수 비교는 일반적으로 두 문자열이 같은지 여부를 결정 하기 위한 적절 한 (즉, id 확인에 대 한) 문화권 구분 비교는 없습니다.  
  
 다음 예제에서는 문화권 구분 및 서 수 비교 차이점을 보여 줍니다. 이 예제에서는 세 개의 문자열, "Apple", "æ b l e" 및 "AEble"를 서 수 비교와 DA-DK 및 EN-US 문화권의 규칙을 사용 하 여 계산 (때 기본 문화권은 각각는 <xref:System.String.Compare%2A> 메서드는). 덴마크어 "Æ" 문자는 개별 문자로 처리는 알파벳의 "z" 정렬 하기 때문에 문자열 "æ b l e는" "Apple" 보다 큽니다. 그러나 "æ b l e" 간주 되지 않습니다 "AEble" 같음 "æ b l e" "AEble" 보다 큰 이기도 하므로. EN-US 문화권 "Æ" 문자를 포함 하지 않는 하지만 "ae" 이유 "æ b l e는" "Apple" 보다 작지만 "AEble" 같은 설명으로 처리 합니다. 서 수 비교는 반면에 "Apple" "æ b l e" 및 "æ b l e" "AEble" 보다 클 수 보다 작을 것으로 고려 합니다.  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 다음 일반 지침을 사용 하 여 적절 한 정렬 또는 문자열 비교 방법을 선택 하려면:  
  
-   순서를 지정할 수 있는 문자열을 사용자의 culture에 따라 하려는 경우 현재 문화권의 규칙에 따라를 주문 해야 합니다. 사용자의 문화권 변경 되는 경우 정렬 된 문자열의 순서도 그에 따라 변경 합니다. 예를 들어 동의어 사전 응용 프로그램 사용자의 culture에 따라 단어를 항상 정렬 해야 합니다.  
  
-   순서를 지정할 수 있는 문자열을 특정 문화권의 규칙에 따라 하려는 경우를 제공 하 여 정렬 해야 하는 <xref:System.Globalization.CultureInfo> 비교 메서드를 해당 문화권을 나타내는 개체입니다. 예를 들어 특정 언어 학생 방법을 응용 프로그램에서 원하는 문자열을 정렬할 익히면 해당 하는 문화권 중 하나의 규칙에 따라 합니다.  
  
-   문화권에 걸쳐 변경 되지 않을 문자열의 순서를 사용 하도록 하려는 경우에 고정 문화권의 규칙에 따라 정렬 하거나 서 수 비교를 사용 해야 합니다. 예를 들어 파일, 프로세스, 뮤텍스의 이름을 구성 하는 서 수 정렬 사용 또는 명명 된 파이프 합니다.  
  
-   보안 결정 (예: 사용자가 유효한 지 여부)를 포함 하는 비교를 위해 항상 수행 해야 같음에 대 한 서 수는 테스트의 오버 로드를 호출 하 여는 <xref:System.String.Equals%2A> 메서드.  
  
> [!NOTE]
>  문화권 구분 정렬 및 문자열 비교에 사용 되는 규칙을 대/소문자는.NET Framework의 버전에 따라 달라 집니다. .NET Framework에서 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 에서 실행 되는 [!INCLUDE[win8](~/includes/win8-md.md)] 유니코드 6.0 표준을 따르는 운영 체제, 정렬, 대/소문자 구분, 정규화 및 유니코드 문자 정보입니다. 다른 운영 체제에서 유니코드 5.0 표준을 준수합니다.  
  
 Word, 문자열 및 정렬 서 수 규칙에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 항목입니다. 각 규칙을 사용 하는 경우에 추가 권장 사항 참조 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md)합니다.  
  
 일반적으로 호출 하지 않으면 문자열 비교 방법와 같은 <xref:System.String.Compare%2A> 문자열의 정렬 순서를 결정 하는 직접 합니다. 와 같은 메서드를 정렬 하 여 비교 메서드는 호출 하는 대신 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 또는 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>합니다. 다음 예에서는 명시적으로 문자열 비교 메서드를 호출 하지 않고 네 가지 정렬 작업 (현재 문화권, 고정 문화권을 사용 하 여 단어 정렬, 서 수 정렬 및 고정 문화권을 사용 하 여 문자열 정렬을 사용 하 여 word 정렬)를 수행 합니다. 하지만 사용할 비교 유형을 지정 수행 합니다. 참고 각 유형의 정렬 배열에서 문자열의 고유한 순서를 생성 합니다.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  내부적으로.net Framework culturallysensitive 문자열 비교를 지원 하기 위해 정렬 키를 사용 합니다. 문자열의 각 문자에는 사전순, 대/소문자 및 분음 부호를 포함하여 여러 범주의 정렬 가중치가 적용됩니다. 정렬 키가 나타내는 <xref:System.Globalization.SortKey> 클래스, 특정 문자열에 대 한 이러한 가중치의 저장소를 제공 합니다. 응용 프로그램의 많은 수의 검색 또는 정렬 동일한 문자열 집합에 대 한 작업을 실행 하는 경우 생성 하 고 사용 하 여 모든 문자열에 대 한 정렬 키를 저장 하 여 성능을 향상 시킬 수 있습니다. 정렬 또는 비교 작업이 필요한 경우에 문자열 대신 정렬 키를 사용 합니다. 자세한 내용은 <xref:System.Globalization.SortKey> 클래스를 참조하세요.  
  
 문자열 비교 규칙을 지정 하지 않으면, 같은 정렬 메서드 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 문자열에서 문화권을 구분, 대/소문자 구분 정렬을 수행 합니다. 다음 예에서는 현재 문화권을 변경 하 배열에 정렬 된 문자열의 순서를 적용 하는 방법을 보여 줍니다. 세 문자열의 배열을 만듭니다. 우선 `System.Threading.Thread.CurrentThread.CurrentCulture` 속성을 "en-US"로 설정하고 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 메서드를 호출합니다. 결과 정렬 순서가 정렬 영어 (미국) 문화권에 대 한 규칙은 기반으로 합니다. 다음으로 예제에서는 `System.Threading.Thread.CurrentThread.CurrentCulture` 속성을 da-DK로 설정하고 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 메서드를 다시 호출합니다. 덴마크어(덴마크)의 정렬 규칙을 사용하는 경우 결과 정렬 순서가 en-US 결과와 어떻게 다른지 확인해 봅니다.  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  문자열 비교의 기본 용도 호출 해야 이러한 값이 같은지 여부를 결정 하는 경우는 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드. 일반적으로 사용 해야 <xref:System.String.Equals%2A> 서 수 비교를 수행 합니다. <xref:System.String.Compare%2A?displayProperty=nameWithType> 방법은 문자열 정렬 하는 데 주로 사용 됩니다.  
  
 와 같은 문자열 검색 메서드를 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 및 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 또한 문화권 구분 또는 서 수 문자열 비교를 수행할 수 있습니다. 다음 예제에서는 서 수와 문화권 구분 비교를 사용 하 여 차이 보여 줍니다.는 <xref:System.String.IndexOf%2A> 메서드. 현재 문화권의 영어 (미국) 문화권 구분 검색에서는 합자 "œ"와 일치 하도록 "oe" 하위 문자열을 고려 합니다. 하이픈이 (U + 00AD)는 너비가 0 인 문자 이기 때문에 검색 취급 동등 하 게 <xref:System.String.Empty> 문자열의 시작 부분에서 일치 하는 항목을 찾습니다. 서 수 검색을 사용 하는 반면에 찾을 수 없습니다 일치 하는 두 경우 모두.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>문자열 검색  
 와 같은 문자열 검색 메서드를 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 및 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 또한 문화권 구분을 수행할 수 있습니다 또는 지정된 된 문자열에 문자 또는 하위 문자열이 있는지 여부를 결정 하는 서 수 문자열 비교를 찾을 수 있습니다.  
  
 검색 메서드는 <xref:System.String> 와 같은 개별 문자를 검색 하는 클래스는 <xref:System.String.IndexOf%2A> 메서드 또는의 문자 집합 중 하나와 같은 <xref:System.String.IndexOfAny%2A> 메서드를 모든 서 수 검색을 수행 합니다. 문자에 대 한 문화권 구분 검색을 수행 하려면 호출 해야 합니다는 <xref:System.Globalization.CompareInfo> 메서드와 같은 <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 또는 <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>합니다. 참고 서 수와 문화권 구분 비교를 사용 하 여 문자에 대 한 검색 결과를 매우 달라질 수 있습니다. 합자 "Æ"와 같은 미리 구성 된 유니코드 문자에 대 한 검색 (U + 00 C 6) 해당 구성 요소가 올바른 순서로 "AE" 등의 모든 항목 수 일치 하는 예를 들어 (U + 041U + 0045) 문화권에 따라 합니다. 다음 예제에서는 차이점을 보여 줍니다.는 <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 개별 문자를 검색할 때 메서드. 합자 "æ" (U + 00E6)를 찾을 수는 문자열에 "항공" EN-US 문화권의 규칙을 사용 하는 경우 하지만 DA-DK 문화권의 규칙을 사용 하 여 때가 아니라 또는 서 수 비교를 수행 하는 경우.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 반면에 <xref:System.String> 검색할 문자가 아니라 문자열 검색 옵션 형식의 매개 변수를 통해 명시적으로 지정 하지 않은 경우 문화권 구분 검색을 수행 하는 메서드를 클래스 <xref:System.StringComparison>합니다. 유일한 예외는 <xref:System.String.Contains%2A>를 서 수 검색을 수행 하는 합니다.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>같음에 대 한 테스트  
 사용 하 여는 <xref:System.String.Compare%2A?displayProperty=nameWithType> 정렬 순서에서 두 문자열의 관계를 확인할 수 있습니다. 일반적으로 문화권 구분 작업입니다. 반면, 호출 된 <xref:System.String.Equals%2A?displayProperty=nameWithType> 같은지 테스트 하는 메서드. 같음에 대 한 테스트는 일반적으로 유효한 사용자 이름, 암호 또는 파일 시스템 경로 같은 몇 가지 알려진된 문자열을 사용 하 여 사용자 입력을 비교 되므로 일반적으로 서 작업 합니다.  
  
> [!WARNING]
>  호출 하 여 같음 여부를 테스트할 수는 <xref:System.String.Compare%2A?displayProperty=nameWithType> 메서드와 반환 값은 0이 있는지 여부를 결정 합니다. 그러나이 방법은 권장 되지 않습니다. 두 문자열이 같은지 여부를 확인 하려면 호출 해야 오버 로드 중 하나는 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드. 호출할 기본 오버 로드 되는 인스턴스 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 메서드 또는 정적 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드를 두 방법 모두 포함 되어 있으므로 <xref:System.StringComparison?displayProperty=nameWithType> 명시적으로 비교 유형을 지정 하는 매개 변수입니다.  
  
 다음 예제에서는 같음 경우 하나를 대신 사용 해야 하는 서 수에 대 한 문화권 구분 비교를 수행 하는 위험을 보여 줍니다. 이 경우 코드의 의도가 "FILE://" 문자열을 사용 하 여 URL 시작 하는 대/소문자 구분 비교를 수행 하 여 "FILE://" 또는 "file://"로 시작 하는 Url에서 파일 시스템 액세스를 금지 하는입니다. 그러나 터키어 (터키) 문화권 "file://"로 시작 하는 URL에서 사용 하 여 문화권 구분 비교 수행 되 같은지 비교 실패, 터키어 대문자 소문자 "i"는 "I" 대신 "İ" 이므로 합니다. 결과적으로, 파일 시스템 액세스 실수로 허용 됩니다. 반면에 서 수 비교에 같음 비교 성공 하 고 파일 시스템 액세스가 거부 됩니다.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>표준화  
 일부 유니코드 문자에 여러 표현이 있습니다. 예를 들어 다음 코드 포인트의 문자 "ắ"을 나타낼 수 있습니다.  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 단일 문자에 대 한 여러 표현을 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.  
  
 유니코드 표준 이진 표현을 해당 하는 이진 표현에 대 한 유니코드 문자를 반환 하는 정규화 라는 프로세스를 정의 합니다. 정규화에는 다양 한 규칙에 따라 정규화 형식 이라는 하는 여러 가지 알고리즘을 사용 합니다. .NET Framework는 유니코드 정규화 형식 C, D, KC 및 KD를 지원합니다. 문자열 정규화 동일한 형식으로 표준화 되었으므로 때 서 수 비교를 사용 하 여 비교할 수 있습니다.  
  
 서 수 비교는 해당 하는 유니코드 스칼라 값의 이진 비교 <xref:System.Char> 각 문자열에 있는 개체입니다. <xref:System.String> 클래스는 다양 한 다음을 포함 한 서 수 비교를 수행할 수 있는 메서드를 포함 합니다.  
  
-   오버 로드는 <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, 및 <xref:System.String.LastIndexOf%2A> 메서드를 포함 하는 <xref:System.StringComparison> 매개 변수입니다. 값을 제공 하는 경우이 메서드는 서 수 비교를 수행 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase> 이 매개 변수에 대 한 합니다.  
  
-   오버 로드는 <xref:System.String.CompareOrdinal%2A> 메서드.  
  
-   기본적으로 같은 서 수 비교를 사용 하는 메서드 <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, 및 <xref:System.String.Split%2A>합니다.  
  
-   검색 하는 메서드는 <xref:System.Char> 값 또는 요소에 대 한는 <xref:System.Char> 문자열 인스턴스의 배열입니다. 이러한 메서드에 <xref:System.String.IndexOf%28System.Char%29> 및 <xref:System.String.Split%28System.Char%5B%5D%29>합니다.  
  
 호출 하 여 문자열을 정규화 형식 C 정규화 되는지 여부를 확인할 수 있습니다는 <xref:System.String.IsNormalized?displayProperty=nameWithType> 하거나 메서드를 호출할 수는 <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 문자열에 지정 된 정규화 형식인 정규화 되는지 여부를 결정 하는 메서드. 호출할 수도 있습니다는 <xref:System.String.Normalize?displayProperty=nameWithType> 정규화 형식 C에 문자열을 변환 하는 메서드를 호출할 수는 <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 지정한 정규화 형식 문자열로 변환 하는 메서드입니다. 정규화 및 문자열 비교 하는 방법에 대 한 단계별 정보를 참조 하십시오.는 <xref:System.String.Normalize> 및 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 메서드.  
  
 다음의 간단한 예제에서는 문자열 정규화를 보여 줍니다. 세 개의 서로 다른 문자열에 세 가지 방법으로 "ố" 문자를 정의 하 고 같음에 대 한 서 수 비교를 사용 하 여 각 문자열이 다른 두 개의 문자열에서 다른 것을 결정 합니다. 그런 다음 지원 되는 정규화 형식으로 각 문자열을 변환 하 고 다시 지정 된 정규화 형식인 각 문자열의 서 수 비교를 수행 합니다. 같음에 대 한 두 번째 테스트 각각의 경우에는 문자열이 동일 하다 보여 줍니다.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 정규화 및 정규화 형식에 대 한 자세한 내용은 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>,으로 [Unicode Standard Annex #15: 유니코드 정규화 형식](https://unicode.org/reports/tr15/) 및 [정규화 FAQ](https://www.unicode.org/faq/normalization.html) 에 unicode.org 웹 사이트입니다.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>범주별으로 문자열 작업  
 <xref:System.String> 문자열이 문자 또는 복사 하는 문자열 값의 서식 지정 문자열 결합 하는 문자열에서 부분 문자열을 추출 하는 문자열을 수정 하는 문자열의 부분 문자열을 찾는 같은지 테스트 문자열 비교를 위한 멤버를 제공 하는 클래스 및 문자열을 정규화 합니다.  
  
### <a name="comparing-strings"></a>문자열 비교  
 다음을 사용 하 여 정렬 순서에서의 상대 위치를 결정 하는 문자열을 비교할 수 <xref:System.String> 메서드:  
  
-   <xref:System.String.Compare%2A> 정렬 순서에서 두 번째 문자열을 하나의 문자열로의 관계를 나타내는 정수를 반환 합니다.  
  
-   <xref:System.String.CompareOrdinal%2A> 코드 포인트 비교를 기반으로 하는 두 번째 문자열을 하나의 문자열로의 관계를 나타내는 정수를 반환 합니다.  
  
-   <xref:System.String.CompareTo%2A> 정렬 순서에서 두 번째 문자열을 현재 문자열 인스턴스 관계를 나타내는 정수를 반환 합니다. <xref:System.String.CompareTo%28System.String%29> 메서드는 제공 된 <xref:System.IComparable> 및 <xref:System.IComparable%601> 에 대 한 구현을 <xref:System.String> 클래스.  
  
### <a name="testing-strings-for-equality"></a>문자열이 같은지를 테스트합니다.  
 호출 하는 <xref:System.String.Equals%2A> 메서드를 두 문자열이 같은지 여부를 확인 합니다. 인스턴스 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 및 정적 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 오버 로드를 통해 문화권을 구분 또는 서 수 비교 인지 및 대/소문자 고려 또는 무시 여부를 지정할 수 있습니다. 같음에 대 한 대부분의 테스트는 서 수 이며 및 시스템 리소스 (예: 파일 시스템 개체)에 대 한 액세스를 결정 하는 같음 비교 항상 서 수 여야 합니다.  
  
### <a name="finding-characters-in-a-string"></a>문자열에서 문자를 찾는  
 <xref:System.String> 클래스는 두 종류의 검색 메서드를 포함 합니다.  
  
-   반환 하는 메서드는 <xref:System.Boolean> 를 특정 하위 문자열이 문자열 인스턴스에서 있는지 여부를 나타내는 값입니다. 여기에 <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, 및 <xref:System.String.StartsWith%2A> 메서드.  
  
-   문자열 인스턴스에서 부분 문자열의 시작 위치를 나타내는 메서드. 여기에 <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, 및 <xref:System.String.LastIndexOfAny%2A> 메서드.  
  
> [!WARNING]
>  특정 부분 문자열 보다는 특정 패턴에 대 한 문자열을 검색 하려는 경우 정규식을 사용 해야 합니다. 자세한 내용은 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md)을 참조하세요.  
  
### <a name="modifying-a-string"></a>문자열을 수정합니다.  
 <xref:System.String> 클래스는 문자열 값을 수정 하는 다음 메서드를 포함 합니다.  
  
-   <xref:System.String.Insert%2A> 현재 문자열 삽입 <xref:System.String> 인스턴스.  
  
-   <xref:System.String.PadLeft%2A> 문자열의 시작 부분에 하나 이상의 지정 된 문자를 삽입합니다.  
  
-   <xref:System.String.PadRight%2A> 문자열의 끝에 하나 이상의 지정 된 문자를 삽입합니다.  
  
-   <xref:System.String.Remove%2A> 현재에서 부분 문자열을 삭제 <xref:System.String> 인스턴스.  
  
-   <xref:System.String.Replace%2A> 현재에서 다른 하위 문자열로 하위 문자열 대체 <xref:System.String> 인스턴스.  
  
-   <xref:System.String.ToLower%2A> 및 <xref:System.String.ToLowerInvariant%2A> 문자열의 모든 문자를 소문자로 변환 합니다.  
  
-   <xref:System.String.ToUpper%2A> 및 <xref:System.String.ToUpperInvariant%2A> 문자열에 있는 모든 문자를 대문자로 변환 합니다.  
  
-   <xref:System.String.Trim%2A> 모든 문자를 문자열의 시작과 끝에서 제거 합니다.  
  
-   <xref:System.String.TrimEnd%2A> 모든 문자를 문자열의 끝에서 제거합니다.  
  
-   <xref:System.String.TrimStart%2A> 모든 문자를 문자열의 시작 부분에서 제거합니다.  
  
> [!IMPORTANT]
>  모든 문자열 수정 메서드가 반환 새 <xref:System.String> 개체입니다. 현재 인스턴스의 값을 수정 하지 마십시오.  
  
### <a name="extracting-substrings-from-a-string"></a>문자열에서 부분 문자열을 추출합니다.  
 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드는 여러 문자열으로 단일 문자열을 구분 합니다. 메서드의 오버 로드를 사용 하면 메서드를 추출 하는 부분 문자열의 최대 수를 확인 하 고 빈 문자열 (구분 기호는 인접 한 경우)는 반환 된 문자열 중에서 포함 되는지 여부를 결정 하 여러 개의 구분 기호를 지정할 수 있도록 합니다.  
  
### <a name="combining-strings"></a>문자열 결합  
 다음 <xref:System.String> 메서드 문자열 연결에 사용할 수 있습니다.  
  
-   <xref:System.String.Concat%2A> 하나 이상의 부분 문자열을 단일 문자열로 결합합니다.  
  
-   <xref:System.String.Join%2A> 단일 요소에 하나 이상의 부분 문자열을 연결 하 고 각 부분 문자열 사이 구분 기호를 추가 합니다.  
  
### <a name="formatting-values"></a>값의 서식 지정  
 <xref:System.String.Format%2A?displayProperty=nameWithType> 메서드는 일부 개체 또는 값의 문자열 표현으로 문자열에서 하나 이상의 자리 표시자를 바꾸려면 합성 서식 지정 기능을 사용 합니다. <xref:System.String.Format%2A> 메서드는 다음을 수행 하는 데 자주 사용 됩니다.  
  
-   문자열에 숫자 값의 문자열 표현을 포함 합니다.  
  
-   문자열의 날짜 및 시간 값의 문자열 표현을 포함 합니다.  
  
-   문자열에서 열거형 값의 문자열 표현을 포함 합니다.  
  
-   지 원하는 일부 개체의 문자열 표현을 포함 하는 <xref:System.IFormattable> 문자열에 대 한 인터페이스입니다.  
  
-   오른쪽 맞춤 또는 더 큰 문자열 내에서 필드의 하위 문자열을 왼쪽으로 정렬 합니다.  
  
 작업 및 예제 서식 지정 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.String.Format%2A> 요약 오버 로드 합니다.  
  
### <a name="copying-a-string"></a>문자열 복사  
 다음을 호출할 수 있습니다 <xref:System.String> 문자열의 복사본을 만드는 방법:  
  
-   <xref:System.String.Clone%2A> 기존에 대 한 참조를 반환 <xref:System.String> 개체입니다.  
  
-   <xref:System.String.Copy%2A> 기존 문자열의 복사본을 만듭니다.  
  
-   <xref:System.String.CopyTo%2A> 문자열의 일부가 문자 배열에 복사합니다.  
  
### <a name="normalizing-a-string"></a>문자열 정규화  
 유니코드, 단일 문자 코드 포인트를 여러 개 있을 수 있습니다. 정규화 같은 이진 표현에 해당 하는 이러한 문자를 변환합니다. <xref:System.String.Normalize%2A?displayProperty=nameWithType> 메서드 정규화, 수행 및 <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> 메서드 문자열 정규화 되는지 여부를 확인 합니다.  
  
 자세한 내용 및 예제에 대 한 참조는 [정규화](#Normalization) 이 항목의 앞부분에 나오는 섹션.  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 섹션 내용  
  
 [오버 로드 된 생성자 구문](#Syntax)   
 [매개 변수](#Params)   
 [예외](#Exceptions)   
 [어떤 방법을 호출할 수 있습니까?](#Tasks)   
 [문자열 만들기](#Creating_Strings)   
 [반복적인 문자열 처리](#Repetitive)   
 인스턴스화하는 동안 문자열의 예:   
 [문자열 할당 사용](#Ctor1_Example)  
 [문자 배열을 사용 하 여](#Ctor2_Example)  
 [문자 배열의 일부를 사용 하 고 단일 문자를 반복 합니다.](#Ctor3_Example)  
 [문자 배열에 대 한 포인터를 사용 하 여](#Ctor4_Example)  
 [포인터가 되 고 배열 범위를 사용 하 여](#Ctor5_Example)  
 [부호 있는 바이트 배열에 대 한 포인터를 사용 하 여](#Ctor6_Example)  
[버전 정보](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>오버 로드 된 생성자 구문  
 두 가지 범주로 나뉩니다 문자열 생성자: 포인터 매개 변수 없이 포인터 매개 변수를 사용 합니다. 포인터를 사용 하는 생성자는 CLS 규격이 아닙니다. 또한 Visual Basic 포인터의 사용을 지원 하지 않습니다 및 C# 코드 포인터를 사용 하 여 안전 하지 않은 컨텍스트에서 실행 하는 필요 합니다. 자세한 내용은 [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)를 참조하세요.  
  
 오버 로드를 선택 하는 방법 추가 지침을 참조 하세요. [방법을 호출 수행 합니까?](#Tasks)  
  
 `String(Char[] value)`  
 유니코드 문자 배열에서 나타내는 값으로 새 인스턴스를 초기화 합니다. 이 생성자는 유니코드 문자를 복사 ([예제](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 이 고 길이 해당 배열 내의 시작 문자 위치는 유니코드 문자의 배열에서 나타내는 값으로 새 인스턴스를 초기화 합니다 ([예제](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 지정 된 유니코드 문자로 표시 된 값으로 새 인스턴스를 초기화 합니다. 지정 된 횟수 만큼 반복 ([예제](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(CLS 규격이 아닙니다.) ** Null 문자로 끝나는 유니코드 문자 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다 (U + 0000 또는 '\0'). ([예제](#Ctor4_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(CLS 규격이 아닙니다.) ** 길이 및 해당 배열 내의 시작 문자 위치, 유니코드 문자 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다. 생성자에서 유니코드 문자를 복사 `value` 인덱스에서 시작 `startIndex` 인덱스에서 끝나는 `startIndex`  +  `length` – 1 ([예제](#Ctor5_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(SByte* value)`  
 **(CLS 규격이 아닙니다.) ** 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다. 현재 시스템 코드 페이지를 사용 하 여 인코딩된 문자열을 나타내도록 배열 가정 됩니다 (즉, 지정한 인코딩을 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). 문자를 처리 하는 생성자 `value` null 문자 (0x00)에 도달할 때까지 포인터에 의해 지정 된 위치에서 시작 ([예제](#Ctor6_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(CLS 규격이 아닙니다.) ** 길이 및 해당 배열 내의 시작 위치, 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다.  현재 시스템 코드 페이지를 사용 하 여 인코딩된 문자열을 나타내도록 배열 가정 됩니다 (즉, 지정한 인코딩을 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). 시작 하는 값에서 문자를 처리 하는 생성자 `startIndex` 에서 끝나는 `startIndex`  +  `length` – 1 ([예제](#Ctor6_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(CLS 규격이 아닙니다.) ** 길이, 해당 배열 내의 시작 위치를 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 및 <xref:System.Text.Encoding> 개체입니다.  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
<a name="Params"></a>   
## <a name="parameters"></a>매개 변수  
 사용 하는 매개 변수의 전체 목록은 다음과 같습니다 <xref:System.String> 포인터 매개 변수를 포함 하지 않는 생성자입니다. 각 오버 로드에서 사용 하는 매개 변수를 위 구문 오버 로드를 참조 하십시오.  
  
|매개 변수|형식|설명|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|유니코드 문자 배열입니다.|  
|`c`|<xref:System.Char>|유니코드 문자입니다.|  
|`startIndex`|<xref:System.Int32>|시작 위치 `value` 새 문자열의 첫 번째 문자입니다.<br /><br /> 기본 값: 0|  
|`length`|<xref:System.Int32>|에 있는 문자의 수 `value` 새 문자열에 포함 하도록 합니다.<br /><br /> 기본값: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|문자 시간 단위로 `c` 새 문자열에서 반복 됩니다. 경우 `count` 가 0 인 새 개체의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.|  
  
 사용 하는 매개 변수의 전체 목록은 다음과 같습니다 <xref:System.String> 포인터 매개 변수를 포함 하는 생성자입니다. 각 오버 로드에서 사용 하는 매개 변수를 위 구문 오버 로드를 참조 하십시오.  
  
|매개 변수|형식|설명|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> 또는<br /><br /> <xref:System.SByte>\*|유니코드 문자의 null로 끝나는 배열 또는 8 비트 부호 있는 정수 배열에 대 한 포인터입니다. 경우 `value` 은 `null` 이거나 빈 배열이 면 새 문자열의 값이 <xref:System.String.Empty?displayProperty=nameWithType>합니다.|  
|`startIndex`|<xref:System.Int32>|새 문자열의 첫 번째 문자를 정의 하는 배열 요소의 인덱스입니다.<br /><br /> 기본 값: 0|  
|`length`|<xref:System.Int32>|새 문자열을 만드는 데 사용 되는 배열 요소의 수입니다. 생성자는 값이 문자열로 만듭니다 길이가 0 인 경우 <xref:System.String.Empty?displayProperty=nameWithType>합니다.<br /><br /> 기본값: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|지정 하는 개체는 어떻게 `value` 배열 인코딩됩니다.<br /><br /> 기본값: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, 또는 시스템의 현재 ANSI 코드 페이지|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>예외  
 포인터 매개 변수를 포함 하지 않는 생성자에서 throw 된 예외 목록은 다음과 같습니다.  
  
|예외|조건|throw|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value`가 `null`인 경우|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex``length`, 또는 `count` 가 0 보다 작습니다.<br /><br /> 또는<br /><br /> `startIndex`와 `length`의 합계가 `value`에 포함된 요소의 수보다 큰 경우<br /><br /> 또는<br /><br /> `count`가 0보다 작은 경우|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 포인터 매개 변수를 포함 하는 생성자에서 throw 된 예외 목록은 다음과 같습니다.  
  
|예외|조건|throw|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` 잘못 된 유니코드 문자가 포함 된 배열을 지정 합니다.<br /><br /> 또는<br /><br /> `value` 또는 `value`  +  `startIndex` 64k 미만 되는 주소를 지정 합니다.<br /><br /> 또는<br /><br /> 새 <xref:System.String> 에서 인스턴스를 초기화 하지 못했습니다 된 `value` 바이트 배열 `value` 기본 코드 페이지 인코딩을 사용 하지 않습니다.|포인터를 사용 하는 모든 생성자|  
|<xref:System.ArgumentNullException>|`value`가 null인 경우|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|현재 프로세스에 주소가 지정된 모든 문자에 대한 읽기 액세스 권한이 있는 것은 아닙니다.<br /><br /> 또는<br /><br /> `startIndex` 또는 `length`가 0보다 작거나 `value` + `startIndex`로 인해 포인터 오버플로가 발생하거나, 현재 프로세스에서 주소가 지정된 모든 문자에 대한 읽기 액세스 권한을 갖지는 않습니다.<br /><br /> 또는<br /><br /> 새 문자열의 길이가 너무 커서 할당할 수 있습니다.|포인터를 사용 하는 모든 생성자|  
|<xref:System.AccessViolationException>|`value`또는 `value`  +  `startIndex`  +  `length` – 1, 잘못 된 주소를 지정 합니다.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>어떤 방법을 호출할 수 있습니까?  
  
|대상|호출 또는 사용|  
|--------|-----------------|  
|문자열을 만듭니다.|문자열 리터럴 또는 기존 문자열의 할당 ([예제](#Ctor1_Example))|  
|전체 문자 배열에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([예제](#Ctor2_Example))|  
|문자 배열의 일부에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([예제](#Ctor3_Example))|  
|같은 문자를 여러 번 반복 되는 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([예제](#Ctor3_Example))|  
|유니코드 또는 와이드 문자 배열에 대 한 포인터에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|포인터를 사용 하 여 일부 유니코드 또는 와이드 문자 배열에서에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|C + +에서 문자열을 만드는 `char` 배열입니다.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> 또는<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|ASCII 문자에서 문자열을 만듭니다.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>문자열 만들기  
 가장 일반적으로 사용 되는 기술을 단순 할당은 문자열을 프로그래밍 방식으로 만들기에 설명 된 대로 [이 예제](#Ctor1_Example)합니다. <xref:System.String> 클래스 생성자 오버 로드에서 다음 값 문자열을 만들 수 있는 네 가지 유형의 포함 되어 있습니다.  
  
-   문자 배열 (u t F-16으로 인코딩된 문자 배열)입니다. 새를 만들 수 있습니다 <xref:System.String> 개체에서 배열 전체 또는 일부에 있는 문자입니다. <xref:System.String.%23ctor%28System.Char%5B%5D%29> 생성자 새 문자열을 배열에 있는 모든 문자를 복사 합니다. <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자는 문자 인덱스에서 복사 `startIndex` 인덱스로 `startIndex`  +  `length` – 새 문자열을 1입니다. 경우 `length` 가 0 인 새 문자열의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
     코드에 동일한 값을 가진 문자열 반복 해 서 인스턴스화할 경우 문자열을 작성 하는 대체 방법을 사용 하 여 응용 프로그램의 성능을 개선할 수 있습니다. 자세한 내용은 참조 [반복적인 문자열 처리](#Repetitive)합니다.  
  
-   단일에서 문자 즉, 한 번 이상를 사용 하 여 중복 된 0은 <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> 생성자입니다. 경우 `count` 가 0 인 새 문자열의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
-   Null로 끝나는 문자 배열에 대 한 포인터에서 사용 하 여는 <xref:System.String.%23ctor%28System.Char%2A%29> 또는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자입니다. 전체 배열 또는 지정된 된 범위 수 데 사용할 문자열을 초기화 합니다. 생성자는 지정된 된 포인터가 더하기 또는 지정된 된 포인터에서 시작 하는 유니코드 문자 시퀀스로 복사 `startIndex` 또는 배열의 끝까지 계속 `length` 문자입니다. 경우 `value` 가 null 포인터 또는 `length` 0 이면 생성자의 값이 문자열을 만듭니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 배열의 끝에 복사 작업을 진행 하 고 null로 끝나는 배열 하지 않는 경우 생성자 동작은 시스템에 따라 다릅니다. 이러한 조건을 액세스 위반이 발생할 수 있습니다.  
  
     배열에 포함 된 null 문자가 포함 된 경우 (U + 0000 또는 '\0')와 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드를 호출한, 포함 된 문자열 인스턴스 `length` 문자를 포함 하 여 null 값을 포함 합니다. 다음 예제에서는 두 개의 null 문자를 포함 하는 10 개 요소의 배열에 대 한 포인터에 전달 될 때 어떤 일이 생기는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 메서드. 주소는 배열의 시작이 고 배열의 모든 요소는 문자열에 추가할 때문에 생성자 내장된 된 null이 두 가지를 포함 하 여 10 개의 문자로 이루어진 문자열을 인스턴스화합니다. 반면, 같은 배열을 전달 하는 경우에 <xref:System.String.%23ctor%28System.Char%2A%29> 생성자의 결과 첫 번째 null 문자를 포함 하지 않는 4 자의 문자열입니다.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     유니코드 문자 배열에 포함 되어야 합니다. C + +에서는이 되어야 함을 의미 하는 문자열 배열에서 관리 되는 것으로 정의 하거나 <xref:System.Char>형식 또는 관리 되지 않는`wchar_t`형식입니다.  
  
     경우는 <xref:System.String.%23ctor%28System.Char%2A%29> 오버 로드는 호출 되 고 null로 끝나는 배열은 있지 않습니다 또는 경우에는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드를 호출한 및 `startIndex`  +  `length`문자의 시퀀스에 할당 된 메모리 외부 범위를 포함 하는-1 생성자의 동작은 시스템 종속적 이며 액세스 위반이 발생할 수 있습니다. 또한 Intel Itanium 프로세서에 대 한 호출이 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자 throw 될 수 있습니다는 <xref:System.DataMisalignedException> 예외입니다. 이 경우 호출 된 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 대신 합니다.  
  
-   부호 있는 바이트 배열에 대 한 포인터입니다. 전체 배열 또는 지정된 된 범위 수 데 사용할 문자열을 초기화 합니다. 인코딩, 기본 코드 페이지를 사용 하 여 바이트 시퀀스를 해석할 수 있습니다 또는 생성자 호출에 인코딩을 지정할 수 있습니다. 생성자를 null로 종결 되지 않은 전체 배열에서 문자열을 인스턴스화하려고 하면 또는 경우에서 배열의 범위를 `value`  +  `startIndex` 를 `value`  +  `startIndex`  +  `length` 배열에 할당 된 메모리 외에-1은,이 생성자의 동작은 시스템에 따라 다름 및 액세스 위반이 발생할 수 있습니다.  
  
     부호 있는 바이트 배열을 매개 변수로 포함 하는 세 명의 생성자는 c + +를 변환 하는 데 주로 만들어진 `char` 이 예제에 표시 된 대로 문자열로 배열:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     값이 0 인 모든 null 문자 ('\0') 또는 바이트 배열에 들어 있으면 및 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드를 호출한, 포함 된 문자열 인스턴스 `length` 문자를 포함 하 여 null 값을 포함 합니다. 다음 예제에서는 두 개의 null 문자를 포함 하는 10 개 요소의 배열에 대 한 포인터에 전달 될 때 어떤 일이 생기는 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 메서드. 주소는 배열의 시작이 고 배열의 모든 요소는 문자열에 추가할 때문에 생성자 내장된 된 null이 두 가지를 포함 하 여 10 개의 문자로 이루어진 문자열을 인스턴스화합니다. 반면, 같은 배열을 전달 하는 경우에 <xref:System.String.%23ctor%28System.SByte%2A%29> 생성자의 결과 첫 번째 null 문자를 포함 하지 않는 4 자의 문자열입니다.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     때문에 <xref:System.String.%23ctor%28System.SByte%2A%29> 및 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자 해석 `value` 기본 ANSI 코드 페이지를 사용 하 여 동일한 바이트 배열이 포함 된 이러한 생성자를 호출 만들 수 있습니다 다른 시스템에서 다른 값이 있는 문자열입니다.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>반복적인 문자열 처리  
 구문 분석 하거나 자주 텍스트 스트림을 디코딩하는 앱에서 사용 하는 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자 또는 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자의 시퀀스를 문자열로 변환 하는 메서드. 만들기 및 단일 문자열을 다시 사용 하는 대신 같은 값을 갖는 새 문자열을 반복 해 서 만들기 메모리가 낭비 됩니다. 동일한 문자열 값을 반복적으로 호출 하 여 만들 수 있는 경우는 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자에서 알 수 없는 경우에 이동할 수 있는 이러한 동일한 문자열 값, 조회 테이블을 대신 사용할 수 있습니다.  
  
 예를 들어 읽고 XML 태그 및 특성을 포함 하는 파일에서 문자 스트림을 구문 분석 합니다. 스트림 구문 분석 하 여, 특정 토큰 (즉, 기호화 된 의미를 갖는 문자 시퀀스)이 반복적으로 발생 합니다. 문자열 "0", "1", "true" 및 "false"에 해당 하는 토큰이 XML 스트림에서 자주 발생할 수 있습니다.  
  
 각 토큰 새 문자열을 변환 하는 대신 만들 수는 <xref:System.Xml.NameTable?displayProperty=nameWithType> 일반적으로 발생 하는 문자열을 저장 하는 개체입니다. <xref:System.Xml.NameTable> 개체 임시 메모리를 할당 하지 않고 저장 된 문자열을 검색 하므로 성능이 향상 됩니다. 사용 하 여 토큰을 발견할 때는 <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 테이블에서 토큰을 검색 하는 메서드입니다. 토큰이 있으면 메서드는 해당 문자열을 반환 합니다. 토큰이 존재 하지 않는 경우 사용 하 여는 <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 토큰 테이블에 삽입 하 고 메서드를 해당 문자열을 가져올 수 있습니다.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>예제 1: 문자열 할당 사용  
 다음 예제에서는 문자열 리터럴을 할당 하 여 새 문자열을 만듭니다. 첫 번째 문자열의 값을 할당 하 여 두 번째 문자열을 만듭니다. 인스턴스화하는 새로운 두 개의 가장 일반적인 방법은 다음과 같습니다 <xref:System.String> 개체입니다.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>예제 2:를 사용 하는 문자 배열  
 다음 예제에서는 새로 만들려면 <xref:System.String> 는 문자 배열에서 개체입니다.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>예제 3: 문자 배열의 일부를 사용 하 고 단일 문자를 반복 합니다.  
 다음 예제에서는 새로 만들려면 <xref:System.String> 는 문자 배열 및 새 하는 방법의 부분에서 개체 <xref:System.String> 단일 문자를 여러 번 포함 된 개체입니다.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>문자 배열에 대 한 포인터를 사용 하는 예 4:  
 다음 예제에서는 새로 만들려면 <xref:System.String> 문자의 배열에 대 한 포인터에서 개체입니다. C# 예제를 사용 하 여 컴파일해야 합니다.는 `/unsafe` 컴파일러 스위치입니다.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>예 5: 인스턴스화는 포인터가 되 고 배열 범위에서 문자열  
 다음 예제에서는 마침표 또는 느낌표 문자 배열의 요소를 검사합니다. 가 있는 경우 문장 부호 기호가 앞에 있는 배열에 문자에서 문자열을 인스턴스화합니다. 그렇지 않으면 배열의 전체 내용으로 문자열을 인스턴스화합니다. C# 예제를 사용 하 여 컴파일해야는 `/unsafe` 컴파일러 스위치입니다.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>예 6: 인스턴스화는 부호 있는 바이트 배열에 대 한 포인터에서 문자열  
 다음 예제에서는의 인스턴스를 만드는 방법을 보여 줍니다.는 <xref:System.String> 클래스와 <xref:System.String.%23ctor%28System.SByte%2A%29> 생성자입니다.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>버전 정보  
 .NET Framework  
 모든 오버 로드에서 지원 됩니다: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 모든 오버 로드에서 지원 됩니다: 4, 3.5 SP1  
  
 이식 가능한 클래스 라이브러리  
 없이 모든 오버 로드는 <xref:System.SByte> `*` 매개 변수를 지원  
  
 Windows 스토어 앱용 .NET  
 없이 모든 오버 로드는 <xref:System.SByte> `*` 매개 변수에서 지원 됩니다: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">null로 끝나는 유니코드 문자 배열에 대한 포인터입니다.</param>
        <summary>유니코드 문자 배열에 대한 지정된 포인터가 가리키는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 프로세스에 주소가 지정된 모든 문자에 대한 읽기 액세스 권한이 있는 것은 아닙니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />에 잘못된 유니코드 문자가 들어 있는 배열이 지정되거나 <paramref name="value" />에 64000보다 작은 주소가 지정된 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">유니코드 문자 배열입니다.</param>
        <summary>유니코드 문자 배열에서 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">null로 끝나는 8비트 부호 있는 정수 배열에 대한 포인터입니다. 정수는 현재 시스템 코드 페이지 인코딩(즉, <see cref="P:System.Text.Encoding.Default" />로 지정된 인코딩)을 사용하여 해석됩니다.</param>
        <summary>8비트 부호 있는 정수 배열에 대한 포인터가 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />가 ANSI로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" />의 null 종결 문자로 결정되는 초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />가 잘못된 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">유니코드 문자입니다.</param>
        <param name="count">
          <c>c</c>가 발생하는 횟수입니다.</param>
        <summary>지정한 횟수만큼 반복되는 지정된 유니코드 문자가 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">유니코드 문자 배열에 대한 포인터입니다.</param>
        <param name="startIndex">
          <c>값</c> 내의 시작 위치입니다.</param>
        <param name="length">
          <c>value</c> 내에서 사용할 문자의 수입니다.</param>
        <summary>유니코드 문자 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 문자 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작거나 <paramref name="value" /> + <paramref name="startIndex" />로 인해 포인터 오버플로가 발생하거나, 현재 프로세스에서 주소가 지정된 모든 문자에 대한 읽기 액세스 권한을 갖지는 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />는 잘못된 유니코드 문자가 포함된 배열을 지정하거나 <paramref name="value" /> + <paramref name="startIndex" />가 64000보다 작은 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">유니코드 문자 배열입니다.</param>
        <param name="startIndex">
          <c>값</c> 내의 시작 위치입니다.</param>
        <param name="length">
          <c>value</c> 내에서 사용할 문자의 수입니다.</param>
        <summary>유니코드 문자 배열에서 나타내는 값, 해당 배열 내의 시작 문자 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" />와 <paramref name="length" />의 합계가 <paramref name="value" />의 요소 수보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">8비트 부호 있는 정수에 대한 포인터입니다. 정수는 현재 시스템 코드 페이지 인코딩(즉, <see cref="P:System.Text.Encoding.Default" />로 지정된 인코딩)을 사용하여 해석됩니다.</param>
        <param name="startIndex">
          <c>값</c> 내의 시작 위치입니다.</param>
        <param name="length">
          <c>value</c> 내에서 사용할 문자의 수입니다.</param>
        <summary>8비트 부호 있는 정수 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  -또는-  <paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 현재 플랫폼에 비해 너무 큽니다. 즉, 주소 계산이 오버플로됩니다.  -또는-  초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 64K 미만입니다.  -또는-  <paramref name="value" />가 ANSI로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> 및 <paramref name="length" />가 전체적으로 잘못된 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">8비트 부호 있는 정수에 대한 포인터입니다.</param>
        <param name="startIndex">
          <c>값</c> 내의 시작 위치입니다.</param>
        <param name="length">
          <c>value</c> 내에서 사용할 문자의 수입니다.</param>
        <param name="enc">
          <c>value</c>에서 참조하는 배열이 인코딩되는 방법을 지정하는 개체입니다. <c>enc</c>가 <see langword="null" />이면 ANSI 인코딩으로 간주됩니다.</param>
        <summary>8비트 부호 있는 정수 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 문자 위치, 길이 및 <see cref="T:System.String" /> 개체로 <see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  -또는-  <paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 현재 플랫폼에 비해 너무 큽니다. 즉, 주소 계산이 오버플로됩니다.  -또는-  초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 64K 미만입니다.  -또는-  <paramref name="value" />가 <paramref name="enc" />로 지정된 대로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> 및 <paramref name="length" />가 전체적으로 잘못된 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">현재 문자열의 위치입니다.</param>
        <summary>현재 <see cref="T:System.Char" /> 개체에서 지정된 문자 위치에 있는 <see cref="T:System.String" /> 개체를 가져옵니다.</summary>
        <value>
          <paramref name="index" /> 위치에 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` 매개 변수는 0부터 시작 합니다.  
  
 이 속성은 반환 된 <xref:System.Char> 로 지정 된 위치에 개체는 `index` 매개 변수. 하지만 개 이상의 유니코드 문자 표현 될 수 있습니다 <xref:System.Char>합니다. 사용 하 여는 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 유니코드를 사용 하는 클래스 문자 대신 <xref:System.Char> 개체입니다. 자세한 내용은의 "개체 및 유니코드 문자 Char" 섹션을 참조는 <xref:System.String> 클래스 개요입니다.  
  
 C#에서 <xref:System.String.Chars%2A> 속성 인덱서입니다. Visual basic에서은의 기본 속성은 <xref:System.String> 클래스입니다. 각 <xref:System.Char> 다음과 같은 코드를 사용 하 여 문자열에서 개체를 액세스할 수 있습니다.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 다음 예제에서는 문자열로 유효성을 검사 하는 루틴에이 인덱서를 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />가 이 개체의 길이보다 크거나 같거나 0보다 작습니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.String" />의 이 인스턴스에 대한 참조를 반환합니다.</summary>
        <returns>이 <see cref="T:System.String" />의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값이이 인스턴스에;의 독립 복사본 동일한 데이터의 다른 단순히 뷰입니다. 사용 하 여는 <xref:System.String.Copy%2A> 또는 <xref:System.String.CopyTo%2A> 메서드를 별도 <xref:System.String> 이 인터페이스와 동일한 값을 가진 개체입니다.  
  
 때문에 <xref:System.String.Clone%2A> 직접 호출할 필요가 거의 메서드는 기존 문자열 인스턴스를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Compare%2A> 메서드의 모든 오버로드는 두 비교 대상 간의 어휘 관계를 나타내는 부호 있는 32비트 정수를 반환합니다.  
  
|값|조건|  
|-----------|---------------|  
|0보다 작음|첫 번째 부분 문자열 정렬 순서에서 두 번째 부분 문자열 앞에 옵니다.|  
|0|부분 문자열이 정렬 순서에서 같은 위치에 나오거나 `length`가 0인 경우|  
|0보다 큼|첫 번째 부분 문자열 정렬 순서에서 두 번째 부분 문자열을 따릅니다.|  
  
> [!WARNING]
>  가능한 경우 항상 오버 로드를 호출 해야는 <xref:System.String.Compare%2A> 메서드를 포함 하는 <xref:System.StringComparison> 매개 변수입니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0 보다 작음  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 "file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Compare%28System.String%2CSystem.String%29> 메서드를 세 개의 문자열을 비교 합니다.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 다음 예제에서는 `ReverseStringComparer` 클래스와 두 개의 문자열을 계산 하는 방법을 보여 줍니다.는 <xref:System.String.Compare%2A> 메서드.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.String)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어, 다음 코드에서 실행 되는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물"와 "ani 메일" (소프트 하이픈 또는 U + 00AD 사용)의 문화권 구분 비교 두 문자열은 해당을 나타냅니다.  [! 코드 csharp [System.String.Compare#21] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.Compare/cs/compare21.cs#21)] [! vb 코드 [System.String.Compare#21] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.Compare/vb/compare21.vb#21)] 호출의 문자열 비교를 무시할 수 있는 문자를 인식 하는 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드 중 하나의 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 'comparisonType' 매개 변수에 대 한 합니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체를 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0 보다 작음  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 "file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 다음 예제에서는 하는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> 사용 하는 것과 같습니다 <xref:System.String.ToUpper%2A> 또는 <xref:System.String.ToLower%2A> 문자열을 비교할 때.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어, 다음 코드에서 실행 되는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물"와 "Ani 메일" (소프트 하이픈 또는 U + 00AD 사용)의 문화권을 구분, 대/소문자 비구분 비교 두 문자열은 해당을 나타냅니다.  [! 코드 csharp [System.String.Compare#22] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.Compare/cs/compare22.cs#22)] [! vb 코드 [System.String.Compare#22] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.Compare/vb/compare22.vb#22)] 호출의 문자열 비교를 무시할 수 있는 문자를 인식 하는 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드 중 하나의 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="comparisonType">비교에 사용할 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 규칙을 사용하여 지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0 보다 작음  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에 있습니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 대상의 대/소문자 무시 (문화권 구분) 단어를 사용 하 여 또는 서 수 (문화권) 정렬 규칙.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 "file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 다음 예제에서는 세 가지 버전의 문자를 비교 "I"입니다. 결과는 문화권, 대/소문자 무시 여부 및 서 수 비교가 수행 되는지 여부는 선택한 항목에 따라 달라 집니다.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" />은 지원되지 않습니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 개체입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체를 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다. 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0 보다 작음  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 "file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 다음 예제에서는 문화권 비교에 영향을 줄 방법을 보여 줍니다. 체코어-체코 공화국 문화권 "ch"는 "d" 보다 큰 단일 문자입니다. 그러나 영어-미국 문화권 "ch" 두 개의 문자로 구성 되어 있으며 "c"를 사용 하면 "d" 보다 작습니다.  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어, 다음 코드에서 실행 되는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 "동물"와 "Ani 메일" (소프트 하이픈 또는 U + 00AD 사용)의 대/소문자 비구분 비교 고정을 사용 하 여 이상 버전에서는 두 문자열은 해당 문화권 나타냅니다.  [! 코드 csharp [System.String.Compare#23] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.Compare/cs/compare23.cs#23)] [! vb 코드 [System.String.Compare#23] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.Compare/vb/compare23.vb#23)] 호출의 문자열 비교를 무시할 수 있는 문자를 인식 하는 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드 중 하나의 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 문화권입니다.</param>
        <param name="options">대/소문자 또는 기호 무시 여부와 같이 비교를 수행할 때 사용할 옵션입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 문자열 간의 관계를 나타내는 정수를 반환합니다. 지정된 비교 옵션 및 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>다음 표와 같이 <paramref name="strA" />와 <paramref name="strB" /> 간의 어휘 관계를 나타내는 부호 있는 32비트 정수입니다.  <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자 사전 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어 특정 문화권 수 특정 문자 조합을 단일 문자로 취급 될, 대 / 소문자에 특정 한 방식으로 비교할 수 또는 지정 정렬 순서는 문자는 문자에 따라 달라 지는 앞 이나 뒤 합니다.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 반환 합니다. 메서드 호출의 주요 목적은 (즉, 메서드 호출의 목적은 인 경우 반환 값 0에 대 한 테스트) 두 문자열이 같은지 여부를 결정 하는 경우 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 비교를 추가로 지정할 수는 `options` 의 하나 이상의 구성원으로 구성 되는 매개 변수는 <xref:System.Globalization.CompareOptions> 열거형입니다. 그러나이 메서드는 문화권 구분 문자열 비교를 수행 하 고 이기 때문에 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 값은 영향을 주지 않습니다.  
  
 비교 중 하나 또는 모두가 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 <xref:System.String.Empty?displayProperty=nameWithType>, null 참조와 두 개의 null 참조 보다 큰 것으로 간주 서로 같다고 간주 합니다.  
  
 비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 있는 나머지 문자로 문자열 큰 간주 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 세 가지 방법으로 두 문자열을 비교: EN-US 문화권에 대 한 언어 비교를 사용 하 여 EN-US 문화권에 대 한 언어의 대/소문자 구분 비교를 사용 하 여 및 서 수 비교를 사용 합니다. 비교의 세 가지 방법에서 세 가지 다른 결과 생성 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />이 <see cref="T:System.Globalization.CompareOptions" /> 값이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합 포함 무시할 수 있는 문자는 문자는 언어 또는 문화권 구분 비교를 수행 하는 경우 고려 되지 않습니다. <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <c>strA</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <c>strB</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 부호 있는 32비트 정수를 반환합니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 옵니다.  </description></item><item><term> 0  </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0입니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 에서 `indexA` 및 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 는 위치 0입니다. 첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다. 두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다. `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 "file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 다음 예제에서는 두 부분 문자열을 비교합니다.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  -또는-  <paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에는 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 값을 지정 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <c>strA</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <c>strB</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 옵니다.  </description></item><item><term> 0  </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0입니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 에서 `indexA`, 및 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 는 위치 0입니다. 첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다. 두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다. `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 경로 이름을 고정 방식에서 비교 해야 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 다음 예제에서는 대/소문자만 다른 두 개의 부분 두 비교 합니다. 첫 번째 비교는 대/소문자를 무시 하 고 두 번째 비교는 대/소문자를 고려 합니다.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  -또는-  <paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에는 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 값을 지정 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <c>strA</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <c>strB</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="comparisonType">비교에 사용할 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 규칙을 사용하여 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 옵니다.  </description></item><item><term> 0  </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" /> 매개변수가 0입니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 에서 `indexA` 및 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 0, 하나를 배치 하지 합니다. 첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다. 두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다. `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 `comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 대상의 대/소문자 무시 (문화권 구분) 단어를 사용 하 여 또는 서 수 (문화권) 정렬 규칙.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 "file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 다음 예제에서는 두 부분 문자열을 비교합니다.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  -또는-  <paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <c>strA</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <c>strB</c>에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 개체입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다. 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 옵니다.  </description></item><item><term> 0  </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0입니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 에서 `indexA`, 및 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 0, 하나를 배치 하지 합니다. 첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다. 두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다. `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.  
  
 같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 "file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이 작업을 수행 하는 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 다음 예제에서는 서로 다른 문화권을 사용 하 고 부분 문자열의 대/소문자를 무시 두 부분 문자열을 비교 합니다. 문화권 선택에 "어떻게 문자 I"가 영향을 비교 합니다.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  -또는-  <paramref name="strA" /> 또는 <paramref name="strB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에는 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드 값을 지정 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <c>strA</c>에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <c>strB</c>에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 개체입니다.</param>
        <param name="options">대/소문자 또는 기호 무시 여부와 같이 비교를 수행할 때 사용할 옵션입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 부분 문자열 간의 관계를 나타내는 정수를 반환합니다. 지정된 비교 옵션 및 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>다음 표와 같이 두 부분 문자열 간의 어휘 관계를 나타내는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 옵니다.  </description></item><item><term> 0  </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0입니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 위치의 `indexA` 및 `strB` 위치의 `indexB`합니다. 첫 번째 부분 문자열의 길이의 길이 `strA` 뺀 `indexA`합니다. 두 번째 부분 문자열의 길이의 길이 `strB` 뺀 `indexB`합니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다. `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자 사전 순서 등의 문화권 관련 정보를 얻습니다. 예를 들어 특정 문화권 수 특정 문자 조합을 단일 문자로 취급 될, 대 / 소문자에 특정 한 방식으로 비교할 수 또는 지정 정렬 순서는 문자는 문자에 따라 달라 지는 앞 이나 뒤 합니다.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 반환 합니다. 메서드 호출의 주요 목적은 (즉, 메서드 호출의 목적은 인 경우 반환 값 0에 대 한 테스트) 두 부분 문자열 동일한 지 여부를 결정 하는 경우 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 하나 또는 둘 다 `strA` 및 `strB` 수 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 <xref:System.String.Empty?displayProperty=nameWithType>, null 참조와 두 개의 null 참조 보다 큰 것으로 간주 서로 같다고 간주 합니다.  
  
 비교를 추가로 지정할 수는 `options` 의 하나 이상의 구성원으로 구성 되는 매개 변수는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다. 그러나이 메서드는 문화권 구분 문자열 비교를 수행 하 고 이기 때문에 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 값은 영향을 주지 않습니다.  
  
 같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 있는 나머지 문자로 문자열 큰 간주 됩니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 메서드를 마지막 두 사용자 이름을 비교 합니다. 사전순에서으로 나열합니다.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />이 <see cref="T:System.Globalization.CompareOptions" /> 값이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" /><see langword=".Length" />보다 큽니다.  -또는- <paramref name="indexB" />가 <paramref name="strB" /><see langword=".Length" />보다 큽니다.  -또는-  <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  -또는-  <paramref name="strA" /> 또는 <paramref name="strB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>각 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산해서 두 <see cref="T:System.Char" /> 개체를 비교합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <summary>각 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산해서 두 지정된 <see cref="T:System.Char" /> 개체를 비교합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />가 <paramref name="strB" />보다 작습니다.  </description></item><item><term> 0  </term><description><paramref name="strA" />와 <paramref name="strB" />가 같습니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />이 <paramref name="strB" />보다 큽니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다. 정렬 서 수 규칙을 사용 하 여 대/소문자 구분 비교를 수행 하려면 호출는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드는 `comparisonType` 인수로 설정 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>합니다.  
  
 때문에 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 정적 메서드입니다 `strA` 및 `strB` 수 `null`합니다. 두 값이 `null`, 메서드가 반환 한다는 0 (영) `strA` 및 `strB` 같은지 합니다. 하나만 값 중 하나 이면 `null`, 메서드는 큰 값으로 null이 아닌 값을 고려 합니다.  
  
   
  
## Examples  
 다음 예제를 수행 하 고 문자열 2의 서 수 비교에서 대/소문자만 다릅니다.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <c>strA</c>에 있는 부분 문자열의 시작 인덱스입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <c>strB</c>에 있는 부분 문자열의 시작 인덱스입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <summary>각 부분 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산하여 지정된 두 <see cref="T:System.Char" /> 개체의 부분 문자열을 비교합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description><paramref name="strA" />의 부분 문자열이 <paramref name="strB" />의 부분 문자열보다 작습니다.  </description></item><item><term> 0  </term><description> 부분 문자열이 같거나 <paramref name="length" />가 0입니다.  </description></item><item><term> 0보다 큼  </term><description><paramref name="strA" />의 부분 문자열이 <paramref name="strB" />의 부분 문자열보다 큽니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교 하는 문자 수는 길이의 기간은 `strA` 덜 `indexA`, 길이의 `strB` 덜 `indexB`, 및 `length`합니다.  
  
 이 메서드는 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다. 정렬 서 수 규칙을 사용 하 여 대/소문자 구분 비교를 수행 하려면 호출는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드는 `comparisonType` 인수로 설정 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>합니다.  
  
 때문에 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 정적 메서드입니다 `strA` 및 `strB` 수 `null`합니다. 두 값이 `null`, 메서드가 반환 한다는 0 (영) `strA` 및 `strB` 같은지 합니다. 하나만 값 중 하나 이면 `null`, 메서드는 큰 값으로 null이 아닌 값을 고려 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.CompareOrdinal%2A> 및 <xref:System.String.Compare%2A> 서로 다른 정렬 순서를 사용 합니다.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" />가 <see langword="null" />이 아니고, <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="strB" />가 <see langword="null" />이 아니고, <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  -또는-  <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스를 지정된 개체 또는 <see cref="T:System.String" />과 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 개체 또는 <see cref="T:System.String" />보다 앞인지, 뒤인지 또는 동일한지를 나타내는 정수를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드의 두 오버 로드는 <xref:System.String.CompareTo%2A> 메서드는 문화권 구분 및 대/소문자 구분 비교를 수행 합니다. 문화권을 구분 하지 않는 또는 서 수 비교를 수행 하려면이 메서드를 사용할 수 없습니다. 코드의 명확성을 권장 하지는 <xref:System.String.CompareTo%2A> 메서드와 호출은 <xref:System.String.Compare%2A> 메서드 대신 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.String" />이 되는 개체입니다.</param>
        <summary>이 인스턴스를 지정된 <see cref="T:System.Object" />와 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 <see cref="T:System.Object" />보다 앞인지, 뒤인지 또는 동일한지를 나타냅니다.</summary>
        <returns>정렬 순서에서 이 인스턴스의 위치가 <paramref name="value" /> 매개 변수보다 앞인지, 뒤인지 또는 동일한지를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description> 이 인스턴스가 <paramref name="value" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description> 이 인스턴스의 위치가 정렬 순서에서 <paramref name="value" />와 같습니다.  </description></item><item><term> 0보다 큼  </term><description> 이 인스턴스가 <paramref name="value" /> 뒤에 옵니다.  -또는-  <paramref name="value" />가 <see langword="null" />입니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 있어야는 <xref:System.String> 개체입니다.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> 메서드 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 설계 되었습니다. 메서드 호출의 주요 목적은 두 문자열이 같은지 여부를 결정 하는 경우 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
 이 방법의 동작에 대 한 자세한 내용은 설명 부분을 참조 하십시오.는 <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.CompareTo%2A> 메서드는 <xref:System.Object>합니다. 비교 하려고 했기 때문에 <xref:System.String> 인스턴스는 `TestClass` 메서드에서 throw 개체는 <xref:System.ArgumentException>합니다.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />가 <see cref="T:System.String" />가 아닌 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.CompareTo(System.Object)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어, 다음 코드에서 실행 되는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물" "ani 메일" (소프트 하이픈 또는 U + 00AD 사용)와 비교 두 문자열은 해당을 나타냅니다.  [! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출 된 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 메서드.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">이 인스턴스와 비교할 문자열입니다.</param>
        <summary>이 인스턴스를 지정된 <see cref="T:System.String" /> 개체와 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 문자열보다 앞인지, 뒤인지 또는 동일한지를 나타냅니다.</summary>
        <returns>정렬 순서에서 이 인스턴스의 위치가 <paramref name="strB" /> 매개 변수보다 앞인지, 뒤인지 또는 동일한지를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 조건  </description></listheader><item><term> 0보다 작음  </term><description> 이 인스턴스가 <paramref name="strB" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description> 이 인스턴스의 위치가 정렬 순서에서 <paramref name="strB" />와 같습니다.  </description></item><item><term> 0보다 큼  </term><description> 이 인스턴스가 <paramref name="strB" /> 뒤에 옵니다.  -또는-  <paramref name="strB" />가 <see langword="null" />입니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> 메서드 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 설계 되었습니다. 메서드 호출의 주요 목적은 두 문자열이 같은지 여부를 결정 하는 경우 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 이 방법의 동작에 대 한 자세한 내용은 설명 부분을 참조 하십시오.는 <xref:System.String.Compare%28System.String%2CSystem.String%29> 메서드.  
  
 이 메서드를 구현 하는 <xref:System.IComparable%601?displayProperty=nameWithType> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> 메서드를 확인할 필요가 없기 때문에 여부는 `strB` 인수 box 수 해야 하는 변경할 수 있는 값 형식 이므로 캐스팅 하지 않아도 해당 매개 변수는 <xref:System.Object> 에 <xref:System.String>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.CompareTo%2A> 메서드를 다른 문자열로 사용 하 여 현재 문자열 인스턴스를 비교 합니다.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 다음 예제에서는 제네릭 및 제네릭이 아닌 여러 값 및 참조 형식에 대 한 버전을 보여 줍니다.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함 됩니다. <see cref="M:System.String.CompareTo(System.String)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어, 다음 코드에서 실행 되는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물" "ani 메일" (소프트 하이픈 또는 U + 00AD 사용)와 비교 두 문자열은 해당을 나타냅니다.  [! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출 된 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 메서드.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" />의 인스턴스를 하나 이상 연결하거나 <see cref="T:System.String" />의 인스턴스 값에 해당하는 <see cref="T:System.Object" /> 표현을 하나 이상 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />을 구현하고 제네릭 형식 인수가 <see cref="T:System.String" />인 컬렉션 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 형식의 생성된 <see cref="T:System.String" /> 컬렉션의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" />의 연결된 문자열이거나, <paramref name="values" />가 빈 <see langword="IEnumerable(Of String)" />이면 <see cref="F:System.String.Empty" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드가 `values`; 구분 기호를 추가 하지는 않습니다. 각 멤버 사이 구분 기호를 지정 하려면 `values`, 호출 된 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.  
  
 <xref:System.String.Empty> 문자열에서 null 요소 대신 사용 됩니다 `values`합니다.  
  
 경우 `values` 은 빈 `IEnumerable(Of String)`, 메서드가 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 경우 `values` 은 `null`, 메서드에서 throw 된 <xref:System.ArgumentNullException> 예외입니다.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 각 요소에 연결할 수 있는 편리한 메서드입니다는 `IEnumerable(Of String)` 먼저 문자열 배열에 요소를 변환 하지 않고 컬렉션입니다. LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 특히 유용합니다. 다음 예제에서는 전달 된 `List(Of String)` 알파벳 문자 (즉, 예제에서는 "M")를 특정 문자 보다 크거나 같은 선택 하는 람다 식에 대 / 소문자 구분 문자가 들어 있는 개체입니다. `IEnumerable(Of String)` 에서 반환 되는 컬렉션은 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 메서드에 전달 되는 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 단일 문자열 결과 표시 하려면 메서드.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 결과를 할당 한 <xref:System.Collections.Generic.List%601> 형식의 개체 <xref:System.String>에 전달 되는 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">나타낼 개체나 <see langword="null" />입니다.</param>
        <summary>지정된 개체의 문자열 표현을 만듭니다.</summary>
        <returns>
          <paramref name="arg0" />이 <see cref="F:System.String.Empty" />인 경우 <paramref name="arg0" /> 또는 <see langword="null" /> 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29> 메서드가 `arg0` 는 매개 변수가 없는 호출 하 여 문자열로 `ToString` 메서드.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Concat%2A> 메서드.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">연결할 요소가 포함된 개체 배열입니다.</param>
        <summary>지정된 <see cref="T:System.Object" /> 배열에 있는 요소의 문자열 표현을 연결합니다.</summary>
        <returns>
          <paramref name="args" />에 있는 요소 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드가 `args` 매개 변수가 없는 호출 하 여 `ToString` 해당 개체의 메서드 구분 기호를 추가 하지는 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 배열에 있는 빈 개체 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Concat%2A> 메서드는 <xref:System.Object> 배열입니다.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <block subset="none" type="usage">
          <para>C + + 코드에서이 메서드는 합니다. C + + 컴파일러에 대 한 호출을 해결 <see cref="Overload:System.String.Concat" /> 개체 매개 변수 4 개 이상에 대 한 호출으로 있는 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />합니다.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">문자열 인스턴스의 배열입니다.</param>
        <summary>지정된 <see cref="T:System.String" /> 배열의 요소를 연결합니다.</summary>
        <returns>
          <paramref name="values" />의 연결된 요소를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드가 `values`; 구분 기호를 추가 하지는 않습니다.  
  
 <xref:System.String.Empty> 문자열 배열에 있는 빈 개체 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Concat%2A> 메서드는 <xref:System.String> 배열입니다.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">연결할 첫 번째 개체입니다.</param>
        <param name="arg1">연결할 두 번째 개체입니다.</param>
        <summary>지정된 두 개체의 문자열 표현을 연결합니다.</summary>
        <returns>
          <paramref name="arg0" /> 및 <paramref name="arg1" /> 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `arg0` 및 `arg1` 매개 변수가 없는 호출 하 여 `ToString` 방식의 `arg0` 및 `arg1`; 구분 기호를 추가 하지는 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 인수를 대신 사용 됩니다.  
  
 경우 인수는 배열 참조, 해당 멤버 (예를 들어 "System.String[]") 대신 해당 배열을 나타내는 문자열을 연결 하는 메서드 중 하나.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Concat%2A> 메서드.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">연결할 첫 번째 문자열입니다.</param>
        <param name="str1">연결할 두 번째 문자열입니다.</param>
        <summary>
          <see cref="T:System.String" />의 지정된 두 인스턴스를 연결합니다.</summary>
        <returns>연결된 <paramref name="str0" /> 및 <paramref name="str1" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `str0` 및 `str1`; 구분 기호를 추가 하지는 않습니다.  
  
> [!NOTE]
>  사용할 수도 있습니다 해당 언어의 문자열 연결 연산자와 같은 `+` C# 또는 `&` 및 `+` Visual basic에서)  
>   
>  문자열을 연결 하 합니다.  
  
 <xref:System.String.Empty> null 인수 문자열이 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자의 이름 및 마지막을 연결합니다.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">연결할 첫 번째 개체입니다.</param>
        <param name="arg1">연결할 두 번째 개체입니다.</param>
        <param name="arg2">연결할 세 번째 개체입니다.</param>
        <summary>지정된 세 개체의 문자열 표현을 연결합니다.</summary>
        <returns>
          <paramref name="arg0" />, <paramref name="arg1" /> 및 <paramref name="arg2" /> 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `arg0`, `arg1`, 및 `arg2` 매개 변수가 없는 호출 하 여 `ToString` ; 각 개체의 모든 구분 기호를 추가 하지는 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 인수를 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Concat%2A> 메서드.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">연결할 첫 번째 문자열입니다.</param>
        <param name="str1">연결할 두 번째 문자열입니다.</param>
        <param name="str2">연결할 세 번째 문자열입니다.</param>
        <summary>
          <see cref="T:System.String" />의 지정된 세 인스턴스를 연결합니다.</summary>
        <returns>연결된 <paramref name="str0" />, <paramref name="str1" /> 및 <paramref name="str2" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `str0`, `str1`, 및 `str2`; 구분 기호를 추가 하지는 않습니다.  
  
> [!NOTE]
>  사용할 수도 있습니다 해당 언어의 문자열 연결 연산자와 같은 `+` C# 또는 `&` 및 `+` Visual basic에서)  
>   
>  문자열을 연결 하 합니다.  
  
 <xref:System.String.Empty> null 인수 문자열이 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Concat%2A> 메서드 3 개를 연결 하는 문자열 및 결과 표시 합니다.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">연결할 첫 번째 개체입니다.</param>
        <param name="arg1">연결할 두 번째 개체입니다.</param>
        <param name="arg2">연결할 세 번째 개체입니다.</param>
        <param name="arg3">연결할 네 번째 개체입니다.</param>
        <summary>지정된 네 개체의 문자열 표현과 선택적 변수 길이 매개 변수 목록에 지정된 개체를 연결합니다.</summary>
        <returns>매개 변수 목록에서 각 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 API는 CLS 규격이 아닙니다. CLS 규격 대체 항목은 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>입니다. C# 및 Visual Basic 컴파일러에 대 한 호출으로이 메서드에 대 한 호출을 자동으로 해결 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>합니다.  
  
 메서드는 매개 변수가 없는 호출 하 여 매개 변수 목록에 있는 각 개체를 연결 `ToString` 메서드; 구분 기호를 추가 하지는 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 인수를 대신 사용 됩니다.  
  
> [!NOTE]
>  마지막 매개 변수는 <xref:System.String.Concat%2A> 메서드는 연결할 하나 이상의 추가 개체의 선택적 쉼표로 구분 된 목록입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 메서드 목록을 연결 하는 가변 매개 변수입니다. 이 경우 9 개의 매개 변수가 있는 메서드가 호출 됩니다.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>이 메서드가로 표시 된 <see langword="vararg" /> 키워드 가변 개수의 매개 변수를 지원 한다는 의미입니다. Visual c + +에서 메서드를 호출할 수 있지만 C# 또는 Visual Basic 코드에서 호출할 수 없습니다. C# 및 Visual Basic 컴파일러에 대 한 호출을 해결 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> 에 호출로 <see cref="M:System.String.Concat(System.Object[])" />합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">연결할 첫 번째 문자열입니다.</param>
        <param name="str1">연결할 두 번째 문자열입니다.</param>
        <param name="str2">연결할 세 번째 문자열입니다.</param>
        <param name="str3">연결할 네 번째 문자열입니다.</param>
        <summary>
          <see cref="T:System.String" />의 지정된 네 인스턴스를 연결합니다.</summary>
        <returns>연결된 <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> 및 <paramref name="str3" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `str0`, `str1`, `str2`, 및 `str3`; 구분 기호를 추가 하지는 않습니다.  
  
> [!NOTE]
>  사용할 수도 있습니다 해당 언어의 문자열 연결 연산자와 같은 `+` C# 또는 `&` 및 `+` Visual basic에서)  
>   
>  문자열을 연결 하 합니다.  
  
 <xref:System.String.Empty> 문자열 배열에 있는 빈 개체 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 네 문자로 된 단어의 배열을 정의 하 고 스크램블 하기 위해 문자열 배열에 개별 문자를 저장 합니다. 그런 다음 호출 하 여 <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> 메서드가를 다시 암호화 된 단어를 합니다.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">구성원 유형을 <c>값</c>합니다.</typeparam>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 인터페이스를 구현하는 컬렉션 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 구현의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" />의 연결된 멤버입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드가 `values`; 구분 기호를 추가 하지는 않습니다.  
  
 <xref:System.String.Empty> null 인수 문자열이 사용 됩니다.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 각 요소에 연결할 수 있는 편리한 메서드입니다는 <xref:System.Collections.Generic.IEnumerable%601> 먼저 요소를 문자열로 변환 하지 않고 컬렉션입니다. 것은 예제와 같이 LINQ (Language-Integrated Query) 쿼리 식, 특히 유용 합니다. 에 있는 각 개체의 문자열 표현을 <xref:System.Collections.Generic.IEnumerable%601> 해당 개체를 호출 하 여 파생 된 컬렉션은 `ToString` 메서드.  
  
   
  
## Examples  
 다음 예제에서는 매우 간단한 정의 `Animal` 동물 속해 있는 주문의 이름을 포함 하는 클래스입니다. 그런 다음 정의 <xref:System.Collections.Generic.List%601> 개체의 번호를 포함 하도록 `Animal` 개체입니다. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 확장 메서드를 호출을 추출 하는 `Animal` 개체 `Order` 속성 "설치류" 값은입니다. 결과에 전달 되는 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드 및 콘솔에 표시 합니다.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <summary>이 문자열 내에서 지정한 하위 문자열이 발생하는지를 나타내는 값을 반환합니다.</summary>
        <returns>이 문자열 내에서 <see langword="true" /> 매개 변수가 발생하거나 <paramref name="value" />가 빈 문자열("")이면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다. 검색이이 문자열의 첫 번째 문자 위치에서 시작 하 고 마지막 문자 위치를 통해 계속 됩니다.  
  
 문자열로 여부를 확인 하려면 이외의 노드 (예: 문화권 구분 비교 또는 대/소문자 비구분 서 수 비교)는 서 수 비교를 사용 하 여 지정된 된 부분 문자열을 포함, 사용자 지정 메서드를 만들 수 있습니다. 다음 예제에서는 이러한 방법을 중 하나를 보여 줍니다. 정의 <xref:System.String> 포함 된 확장 메서드는 <xref:System.StringComparison> 매개 변수가 지정 된 형식의 문자열 비교를 사용 하는 경우 부분 문자열을 포함 하는 문자열 인지 여부를 나타냅니다.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 다음 예제에서는 다음 호출에서 `Contains` 확장 메서드를 서 수 비교와 대/소문자 비구분 서 수 비교를 사용 하는 경우 문자열에 부분 문자열은 찾을 지 여부를 결정 합니다.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 하는 경우에 관심이 있는 부분 문자열의 위치 `value` 현재 인스턴스를 호출할 수 있습니다는 <xref:System.String.IndexOf%2A> 여 처음으로 일치의 시작 위치를 가져올 메서드를 호출할 수는 <xref:System.String.LastIndexOf%2A> 메서드를 시작 하는 항목의 위치는 마지막으로 검색 합니다. 예제에 대 한 호출에 포함 되어는 <xref:System.String.IndexOf%28System.String%29> 메서드 문자열 인스턴스에서 부분 문자열을 찾은 경우.  
  
   
  
## Examples  
 다음 예제에서는 문자열 "fox" 일반적인 따옴표의 부분 문자열 인지 확인 합니다. 문자열에서 "fox" 발견 되는 경우 또한 해당 시작 위치를 표시 합니다.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">복사할 문자열입니다.</param>
        <summary>지정된 <see cref="T:System.String" />과 동일한 값을 갖는 <see cref="T:System.String" />의 새 인스턴스를 만듭니다.</summary>
        <returns>
          <paramref name="str" />과 동일한 값을 갖는 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Copy%2A> 메서드가 반환 되는 <xref:System.String> 개체는 원래 문자열과 같은 값을 가진 하지만 다른 개체 참조를 나타냅니다. 기존 문자열 참조를 추가 개체 변수에 할당 하는 할당 연산에서 점이 다릅니다. 이 예제에서는 차이점을 보여 줍니다.  
  
   
  
## Examples  
 다음 예에서는 값이 서로 다른 두 string 개체를 만듭니다. 호출할 때는 <xref:System.String.Copy%2A> 두 번째 문자열이 첫 번째 값을 할당 하는 메서드 문자열 요소의 값은 이제 동일 하지만 다른 개체 참조를 나타내며 그 결과 나타납니다. 반면에 첫 번째 문자열이 두 번째 문자열에 할당 될 경우 두 문자열 값이 적용 동일한 같은 개체 참조를 나타내므로 합니다.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">이 인스턴스에서 복사할 첫 번째 문자의 인덱스입니다.</param>
        <param name="destination">이 인스턴스의 문자가 복사되는 유니코드 문자의 배열입니다.</param>
        <param name="destinationIndex">
          <c>destination</c>에서 복사 작업이 시작되는 인덱스입니다.</param>
        <param name="count">이 인스턴스에서 <c>destination</c>에 복사할 문자의 수입니다.</param>
        <summary>이 인스턴스의 지정한 위치에 있는 지정한 수의 문자를 유니코드 문자 배열의 특정 위치에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 복사 `count` 에서 문자는 `sourceIndex` 를이 인스턴스의 위치는 `destinationIndex` 항목의 위치 `destination` 문자 배열입니다. 이 메서드는 크기를 조정 하지는 `destination` 문자 배열; 요소 복사한 문자를 포함 하기에 충분 한 수 있어야 또는 메서드에서 throw 된 <xref:System.ArgumentOutOfRangeException>합니다.  
  
 `sourceIndex` 및 `destinationIndex` 0부터 시작 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.CopyTo%2A> 메서드.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> 또는 <paramref name="count" />가 음수입니다.  -또는-  <paramref name="sourceIndex" />가 현재 인스턴스의 위치를 식별하지 않습니다.  -또는-  <paramref name="destinationIndex" />가 <paramref name="destination" /> 배열에서 유효한 인덱스를 식별하지 않습니다.  -또는- <paramref name="count" />가 <paramref name="sourceIndex" />부터 이 인스턴스 끝까지의 하위 문자열 길이보다 큽니다.  -또는-  <paramref name="count" />가 <paramref name="destinationIndex" />부터 <paramref name="destination" /> 배열 끝까지의 부분 배열 길이보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>빈 문자열을 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드의 값은 빈 문자열 ""입니다.  
  
 응용 프로그램 코드에서이 필드는 가장 일반적으로 할당에 문자열 변수를 빈 문자열로 초기화에 사용 됩니다. 문자열의 값 중 하나 인지를 테스트 하려면 `null` 또는 <xref:System.String.Empty?displayProperty=nameWithType>를 사용 하 여는 <xref:System.String.IsNullOrEmpty%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</param>
        <summary>이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 인스턴스의 끝이 <see langword="true" />와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비교 `value` 와 같은 길이가이 인스턴스의 끝에 있는 부분 문자열과 `value`와 같은지 여부를 나타내는 값을 반환 합니다. 하려면 `value` 동일한이 인스턴스에 대 한 참조 이거나이 인스턴스의 끝과 일치 해야 합니다.  
  
 이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열의 각 문자열 마침표로 끝나는 있는지 여부를 나타냅니다 (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 다음 예제에서는 정의 `StripEndTags` 메서드를 사용 하는 <xref:System.String.EndsWith%28System.String%29> 메서드 줄의 끝에서 HTML 끝 태그를 제거 합니다. `StripEndTags` 메서드는 재귀적으로 줄의 끝에 HTML 끝 태그를 여러가 제거 되었는지 확인 합니다.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 확인 하려면 현재 문화권의 문자열 비교 규칙을 사용 하 여 문자열이 특정 하위 문자열로 끝나는지를 호출는 <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</param>
        <param name="comparisonType">이 문자열과 <c>value</c>를 비교하는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정한 비교 옵션을 사용하여 비교할 때 지정한 문자열과 이 문자열 인스턴스의 끝 부분이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 끝이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A> 메서드 비교는 `value` 이 문자열의 끝에 있는 부분 문자열과 매개 변수가 같은지 여부를 나타내는 값을 반환 합니다. 하려면 `value` 이 동일한 문자열에 대 한 참조 여야, 빈 문자열 이어야 합니다 (""), 또는이 문자열의 끝 일치 해야 합니다. 비교를 수행 하 여 유형의 <xref:System.String.EndsWith%2A> 메서드는 값에 따라는 `comparisonType` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예에서는 문자열이 특정 하위 문자열로 끝나는지를 확인 합니다. 결과는 문화권, 대/소문자 무시 여부 및 서 수 비교가 수행 되는지 여부는 선택한 항목에 따라 달라 집니다.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">이 인스턴스와 <c>value</c>의 비교 방법을 결정하는 문화권 정보입니다. <c>culture</c>가 <see langword="null" />이면 현재 문화권이 사용됩니다.</param>
        <summary>지정한 문화권을 사용하여 비교할 때 이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 끝이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비교는 `value` 와 같은 길이가이 문자열의 끝에 있는 부분 문자열과 매개 변수 `value`, 같은지 여부를 나타내는 값을 반환 합니다. 하려면 `value` 동일한이 인스턴스에 대 한 참조 하거나이 문자열의 끝과 일치 해야 합니다.  
  
 이 메서드는 지정 된 대/소문자 및 문화권을 사용 하 여 단어 (문화권별) 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예에서는 문자열이 다른 문자열의 끝에 있는지 여부를 확인 합니다. <xref:System.String.EndsWith%2A> 여러 번 대/소문자 구분, 대/소문자, 및 검색 결과 영향을 주는 다양 한 문화권을 사용 하 여 메서드를 호출 합니다.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 문자열입니다.</param>
        <summary>이 인스턴스와 지정한 개체의 값이 같은지를 확인합니다. 이 개체도 <see cref="T:System.String" /> 개체여야 합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="obj" />이고 이 인스턴스와 같은 값을 가지면 <see cref="T:System.String" />이고, 그러지 않으면 <see langword="false" />입니다.  <paramref name="obj" />가 <see langword="null" />이면 메서드에서 <see langword="false" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Equals%2A> 메서드.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스와 비교할 문자열입니다.</param>
        <summary>이 인스턴스와 지정한 다른 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수와 이 인스턴스의 값이 같으면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다. <paramref name="value" />가 <see langword="null" />이면 메서드에서 <see langword="false" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Equals%2A> 메서드. 해당 하는 word, 해당 하는 소문자 이거나, 해당 대문자로 LATIN SMALL 문자 점이 없는 I를 포함 하는 단어와 제목 대/소문자 단어 "File"를 비교 (U + 0131) 대신 LATIN SMALL LETTER I (U + 0069). 때문에 <xref:System.String.Equals%28System.String%29> 는 서 수 비교를 수행 하는 메서드, 동일한 단어로 비교만 반환 `true`합니다.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" />의 값이 <paramref name="a" />의 값과 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다. <paramref name="a" /> 및 <paramref name="b" />가 <see langword="null" />인 경우 이 메서드는 <see langword="true" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Equals%2A> 메서드.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스와 비교할 문자열입니다.</param>
        <param name="comparisonType">문자열 비교 방법을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>이 문자열과 지정한 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다. 매개 변수는 비교에 사용되는 문화권, 대/소문자 및 정렬 규칙을 지정합니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수와 이 문자열의 값이 같으면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야을 인식 하거나 비교 하 고 두 문자열의 대/소문자 무시 단어 또는 정렬 서 수 규칙을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 구성 된 대문자 "I", "i", 소문자 및 점이 없는 "ı" 문자열 배열을 만듭니다. 그런 다음 호출 하는 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 메서드 각각의 가능한 사용 하 여 비교할 <xref:System.StringComparison> 열거형 값입니다.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 다음 예제에서는의 각 멤버를 사용 하 여 4 개의 집합이 단어를 비교는 <xref:System.StringComparison> 열거형입니다.  비교는 영어 (미국) 및 라프어 (스웨덴 위) 문화권의 규칙을 사용 합니다. Note 문자열 "encyclopædia" 및 "백과" 라프어 (스웨덴 북부) 문화권 있지만 EN-US 문화권에 해당 하는 간주 됩니다.  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="comparisonType">비교 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다. 매개 변수는 비교에 사용되는 문화권, 대/소문자 및 정렬 규칙을 지정합니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수와 <paramref name="a" /> 매개 변수의 값이 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야을 인식 하거나 비교 하 고 두 문자열의 대/소문자 무시 단어 또는 정렬 서 수 규칙을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는의 각 멤버를 사용 하 여 4 개의 집합이 단어를 비교는 <xref:System.StringComparison> 열거형입니다.  비교는 영어 (미국) 및 라프어 (스웨덴 위) 문화권의 규칙을 사용 합니다. Note 문자열 "encyclopædia" 및 "백과" 라프어 (스웨덴 북부) 문화권 있지만 EN-US 문화권에 해당 하는 간주 됩니다.  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식에 따라 개체의 값을 문자열로 변환하여 다른 문자열에 삽입 합니다.  `String.Format` 메서드를 처음 사용하는 경우 [String.Format 메서드 시작](#Starting) 섹션에서 대략적인 내용을 살펴보세요.  `String.Format` 메서드에 대한 일반 설명서는 [설명](#remarks-top) 섹션을 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 섹션 내용  
  
 [String.Format 메서드 시작](#Starting)   
 [어떤 방법을 호출할 수 있습니까?](#FTaskList)   
 [Brief에 Format 메서드](#Format_Brief)   
 [서식 항목](#FormatItem)   
 [인수는 형식을 지정 하는 방법을](#HowFormatted)   
 [동일한 인덱스에 있는 서식 항목](#SameIndex)   
 [서식 지정 및 문화권](#Format_Culture)   
 [사용자 지정 서식 지정 작업](#Format_Custom)   
 [String.Format 질문 및 답변](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>String.Format 메서드 시작  
 사용 하 여 <xref:System.String.Format%2A?displayProperty=nameWithType> 다른 문자열에는 개체, 변수 또는 식의 값을 삽입 하는 경우. 예를 들어 값을 삽입할 수 있습니다는 <xref:System.Decimal> 을 단일 문자열로 사용자에 게 표시 하는 문자열에는 값:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 및 해당 값의 서식을 제어할 수 있습니다.  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 서식 지정 외에도 맞춤 및 간격을 제어할 수 있습니다.  
  
 ### <a name="inserting-a-string"></a>삽입  

 <xref:System.String.Format%2A?displayProperty=nameWithType> 형식 문자열 뒤에 하나 이상의 개체 또는 문자열로 변환 되며 형식 문자열에서 지정된 된 위치에 삽입 하는 식으로 시작 합니다. 예:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}` 형식에서 문자열은 형식 항목입니다. `0` 문자열 값을 해당 위치에 삽입할 개체의 인덱스가입니다. (인덱스 0부터 시작)입니다. 삽입 될 개체가 문자열이 아닌 경우 해당 `ToString` 메서드를 호출 하는 결과 문자열에 삽입 하기 전에 하나를 변환 합니다.  
  
 두 개의 형식 항목 및 개체 2 개를 사용 하 여 개체 목록에는 또 다른 예는 다음과 같습니다.  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 형식 항목 수 만큼 있고 모든 서식 항목의 인덱스 개체 목록에서 일치 하는 개체의 개체와 개체 목록에서 원하는 합니다. 또한 필요가 없습니다 걱정할 오버 로드에 대 한 호출입니다. 컴파일러는 적절 한 수를 선택 합니다.  
  
 ### <a name="controlling-formatting"></a>서식 지정 제어  
 개체의 서식 지정 하는 방법을 제어 하는 형식 문자열 형식 항목의 인덱스를 따를 수 있습니다. 예를 들어 `{0:d}` 개체 목록에서 첫 번째 개체 "d" 형식 문자열에 적용 됩니다. 다음은 단일 개체와 예제 하 고 두 항목의 서식을 지정 합니다.  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 형식 문자열, 모든 숫자 형식을 포함 한 다양 한 형식 지원 (둘 다 [표준](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정](~/docs/standard/base-types/custom-numeric-format-strings.md) 형식 문자열), 모든 날짜 및 시간 (둘 다 [표준](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정](~/docs/standard/base-types/custom-date-and-time-format-strings.md) 형식 문자열) 및 시간 간격 (둘 다 [표준](~/docs/standard/base-types/standard-timespan-format-strings.md) 및 [사용자 지정](~/docs/standard/base-types/custom-timespan-format-strings.md) 형식 문자열), 모든 열거형 형식 [열거형 형식 ](~/docs/standard/base-types/enumeration-format-strings.md), 및 [Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)합니다. 또한 사용자 고유의 형식에 형식 문자열에 대 한 지원을 추가할 수 있습니다.  
  
 ### <a name="controlling-spacing"></a>간격을 제어합니다.  
 와 같은 구문을 사용 하 여 결과 문자열에 삽입 되는 문자열의 너비를 정의할 수 있습니다 `{0,12}`, 문자열 12를 삽입 합니다. 이 경우 첫 번째 개체의 문자열 표현을 12 자 필드에 오른쪽 맞춤를입니다.  (첫 번째 개체의 문자열 표현을 길이 12 자 이면 그러나 기본 필드 너비는 무시 됩니다 및 전체 문자열이 결과 문자열에 삽입 됩니다.)  
  
 다음 예제에서는 정의 문자열을 보관할 6 자 필드 "Year" 및 일부 연도 문자열으로 15 자 필드는 문자열을 보관할 "채우기"와 일부 인구 데이터입니다. 문자는 오른쪽 정렬 필드에 note 합니다.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>맞춤을 제어합니다.  
 기본적으로 문자열은 해당 필드 내에서 오른쪽 정렬 필드 너비를 지정 하는 경우입니다. 문자열 필드에서를 왼쪽에 맞추려면 앞에 음수 기호를 사용 하 여 필드 너비와 같은 `{0,-12}` 12 자로 오른쪽 정렬 필드를 정의 합니다.  
  
 다음 예제에서는 왼쪽 맞춤 레이블과 데이터 한다는 점을 제외 하면 이전 쿼리와 비슷합니다.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> 에서는 합성 서식 지정 기능을 활용합니다. 자세한 내용은 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md)을 참조하세요.  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>어떤 방법을 호출할 수 있습니까?  
  
|대상|Call|  
|--------|----------|  
|현재 문화권의 규칙을 사용 하 여 하나 이상의 개체를 포맷 합니다.|포함 하는 오버 로드를 제외 하 고는 `provider` 매개 변수를 나머지 <xref:System.String.Format%2A> 오버 로드는 포함는 <xref:System.String> 매개 변수 뒤에 하나 이상의 개체 매개 변수입니다. 이 인해 결정할 필요가 없습니다 <xref:System.String.Format%2A> 호출 하려는 오버 로드 합니다. 적합 한 오버 헤드로 없는 오버 로드 중에서 선택 하는 언어 컴파일러는 `provider` 매개 변수를 인수 목록에 기반 합니다. 예를 들어 인수 목록에 다섯 개의 인수, 있는 경우 컴파일러 호출 하 여는 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 메서드.|  
|특정 문화권의 규칙을 사용 하 여 하나 이상의 개체를 포맷 합니다.|각 <xref:System.String.Format%2A> 로 시작 하는 오버 로드는 `provider` 매개 변수 뒤에 <xref:System.String> 매개 변수 또는 하나 이상의 매개 변수 개체입니다. 이 때문에 어떤 확인할 필요가 없습니다 <xref:System.String.Format%2A> 호출 하려는 오버 로드 합니다. 오버 로드 중에서 적절 한 오버 로드를 선택 하는 언어 컴파일러는 `provider` 매개 변수를 인수 목록에 기반 합니다. 예를 들어 인수 목록에 다섯 개의 인수, 있는 경우 컴파일러 호출 하 여는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드.|  
|사용자 지정 서식 지정 작업을 사용 하 여 수행는 <xref:System.ICustomFormatter> 구현 또는 <xref:System.IFormattable> 구현 합니다.|4 개의 오버 로드 중 하나는 `provider` 매개 변수입니다. 오버 로드 중에서 적절 한 오버 로드를 선택 하는 컴파일러는 `provider` 매개 변수를 인수 목록에 기반 합니다.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Brief에 Format 메서드 

 각 오버 로드는 <xref:System.String.Format%2A> 메서드는 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 호출는 0부터 시작 인덱싱된 자리 표시자를 포함 하도록 *항목의 서식을 지정*, 복합 형식 문자열에 있습니다. 런타임 시 각 형식 항목이 매개 변수 목록에서 해당 인수의 문자열 표현으로 바뀝니다. 인수의 값이 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 다음을 호출 하는 예를 들어는 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 메서드에 형식 문자열을 3 개의 형식 항목이 포함 되어 있습니다. {0}, {1}, 및 {2}, 및 세 가지 항목으로 인수 목록이 있습니다.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>서식 항목  
 서식 항목이이 구문은 다음과 같습니다.  
  
```  
{index[,alignment][:formatString]}  
```  
 
 대괄호는 선택적 요소를 나타냅니다. 여는 태그와 닫는 중괄호는 필요 합니다. (리터럴 여 포함 하거나 참조 하는 닫는 중괄호 형식 문자열에는 [이스케이프 중괄호](~/docs/standard/base-types/composite-formatting.md#escaping-braces) 섹션은 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문서입니다.)  
  
 예를 들어 통화 값의 서식을 지정 하려면 형식 항목은 다음과 같이 나타날 수 있습니다.  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 형식 항목에는 다음과 같은 요소가 있습니다.  
  
 *index*  
 문자열 표현의 되도록 형식이 인수의 0부터 시작 인덱스는 문자열의이 위치에 포함 합니다. 이 인수가 `null`, 문자열에서이 위치에 빈 문자열이 포함 됩니다.  
  
 *alignment*  
 선택 사항입니다. 인수를 삽입 하는 지, 오른쪽 맞춤 (양의 정수) 왼쪽 맞춤 (음의 정수)에 필드의 총 길이 나타내는 부호 있는 정수입니다. 생략 하면 *맞춤*, 선행 또는 후행 공백 없이 필드에 해당 인수의 문자열 표현을 삽입 됩니다.  
  
 하는 경우의 값 *맞춤* 을 삽입할 수는 인수의 길이 보다 작으면 *맞춤* 무시 됩니다 및 인수의 문자열 표현의 길이가 필드 너비로 사용 됩니다.  
  
 *formatString*  
 선택 사항입니다. 해당 인수가 결과 문자열의 형식을 지정 하는 문자열입니다. 생략 하면 *formatString*, 해당 인수의 매개 변수가 없는 `ToString` 메서드는 문자열 표현이 있습니다. 지정 하는 경우 *formatString*, 형식 항목으로 참조 하는 인수를 구현 해야 합니다는 <xref:System.IFormattable> 인터페이스입니다. 형식 문자열을 지 원하는 유형은 다음과 같습니다.  
  
-   모든 정수 계열 및 부동 소수점 형식입니다. (참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime>와 <xref:System.DateTimeOffset>을 참조하세요. (참조 [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   모든 열거형 형식입니다. (참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   <xref:System.TimeSpan> 값 (참조 [표준 TimeSpan 형식 문자열](~/docs/standard/base-types/standard-timespan-format-strings.md) 및 [사용자 지정 TimeSpan 형식 문자열](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUID입니다. (참조는 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 메서드.)  
  
 그러나 모든 사용자 지정 형식 구현할 수를 메모 <xref:System.IFormattable> 기존 형식을 확장할 또는 <xref:System.IFormattable> 구현 합니다.  
  
 다음 예제에서는 `alignment` 및 `formatString` 인수 형식이 지정 된 출력을 생성 합니다.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>인수는 형식을 지정 하는 방법을  
 서식 항목이 문자열의 시작 부분에서 순차적으로 처리 됩니다. 각 형식 항목에는 메서드의 인수 목록에 있는 개체에 해당 하는 인덱스입니다. <xref:System.String.Format%2A> 메서드 인수를 검색 하 고 해당 문자열 표현에 다음과 같이 파생 됩니다.  
  
-   인수가 `null`, 삽입 <xref:System.String.Empty?displayProperty=nameWithType> 는 결과 문자열에 있습니다. 처리 신경 쓸 필요가 없습니다는 <xref:System.NullReferenceException> null 인수를 합니다. 
  
-   호출 하는 경우는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 오버 로드와 `provider` 개체의 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 구현은 null이 아닌 <xref:System.ICustomFormatter> 인수가 전달이 구현에서 해당 <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드. 형식 항목을 포함 하는 경우는 *formatString* 인수를 것은 첫 번째 인수로 메서드에 전달 합니다. 경우는 <xref:System.ICustomFormatter> 구현 ´ ï ´ 문자열 인수의 문자열 표현으로 반환 되는 null이 아닌 문자열을 생성 하 고 그렇지 않으면 다음 단계를 실행 합니다.  
  
-   인수를 구현 하는 경우는 <xref:System.IFormattable> 인터페이스를 해당 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 구현이 호출 됩니다.  
  
-   인수의 매개 변수가 없는 `ToString` 메서드를 재정의 하거나 기본 클래스 구현에서 상속 호출 됩니다.  
  
 예에 대 한 호출을 가로채는 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 메서드 정보를 볼 수 있습니다 및는 <xref:System.String.Format%2A> 합성 형식 문자열의 각 형식 항목에 대 한 서식 지정 메서드에 메서드가 전달 참조 [예제: 절편 공급자 및 로마 숫자 포맷터](#Format7_Example)합니다.  

 자세한 내용은 참조는 [처리 순서](~/docs/standard/base-types/composite-formatting.md##processing-order) 섹션은 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문서.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>동일한 인덱스에 있는 서식 항목  
 <xref:System.String.Format%2A> 메서드가 throw 한 <xref:System.FormatException> 경우 인수 목록에는 수의 인수 보다 크거나 인덱스 항목의 인덱스는 예외입니다. 그러나 `format` 같은 인덱스를 보유 하는 여러 개의 형식 항목이 인수 보다 더 많은 형식 항목을 포함할 수 있습니다. 에 대 한 호출에는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 다음 예제에서는 인수 목록에에서는 메서드는 단일 인수를 형식 문자열에는 두 개의 형식 항목이 포함 되어 있지만: 숫자의 10 진수 값을 16 진수 값을 표시, 다른 하나입니다.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>서식 지정 및 문화권  
 일반적으로 인수 목록에는 개체에서 반환 되는 현재 문화권의 규칙을 사용 하 여 해당 문자열 표현으로 변환 됩니다는 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성입니다. 오버 로드 중 하나를 호출 하 여이 동작을 제어할 수 <xref:System.String.Format%2A> 포함 하는 `provider` 매개 변수입니다. `provider` 매개 변수는 한 <xref:System.IFormatProvider> 서식을 중재 하는 데 사용 되는 사용자 지정 및 culture 별 서식 지정 정보를 제공 하는 구현 처리 합니다.  
  
 <xref:System.IFormatProvider> 인터페이스에는 단일 멤버 <xref:System.IFormatProvider.GetFormat%2A>, 하는 서식 지정 정보를 제공 하는 개체를 반환 합니다. .NET Framework에는 3 개의 <xref:System.IFormatProvider> culture 별 서식 지정을 제공 하는 구현:  
  
-   <xref:System.Globalization.CultureInfo>. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드 반환 culture 별 <xref:System.Globalization.NumberFormatInfo> 숫자 값 및 culture 별 서식 지정에 대 한 개체 <xref:System.Globalization.DateTimeFormatInfo> 날짜 및 시간 값의 서식을 지정 하기 위한 개체입니다.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>날짜 및 시간 값의 culture 별 서식 지정에 사용 됩니다. 해당 <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> 메서드 자체를 반환 합니다.  
  
-   <xref:System.Globalization.NumberFormatInfo>를 숫자 값의 culture 별 서식 지정에 사용 됩니다. 해당 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 속성 자체를 반환 합니다. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>사용자 지정 서식 지정 작업  
 오버 로드 중 하나를 호출할 수도 수는 <xref:System.String.Format%2A> 메서드에 `provider` 형식의 매개 변수 <xref:System.IFormatProvider> 사용자 지정 서식 지정 작업을 수행 합니다. 예를 들어 전화 번호 또는 id 번호도 정수 서식을 지정할 수 있습니다. 사용자 지정 형식 지정을 수행 하 여 `provider` 인수 둘 다 구현 해야 합니다는 <xref:System.IFormatProvider> 및 <xref:System.ICustomFormatter> 인터페이스입니다. 경우는 <xref:System.String.Format%2A> 메서드에 전달 됩니다는 <xref:System.ICustomFormatter> 구현을으로 `provider` 인수를는 <xref:System.String.Format%2A> 메서드 호출의 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 구현 형식의 개체를 요청 하 고 <xref:System.ICustomFormatter>합니다. 그런 다음 반환 된 호출 <xref:System.ICustomFormatter> 개체의 <xref:System.ICustomFormatter.Format%2A> 복합 문자열의 각 형식 항목의 형식을 지정 메서드를 전달 합니다.  
  
 사용자 지정 형식 지정 솔루션을 제공 하는 방법에 대 한 자세한 내용은 참조 [하는 방법: 정의 및 사용 하 여 사용자 지정 숫자 형식 공급자](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) 및 <xref:System.ICustomFormatter>합니다. 서식이 지정 된 사용자 지정 번호에 정수를 변환 하는 예제를 보려면 [예제: 사용자 지정 서식 지정 작업](#Format6_Example)합니다. 부호 없는 바이트 로마 숫자 변환 하는 예제를 보려면 [예제: 절편 공급자 및 로마 숫자 포맷터](#Format7_Example)합니다.  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>예: 사용자 지정 서식 지정 작업  
 이 예제에서는 양식 x-xxxxx-xx에서 고객 계정 번호도 정수 값의 형식을 지정 하는 형식 공급자를 정의 합니다.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>예:는 절편 공급자 및 로마 숫자 포맷터  
 구현 하는 사용자 지정 형식 공급자를 정의 하는이 예제는 <xref:System.ICustomFormatter> 및 <xref:System.IFormatProvider> 다음 두 가지 작업을 수행 하는 인터페이스:  
  
-   에 전달 된 매개 변수 표시는 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 구현 합니다. 이렇게 하면를 매개 변수를 볼 수는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드가 서식을 시도 하는 각 개체에 대 한 사용자 지정 서식 구현에 전달 합니다. 응용 프로그램을 디버깅할 때 유용할 수 있습니다.  
  
-   형식을 지정할 개체는 "R" 표준 형식 문자열을 사용 하 여 형식을 지정할 수 있는 부호 없는 바이트 값 이면 사용자 지정 포맷터 형식을 로마 숫자도 숫자 값을 지정 합니다.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format 질문 및 답변  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>이유 합니까 문자열 보간 호출에 대해는 `String.Format` 메서드?

문자열 보간은입니다.

- 보다 유연 합니다. 복합 형식을 지 원하는 메서드를 호출 하지 않고도 문자열에 사용할 수 있습니다. 그렇지 않으면 호출 할는 <xref:System.String.Format%2A> 메서드 또는 복합 형식을 지 원하는와 같은 다른 방법을 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>합니다. 

- 더 쉽게 읽을 수 있습니다. 인수 목록이 아닌 보간된 식에는 문자열에 삽입할 식 나타나므로 보간된 문자열은 코드를 읽을를 훨씬 간편 합니다. 큰 여 가독성 때문에 보간된 문자열 뿐만 아니라 메서드 호출에 복합 형식, 바꿀 수는 있지만 수도 수 문자열 연결 작업에 더 간결 하 고 명확 하 게 코드를 생성 하기 위해. 

비교는 다음 두 코드 예제에서는 문자열을 연결 및 복합 형식 지정 메서드를 호출 보간된 문자열 우수성을 보여 줍니다. 다음 예제에서 여러 문자열 연결 작업을 사용 하 여 자세한 정보 보기 및 읽기 하드 코드를 생성합니다.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

다음 예에서 보간된 문자열을 사용 하 문자열 연결 문과에 대 한 호출 보다 훨씬 더 명확 하 게, 더 간결한 코드를 생성 하는 반면,는 <xref:System.String.Format%2A> 이전 예제의 메서드.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>형식 항목에 사용할 수 있는 미리 정의 된 형식 문자열의 목록을 어디에 있습니까?  
  
-   모든 정수 계열 및 부동 소수점 형식에 대 한 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   날짜 및 시간 값에 대 한 참조 [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다.  
  
-   열거형 값에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
-   에 대 한 <xref:System.TimeSpan> 값, 참조 [표준 TimeSpan 형식 문자열](~/docs/standard/base-types/standard-timespan-format-strings.md) 및 [사용자 지정 TimeSpan 형식 문자열](~/docs/standard/base-types/custom-timespan-format-strings.md)합니다.  
  
-   에 대 한 <xref:System.Guid> 의 설명 섹션을 참조 하는 값은 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 참조 페이지입니다.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>형식 항목을 대체 하는 경우 결과 문자열의 맞춤을 제어 하는 방법  
 형식 항목의 일반 구문은 다음과 같습니다.  
  
```  
{index[,alignment][: formatString]}  
```  
  
 여기서 *맞춤* 필드 너비를 정의 하는 부호 있는 정수입니다. 이 값이 음수 이면 필드의 텍스트가 왼쪽 맞춤입니다. 양수 이면 텍스트가 오른쪽 맞춤 됩니다.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>소수 구분 기호 뒤의 자릿수를 제어 하는 방법  
 모든 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) (정수만 사용 됨)입니다 "D", "G", "R", except 및 "X"는 결과 문자열의 소수 자릿수를 정의 하는 전체 자릿수 지정자를 허용 합니다. 다음 예제에서는 표준 숫자 형식 문자열을 사용 하 여 결과 문자열의 소수 자릿수의 수를 제어 합니다.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 사용 중인 경우는 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md), "0" 형식 지정자를 사용 하 여 다음 예제와 같이 결과 문자열의 소수 자릿수 수를 제어 합니다.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>정수 자릿수를 제어 하는 방법  
 기본적으로 형식 지정 작업만 0이 아닌 정수 자릿수를 표시 합니다. 정수 형식을 지정 하는 경우 숫자의 수를 제어 하려면 "X" 표준 형식 문자열 "D"와 전체 자릿수 지정자를 사용할 수 있습니다.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 "0"을 사용 하 여 지정된 하는 정수 개수의 함께 결과 문자열을 생성 하는 정수 또는 부동 소수점 숫자 앞에 오는 0을 채울 수 있습니다 [사용자 지정 숫자 서식 지정자](~/docs/standard/base-types/custom-numeric-format-strings.md)다음 예제와 같이 합니다.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>형식 목록에 포함할 수 있는 항목 수는 있습니까?  
 실용적인 제한은 없습니다. 두 번째 매개 변수는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드는 태그로 지정는 <xref:System.ParamArrayAttribute> 특성 구분 된 목록 또는 형식 목록으로 개체 배열을 포함할 수 있습니다.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>리터럴 중괄호 포함 방법 ("{" 및 "}")는 결과 문자열에 있습니까?  
 예를 들어 영향을 최소화 하는 다음 메서드 호출에서 throw 한 <xref:System.FormatException> 예외?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 여는 중괄호와 닫는 중괄호의 단일는 항상 시작 또는 형식 항목의 끝으로 해석 됩니다. 문자 그대로 해석 되도록 이스케이프 해야 합니다. 다른 중괄호를 추가 하 여는 중괄호를 이스케이프 ("{{" 및 "}}" 대신 "{" 및 "}")와 같이, 다음과 같은 메서드 호출:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 그러나 이스케이프 된 중괄호는 쉽게 잘못 해석 된 합니다. 형식 목록에서에 중괄호를 사용할 형식 항목을 사용 하 여 다음 예제와 같이 결과 문자열에 삽입 하는 것이 좋습니다.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>String.Format 메서드 호출 내는 FormatException를 throw 하는 이유  
 예외의 가지 가장 일반적인 원인은 형식 항목의 인덱스는 개체 형식 목록에서에 해당 하지 않습니다. 일반적으로 형식 항목의 인덱스가 misnumbered 했습니다 또는 형식 목록에서 개체를 포함 하려면 잊었으며 나타냅니다. 문자는 이스케이프 되지 않은 왼쪽 또는 오른쪽 중괄호를 포함 하는 또한 throw 한 <xref:System.FormatException>합니다. 경우에 따라 예외가 오타가; 결과 일반적인 실수는 잘못 입력 하는 되는 예를 들어, "[" (왼쪽된 대괄호) 대신 "{" (왼쪽된 중괄호)입니다.  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Format(System.IFormatProvider,System.String,System.Object[]) 메서드 매개 변수 배열을 지 원하는 경우 이유 코드 예외를 throw지 않습니다 배열을 사용 하는 경우?  
 예를 들어 다음 코드 throw 한 <xref:System.FormatException> 예외:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 컴파일러가 오버 로드 확인의 문제입니다. 호출 하므로 단일 인수로 정수 배열로 처리 컴파일러 정수의 배열 개체 배열을 변환할 수 없습니다는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 메서드. 4 개의 형식 항목이 있지만 형식 목록에서 항목을 단일 있기 때문에 예외가 throw 됩니다.  
  
 호출 하기 전에 사용자가 직접 변환을 수행 해야 하는 Visual Basic 또는 C# 아닙니다 개체 배열에 정수 배열로 변환할 수는 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 메서드. 다음 예제에는 하나의 구현을 제공합니다.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

호출 하는 다양 한 예제는 <xref:System.String.Format%2A> 메서드를 통해 섞여는 [주의](#remarks) 이 문서의 섹션.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

완전 한 집합을 다운로드할 수 있습니다 `String.Format` 포함 되어 있는 예제는 [C#.NET Core 2.0 프로젝트](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip) 및 [Visual basic.NET Core 2.0 프로젝트](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)에서 [dotnet/docs GitHub 리포지토리](https://github.com/dotnet/docs)합니다.

다음은 문서에 포함 된 예제입니다.

### <a name="create-a-format-string"></a>형식 문자열 만들기

[삽입](#inserting-a-string)  
[서식 항목](#the-format-item)  
[동일한 인덱스에 있는 서식 항목](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>형식이 지정 된 출력을 제어 합니다.

[서식 지정 제어](#controlling-formatting)  
[간격을 제어합니다.](#controlling-spacing)  
[맞춤을 제어합니다.](#controlling-alignment)  
[정수 자릿수를 제어합니다.](#how-do-i-control-the-number-of-integral-digits)  
[소수 구분 기호 뒤 자릿수를 제어합니다.](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[결과 문자열에 리터럴 중괄호를 포함 하 여](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>문화권 구분 형식 문자열 확인

[문화권 구분 서식 지정](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>서식 지정 작업을 사용자 지정

[사용자 지정 서식 지정 작업](#example-a-custom-formatting-operation)  
[절편 공급자 및 로마 숫자 포맷터](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">형식을 지정할 개체입니다.</param>
        <summary>문자열에 있는 하나 이상의 형식 항목을 지정된 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>서식 지정 항목이 <paramref name="format" />의 문자열 표현으로 바뀌는 <paramref name="arg0" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에서 표현을 포함 합니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>예: 단일 인수를 형식 지정  
 
 다음 예제에서는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 메서드 문자열에 특정 사용자의 나이 포함 합니다.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />의 형식 항목이 잘못된 경우  -또는-  서식 항목의 인덱스가 0이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="args">형식을 지정할 개체를 0개 이상 포함하는 개체 배열입니다.</param>
        <summary>지정된 문자열의 형식 항목을 지정된 배열에 있는 해당 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>형식 항목을 <paramref name="format" />에 있는 해당 개체의 문자열 표현으로 바꾼 <paramref name="args" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 의 4 개 이상의 식 값의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다. 이후는 `args` 으로 표시 된 매개 변수는 <xref:System.ParamArrayAttribute?displayProperty=nameWithType> 특성에 전달할 수 있습니다 개체 메서드 또는 개별 인수로 <xref:System.Object> 배열입니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>예: 4 개 이상의 인수를 형식 지정  
 
 이 예제에서는 특정 날짜의 최고 / 최저 온도에 대 한 데이터를 포함 하는 문자열을 만듭니다. 합성 형식 문자열에는 C# 예제에서 다섯 개의 형식 항목 및 Visual Basic 예의 경우 6 개 있습니다. 해당 값의 문자열 표현을 너비를 정의 하는 두 개의 형식 항목의 상태와 첫 번째 형식 항목인 아울러 표준 날짜 및 시간 서식 문자열입니다.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 배열 형식을 개체를 전달할 수도 있습니다는 인수 목록입니다.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  -또는-  서식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">형식을 지정할 개체입니다.</param>
        <summary>지정된 문자열에 있는 하나의 형식 항목 또는 여러 개의 형식 항목을 해당하는 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</summary>
        <returns>하나의 형식 항목 또는 여러 개의 형식 항목이 <paramref name="format" />의 문자열 표현으로 바뀌는 <paramref name="arg0" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에서 표현을 포함 합니다. 변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드가 변환 `arg0` 호출 하 여 문자열 표현으로 해당 **ToString(IFormatProvider)** 메서드 또는 서식 항목 호출 하 여 형식 문자열을 포함 하는 개체의 해당 하는 경우 해당 **ToString ( String, IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  -또는-  서식 항목의 인덱스가 0이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="args">형식을 지정할 개체를 0개 이상 포함하는 개체 배열입니다.</param>
        <summary>문자열의 형식 항목을 지정된 배열에 있는 해당 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</summary>
        <returns>형식 항목을 <paramref name="format" />에 있는 해당 개체의 문자열 표현으로 바꾼 <paramref name="args" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 4 개 이상의 식의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다. 변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 또는 형식 항목 형식 문자열에 포함 되어 해당 를호출하여개체의해당하는경우**ToString(String,IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>예: 문화권 구분 서식 지정  
 사용 하 여이 예제는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드를 여러 가지 서로 다른 문화권을 사용 하 여 일부 날짜 및 시간 값 및 숫자 값의 문자열 표현을 표시 합니다.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  -또는-  서식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 두 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>서식 지정 항목이 <paramref name="format" /> 및 <paramref name="arg0" />의 문자열 표현으로 바뀌는 <paramref name="arg1" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 두 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>예: 두 개의 인수를 형식 지정  
 
 사용 하 여이 예제는 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> 제네릭에 저장 된 시간 및 온도 데이터를 표시 하는 메서드 <xref:System.Collections.Generic.Dictionary%602> 개체입니다. 형식 문자열의 서식을 지정 하려면 두 개체는 있지만 세 개의 형식 항목에 있는지 확인 합니다. 가 두 형식 (날짜 및 시간 값) 목록에서 첫 번째 개체를 사용 하기 때문에 이것이: 첫 번째 형식 항목 표시 되는 경우 시간 및 두 번째 날짜를 표시 합니다.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  -또는-  서식 항목의 인덱스가 0 또는 1입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 두 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</summary>
        <returns>서식 지정 항목이 <paramref name="format" /> 및 <paramref name="arg0" />의 문자열 표현으로 바뀌는 <paramref name="arg1" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 두 식의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다. 변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 또는 형식 항목 형식 문자열에 포함 되어 해당 를호출하여개체의해당하는경우**ToString(String,IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  -또는-  서식 항목의 인덱스가 0 또는 1입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 세 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>형식 항목이 <paramref name="format" />, <paramref name="arg0" /> 및 <paramref name="arg1" />의 문자열 표현으로 바뀌는 <paramref name="arg2" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 의 세 가지 식 값의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>예: 세 개의 인수를 형식 지정  
 
 사용 하 여이 예제는 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 부울 결과 나타내는 문자열을 만들려면 메서드 `And` 두 정수 값으로 작업 합니다. 각 항목의 형식이 두 가지 방법으로 하기 때문에 형식 문자열에 6 개의 형식 항목을 포함 되지만 메서드가 매개 변수 목록에 대 한 세 개의 항목을 note 합니다.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  -또는-  서식 항목의 인덱스가 0보다 작거나, 2보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 세 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 형식 지정 정보를 제공합니다.</summary>
        <returns>형식 항목이 <paramref name="format" />, <paramref name="arg0" /> 및 <paramref name="arg1" />의 문자열 표현으로 바뀌는 <paramref name="arg2" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 세 개의 식을 해당 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다. 변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 또는 형식 항목 형식 문자열에 포함 되어 해당 를호출하여개체의해당하는경우**ToString(String,IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  -또는-  서식 항목의 인덱스가 0보다 작거나, 2보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 개별 문자에서 반복될 수 있는 개체를 검색합니다.</summary>
        <returns>열거자 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> 호출 하는 대신는 <xref:System.String.GetEnumerator%2A> 를 검색할 메서드는 <xref:System.CharEnumerator> 개체 다음 문자열을 열거할 때 사용, 해당 언어의 열거자를 대신 사용 해야 (C#, C + + /cli CLR, 및 Visual basic에서). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) C#에서는 [각각에 대해](/cpp/dotnet/for-each-in) C + + CLR, 및 [각각에 대해](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) Visual basic에서).
  
 이 메서드를 사용 하면 문자열의 개별 문자를 반복할 수 있습니다. 예를 들어, Visual Basic `For Each` 및 C# `foreach` 반환 하려면이 메서드를 호출 하는 문을 <xref:System.CharEnumerator> 는이 인스턴스의 문자를 문자열에 대 한 읽기 전용 액세스를 제공할 수 있는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 여러 개의 문자열에 문자를 반복 하 고 해당 개별 문자에 대 한 정보를 표시 합니다. 에 대 한 호출 하지 않고 언어 반복 구문을 사용 하 여는 <xref:System.String.GetEnumerator%2A> 메서드.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 문자열에 대한 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동작은 <xref:System.String.GetHashCode%2A> 공용 언어 런타임에의 한 버전에서 변경 될 수 있습니다 하는 구현에 따라 달라 집니다. 성능을 향상 시키기 위해이 문제가 발생 하는 이유는 <xref:System.String.GetHashCode%2A>합니다.  
  
> [!IMPORTANT]
>  두 string 개체 같으면는 <xref:System.String.GetHashCode%2A> 메서드 같은 값을 반환 합니다. 그러나 않습니다 각 고유한 문자열 값에 대 한 고유 해시 코드 값. 서로 다른 문자열이 동일한 해시 코드를 반환할 수 있습니다.  
>   
>  해시 코드 자체은 안정적인 것으로 보장 되지 않습니다. 동일한 문자열에 대 한 해시 코드 (예: 32 비트 및 64 비트)는 단일 버전의.NET Framework에 대 한 플랫폼 및 버전의.NET Framework에서 다를 수 있습니다. 경우에 따라 응용 프로그램 도메인 별로 다도 수 있습니다. 즉, 같은 프로그램의 후속 실행을 두 개의 다른 해시 코드를 반환할 수 있습니다.  
>   
>  결과적으로 해시 코드 작성 된 응용 프로그램 도메인 외부에서 사용할 수는 없습니다는 컬렉션의 키 필드와 사용 하지 않아야 하 고 유지 되지 않도록 합니다.  
>   
>  마지막으로, 하지 않는 암호화 된 강력한 해시 해야 할 경우 암호화 해시 함수에서 반환 된 값 대신 해시 코드를 사용 합니다. 파생 된 클래스를 사용 하 여 암호화 해시에 대 한는 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 또는 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 클래스입니다.  
>   
>  해시 코드에 대 한 자세한 내용은 참조 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 데스크톱 앱에서 사용할 수 있습니다는 [ \<UseRandomizedStringHashAlgorithm > 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) 에 고유한 해시 코드를 생성 하는 응용 프로그램 도메인 단위로. 수 충돌 수 줄이고 삽입 및 해시 테이블을 사용 하는 조회의 전체 성능을 향상 시킵니다. 사용 하는 방법을 보여 주는 다음 예제는 [ \<UseRandomizedStringHashAlgorithm > 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)합니다. 정의 고유한 해시 코드를 생성에 응용 프로그램 도메인 단위로. 수 충돌 수 줄이고 삽입 및 해시 테이블을 사용 하는 조회의 전체 성능을 향상 시킵니다. 사용 하는 방법을 보여 주는 다음 예제는 합니다. 정의 `DisplayString` 개인 문자열 상수를 포함 하는 클래스 `s`, 해당 값은 "는 문자열입니다." 메서드를 실행하는 응용 프로그램 도메인의 이름과 함께 문자열 값 및 해시 코드를 표시하는 `ShowStringHashCode` 메서드도 포함합니다.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 구성 파일을 지정하지 않고 이 예제를 실행할 경우 다음과 유사한 출력이 표시됩니다. 문자열의 해시 코드는 두 응용 프로그램 도메인에서 동일합니다.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 하지만 샘플 디렉터리에 다음의 구성을 추가하고 샘플을 실행하는 경우 동일 문자열의 해시 코드는 응용 프로그램 도메인에 의해 달라집니다.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 구성 파일이 있는 경우 예제는 다음과 같은 출력을 표시합니다.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  해시 코드를 삽입 하 고 효율적으로 해시 테이블에서 키가 지정 된 개체를 검색 하는 데 사용 됩니다. 그러나 해시 코드 문자열을 고유 하 게 식별 하지 않습니다. 동일한 문자열 같은 해시 코드를 갖지만 공용 언어 런타임에서 다른 문자열에는 동일한 해시 코드 할당할 수도 있습니다. 또한.NET Framework의 버전, 단일 버전 내에서 플랫폼 및 응용 프로그램 도메인에서 해시 코드 달라질 수 있습니다. 이 때문에 serialize 하거나 해시 코드 값을 유지 해야 하거나 해시 테이블 또는 사전에 키로 사용 합니다.  
  
 해시 코드의 사용에 대 한 자세한 내용은 및 `GetHashCode` 메서드를 참조 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.GetHashCode%2A> 다양 한를 사용 하 여 메서드 입력 문자열입니다.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>반환한 값 <see cref="M:System.String.GetHashCode" /> 플랫폼에 따라 다릅니다. 32 비트 및 64 비트 버전의.NET Framework에 점이 다릅니다. .NET Framework의 버전 간에 달라질 수 있으므로 합니다.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.TypeCode" /> 클래스에 대한 <see cref="T:System.String" />를 반환합니다.</summary>
        <returns>열거형 상수인 <see cref="F:System.TypeCode.String" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 표시는 <xref:System.TypeCode> 에 대 한 열거형된 상수는 <xref:System.String> 유형입니다.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 유니코드 문자 또는 문자열의 0부터 시작하는 인덱스를 보고합니다. 이 인스턴스에 해당 문자나 문자열이 없으면 이 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <summary>이 문자열에서 맨 처음 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스를 보고합니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 방법을 검색할 수 있습니다는 <xref:System.String> 사용 하 여 문자에 대 한는 <xref:System.String.IndexOf%2A> 메서드.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다. 이 인스턴스의 첫 번째 문자 위치에서 시작 하 고 마지막 문자 위치까지 검색 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.IndexOf%28System.String%29> 메서드는 항상 현재 인스턴스의 시작 부분에서 일치 항목은 발견 되었음을 나타내려면 0 (영)을 반환 합니다. 다음 예제에서는 <xref:System.String.IndexOf%28System.String%29> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 각각의 경우에는 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 결과 동일에 붙은 사용자 지정 하이픈이 포함 되지 않았던 마치 `value`합니다. 하이픈이를 검색할 때 메서드를 나타내는 문자열의 시작 부분에서 일치 하는 항목이 발견 했다는 0 (영)을 반환 합니다.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 다음 예제에서는 "동물"에서 "n"를 검색합니다. 문자열 인덱스를 보다는 0부터 시작 하므로 <xref:System.String.IndexOf%28System.String%29> 메서드 위치 1에 "n" 임을 나타냅니다.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 다음 예제에서는 <xref:System.String.IndexOf%2A> 문장의 동물 이름의 시작 위치를 결정 하는 메서드. 다음이 위치를 사용 하 여는 문장으로 동물을 설명 하는 형용사를 삽입 합니다.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 현재 문화권의 비교 규칙을 사용 하 여 문자열 인스턴스 내에서 부분 문자열의 첫 번째 인덱스를 찾으려면, 호출의 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 'comparisonType' 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <summary>이 문자열에서 맨 처음 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작됩니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치는 문자열의 시작 부분에서 0부터 시작되고 해당 문자열이 없으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0에서 시작합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다. 경우 `startIndex` 문자열 인스턴스 길이 같으면, 메서드가-1을 반환 합니다.  
  
 검색 범위에서 `startIndex` 문자열의 끝에 있습니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.IndexOf%2A> 메서드.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 0보다 작거나 문자열의 길이보다 큰 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작됩니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 인덱스 위치(0부터 시작)이고, 해당 문자열이 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0에서 시작합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다. 경우 `startIndex` 문자열 인스턴스 길이 같으면, 메서드가-1을 반환 합니다.  
  
 이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다. 검색이 시작 된 `startIndex` 문자이 인스턴스의 위치 및 마지막 문자 위치까지 계속 됩니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다. 다음 예제에서는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 메서드 뒤에 두 개의 문자열에 "m" 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스입니다. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 다음 예제에서는 대상 문자열에 지정된 된 문자열의 문자열을 모두 검색 합니다.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 0보다 작거나 이 문자열의 길이보다 큰 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 현재 문화권의 비교 규칙을 사용 하 여 특정 문자 위치 후 발생 하는 부분 문자열의 첫 번째 인덱스를 찾으려면, 호출 된 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 'comparisonType' 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 `comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 3 오버 로드는 <xref:System.String.IndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 첫 번째 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합 포함 무시할 수 있는 문자는 문자는 언어 또는 문화권 구분 비교를 수행 하는 경우 고려 되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드는 항상 현재 인스턴스의 시작 부분에서 일치 항목은 발견 되었음을 나타내려면 0 (영)을 반환 합니다.  다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 예제를 실행 하는 경우는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 문화권 구분 검색 동일한 값을 반환 하이픈 검색 문자열에 포함 되지 않은 경우이 반환 됩니다. 그러나 서 수 검색을 성공적으로 하이픈 한 문자열에서 찾아 보고 해주어에서 두 번째 문자열입니다.  [! 코드 csharp [System.String.IndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.IndexOf/CS/ignorable26.cs#26)] [! vb 코드 [System.String.IndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치는 문자열의 시작 부분에서 0부터 시작되고 해당 문자열이 없으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 인덱스 번호 0 (영)부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.IndexOf%2A> 메서드.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  -또는-  <paramref name="startIndex" />가 이 문자열의 길이보다 큽니다.  -또는-  <paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 인덱스 위치(0부터 시작)이고, 해당 문자열이 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호 0 (영)부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.  
  
 이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다. 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다. 다음 예제에서는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드 뒤에 "m"부터 두 문자열의 여섯 번째 문자 위치에서 세 번째 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 다음 예제에서는 문자열의 모든 항목의 인덱스를 찾습니다 다른 문자열의 부분 문자열에서 "he"입니다. 각 검색 반복에 대해 검색할 문자의 수를 다시 계산 해야 하는 참고 합니다.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  -또는-  <paramref name="startIndex" />가 이 문자열의 길이보다 큽니다.  -또는-  <paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 이 작업을 수행 하려면 현재 문화권의 비교 규칙을 사용 하려면 호출는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 'comparisonType' 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 현재 문자열의 검색 시작 위치와 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0에서 시작합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다. 경우 `startIndex` 문자열 인스턴스 길이 같으면, 메서드가-1을 반환 합니다.  
  
 `comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 3 오버 로드는 <xref:System.String.IndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 첫 번째 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 0보다 작거나 이 문자열의 길이보다 큰 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합 포함 무시할 수 있는 문자는 문자는 언어 또는 문화권 구분 비교를 수행 하는 경우 고려 되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.  다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m"가 포함 된 두 문자열의 세 번째 문자 위치부터 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함 되어 있습니다. 예제를 실행 하는 경우는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다. 메서드는 서 수 비교를 수행 하는 경우에 첫 번째 문자열에는 사용자 지정 하이픈의 인덱스를 반환 합니다.  [! 코드 csharp [System.String.IndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.IndexOf/CS/ignorable25.cs#25)] [! vb 코드 [System.String.IndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 현재 문자열의 검색 시작 위치, 검색할 현재 문자열의 문자 수 및 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호 0 (영)부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.  
  
 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 `comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 3 오버 로드는 <xref:System.String.IndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 첫 번째 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  -또는-  <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.  -또는-  <paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합 포함 무시할 수 있는 문자는 문자는 언어 또는 문화권 구분 비교를 수행 하는 경우 고려 되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.  다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m"부터 두 문자열의 여섯 번째 문자 위치에서 세 번째 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우. 그러나 서 수 비교를 수행 하는 경우 찾으면 부분 문자열이 첫 번째 문자열에만 합니다. 참고의 경우 첫 번째 문자열 뒤에 "m" 하이픈을 포함 하는 메서드는 사용자 지정 하이픈의 인덱스를 반환 하지 못하고 문화권 구분 비교를 수행 하는 경우 대신 "m"의 인덱스를 반환 합니다. 메서드는 서 수 비교를 수행 하는 경우에 첫 번째 문자열에는 사용자 지정 하이픈의 인덱스를 반환 합니다.  [! 코드 csharp [System.String.IndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.IndexOf/CS/ignorable24.cs#24)] [! vb 코드 [System.String.IndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에서 이 인스턴스에서 맨 처음 발견되는 문자의 인덱스를 보고합니다. 이 인스턴스에 해당 문자가 없으면 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 에 대 한 검색 `anyOf` 대 소문자를 구분 합니다. 경우 `anyOf` (가) 빈 배열에서 문자열의 시작 부분에서 일치 하는 방법 찾습니다 (즉, 인덱스 0에).  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열에서 첫 번째 모음을 찾습니다.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작됩니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 보다 1 작은 값입니다.  
  
 검색 범위에서 `startIndex` 문자열의 끝에 있습니다.  
  
 에 대 한 검색 `anyOf` 대 소문자를 구분 합니다.  
  
 이 메서드 유니코드 스칼라 값의 동일 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에서 "is"는 문자열의 문자를 일치 하는 항목의 인덱스를 찾습니다.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 음수입니다.  -또는-  <paramref name="startIndex" />가 이 인스턴스의 문자 수보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 인덱스 번호는 0부터 시작합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 보다 1 작은 값입니다.  
  
 에 대 한 검색 `anyOf` 대 소문자를 구분 합니다.  
  
 이 메서드 유니코드 스칼라 값의 동일 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에서 "aid" 문자열의 문자를 일치 하는 항목의 인덱스를 찾습니다.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  -또는-  <paramref name="count" /> + <paramref name="startIndex" />가 이 인스턴스의 문자 수보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">삽입의 0부터 시작하는 인덱스 위치입니다.</param>
        <param name="value">삽입할 문자열입니다.</param>
        <summary>이 인스턴스의 지정된 인덱스 위치에 지정한 문자열이 삽입되는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 <paramref name="value" /> 위치에 <paramref name="startIndex" />가 삽입된 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `startIndex` 이 인스턴스의 길이 같으면 `value` 이 인스턴스의 끝에 추가 됩니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 새 문자열을 반환 대신 `value` 가 현재 인스턴스에 삽입 합니다.  
  
 반환 값의 예를 들어 `"abc".Insert(2, "XYZ")` "abXYZc" 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열의 네 번째 문자 위치 (인덱스 3에 문자)에 나오는 공백 문자를 삽입합니다.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 다음 콘솔 응용 프로그램에는 사용자가 두 개의 동물을 설명 하기 위해 하나 이상의 형용사를 입력 하도록 메시지 표시 합니다. 그런 다음 호출 하는 <xref:System.String.Insert%2A> 메서드는 문자열에 사용자가 입력 한 텍스트를 삽입 합니다.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 음수이거나 이 인스턴스의 길이보다 큰 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">내부 풀에서 검색할 문자열입니다.</param>
        <summary>지정된 <see cref="T:System.String" />에 대한 시스템의 참조를 검색합니다.</summary>
        <returns>
          <paramref name="str" />이 내부 풀에 추가되었으면 해당 시스템 참조이고, 그러지 않으면 <paramref name="str" /> 값을 가진 문자열에 대한 새 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공용 언어 런타임 선언 또는 프로그램에서 프로그래밍 방식으로 만든 각 고유 리터럴 문자열에 대 한 단일 참조를 포함 하는 내부 풀 이라는 테이블을 유지 하 여 문자열 저장소를 절약 합니다. 따라서 특정 값으로는 리터럴 문자열의 인스턴스만 한 번 시스템에 있습니다.  
  
 예를 들어 여러 변수에 동일한 리터럴 문자열을 할당 하는 경우 런타임 내부 풀에서 리터럴 문자열에 같은 참조를 검색 및 각 변수에 할당 합니다.  
  
 <xref:System.String.Intern%2A> 메서드 내부 풀의 값과 같은 문자열 검색을 사용 하 여 `str`합니다. 해당 문자열이 있으면 해당 참조는 내부 풀에서 반환 됩니다. 문자열 존재 하지 않는 경우에 대 한 참조 `str` 반환 되 고 참조 하는 내부 풀에 추가 됩니다.  
  
 다음 예제에서는 "mytest" 값이 문자열 s1은 이미 인턴 지정은 프로그램의 리터럴 이기 때문에 합니다. <xref:System.Text.StringBuilder?displayProperty=nameWithType> 클래스 s 1과 동일한 값을 갖는 새 문자열 개체를 생성 합니다. 이 문자열에 대 한 참조는 s 2에 할당 됩니다. <xref:System.String.Intern%2A> s 2와 동일한 값을 가진 문자열에 대 한 메서드를 검색 합니다. 이러한 문자열 존재 하기 때문에 s 1에 할당 된 동일한 참조가 반환 합니다. 참조 하는 s 3에 할당 됩니다. 참조 s1 및 s2 같지 않은 다른 개체 참조 하기 때문에 동일한 문자열 참조 하기 때문에 참조 s1 및 s 3 같은지 비교 합니다.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 이 <xref:System.String.IsInterned%2A> 메서드.  
  
## <a name="version-considerations"></a>버전 고려 사항  
 에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> 메서드는.NET Framework 1.0 및 1.1 빈 문자열 인터닝 관련 하 여 해당 동작으로 돌아갑니다. 다음 예에서 변수 `str1` 에 대 한 참조를 할당 된 <xref:System.String.Empty>, 변수 및 `str2` 에 대 한 참조를 할당 된 <xref:System.String.Empty> 호출 하 여 반환 되는 <xref:System.String.Intern%2A> 메서드는 변환한후<xref:System.Text.StringBuilder>값을 가진 개체 <xref:System.String.Empty> 문자열로 합니다. 에 포함 된 참조 다음 `str1` 및 `str2` 동등한 지 비교 합니다.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 에 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], 및 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` 및 `str2` 같은지 합니다. 에 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] 및 [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` 및 `str2` 같지 않습니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 총 메모리 양을 줄이기 위해 시도 하는 경우 응용 프로그램 할당, 하는 문자열 인터닝 두 원치 않는 부작용 염두에서에 둬야 합니다. 내부 풀에 추가 대 한 메모리가 할당 하는 첫째, <xref:System.String> 개체는 가능성이 해제 될 공용 언어 런타임 (CLR) 종료 될 때까지 합니다. 이유는는 풀에 대 한 참조를 CLR의 <xref:System.String> 개체 내부 응용 프로그램 또는 사용자 응용 프로그램 도메인, 종료 합니다. 둘째, 문자열을 내부 화를 먼저 만들어야 합니다는 문자열입니다. 사용 되는 메모리는 <xref:System.String> 개체 해야 여전히를 할당할 수 있지만 메모리 가비지 수집 됩니다.  
  
 .NET Framework 버전 2.0에 도입 된 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> 열거형 멤버입니다. <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 멤버 문자열 리터럴 인턴 지정 필요 하지 않은 어셈블리를 표시 합니다. 적용할 수 있습니다 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 를 사용 하 여 어셈블리에는 <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> 특성입니다. 또한 사용 하는 경우는 [Ngen.exe (네이티브 이미지 생성기)](~/docs/framework/tools/ngen-exe-native-image-generator.md) 런타임 이전 어셈블리를 컴파일, 문자열은 모듈 간에 인턴 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 문자열 같은 새로 만든된 문자열과 지 여부를 결정 하는 값을 사용 하 여 및 인턴 지정된 문자열이 같은지 합니다.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">내부 풀에서 검색할 문자열입니다.</param>
        <summary>지정된 <see cref="T:System.String" />에 대한 참조를 검색합니다.</summary>
        <returns>
          <paramref name="str" />이 공용 언어 런타임 내부 풀에 있으면 해당 참조이고, 그렇지 않으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공용 언어 런타임에서 자동으로 테이블을 유지 하는데의 모든 고유 인스턴스를 비롯 하 여 프로그램에 선언 된 각 고유한 리터럴 문자열 상수의 단일 인스턴스를 포함 하는 내부 풀 이라는 <xref:System.String> 호출 하 여 프로그래밍 방식으로 추가 <xref:System.String.Intern%2A> 메서드.  
  
 내부 풀 문자열 저장소를 절약합니다. 각 변수는 내부 풀의 여러 인스턴스를 참조 하는 대신에 동일한 상수 참조로 설정 됩니다 여러 변수에 리터럴 문자열 상수를 할당 하는 경우 <xref:System.String> 동일한 값을 갖는 합니다.  
  
 이 메서드를 찾습니다 `str` 내부 풀에 있습니다. 경우 `str` 가 이미 반환 되 고, 그렇지 않으면 해당 인스턴스에 대 한 참조는 풀 `null` 반환 됩니다.  
  
 이 <xref:System.String.Intern%2A> 메서드.  
  
 이 메서드는 부울 값을 반환 하지 않습니다. 특정 문자열은 인턴 지정 하는지 여부를 나타내는 부울 값을 반환 하기 때문에 메서드를 호출 하는 경우에 다음과 같은 코드를 사용할 수 있습니다.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  .NET Framework 버전 2.0 부터는 재정의할 수 있습니다는 내부 풀의 사용 하 여 사용 하는 경우는 [Ngen.exe (네이티브 이미지 생성기)](~/docs/framework/tools/ngen-exe-native-image-generator.md) 로컬 컴퓨터의 네이티브 이미지 캐시에는 어셈블리를 설치 합니다. 자세한 내용은 성능 고려 사항에 대 한 설명 섹션을 참조 하십시오.는 <xref:System.String.Intern%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예에서는 리터럴 문자열 컴파일러에 의해 자동으로 수행 됩니다 하는 방법을 보여 줍니다.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열의 형식이 특정 유니코드 정규화 형식인지를 나타냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 형식이 유니코드 정규화 형식 C인지를 나타냅니다.</summary>
        <returns>이 문자열의 형식이 정규화 형식 C이면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.  
  
 표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다. 정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다. .NET Framework는 현재 정규화 형식 C, D, KC 및 KD를 지원합니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 성공적으로 다양 한 정규화 형식으로 정규화 되어 있는지 여부를 결정 합니다.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다. 따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">유니코드 정규화 형식입니다.</param>
        <summary>이 문자열의 형식이 지정한 유니코드 정규화 형식인지를 나타냅니다.</summary>
        <returns>이 문자열의 형식이 <see langword="true" /> 매개 변수로 지정된 정규화 형식이면 <paramref name="normalizationForm" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.  
  
 표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다. 정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다. .NET Framework는 현재 정규화 형식 C, D, KC 및 KD를 지원합니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.IsNormalized%2A> 및 <xref:System.String.Normalize%2A> 메서드.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다. 따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">테스트할 문자열입니다.</param>
        <summary>지정된 문자열이 <see langword="null" />이거나 <see cref="F:System.String.Empty" /> 문자열인지를 나타냅니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수가 <paramref name="value" />이거나 빈 문자열("")이면 <see langword="null" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> 동시에 테스트할 수 있도록 하는 편리한 메서드입니다 여부는 <xref:System.String> 은 `null` 여부나 해당 값이 <xref:System.String.Empty>합니다. 다음 코드를 하는 것이 같습니다.  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 사용할 수 있습니다는 <xref:System.String.IsNullOrWhiteSpace%2A> 메서드는 문자열이 있는지 여부를 테스트 `null`, 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>, 또는 공백 문자로 구성 되어 있습니다.  
  
## <a name="what-is-a-null-string"></a>Null 문자열 이란?  
 문자열은 `null` 에 명시적으로 할당 된 경우의 값 또는 값 (c + + 및 Visual Basic) 할당 하지 않은 경우 `null`합니다. 하지만 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 기능 해당 멤버를 throw 하는 경우 하나를 호출 하는 다음 예제와 같이 null 문자열을 정상적으로 처리할 수는 <xref:System.NullReferenceException>합니다.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>빈 문자열 이란?  
 문자열은 빈 문자열을 명시적으로 할당 된 경우에 빈 ("") 또는 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 빈 문자열에는 <xref:System.String.Length%2A> 0입니다.  다음 예제에서는 빈 문자열을 만들고 해당 값 및 해당 길이 표시 합니다.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 다음 예제에서는 세 개의 문자열을 검사 하 고 하는지를 결정 합니다. 각 문자열 값, 빈 문자열인은 `null`합니다.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">테스트할 문자열입니다.</param>
        <summary>지정된 문자열이 <see langword="null" />이거나 비어 있거나 공백 문자로만 구성되어 있는지를 나타냅니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수가 <paramref name="value" /> 또는 <see langword="null" />이거나, <see cref="F:System.String.Empty" />가 모두 공백 문자로 구성되어 있으면 <paramref name="value" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> 뛰어난 성능을 제공 한다는 점을 제외 하면 다음 코드와 유사 하는 편리한 메서드입니다.  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 공백 문자는 유니코드 표준에서 정의 됩니다. <xref:System.String.IsNullOrWhiteSpace%2A> 의 값을 반환 하는 임의의 문자 1 보다 크거나 `true` 를 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 공백 문자로 메서드.  
  
   
  
## Examples  
 다음 예제에서는 문자열 배열을 만들고 그런 다음에 배열의 각 요소에 전달 된 <xref:System.String.IsNullOrWhiteSpace%2A> 메서드.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>각 요소 또는 멤버 사이에 지정된 구분 기호를 사용하여 지정된 배열 요소나 컬렉션 멤버를 연결합니다.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다. <c>separator</c>는 <c>values</c>에 요소가 둘 이상 있는 경우에만 반환 문자열에 포함됩니다.</param>
        <param name="values">연결할 문자열을 포함하는 컬렉션입니다.</param>
        <summary>각 멤버 사이에 지정된 구분 기호를 사용하여 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 형식의 생성된 <see cref="T:System.String" /> 컬렉션의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 멤버로 구성된 문자열입니다. <paramref name="values" />에 멤버가 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 하는 경우의 모든 멤버가 `values` 은 `null`, 빈 문자열을 대신 사용 됩니다.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 각 요소에 연결할 수 있는 편리한 메서드입니다는 `IEnumerable(Of String)` 먼저 문자열 배열에 요소를 변환 하지 않고 컬렉션입니다. LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 특히 유용합니다. 다음 예제에서는 전달 된 `List(Of String)` 알파벳 문자 (즉, 예제에서는 "M")를 특정 문자 보다 크거나 같은 선택 하는 람다 식에 대 / 소문자 구분 문자가 들어 있는 개체입니다. `IEnumerable(Of String)` 에서 반환 된 컬렉션의 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 메서드에 전달 되는 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 단일 문자열 결과 표시 하려면 메서드.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 결과를 할당 한 <xref:System.Collections.Generic.List%601> 형식의 개체 <xref:System.String>에 전달 되는 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다. <c>values</c>에 둘 이상의 요소가 있는 경우에만 <c>separator</c>가 반환된 문자열에 포함됩니다.</param>
        <param name="values">연결할 요소가 포함된 배열입니다.</param>
        <summary>각 요소 사이에 지정된 구분 기호를 사용하여 개체 배열의 요소를 연결합니다.</summary>
        <returns>
          <paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 요소로 구성된 문자열입니다. <paramref name="values" />가 빈 배열인 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `separator` 은 `null` 경우의 요소가 `values` 이외의 첫 번째 요소는 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 경우에 호출자에 대 한 메모를 참조 하세요의 첫 번째 요소로 `values` 은 `null`합니다.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 명시적으로 해당 요소를 문자열로 변환 하지 않고 개체 배열의 각 요소에에서 연결할 수 있는 편리한 메서드입니다. 배열에 있는 각 개체의 문자열 표현을 해당 개체를 호출 하 여 파생 된 `ToString` 메서드.  
  
   
  
## Examples  
 다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 결과에 전달 되는 정수 배열에 할당 된 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 메서드.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>하는 경우의 첫 번째 요소 <paramref name="values" /> 은 <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> 메서드의 요소를 연결 하지 않는 <paramref name="values" /> 않고 <see cref="F:System.String.Empty" />합니다. 이 문제에 대 한 대안 다양을 사용할 수 있습니다. 값을 할당 하는 가장 쉬운 방법은 <see cref="F:System.String.Empty" /> 배열의 첫 번째 요소에 다음 예제와 같이 보여 줍니다.  [! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다. <c>value</c>에 둘 이상의 요소가 있는 경우에만 <c>separator</c>가 반환된 문자열에 포함됩니다.</param>
        <param name="value">연결할 요소가 포함된 배열입니다.</param>
        <summary>각 요소 사이에 지정된 구분 기호를 사용하여 문자열 배열의 모든 요소를 연결합니다.</summary>
        <returns>
          <paramref name="value" /> 문자열로 구분된 <paramref name="separator" />의 요소로 구성된 문자열입니다. <paramref name="value" />가 빈 배열인 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 경우 `separator` 은 "," 및 요소의 `value` "apple", "주황색", "포도" 및 "배" `Join(separator, value)` "apple, 주황, 포도, 배"를 반환 합니다.  
  
 경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 경우에 있는 모든 요소 `value` 은 `null`, 빈 문자열을 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Join%2A> 메서드.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다. <c>value</c>에 둘 이상의 요소가 있는 경우에만 <c>separator</c>가 반환된 문자열에 포함됩니다.</param>
        <param name="value">연결할 요소가 포함된 배열입니다.</param>
        <param name="startIndex">사용할 <c>value</c>의 첫 번째 요소입니다.</param>
        <param name="count">
          <c>value</c> 중에서 사용할 요소의 수입니다.</param>
        <summary>각 요소 사이에 지정된 구분 기호를 사용하여 문자열 배열의 지정된 요소를 연결합니다.</summary>
        <returns>
          <paramref name="value" /> 문자열로 구분된 <paramref name="separator" />의 문자열로 구성된 문자열입니다.  -또는-  <paramref name="count" />가 0이거나, <paramref name="value" />에 요소가 없거나, <paramref name="separator" /> 및 <paramref name="value" />의 모든 요소가 <see cref="F:System.String.Empty" />인 경우 <see cref="F:System.String.Empty" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 경우 `separator` 은 "," 및 요소의 `value` "apple", "주황색", "포도" 및 "배" `Join(separator, value, 1, 2)` 반환 "주황색, 포도"입니다.  
  
 경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 경우에 있는 모든 요소 `value` 은 `null`, 빈 문자열을 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 과일 이름의 배열에서 두 요소를 연결 합니다.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="count" />가 0 미만입니다.  -또는-  <paramref name="startIndex" /> + <paramref name="count" />가 <paramref name="value" />의 요소 수보다 큽니다.</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">구성원 유형을 <c>값</c>합니다.</typeparam>
        <param name="separator">구분 기호로 사용할 문자열입니다. <c>separator</c>는 <c>values</c>에 요소가 둘 이상 있는 경우에만 반환 문자열에 포함됩니다.</param>
        <param name="values">연결할 개체를 포함하는 컬렉션입니다.</param>
        <summary>각 멤버 사이에 지정된 구분 기호를 사용하여 컬렉션의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 멤버로 구성된 문자열입니다. <paramref name="values" />에 멤버가 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 하는 경우의 모든 멤버가 `values` 은 `null`, 빈 문자열을 대신 사용 됩니다.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 각 멤버를 연결할 수 있는 편리한 메서드입니다는 <xref:System.Collections.Generic.IEnumerable%601> 첫 번째 요소를 문자열로 변환 하지 않고 컬렉션입니다. 에 있는 각 개체의 문자열 표현을 <xref:System.Collections.Generic.IEnumerable%601> 해당 개체를 호출 하 여 파생 된 컬렉션은 `ToString` 메서드.  
  
 이 메서드는 특정 LINQ (Language-Integrated Query) 쿼리 식을 사용할 때 도움이 됩니다. 예를 들어 다음 코드는 매우 간단한 정의 `Animal` 동물 속해 있는 주문의 이름을 포함 하는 클래스입니다. 그런 다음 정의 <xref:System.Collections.Generic.List%601> 의 수를 포함 하는 개체 `Animal` 개체입니다. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 확장 메서드를 호출을 추출 하는 `Animal` 개체 `Order` 속성 "설치류" 값은입니다. 결과에 전달 되는 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 결과를 할당 한 <xref:System.Collections.Generic.List%601> 에 전달 되는 정수 형식의 개체는 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자 또는 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 이 인스턴스에 해당 문자나 문자열이 없으면 이 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 이 메서드는이 인스턴스의 마지막 문자 위치에서 검색을 시작 하 고 될 때까지 시작 부분을 향해 뒤로 `value` 보수인 찾거나 첫 번째 문자 위치입니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `ExtractFilename` 메서드를 사용 하는 <xref:System.String.LastIndexOf%28System.Char%29> 메서드 문자열에서 마지막 디렉터리 구분 문자를 찾습니다 하 고 문자열의 파일 이름을 추출 합니다. 파일이 있는 경우 해당 경로 없이 파일 이름만을 반환 됩니다.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 0부터 시작하는 인덱스 위치이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 이 인스턴스의 마지막 인덱스 위치를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 이 인스턴스의 마지막 문자 위치에서 시작 하 고 될 때까지 시작 부분을 향해 뒤로 검색 `value` 발견 되 찾거나 첫 번째 문자 위치입니다.  
  
 이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.LastIndexOf%28System.String%29> 메서드는 항상 반환 <xref:System.String.Length%2A?displayProperty=nameWithType> – 현재 인스턴스의 마지막 인덱스 위치를 나타내는 1입니다. 다음 예제에서는 <xref:System.String.LastIndexOf%28System.String%29> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 각각의 경우에는 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 결과 동일에 붙은 사용자 지정 하이픈이 포함 되지 않았던 마치 `value`합니다. 하이픈이를 검색할 때 메서드 6, 5를 반환 합니다. 이러한 값의 두 문자열의 마지막 문자 인덱스에 해당 합니다.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 다음 예제에서는 열고 닫는 태그를 시작 하는 경우 문자열 및 문자열 끝에서 HTML 태그를 제거 합니다. 문자열에 닫는로 끝나는 경우 대괄호 문자 (">")를 사용 하 여는 <xref:System.String.LastIndexOf%2A> 끝 태그 시작을 찾을 방법.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 현재 문화권의 비교 규칙을 사용 하 여 문자열 인스턴스 내에서 부분 문자열의 마지막 인덱스를 찾으려면, 호출의 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자가 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1.가이 메서드 검색 시작 위치는 `startIndex` 문자이 인스턴스와 될 때까지 현재 인스턴스의 시작 부분을 향해 뒤로의 위치 `value` 보수인 찾거나 첫 번째 문자 위치입니다. 예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1, 메서드 시작 부분에 문자열에 있는 모든 문자와 마지막 문자에서를 검색 합니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열의 끝에서 작업 하는 문자열의 시작 부분에 문자열에서 문자의 모든의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 이 인스턴스의 길이보다 크거나 같습니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작는 `startIndex` 문자이 인스턴스 위치 때까지 뒤로 `value` 발견 되 찾거나 첫 번째 문자 위치입니다. 예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1, 메서드 시작 부분에 문자열에 있는 모든 문자와 마지막 문자에서를 검색 합니다.  
  
 이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다. 다음 예제에서는 <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 메서드 하이픈이 (U + 00AD)를 포함 하 고 앞 또는 마지막 "m" 문자열에 포함 하는 부분 문자열을 찾는 데 사용 됩니다. 이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 하거나 검색 문자열에 하이픈은 무시 되므로 나중를 substrin를 찾기 위해 호출 하는 반면 문자열에 "m"의 위치를 반환 하는 사용자 지정 하이픈 및 "m"으로 구성 된 부분 문자열을 찾을 수 메서드를 호출 사용자 지정 하이픈 및 "n"으로 구성 된 g "n"의 위치를 반환 합니다. 검색 문자열만 하이픈을 포함 된 경우 메서드는 "m"의 값을 나타내는의 인덱스를 반환 하는 `startIndex`합니다.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 다음 예제에서는 대상 문자열에 대상 문자열의 시작 부분에 대상 문자열의 끝에서 작업 하는 모든 문자열의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 현재 인스턴스의 길이보다 큽니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="startIndex" />가 -1보다 작거나 0보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 현재 문화권의 비교 규칙을 사용 하 여 특정 문자 위치를 앞에 있는 부분 문자열의 인덱스를 찾기 위해 호출 된 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 0부터 시작하는 인덱스 위치이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 이 인스턴스의 마지막 인덱스 위치를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 `comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
 이 인스턴스의 마지막 문자 위치에서 시작 하 고 될 때까지 시작 부분을 향해 뒤로 검색 `value` 발견 되 찾거나 첫 번째 문자 위치입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 3 오버 로드는 <xref:System.String.LastIndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합 포함 무시할 수 있는 문자는 문자는 언어 또는 문화권 구분 비교를 수행 하는 경우 고려 되지 않습니다. 문화권 구분 검색(즉, <paramref name="options" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드는 항상 반환 <see cref="P:System.String.Length" /> – 현재 인스턴스의 마지막 인덱스 위치를 나타내는 1입니다.  다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 예제를 실행 하는 경우는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 문화권 구분 검색 동일한 값을 반환 하이픈 검색 문자열에 포함 되지 않은 경우이 반환 됩니다. 그러나 서 수 검색을 성공적으로 하이픈 한 문자열에서 찾아 보고 해주어에서 두 번째 문자열입니다.  [! 코드 csharp [System.String.LastIndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.LastIndexOf/cs/lastindexof26.cs#26)] [! vb 코드 [System.String.LastIndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스의 부분 문자열에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자가 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 이 메서드 검색 시작 위치는 `startIndex` 위치 및 될 때까지이 인스턴스의 시작 부분을 향해 뒤로 문자 `value` 가 또는 `count` 문자 위치가 검사 합니다. 예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자는 문자열의 마지막 문자를 합니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드 유니코드 스칼라 값의 동일 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 부분 문자열의 시작 부분에 있는 부분 문자열의 끝에서 작업 하는 부분 문자열에서 문자의 모든의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 이 인스턴스의 길이보다 크거나 같습니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 0보다 작습니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작는 `startIndex` 문자이 인스턴스 위치 때까지 뒤로 `value` 를 찾을 수 또는 `count` 문자 위치가 검사 합니다. 예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자는 문자열의 마지막 문자를 합니다.  
  
 이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.LastIndexOf%2A> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다. 다음 예제에서는 <xref:System.String.LastIndexOf%2A> 메서드 두 문자열의 최종 "m" 앞에 있는 두 문자에서 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 다음 예제에서는 부분 문자열의 시작 부분에 있는 부분 문자열의 끝에서 작업 하는 부분 문자열에서 모든 문자열의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 음수입니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 인스턴스 외부의 위치를 지정합니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="start" />가 -1보다 작거나 0보다 큽니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="count" />가 1보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 현재 문화권의 비교 규칙을 사용 하 여이 작업을 수행 하려면 호출는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다. 매개 변수는 지정된 문자열을 검색할 때 수행할 비교 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작 된 `startIndex` 위치 및 될 때까지 뒤로 문자 `value` 발견 되 찾거나 첫 번째 문자 위치입니다. 예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1, 메서드 시작 부분에 문자열에 있는 모든 문자와 마지막 문자에서를 검색 합니다.  
  
 `comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 3 오버 로드는 <xref:System.String.LastIndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 현재 인스턴스의 길이보다 큽니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="startIndex" />가 -1보다 작거나 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합 포함 무시할 수 있는 문자는 문자는 언어 또는 문화권 구분 비교를 수행 하는 경우 고려 되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.  다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m", 두 문자열의 마지막 "m"부터 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다. 메서드는 서 수 비교를 수행 하는 경우에 첫 번째 문자열에는 사용자 지정 하이픈의 인덱스를 반환 합니다.  [! 코드 csharp [System.String.LastIndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.LastIndexOf/cs/lastindexof25.cs#25)] [! vb 코드 [System.String.LastIndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다. 매개 변수는 지정된 문자열을 검색할 때 수행할 비교 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작 된 `startIndex` 위치 및 될 때까지 뒤로 문자 `value` 발견 되 또는 `count` 문자 위치가 검사 합니다. 예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자는 문자열의 마지막 문자를 합니다.  
  
 `comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 3 오버 로드는 <xref:System.String.LastIndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 음수입니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> + 1 - <paramref name="count" />가 이 인스턴스 외부의 위치를 지정합니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="start" />가 -1보다 작거나 0보다 큽니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="count" />가 1보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합 포함 무시할 수 있는 문자는 문자는 언어 또는 문화권 구분 비교를 수행 하는 경우 고려 되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.  다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m" 모든 하이픈이 (U + 00AD)의 위치를 알았지만 두 문자열의 "m"의 최종 하기 전에 첫 번째 문자 위치를 사용 합니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [! INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우. 그러나 서 수 비교를 수행 하는 경우 찾으면 부분 문자열이 첫 번째 문자열에만 합니다. 참고의 경우 첫 번째 문자열 뒤에 "m" 하이픈을 포함 하는 메서드는 사용자 지정 하이픈의 인덱스를 반환 하지 못하고 문화권 구분 비교를 수행 하는 경우 대신 "m"의 인덱스를 반환 합니다. 메서드는 서 수 비교를 수행 하는 경우에 첫 번째 문자열에는 사용자 지정 하이픈의 인덱스를 반환 합니다.  [! 코드 csharp [System.String.LastIndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. String.LastIndexOf/cs/lastindexof24.cs#24)] [! vb 코드 [System.String.LastIndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 이 인스턴스에 해당 문자가 없으면 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드는이 인스턴스의 마지막 문자 위치에서 검색을 시작 하 고의 문자 올 때까지 뒤로 `anyOf` 보수인 찾거나 첫 번째 문자 위치입니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열 내에서 "is" 문자열에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 동일하면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드 검색 시작 위치는 `startIndex` 문자이 인스턴스의 위치에는 문자 올 때까지 뒤로 `anyOf` 가 찾거나 첫 번째 문자 위치입니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에서 "is" 문자열에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 인스턴스 외부의 위치를 지정합니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 동일하면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드 검색 시작 위치는 `startIndex` 문자이 인스턴스의 위치에는 문자 올 때까지 뒤로 `anyOf` 가 또는 `count` 문자 위치가 검사 합니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에서 문자열 "지원"에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" /> 같지 않고 <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  -또는-  현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 0보다 작습니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체의 문자 수를 가져옵니다.</summary>
        <value>현재 문자열의 문자 수를 가져옵니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A> 속성의 수를 반환 <xref:System.Char> 의이 인스턴스 개체, 유니코드 문자 수 없습니다. 이유는 둘 이상의 유니코드 문자를 표현 될 수 있습니다 <xref:System.Char>합니다. 사용 하 여는 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 각 하는 대신 각 유니코드 문자를 사용 하는 클래스 <xref:System.Char>합니다.  
  
 C 및 c + +와 같은 일부 언어에서는 null 문자는 문자열의 끝을 나타냅니다. .NET Framework에서 문자열에 null 문자를 포함할 수 있습니다. 문자열 하나 이상의 null 문자를 포함 하는 경우 전체 문자열의 길이에 포함 됩니다. 예를 들어 다음 문자열을 부분 문자열 "abc"와 "def" null 문자로 구분 됩니다. <xref:System.String.Length%2A> 속성 영문자 6 뿐 아니라 null 문자를 포함 하는 것이 나타내는 7을 반환 합니다.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Length%2A> 속성입니다.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이진 표현의 형식이 특정 유니코드 정규화 형식인 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 유니코드 정규화 형식 C인 새 문자열을 반환합니다.</summary>
        <returns>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 정규화 형식 C인 정규화된 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 예를 들어 다음 코드 포인트의 문자 "ắ"을 나타낼 수 있습니다.  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.  
  
 표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다. 정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다. .NET Framework 4 개의 정규화 형식을 (C, D, KC 및 KD)는 유니코드 표준에서 정의 된 지원 합니다. 두 문자열이 동일한 정규화 형식에 표시 되는 경우 theycan 서 수 비교를 사용 하 여 비교할 수 있습니다.  
  
 정규화 하 고 두 문자열을 비교 하려면 다음을 수행 합니다.  
  
1.  파일 또는 사용자 입력된 장치 등의 입력된 소스에서 비교할 문자열을 가져옵니다.  
  
2.  호출 된 <xref:System.String.Normalize> C. 정규화 형식 문자열을 정교화 메서드  
  
3.  두 문자열을 비교 하려면와 같은 서 수 문자열 비교를 지 원하는 메서드를 호출는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드의 값을 제공 하 고 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 으로 <xref:System.StringComparison> 인수입니다. 정규화 된 문자열의 배열을 정렬 하려면 전달는 `comparer` 값 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 의 적절 한 오버 로드에 <xref:System.Array.Sort%2A?displayProperty=nameWithType>합니다.  
  
4.  이전 단계에 설명 된 순서에 따라 정렬된 된 출력에서 문자열을 내보냅니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 각각 네 가지 정규화 형식으로 확인 문자열이 지정 된 정규화 형식인 정규화 된 다음 정규화 문자열에 코드 포인트를 표시 합니다.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다. 따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">유니코드 정규화 형식입니다.</param>
        <summary>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 지정한 유니코드 정규화 형식인 새 문자열을 반환합니다.</summary>
        <returns>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 <paramref name="normalizationForm" /> 매개 변수로 지정된 정규화 형식인 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.  
  
 표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다. 정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다. .NET Framework 4 개의 정규화 형식을 (C, D, KC 및 KD)는 유니코드 표준에서 정의 된 지원 합니다. 두 문자열이 동일한 정규화 형식에 표시 되는 경우 서 수 비교를 사용 하 여 비교할 수 있습니다.  
  
 정규화 하 고 두 문자열을 비교 하려면 다음을 수행 합니다.  
  
1.  파일 또는 사용자 입력된 장치 등의 입력된 소스에서 비교할 문자열을 가져옵니다.  
  
2.  호출 된 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 메서드는 문자열을 지정 된 정규화 형식인 정규화를 합니다.  
  
3.  두 문자열을 비교 하려면와 같은 서 수 문자열 비교를 지 원하는 메서드를 호출는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드의 값을 제공 하 고 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 으로 <xref:System.StringComparison> 인수입니다. 정규화 된 문자열의 배열을 정렬 하려면 전달는 `comparer` 값 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 의 적절 한 오버 로드에 <xref:System.Array.Sort%2A?displayProperty=nameWithType>합니다.  
  
4.  이전 단계에 설명 된 순서에 따라 정렬된 된 출력에서 문자열을 내보냅니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 각각 네 가지 정규화 형식으로 확인 문자열이 지정 된 정규화 형식인 정규화 된 다음 정규화 문자열에 코드 포인트를 표시 합니다.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다. 따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드가 throw 할 수 있습니다는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <summary>지정된 두 문자열의 값이 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" />의 값이 <paramref name="a" />의 값과 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A> 같음 연산자에 대 한 작업을 정의 하는 메서드는 <xref:System.String> 클래스입니다. "예" 섹션에 표시 된 것과 같은 코드 수 있습니다. 연산자를 호출 하는 정적 <xref:System.String.Equals%28System.String%2CSystem.String%29> 메서드로 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행 합니다.  
  
> [!NOTE]
>  Visual Basic 컴파일러 같음 연산자에 대 한 호출으로 해결 되지 않으면는 <xref:System.String.op_Equality%2A> 메서드. 대신, 같음 연산자에 대 한 호출을 래핑하는 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 같음 연산자를 보여 줍니다.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <summary>지정된 두 문자열의 값이 다른지를 확인합니다.</summary>
        <returns>
          <see langword="true" />의 값이 <paramref name="a" />의 값과 다르면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드는 <xref:System.String> 클래스입니다.   "예" 섹션에 표시 된 것과 같은 코드 수 있습니다.  
  
 <xref:System.String.op_Inequality%2A> 연산자 호출 하 여 정적 <xref:System.String.Equals%28System.String%2CSystem.String%29> 메서드로 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행 합니다.  
  
> [!NOTE]
>  Visual Basic 컴파일러 같지 않음 연산자에 대 한 호출으로 해결 되지 않으면는 <xref:System.String.op_Inequality%2A> 메서드. 대신, 같지 않음 연산자에 대 한 호출을 래핑하는 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예에서는 같지 않음 연산자를 보여 줍니다.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열의 시작 부분이 공백이나 지정된 유니코드 문자로 채워지는 지정된 길이의 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <summary>지정한 길이만큼 왼쪽의 안쪽 여백을 공백으로 채워서 이 인스턴스의 문자를 오른쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 오른쪽으로 맞춰지고 왼쪽의 안쪽 여백이 <paramref name="totalWidth" />의 길이만큼 공백 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유니코드 공백 문자는 16 진수 0x0020 정의 됩니다.  
  
 <xref:System.String.PadLeft%28System.Int32%29> 메서드는 반환 된 문자열의 시작 부분을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 오른쪽 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadLeft%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 새 문자열을 전체 길이가 되도록 선행 공백을 채운 반환 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadLeft%2A> 메서드.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <param name="paddingChar">유니코드 안쪽 여백 문자입니다.</param>
        <summary>지정한 길이만큼 왼쪽의 안쪽 여백을 지정된 유니코드 문자로 채워서 이 인스턴스의 문자를 오른쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 오른쪽으로 맞춰지고 왼쪽의 안쪽 여백이 <paramref name="paddingChar" />의 길이만큼 <paramref name="totalWidth" /> 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> 메서드는 반환 된 문자열의 시작 부분을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 오른쪽 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadLeft%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 새 문자열 앞에 오는 채운 반환 `paddingChar` 자 전체 길이가 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadLeft%2A> 메서드.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열의 끝 부분이 공백이나 지정된 유니코드 문자로 채워지는 지정된 길이의 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <summary>지정한 길이만큼 오른쪽의 안쪽 여백을 공백으로 채워서 이 문자열의 문자를 왼쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 왼쪽으로 맞춰지고 오른쪽의 안쪽 여백이 <paramref name="totalWidth" />의 길이만큼 공백 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유니코드 공백 문자는 16 진수 0x0020 정의 됩니다.  
  
 <xref:System.String.PadRight%28System.Int32%29> 메서드는 반환 된 문자열의 끝을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 왼쪽된 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadRight%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 새 문자열을 전체 길이가 되도록 후행 공백 채운 반환 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadRight%2A> 메서드.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <param name="paddingChar">유니코드 안쪽 여백 문자입니다.</param>
        <summary>지정한 길이만큼 오른쪽의 안쪽 여백을 지정된 유니코드 문자로 채워서 이 문자열의 문자를 왼쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 왼쪽으로 맞춰지고 오른쪽의 안쪽 여백이 <paramref name="paddingChar" />의 길이만큼 <paramref name="totalWidth" /> 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> 메서드는 반환 된 문자열의 끝을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 왼쪽된 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadRight%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 후행 채운 새 문자열을 반환 `paddingChar` 자 전체 길이가 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadRight%2A> 메서드.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열에서 지정한 수의 문자가 삭제되는 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">문자 삭제를 0부터 시작할 위치입니다.</param>
        <summary>지정된 위치부터 마지막 위치 사이에 현재 인스턴스의 모든 문자가 삭제되었던 새 문자열을 반환합니다.</summary>
        <returns>제거된 문자를 제외하고 이 문자열과 동일한 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], 문자열은 0부터 시작 합니다. 값은 `startIndex` 매개 변수의 범위는 0-문자열 인스턴스 길이 보다 1 작은 값입니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 반환 새 문자열에 있는 모든 문자 위치에서 `startIndex` 원래 문자열의 끝에 제거 되었습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Remove%2A> 메서드. 마지막-두 번째 경우 문자열의 끝을 통해 지정된 된 인덱스에서 시작 하는 모든 텍스트를 제거 합니다. 마지막 경우 지정된 된 인덱스에서 시작 하는 3 개의 문자를 제거 합니다.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 0보다 작은 경우  -또는-  <paramref name="startIndex" />가 이 문자열 내에 없는 위치를 지정합니다.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">문자 삭제를 0부터 시작할 위치입니다.</param>
        <param name="count">삭제할 문자의 수입니다.</param>
        <summary>현재 인스턴스의 지정된 위치에서 시작하여 지정된 수의 문자가 삭제되었던 새 문자열을 반환합니다.</summary>
        <returns>제거된 문자를 제외하고 이 인스턴스와 동일한 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], 문자열은 0부터 시작 합니다. 값은 `startIndex` 매개 변수의 범위는 0-문자열 인스턴스 길이 보다 1 작은 값입니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 문자 수가 하 여 지정 된 새 문자열을 반환 된 `count` 매개 변수 제거 되었습니다. 지정 된 위치에서의 문자 제거 `startIndex`합니다.  
  
   
  
## Examples  
 다음 예제에서는 전체 이름에서 중간 이름을 제거 하는 방법을 보여 줍니다.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="count" />가 0보다 작은 경우  -또는-  <paramref name="startIndex" /> + <paramref name="count" />가 이 인스턴스 외부 위치를 지정합니다.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열에서 발견되는 지정된 유니코드 문자 또는 <see cref="T:System.String" />을 모두 지정된 다른 유니코드 문자 또는 <see cref="T:System.String" />으로 바꾼 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">바꿀 유니코드 문자입니다.</param>
        <param name="newChar">모든 <c>oldChar</c>를 바꿀 유니코드 문자입니다.</param>
        <summary>현재 인스턴스의 지정된 유니코드 문자가 지정된 다른 유니코드 문자로 모두 바뀌는 새 문자열을 반환합니다.</summary>
        <returns>
          <paramref name="oldChar" />의 모든 인스턴스를 <paramref name="newChar" />로 바꾼다는 점을 제외하고 이 인스턴스와 동일한 문자열입니다. <paramref name="oldChar" />를 현재 인스턴스에서 찾을 수 없으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 찾기 검색을 수행 `oldChar`합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 모두 바뀌는 새 문자열을 반환 대신 `oldChar` 바뀝니다 `newChar`합니다.  
  
 이 메서드는 수정 된 문자열을 반환 하므로 함께 결합할 수에 대 한 연속 호출은 <xref:System.String.Replace%2A> 원래 문자열에서 여러 교체를 수행 하는 메서드. 메서드 호출 왼쪽에서 오른쪽으로 실행 됩니다. 다음 예제에서 이에 대해 설명합니다.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 다음 예제에서는 일련의 숫자 사이 있는 공백에 대 한 쉼표를 대체 하 여 쉼표로 구분 된 값 목록을 만듭니다.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">바꿀 문자열입니다.</param>
        <param name="newValue">모든 <c>oldValue</c>를 바꿀 문자열입니다.</param>
        <summary>현재 인스턴스의 지정된 문자열이 지정된 다른 문자열로 모두 바뀌는 새 문자열을 반환합니다.</summary>
        <returns>
          <paramref name="oldValue" />의 모든 인스턴스를 <paramref name="newValue" />로 바꾼다는 점을 제외하고 현재 문자열과 동일한 문자열입니다. <paramref name="oldValue" />를 현재 인스턴스에서 찾을 수 없으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `newValue` 은 `null`의 항목을 모두 `oldValue` 제거 됩니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 모두 바뀌는 새 문자열을 반환 대신 `oldValue` 바뀝니다 `newValue`합니다.  
  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 찾기 검색을 수행 `oldValue`합니다.  
  
 이 메서드는 수정 된 문자열을 반환 하므로 함께 결합할 수에 대 한 연속 호출은 <xref:System.String.Replace%2A> 원래 문자열에서 여러 교체를 수행 하는 메서드. 메서드 호출 왼쪽에서 오른쪽으로 실행 됩니다. 다음 예제에서 이에 대해 설명합니다.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.String.Replace%2A> 맞춤법 오류를 해결 하려면 메서드.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" />가 빈 문자열("")입니다.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 문자열 또는 유니코드 문자 배열의 요소로 구분된 이 인스턴스의 부분 문자열이 포함된 문자열 배열을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> 문자열을 부분 문자열로 구분된 된 문자열을 중단 하는 데 사용 됩니다. 0, 1 또는 여러 구분 문자를 지정 하는 문자 배열 중 하나를 사용할 수 있습니다 (의 <xref:System.String.Split%28System.Char%5B%5D%29> 메서드), 0, 1 또는 여러 개의 구분 기호 문자열을 지정 하는 문자 배열에 사용할 수 있습니다. 오버 로드는 <xref:System.String.Split%2A> 메서드를 통해 메서드에서 반환 되는 부분 문자열의 수를 제한할 수 있습니다 (의 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> 메서드)를 빈 문자열이 반환 된 부분 문자열에 포함할지 여부를 결정 하기 위해 (의 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> 및 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> 메서드 또는 모두 (의 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 및 <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 메서드).  
  
> [!IMPORTANT]
>  자세한 내용을 보려면은 <xref:System.String.Split%2A> 개별 오버 로드에 대 한 설명서를 참조 하는 메서드를 호출 하는 예제는 물론 각 오버 로드 하는 대로 <xref:System.String.Split%2A>합니다.  
  
 <xref:System.String.Split%2A> 메서드는 항상 문자열을 부분 문자열로 구분된 된 문자열을 중단 하는 가장 좋은 방법은 없습니다. 구분된 된 문자열의 부분 문자열의 모든 추출 하지 않으려는 경우 또는 구분 기호 문자 집합이 아닌 패턴에 따라 문자열을 구문 분석 하려는 경우 다음과 같은 대안을 고려해.  
  
## <a name="regular-expressions"></a>정규식  
 문자열에 고정된 패턴을 따르지를 추출 하 여 해당 요소를 처리 하는 정규식을 사용할 수 있습니다. 예를 들어, 문자열 형태로 "*번호* *피연산자* *번호*" 사용할 수 있습니다는 [정규식](~/docs/standard/base-types/regular-expressions.md) 추출 및 처리 하는 문자열의 요소입니다. 예를 들면 다음과 같습니다.  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 정규식 패턴 `(\d+)\s+([-+*/])\s+(\d+)` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`(\d+)`|하나 이상의 10진수 숫자가 일치하는지 확인합니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`([-+*/])`|일치는 산술 연산자 기호 (+,-, *, 또는 /). 이 그룹은 두 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`(\d+)`|하나 이상의 10진수 숫자가 일치하는지 확인합니다. 이 그룹은 세 번째 캡처링 그룹입니다.|  
  
 또한 둘러싸인 문자 집합이 고정된 보다는 패턴을 기반으로 문자열에서 하위 문자열을 추출 하는 정규식을 사용할 수 있습니다. 다음은 이러한 조건 중 하나가 발생 하는 경우 일반적인 시나리오입니다.  
  
-   하나 이상의 구분 기호 문자 처리 하지 않는 경우 항상에 구분 기호로 <xref:System.String> 인스턴스.  
  
-   순서 및 구분 기호 문자 수는 변수 또는 알 수 없는 합니다.  
  
 예를 들어는 <xref:System.String.Split%2A> 때문에 다음 문자열을 분할 메서드를 사용할 수 없습니다 수가 `\n` (C#에서) 또는 `vbCrLf` (Visual Basic)의 문자는 변수 이며 항상 구분 기호로 사용 하지 않습니다.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 정규식이이 문자열을 쉽게 다음 예제와 분할할 수 있습니다.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 정규식 패턴 `\[([^\[\]]+)\]` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\[`|여는 대괄호를 찾습니다.|  
|`([^\[\]]+)`|하지 않은 중괄호와 닫는 대괄호는 한 번 이상 나타나는 모든 문자를 찾습니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\]`|닫는 대괄호를 찾습니다.|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 거의 동일 <xref:System.String.Split%2A?displayProperty=nameWithType>제외 하 고 고정된 문자 집합 대신 정규식 패턴에 따라 문자열을 분할 합니다. 예를 들어 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 하이픈과 다른 문자를 조합으로 구분 하는 부분 문자열을 포함 하는 문자열을 분할 하는 메서드.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 정규식 패턴 `\s-\s?[+*]?\s?-\s` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\s-`|하이픈 공백 문자를 찾습니다.|  
|`\s?`|0 개 이상의 공백 문자를 찾습니다.|  
|`[+*]?`|중 0 개 또는 1 개 찾습니다는 + 또는 * 문자입니다.|  
|`\s?`|0 개 이상의 공백 문자를 찾습니다.|  
|`-\s`|공백 문자로 이어지는 하이픈을 찾습니다.|  
  
## <a name="search-methods-and-the-substring-method"></a>검색 방법 및 Substring 메서드  
 문자열의 부분 문자열의 모든 원하지 않는 경우에 일치 항목 찾기를 시작 되는 인덱스를 반환 하는 문자열 비교 방법 중 하나를 사용 하는 것이 좋습니다. 호출할 수 있습니다는 <xref:System.String.Substring%2A> 메서드를 원하는 하위 문자열을 추출 합니다. 다음과 같은 문자열 비교 방법  
  
-   <xref:System.String.IndexOf%2A>문자열 인스턴스에서 맨 처음 발견 되는 문자 또는 문자열의 0부터 시작 하는 인덱스를 반환 하는 합니다.  
  
-   <xref:System.String.IndexOfAny%2A>을 문자 배열에 있는 문자 중 첫 번째 요소의 현재 문자열 인스턴스 0부터 시작 하는 인덱스를 반환 하는 합니다.  
  
-   <xref:System.String.LastIndexOf%2A>문자열 인스턴스에서는 문자 또는 문자열의 마지막 항목의 0부터 시작 인덱스를 반환 하는 합니다.  
  
-   <xref:System.String.LastIndexOfAny%2A>현재 문자열 인스턴스에서 문자 배열에 있는 문자 중 마지막 요소의 0 기반 인덱스를 반환 하는 합니다.  
  
 다음 예제에서는 <xref:System.String.IndexOf%2A> 메서드를 문자열에서 마침표를 찾습니다. 다음 사용 하 여는 <xref:System.String.Substring%2A> 메서드를 완전 한 문장을 반환 합니다.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <summary>문자열을 배열 내 문자에 기초하는 하위 문자열로 분할합니다.</summary>
        <returns>요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 인스턴스의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 알려진된 문자 집합으로 구분 하는 문자열은 때 사용할 수 있습니다는 <xref:System.String.Split%28System.Char%5B%5D%29> 메서드 문자열을 부분 문자열로 구분 될 수 있도록 합니다. 부분 문자열을 추출 문자열에서 다른 방법에 대 한 참조는 [String.Split에 대 한 대안](#Alternatives) 섹션.  
  
## <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다. 예를 들어, 구분 기호 배열 문자를 포함 하는 경우 "-" 문자열 현재 인스턴스의 값이 "aa bb 참조", 세 개의 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.  
  
 각 요소 `separator` 별도 구분 기호 문자를 정의 합니다. 두 개의 구분 기호는, 인접 한 경우 나이 인스턴스의 끝 부분에는 구분 기호를 찾을 수 반환된 배열에 있는 해당 요소 포함 <xref:System.String.Empty>합니다. 다음은 몇 가지 예입니다.  
  
|문자열 값|구분 기호|반환 되는 배열|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|새로운 문자 {',', ' '을 (를) (C#)<br /><br /> Char () = {"," c "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|새로운 문자 {'. '을 (를) (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"바나나"|새로운 문자 {'. '을 (를) (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"바나나"을 (를)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|new Char {} (C#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|null(C#)<br /><br /> Nothing(Visual Basic)|{"Darb", "Smarba"}|  
  
## <a name="the-separator-array"></a>구분 기호 배열  
 각 요소 구분 기호는 단일 문자 구성 된 별도 구분 기호를 정의 합니다. 경우는 `separator` 인수가 `null` 포함 되지 않은 또는 메서드를 구분 기호로 공백 문자를 처리 합니다. 공백 문자는 유니코드 표준; 정의 반환 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>오버 로드 확인에 String.Split(Char[]) 및 컴파일러  
 하지만이 오버 로드에 대 한 단일 매개 변수 <xref:System.String.Split%2A?displayProperty=nameWithType> 문자 배열에는 다음 예제와 같이 단일 문자를 호출할 수 있습니다.  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 때문에 `separator` 으로 데코레이팅되 어 매개 변수는 <xref:System.ParamArrayAttribute> 특성, 컴파일러는 단일 요소 문자 배열로 단일 문자를 해석 합니다. 이 다른 사례 <xref:System.String.Split%2A?displayProperty=nameWithType> 포함 하는 오버 로드는 `separator` parameter; 명시적으로 전달 해야 이러한 오버 로드와 문자 배열은 `separator` 인수입니다.  
  
## <a name="comparison-details"></a>비교 세부 정보  
 <xref:System.String.Split%28System.Char%5B%5D%29> 의 문자를 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 배열 및 배열 요소와 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%28System.Char%5B%5D%29> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>String.Split에 대 한 대안  
 <xref:System.String.Split%2A> 메서드는 항상 문자열을 부분 문자열로 구분된 된 문자열을 중단 하는 가장 좋은 방법은 없습니다. 구분된 된 문자열의 부분 문자열의 모든 추출 하지 않으려는 경우 또는 구분 기호 문자 집합이 아닌 패턴에 따라 문자열을 구문 분석 하려는 경우 다음과 같은 대안을 고려해.  
  
### <a name="regular-expressions"></a>정규식  
 문자열에 고정된 패턴을 따르지를 추출 하 여 해당 요소를 처리 하는 정규식을 사용할 수 있습니다. 예를 들어, 문자열 형태로 "*번호* *피연산자* *번호*" 사용할 수 있습니다는 [정규식](~/docs/standard/base-types/regular-expressions.md) 추출 및 처리 하는 문자열의 요소입니다. 예를 들면 다음과 같습니다.  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 정규식 패턴 `(\d+)\s+([-+*/])\s+(\d+)` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`(\d+)`|하나 이상의 10진수 숫자가 일치하는지 확인합니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`([-+*/])`|일치는 산술 연산자 기호 (+,-, *, 또는 /). 이 그룹은 두 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`(\d+)`|하나 이상의 10진수 숫자가 일치하는지 확인합니다. 이 그룹은 세 번째 캡처링 그룹입니다.|  
  
 또한 둘러싸인 문자 집합이 고정된 보다는 패턴을 기반으로 문자열에서 하위 문자열을 추출 하는 정규식을 사용할 수 있습니다. 다음은 이러한 조건 중 하나가 발생 하는 경우 일반적인 시나리오입니다.  
  
-   하나 이상의 구분 기호 문자 처리 하지 않는 경우 항상에 구분 기호로 <xref:System.String> 인스턴스.  
  
-   순서 및 구분 기호 문자 수는 변수 또는 알 수 없는 합니다.  
  
 예를 들어는 <xref:System.String.Split%2A> 때문에 다음 문자열을 분할 메서드를 사용할 수 없습니다 수가 `\n` (C#에서) 또는 `vbCrLf` (Visual Basic)의 문자는 변수 이며 항상 구분 기호로 사용 하지 않습니다.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 정규식이이 문자열을 쉽게 다음 예제와 분할할 수 있습니다.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 정규식 패턴 `\[([^\[\]]+)\]` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\[`|여는 대괄호를 찾습니다.|  
|`([^\[\]]+)`|하지 않은 중괄호와 닫는 대괄호는 한 번 이상 나타나는 모든 문자를 찾습니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\]`|닫는 대괄호를 찾습니다.|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 거의 동일 <xref:System.String.Split%2A?displayProperty=nameWithType>제외 하 고 고정된 문자 집합 대신 정규식 패턴에 따라 문자열을 분할 합니다. 예를 들어 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 하이픈과 다른 문자를 조합으로 구분 하는 부분 문자열을 포함 하는 문자열을 분할 하는 메서드.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 정규식 패턴 `\s-\s?[+*]?\s?-\s` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\s-`|하이픈 공백 문자를 찾습니다.|  
|`\s?`|0 개 이상의 공백 문자를 찾습니다.|  
|`[+*]?`|중 0 개 또는 1 개 찾습니다는 + 또는 * 문자입니다.|  
|`\s?`|0 개 이상의 공백 문자를 찾습니다.|  
|`-\s`|공백 문자로 이어지는 하이픈을 찾습니다.|  
  
### <a name="search-methods-and-the-substring-method"></a>검색 방법 및 Substring 메서드  
 문자열의 부분 문자열의 모든 원하지 않는 경우에 일치 항목 찾기를 시작 되는 인덱스를 반환 하는 문자열 비교 방법 중 하나를 사용 하는 것이 좋습니다. 호출할 수 있습니다는 <xref:System.String.Substring%2A> 메서드를 원하는 하위 문자열을 추출 합니다. 다음과 같은 문자열 비교 방법  
  
-   <xref:System.String.IndexOf%2A>문자열 인스턴스에서 맨 처음 발견 되는 문자 또는 문자열의 0부터 시작 하는 인덱스를 반환 하는 합니다.  
  
-   <xref:System.String.IndexOfAny%2A>을 문자 배열에 있는 문자 중 첫 번째 요소의 현재 문자열 인스턴스 0부터 시작 하는 인덱스를 반환 하는 합니다.  
  
-   <xref:System.String.LastIndexOf%2A>문자열 인스턴스에서는 문자 또는 문자열의 마지막 항목의 0부터 시작 인덱스를 반환 하는 합니다.  
  
-   <xref:System.String.LastIndexOfAny%2A>현재 문자열 인스턴스에서 문자 배열에 있는 문자 중 마지막 요소의 0 기반 인덱스를 반환 하는 합니다.  
  
 다음 예제에서는 <xref:System.String.IndexOf%2A> 메서드를 문자열에서 마침표를 찾습니다. 다음 사용 하 여는 <xref:System.String.Substring%2A> 메서드를 완전 한 문장을 반환 합니다.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 <xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하 여 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드. 사용할 수 있습니다는 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.  
  
 문자열 구분 기호 문자에서 분할을 사용 하 여는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다. 문자열에서 구분 기호 문자열을 분할 하려면 사용는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다. 다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.  
  
 또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.  
  
   
  
## Examples  
 다음 예제에는 구분 기호로 공백 및 문장 부호를 처리 하 여 텍스트 블록에서 개별 단어를 추출 하는 방법을 보여 줍니다. 에 전달 된 문자 배열에서 `separator` 의 매개 변수는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 방법은 단순히 공백 문자 및 탭 문자와 함께 몇 가지 공통 문장 부호 기호.  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>에 [! INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전을 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 분할 하는 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드는 문자열을 트리밍를 수행 합니다. 에 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="count">반환할 부분 문자열의 최대 수입니다.</param>
        <summary>배열에 있는 문자에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다. 반환할 부분 문자열의 최대 수도 지정합니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 인스턴스의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다. 경우 `count` 가 0 인 경우 빈 배열이 반환 됩니다.  
  
 경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
 각 요소 `separator` 별도 구분 기호 문자를 정의 합니다. 두 개의 구분 기호는, 인접 한 경우 나이 인스턴스의 끝 부분에는 구분 기호를 찾을 수, 해당 배열 요소 포함 <xref:System.String.Empty>합니다.  
  
 있는 경우 이상 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 1 부분 문자열에서 뺀 첫 번째 범위에서 반환 됩니다 `count` 의 반환 값과 나머지이 인스턴스의 문자를이 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.  
  
 경우 `count` 수보다 크면의 부분 문자열을 사용할 수 있는 부분 문자열이 반환 되 고 예외가 throw 되지 않습니다.  
  
 다음 표에서 예제를 제공합니다.  
  
|문자열 값|구분 기호|개수|반환 되는 배열|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|새로운 문자 {',', ' '을 (를) (C#)<br /><br /> Char () = {"," c "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|새로운 문자 {'. '을 (를) (C#)<br /><br /> Char () = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"바나나"|새로운 문자 {'. '을 (를) (C#)<br /><br /> Char () = {"." c} (Visual Basic)|2|{"바나나"을 (를)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|new Char {} (C#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|새 Char] null (C#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|새 Char] null (C#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 <xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.  
  
 사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다. 사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다. 다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.  
  
 또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.  
  
   
  
## Examples  
 다음 예제에서는 어떻게 `count` 에서 반환 된 문자열의 수에 영향을 <xref:System.String.Split%2A>합니다.  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.</exception>
        <block subset="none" type="usage">
          <para>에 [! INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전을 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 분할 하는 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드는 문자열을 트리밍를 수행 합니다. 에 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자에 따라 문자열을 부분 문자열로 분할합니다. 부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자 (의 문자는 `separator` 배열)의 반환된 된 배열 요소에 포함 되지 않습니다. 예를 들어 경우는 `separator` 문자를 포함 하는 배열 "-" 문자열 현재 인스턴스의 값이 "aa bb 참조", 세 개의 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.  
  
 경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 하 고이 인스턴스의 길이 0, 메서드는 빈 배열을 반환 합니다.  
  
 각 요소 `separator` 단일 문자 구성 된 별도 구분 기호를 정의 합니다. 경우는 `options` 인수가 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 예를 들어 경우 `separator` 두 개의 요소가 포함 됩니다 "-" 및 "\_", 문자열 인스턴스의 값이 "-\_aa-\_"의 값과는 `options` 인수는 <xref:System.StringSplitOptions.None>, 메서드가 문자열 배열을 반환 다음 5 개 요소:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>를 앞에 빈 문자열을 나타내는 "-" 문자 인덱스 0에 있습니다.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>사이의 빈 문자열을 나타내는 "-" 인덱스 0와 인덱스 1에 "_" 문자는 문자입니다.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>인덱스 4에서 "_" 문자 뒤에 오는 빈 문자열을 나타냅니다.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>뒤에 오는 빈 문자열을 나타내는 "-"에서 인덱스 5 문자.  
  
## <a name="the-separator-array"></a>구분 기호 배열  
 경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야는 `null`합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>비교 세부 정보  
 <xref:System.String.Split%2A> 의 문자를 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소를 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%2A> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 <xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.  
  
 사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다. 사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다. 다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.  
  
 또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을는 <xref:System.String.Split%2A> 메서드.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [! INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전을 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 분할 하는 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드는 문자열을 트리밍를 수행 합니다. 에 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자열 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자열에 따라 문자열을 부분 문자열로 분할합니다. 부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자열로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 알려진된 일련의 문자열에서 구분은 문자열 때 사용할 수 있습니다는 <xref:System.String.Split%2A> 메서드 문자열을 부분 문자열로 구분 될 수 있도록 합니다.  
  
## <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자열로 반환 된 배열의 요소에 포함 되지 않습니다. 예를 들어 경우는 `separator` 문자열을 포함 하는 배열 "-" 문자열 현재 인스턴스의 값이 "aa-cc bb", 세 개의 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.  
  
 이 인스턴스가 없는 경우에 문자열이 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.  
  
 경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 하 고이 인스턴스의 길이 0, 메서드는 빈 배열을 반환 합니다.  
  
 각 요소 `separator` 하나 이상의 문자로 구성 된 별도 구분 기호를 정의 합니다. 경우는 `options` 인수가 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 예를 들어 경우 `separator` 두 개의 요소가 포함 됩니다 "-" 및 "_", 문자열 인스턴스의 값이 "-_aa-\_"의 값과는 `options` 인수는 <xref:System.StringSplitOptions.None>, 메서드는 다음 5 개의 요소로 문자열 배열을 반환:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>를 앞에 빈 문자열을 나타내는 "-" 인덱스 0에 부분 문자열입니다.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>사이의 빈 문자열을 나타내는 "-" 0 인덱스와 인덱스 1에 있는 "_" 부분 문자열에 부분 문자열입니다.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>인덱스 4에서 "_" 부분 문자열 뒤에 오는 빈 문자열을 나타냅니다.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>뒤에 오는 빈 문자열을 나타내는 "-" 인덱스 5에 부분 문자열입니다.  
  
## <a name="the-separator-array"></a>구분 기호 배열  
 요소 하나라 `separator` 구성 되어 전체 부분 문자열이 여러 문자는 구분 기호 간주 됩니다. 예를 들어 하나에 있는 요소의 `separator` 은 "10", "This10is10a10string" 문자열을 분할 하려고 합니다. 다음 4 개 요소 배열을 반환: {"This", "is", "a", "문자열입니다." }.  
  
 경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야는 `null`합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>비교 세부 정보  
 <xref:System.String.Split%2A> 있는 문자열 중 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소를 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%2A> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
 <xref:System.String.Split%2A> 의 요소를 무시 하는 메서드 `separator` 값인 `null` 또는 빈 문자열 ("").  
  
 모호한 결과 방지 하려면 때 문자열 `separator` 공통적인, 문자가 있는 <xref:System.String.Split%2A> 작업의 인스턴스 값의 끝에 처음부터 진행 되 고 첫 번째 요소에 일치 `separator` 의 구분 같거나는 인스턴스입니다. 인스턴스에서 부분 문자열은 나타나는 순서에 있는 요소의 순서 보다 우선 `separator`합니다.  
  
 예를 들어 값이 "abcdef" 인스턴스를 것이 좋습니다. 경우에 첫 번째 요소 `separator` "ef"와 두 번째 요소 "bcde" 이면 split 작업의 결과 두 개의 요소를 포함 하는 문자열 배열 "a"와 "f"입니다. 이 "bcde" 인스턴스에 있는 부분 문자열은와 일치 하기 때문에 요소 `separator` 전에 부분 문자열 "f"가 발생 합니다.  
  
 그러나 경우의 첫 번째 요소로 `separator` "bcd"와 두 번째 요소 "bc" 이면 split 작업의 결과 두 개의 요소를 포함 하는 문자열 배열 "a"와 "ef"입니다. "Bcd"는 첫 번째 구분 기호 때문에 이것이 `separator` 인스턴스에서 구분 기호와 일치 하는 합니다. 첫 번째 요소 기간은 "bc"는 구분 기호가 순서 취소 하 고 두 번째 요소가 "bcd" 이면 결과 두 요소를 포함 하는 문자열 배열 하는 경우 "a"와 "def"입니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 <xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.  
  
 사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다. 사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다. 다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.  
  
 또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열의 호출 하 여 반환 된 배열에 있는 차이 보여 줍니다. <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> 메서드를 해당 `options` 매개 변수를 <xref:System.StringSplitOptions.None?displayProperty=nameWithType> 및 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 다음 예제에서는 문장 부호 및 공백 문자를 포함 하는 구분 기호 배열을 정의 합니다. 값과 함께이 배열을 전달 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 에 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> 문자열에서 개별 단어로 구성 된 배열을 반환 합니다.  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 여는 메서드를 호출 하는 `options` 인수로 설정 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>합니다. 반환된 된 배열에서 포함 하지 않습니다 <xref:System.String.Empty?displayProperty=nameWithType> 문장 부호 및 공백 문자 사이 빈 부분 문자열 일치를 나타내는 값입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [! INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전을 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 분할 하는 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드는 문자열을 트리밍를 수행 합니다. 에 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="count">반환할 부분 문자열의 최대 수입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 또는 `count` 매개 변수가 1 이면 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다. 경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드. 그러나 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드에는 null의 형식을 나타내야 합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 경우는 `count` 매개 변수는 0 또는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 고이 인스턴스의 길이 0, 빈 배열이 반환 됩니다.  
  
 각 요소 `separator` 별도 구분 기호 문자를 정의 합니다. 경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty>합니다.  
  
 있는 경우 이상 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 1 부분 문자열에서 뺀 첫 번째 범위에서 반환 됩니다 `count` 의 반환 값과 나머지이 인스턴스의 문자를이 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.  
  
 경우 `count` 수보다 크면의 부분 문자열을 사용할 수 있는 부분 문자열이 반환 되 고 예외가 throw 되지 않습니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 <xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.  
  
 사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다. 사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다. 다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.  
  
 또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을는 <xref:System.String.Split%2A> 메서드.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [! INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전을 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 분할 하는 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드는 문자열을 트리밍를 수행 합니다. 에 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자열 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="count">반환할 부분 문자열의 최대 수입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자열에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다. 부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자열로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자열로 반환 된 배열의 요소에 포함 되지 않습니다.  
  
 이 인스턴스가 없는 경우에 문자열이 `separator`, 또는 `count` 매개 변수가 1 이면 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다. 경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드. 그러나 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야는 `null`합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 경우는 `count` 매개 변수는 0 또는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 고이 인스턴스의 길이 0, 빈 배열이 반환 됩니다.  
  
 각 요소 `separator` 하나 이상의 문자로 구성 된 별도 구분 기호를 정의 합니다. 경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty>합니다.  
  
 있는 경우 이상 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 1 부분 문자열에서 뺀 첫 번째 범위에서 반환 됩니다 `count` 의 반환 값과 나머지이 인스턴스의 문자를이 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.  
  
 경우 `count` 수보다 크면의 부분 문자열을 사용할 수 있는 부분 문자열이 반환 되 고 예외가 throw 되지 않습니다.  
  
## <a name="the-separator-array"></a>구분 기호 배열  
 요소 하나라 `separator` 구성 되어 전체 부분 문자열이 여러 문자는 구분 기호 간주 됩니다. 예를 들어 하나에 있는 요소의 `separator` 은 "10", "This10is10a10string" 문자열을 분할 하려고 합니다. 이 네 개의 요소로 배열을 반환: {"This", "is", "a", "문자열입니다." }.  
  
## <a name="comparison-details"></a>비교 세부 정보  
 <xref:System.String.Split%2A> 있는 문자열 중 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소를 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%2A> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
 <xref:System.String.Split%2A> 의 요소를 무시 하는 메서드 `separator` 값인 `null` 또는 빈 문자열 ("").  
  
 모호한 결과 방지 하려면 때 문자열 `separator` 공통적인, 문자가 있는 <xref:System.String.Split%2A> 메서드는 인스턴스 값의 끝에 처음부터 진행 되 고 첫 번째 요소에 일치 `separator` 의 구분 같거나는 인스턴스입니다. 인스턴스에서 부분 문자열은 나타나는 순서에 있는 요소의 순서 보다 우선 `separator`합니다.  
  
 예를 들어 값이 "abcdef" 인스턴스를 것이 좋습니다. 경우에 첫 번째 요소 `separator` "ef"와 두 번째 요소 "bcde" 이면 split 작업의 결과 "a"와 "f"입니다. 이 "bcde" 인스턴스에 있는 부분 문자열은와 일치 하기 때문에 요소 `separator` 전에 부분 문자열 "f"가 발생 합니다.  
  
 그러나 경우의 첫 번째 요소로 `separator` "bcd"와 두 번째 요소 "bc" 이면 split 작업의 결과 "a"와 "ef"입니다. "Bcd"는 첫 번째 구분 기호 때문에 이것이 `separator` 인스턴스에서 구분 기호와 일치 하는 합니다. 첫 번째 요소 기간은 "bc"는 구분 기호가 순서 취소 하 고 두 번째 요소가 "bcd"을 결과로 "a"와 "def"입니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 <xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.  
  
 사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다. 사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다. 다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.  
  
 또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을는 <xref:System.String.Split%2A> 메서드.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [! INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전을 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 분할 하는 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드는 문자열을 트리밍를 수행 합니다. 에 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">비교할 문자열입니다.</param>
        <summary>이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 시작 부분이 <see langword="true" />와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비교 `value` 와 같은 길이가이 인스턴스의 시작 부분에 있는 부분 문자열과 `value`와 같은지 여부를 나타내는 값을 반환 합니다. 하려면 `value` 빈 문자열 이어야 합니다 (<xref:System.String.Empty?displayProperty=nameWithType>)이 같은 인스턴스에 대 한 참조 여야, 또는이 인스턴스의 시작 부분과 일치 해야 합니다.  
  
 이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `StripStartTags` 메서드를 사용 하는 <xref:System.String.StartsWith%28System.String%29> 문자열의 시작 부분에서 시작 태그를 HTML을 제거 하는 메서드. `StripStartTags` 메서드는 재귀적으로 줄의 시작 부분에는 여러 HTML 시작 태그가 제거 되었는지 확인 합니다. 이 예제에서는 문자열에 포함 된 HTML 태그를 제거 하지 않습니다.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 명시적으로 지정 합니다. 확인 하려면 현재 문화권의 문자열 비교 규칙을 사용 하 여 특정 문자열이 부분 문자열로 시작 하는지 여부를 호출는 <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">비교할 문자열입니다.</param>
        <param name="comparisonType">이 문자열과 <c>value</c>를 비교하는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정한 비교 옵션을 사용하여 비교할 때 지정한 문자열과 이 문자열 인스턴스의 시작 부분이 일치하는지를 확인합니다.</summary>
        <returns>이 인스턴스가 <see langword="true" />로 시작하는 경우 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A> 메서드 비교는 `value` 이 문자열의 시작 부분에 부분 문자열에 매개 변수가 같은지 여부를 나타내는 값을 반환 합니다. 하려면 `value` 이 동일한 문자열에 대 한 참조 여야, 빈 문자열 이어야 합니다 (""), 또는이 문자열의 시작 일치 해야 합니다. 비교를 수행 하 여 유형의 <xref:System.String.StartsWith%2A> 메서드는 값에 따라는 `comparisonType` 매개 변수입니다. 비교 현재 문화권의 규칙을 사용할 수 있습니다 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 및 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 이나 고정 문화권 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 및 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), 또는 코드 포인트를 문자 단위로 비교를 구성할 수 있습니다 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). 비교도 대/소문자 구분 될 수 있습니다 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, 또는 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), 대/소문자를 무시할 수도 있습니다 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 다음 예에서는 문자열에 대 한 검색 단어로 시작 하는 긴 문자열의 시작 부분에서 "the" "The"입니다. 예제에 대 한 호출에서 출력으로의 <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> 메서드 문화권을 구분 하지 않지만 대/소문자 구분 비교를 수행 하는 문자열과 일치 하는 문화권 및 case insensitive 비교를 수행 하는 호출 하는 동안 문자열 일치에 실패 합니다.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 다음 예에서는 문자열이 특정 하위 문자열로 시작 하는지를 확인 합니다. 2 차원 문자열 배열을 초기화합니다. 두 번째 차원에 있는 첫 번째 요소는 문자열을 포함 하 고 두 번째 요소에 대 한 첫 번째 문자열의 시작 부분에 검색할 문자열을 포함 합니다. 결과는 문화권, 대/소문자 무시 여부 및 서 수 비교가 수행 되는지 여부는 선택한 항목에 따라 달라 집니다. Note는 합자를 포함 하는 문자열 인스턴스를 연속 문자의 문화권 구분 비교 성공적으로 일치 합니다.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">비교할 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">이 문자열과 <c>value</c>의 비교 방법을 결정하는 문화권 정보입니다. <c>culture</c>가 <see langword="null" />이면 현재 문화권이 사용됩니다.</param>
        <summary>지정한 문화권을 사용하여 비교할 때 이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 시작 부분이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비교는 `value` 와 같은 길이가이 문자열의 시작 부분에 있는 부분 문자열과 매개 변수 `value`, 같은지 여부를 나타내는 값을 반환 합니다. 하려면 `value` 빈 문자열 이어야 합니다 (<xref:System.String.Empty?displayProperty=nameWithType>)이 같은 인스턴스에 대 한 참조 여야, 또는이 인스턴스의 시작 부분과 일치 해야 합니다.  
  
 이 메서드는 지정 된 대/소문자 및 문화권을 사용 하 여 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예에서는 문자열이 다른 문자열의 시작 부분에 있는지 여부를 확인 합니다. <xref:System.String.StartsWith%2A> 여러 번 대/소문자 구분, 대/소문자, 및 검색 결과 영향을 주는 다양 한 문화권을 사용 하 여 메서드를 호출 합니다.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 부분 문자열을 검색합니다.  이 멤버는 오버로드됩니다. 구문, 사용법 및 예제를 비롯하여 이 멤버에 대한 자세한 내용을 보려면 오버로드 목록에서 이름을 클릭합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스의 부분 문자열에 있는 0부터 시작할 문자 위치입니다.</param>
        <summary>이 인스턴스에서 부분 문자열을 검색합니다. 부분 문자열은 지정된 문자 위치에서 시작하고 문자열 끝까지 계속됩니다.</summary>
        <returns>이 인스턴스의 <paramref name="startIndex" />에서 시작하는 부분 문자열에 해당하는 문자열이거나, <see cref="F:System.String.Empty" />가 이 인스턴스의 길이와 같으면 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 <xref:System.String.Substring%2A> 메서드를 문자열로 지정된 된 문자 위치에서 시작 하 고 문자열의 끝에서 끝나는 부분 문자열을 추출 합니다. 시작 문자 위치는 0부터 시작 합니다. 즉, 문자열에서 첫 번째 문자는 인덱스 0, 1 인덱싱하지 않아야 합니다. 지정 된 문자 위치에서 시작 하는 문자열의 끝에 앞에서 끝납니다 하는 부분 문자열을 추출 하려면 호출 된 <xref:System.String.Substring%2A> 메서드.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,에서 시작 하는 새 문자열을 반환 합니다는 `startIndex` 현재 문자열의 위치입니다.  
  
 특정 문자 또는 문자 시퀀스와 시작 하는 부분 문자열을 추출 하려면 메서드를와 같은 호출 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 의 값을 가져오는 `startIndex`합니다. 두 번째 예제에서는이; "=" 문자 다음 문자를 한 위치를 시작 하는 키 값을 추출 합니다.  
  
 경우 `startIndex` 0, 원래 문자열 변경 하지 않고 메서드가 반환 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열에서 하위 문자열을 얻는 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 다음 예제에서는 <xref:System.String.Substring%2A> 같음 구분 되는 키/값 쌍을 구분 하는 메서드 문자 ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> 메서드 문자열에 equals 문자의 위치를 가져오는 데 사용 됩니다. 에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드 추출을 문자열의 첫 번째 문자에서 시작 및 확장에 대 한 호출에서 반환 된 문자 수에 대 한 키 이름에는 <xref:System.String.IndexOf%2A> 메서드. 에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%29> 메서드는 키에 할당 된 값을 추출 합니다. Equals 문자 뒤에 있는 한 문자 위치에서 시작 하 고 문자열의 끝까지 확장 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스의 부분 문자열에 있는 0부터 시작할 문자 위치입니다.</param>
        <param name="length">부분 문자열에 있는 문자의 수입니다.</param>
        <summary>이 인스턴스에서 부분 문자열을 검색합니다. 부분 문자열은 지정된 문자 위치에서 시작하고 길이도 지정되어 있습니다.</summary>
        <returns>이 인스턴스의 <paramref name="length" />에서 시작하는 <paramref name="startIndex" /> 길이의 부분 문자열에 해당하는 문자열이거나, <see cref="F:System.String.Empty" />가 이 인스턴스의 길이와 같고 <paramref name="startIndex" />가 0이면 <paramref name="length" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드를 지정된 된 문자 위치에서 시작 하 고 문자열의 끝 이전 끝나는 문자열에서 하위 문자열을 추출 합니다. 시작 문자 위치는 0부터 시작 합니다. 즉, 문자열에서 첫 번째 문자는 인덱스 0, 1 인덱싱하지 않아야 합니다. 지정 된 문자 위치에서 시작 하는 문자열의 끝으로 계속 하는 부분 문자열을 추출 하려면 호출 된 <xref:System.String.Substring%28System.Int32%29> 메서드.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,을 갖는 새 문자열을 반환 `length` 부터 문자는 `startIndex` 현재 문자열의 위치입니다.  
  
 `length` 매개 변수는 현재 문자열 인스턴스에서 추출할 문자의 총 수를 나타냅니다. 인덱스에서 시작 문자가 여기에 `startIndex`합니다.  즉,는 <xref:System.String.Substring%2A> 메서드 인덱스에서 문자를 추출 하려고 `startIndex` 인덱스로 `startIndex`  +  `length` -1입니다.  
  
 특정 문자 또는 문자 시퀀스와 시작 하는 부분 문자열을 추출 하려면 메서드를와 같은 호출 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.LastIndexOf%2A> 의 값을 가져오는 `startIndex`합니다.  
  
 부분 문자열에서 확장 되 면 `startIndex` 지정 된 문자 시퀀스를 있습니다 메서드를 호출할 수와 같은 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.LastIndexOf%2A> 끝 문자 또는 문자 시퀀스의 인덱스를 가져옵니다.  변환할 수 있습니다 다음 해당 값 문자열의 인덱스 위치를 다음과 같습니다.  
  
-   부분 문자열의 끝을 표시 하는 단일 문자에 대 한 검색 하는 경우는 `length` 매개 변수와 같으면 `endIndex`  -  `startIndex` + 1, 여기서 `endIndex` 의 반환 값은 고 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다. 다음 예제에서는 문자열에서 "b" 문자는 연속 된 블록을 추출합니다.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   부분 문자열의 끝을 표시 하는 여러 문자에 대 한 검색 하는 경우는 `length` 매개 변수와 같으면 `endIndex`  +  `endMatchLength`  -  `startIndex`여기서 `endIndex` 는 의반환값은<xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다. 및 `endMatchLength` 부분 문자열의 끝을 표시 하는 문자 시퀀스의 길이입니다. 다음 예제는 XML이 포함 된 텍스트 블록을 추출 `<definition>` 요소입니다.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   문자 또는 문자 시퀀스는 문자열의 끝에 포함 되지 않은 경우는 `length` 매개 변수와 같으면 `endIndex`  -  `startIndex`여기서 `endIndex` 의 반환 값이 고 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다.  
  
 경우 `startIndex` 0와 equals 메서드는 현재 문자열의 길이 변경 하지 않고 원래 문자열을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에 대 한 간단한 호출은 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 여섯 번째 문자 위치에서 시작 하는 문자열에서 두 개의 문자를 추출 하는 메서드 (즉, 인덱스에 포함 된 5).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 다음 예제에서는 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드 다음 세 가지 경우 문자열 내에서 부분 문자열을 분리 합니다. 두 가지 경우에는 부분 문자열을 비교에 사용 하 고 잘못 된 매개 변수를 지정 하기 때문에 세 번째 경우 예외가 throw 됩니다.  
  
-   단일 문자 및 문자열 (인덱스 2)에서 세 번째 위치를 추출 하 고 "c"와 비교 합니다. 이 반환 `true`합니다.  
  
-   문자열 (인덱스 3)에서 네 번째 위치에서 시작 하는 0 개 문자를 추출 하 고에 전달 된 <xref:System.String.IsNullOrEmpty%2A> 메서드. 이 true를 반환 하기 때문에에 대 한 호출에서 <xref:System.String.Substring%2A> 메서드 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
-   문자열에서 네 번째 위치에서 시작 하는 한 문자를 추출 하려고 시도 합니다. 해당 위치에서 문자가 있기 때문에 메서드 호출에서 throw 한 <xref:System.ArgumentOutOfRangeException> 예외입니다.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 다음 예제에서는 <xref:System.String.Substring%2A> 같음 구분 되는 키/값 쌍을 구분 하는 메서드 문자 ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> 메서드 문자열에 equals 문자의 위치를 가져오는 데 사용 됩니다. 에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드 추출을 문자열의 첫 번째 문자에서 시작 및 확장에 대 한 호출에서 반환 된 문자 수에 대 한 키 이름에는 <xref:System.String.IndexOf%2A> 메서드. 에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%29> 메서드는 키에 할당 된 값을 추출 합니다. Equals 문자 뒤에 있는 한 문자 위치에서 시작 하 고 문자열의 끝까지 확장 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="length" />는 문자 위치가 이 인스턴스 안에 없음을 나타냅니다.  -또는-  <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체를 반복하는 열거자를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체를 반복하는 데 사용할 수 있는 강력한 형식의 열거자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, 사용할 수 있습니다 경우에만 <xref:System.String> 인스턴스로 캐스팅 되는 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스 개체입니다. 자세한 내용은 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체를 반복하는 열거자를 반환합니다.</summary>
        <returns>현재 문자열을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.Collections.IEnumerable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 자세한 내용은 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 문자열의 값이 <see langword="true" />이면 <see cref="F:System.Boolean.TrueString" />이고, 현재 문자열의 값이 <see langword="false" />이면 <see cref="F:System.Boolean.FalseString" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 문자열의 값은 <see cref="F:System.Boolean.TrueString" /> 또는 <see cref="F:System.Boolean.FalseString" />이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Byte.MaxValue" />보다 크거나 <see cref="F:System.Byte.MinValue" />보다 작은 수인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 인덱스 0에 있는 문자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Decimal.MinValue" />보다 작거나 <see cref="F:System.Decimal.MaxValue" />보다 큰 수인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 수인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Int16.MaxValue" />보다 크거나 <see cref="F:System.Int16.MinValue" />보다 작은 수인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.SByte.MaxValue" />보다 크거나 <see cref="F:System.SByte.MinValue" />보다 작은 수인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">반환되는 개체의 형식입니다.</param>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ChangeType%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidCastException">현재 <see cref="T:System.String" /> 개체의 값을 <paramref name="type" /> 매개 변수로 지정된 형식으로 변환할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.UInt16.MaxValue" />보다 크거나 <see cref="F:System.UInt16.MinValue" />보다 작은 수인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.UInt32.MaxValue" />보다 크거나 <see cref="F:System.UInt32.MinValue" />보다 작은 수인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 문자를 유니코드 문자 배열에 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 문자를 유니코드 문자 배열에 복사합니다.</summary>
        <returns>해당 요소가 이 인스턴스의 각 문자로 이루어진 유니코드 문자 배열을 반환합니다. 이 인스턴스가 빈 문자열이면 반환된 배열은 길이가 0인 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 각 문자를 복사 (즉, 각 <xref:System.Char> 개체) 문자열에 문자 배열입니다. 반환 된 문자 배열의; 인덱스 0에 복사 하는 첫 번째 문자는 인덱스에 복사 하는 마지막 문자는 <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1입니다.  
  
 문자열에서 문자 배열에 있는 문자를 만들려면 호출의 <xref:System.String.%23ctor%28System.Char%5B%5D%29> 생성자입니다.  
  
 문자열에 인코딩된 문자를 포함 하는 바이트 배열을 만들려면 적절 한 인스턴스화할 <xref:System.Text.Encoding> 개체와 호출 해당 <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> 메서드. .NET Framework에서 사용할 수 있는 표준 인코딩 중 일부는 다음과 같습니다.  
  
|인코딩|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 자세한 내용은 참조 [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.ToCharArray%2A> 메서드 문자열 문자 배열에 문자를 추출 합니다. 다음 배열에는 원래 문자열과 요소 표시 합니다.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 다음 예제는 구분 기호로 분리 된 문자열에 구분 기호로 사용 되는 문자를 포함 하는 문자열을 정의 합니다. 그런 다음 호출 하는 <xref:System.String.ToCharArray%2A> 에 전달 될 수 있는 문자 배열을 만들려면 메서드는 <xref:System.String.Split%28System.Char%5B%5D%29> 해당 개별 부분 문자열로 구분된 된 문자열을 구분 하는 메서드.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="length">이 인스턴스에 있는 부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 지정된 부분 문자열에 있는 문자를 유니코드 문자 배열에 복사합니다.</summary>
        <returns>해당 요소가 이 인스턴스의 <paramref name="length" /> 문자 위치부터 <paramref name="startIndex" /> 개의 문자로 이루어진 유니코드 문자 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문자 배열에는 문자열의 부분에는 문자를 복사합니다. 문자열에서 문자 배열의 문자 범위를 만들려면 호출의 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자입니다.  
  
 `startIndex` 매개 변수는 0부터 시작 합니다. 즉, 문자열 인스턴스에서 첫 번째 문자의 인덱스는 0입니다.  
  
 경우 `length` 가 0 이면 반환 된 배열은 비어 있고 길이가 0입니다. 이 인스턴스가 `null` 또는 빈 문자열 (""), 반환 된 배열은 비어 있고 길이가 0입니다.  
  
 문자열의 일부에 인코딩된 문자를 포함 하는 바이트 배열을 만들려면 적절 한 인스턴스화할 <xref:System.Text.Encoding> 개체와 호출 해당 <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> 메서드. .NET Framework에서 사용할 수 있는 표준 인코딩 중 일부는 다음과 같습니다.  
  
|인코딩|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 자세한 내용은 참조 [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열에 부분 문자열을 문자 배열로 변환 다음 열거 하 고 배열의 요소를 표시 합니다.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" /> + <paramref name="length" />가 이 인스턴스의 길이보다 큽니다.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열의 복사본을 소문자로 변환하여 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 복사본을 소문자로 변환하여 반환합니다.</summary>
        <returns>소문자 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 문화권의 대/소문자 규칙을 고려합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스의 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 대/소문자 구분 작업 호출의 결과로 생성 되는 <xref:System.String.ToLower> 메서드는 현재 문화권의 대/소문자 규칙을 고려 합니다. 파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 모든 문화권에서 동일한 결과 (달리는 <xref:System.String.ToLower> 메서드) 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 소문자가 혼합된 되어 있는 여러 문자열 소문자로 변환합니다.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 대/소문자 구분 메서드를 호출 하지 명시적으로 지정 합니다. 문자를 현재 문화권의 대/소문자 규칙을 사용 하 여 소문자로 변환할 호출는 <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> 메서드 오버 로드의 값을 가진 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 에 대 한 해당 <paramref name="culture" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">문화권별 대/소문자 규칙을 제공하는 개체입니다.</param>
        <summary>지정한 문화권의 대/소문자 규칙을 사용하여 소문자로 변환된 이 문자열의 복사본을 반환합니다.</summary>
        <returns>소문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 문화권의 대/소문자 규칙은 `culture` 매개 변수 변경 되는 문자열의 대/소문자 방식을 결정 합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스의 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 전달 하는 경우는 <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> 메서드는 <xref:System.Globalization.CultureInfo> 이외의 개체 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, 대/소문자 구분 작업 계정에는 culture 별 규칙 걸립니다. 파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 이 모든 문화권에서 동일한 결과 생성 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 문자열의 대문자를 영어-미국 및 터키어-터키 문화권을 사용 하 여 문자를 소문자로 변환한 다음 소문자 문자열을 비교 합니다. 제외 하는 유니코드 LATIN CAPITAL LETTER I 한 문자열에서 발생할 때마다, LATIN CAPITAL LETTER I와 점 위에 포함 하는 다른 문자열 대문자 문자열과 동일 합니다.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>고정 문화권의 대/소문자 규칙을 사용하여 소문자로 변환된 이 <see cref="T:System.String" /> 개체의 복사본을 반환합니다.</summary>
        <returns>소문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 고정 문화권을 문화권을 구분 하지 않으므로 하는 culture를 나타냅니다. 연결 된 영어 있고 특정 국가 또는 지역을 사용 하지 않습니다. 자세한 내용은 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성을 참조하세요.  
  
 응용 프로그램이 사용 하 여 현재 문화권에 따라 영향을 받지 않는 예측 가능한 방식으로 변경 하는 문자열의 대/소문자에 따라 달라 지는 <xref:System.String.ToLowerInvariant%2A> 메서드. <xref:System.String.ToLowerInvariant%2A> 메서드 `ToLower(CultureInfo.InvariantCulture)`합니다. 문자열 컬렉션을 사용자 인터페이스 컨트롤에 예측 가능한 순서로 나타나야 하는 경우 메서드는 것이 좋습니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스의 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 언어에서에서 한 단어를 포함 하는 문자열 배열을 정의 합니다. <xref:System.String.ToLowerInvariant%2A> 메서드 각 단어의 대/소문자 구분 버전과 병렬 배열의 요소를 채우는 데 사용 됩니다. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 배열을 정렬 하 여 대/소문자 구분 요소 언어에 관계 없이 동일한 순서로 표시 되도록 소문자 배열의 요소 순서를 기반으로 메서드를 사용 합니다.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.String" />의 이 인스턴스를 반환하며, 이때 실제 변환은 수행되지 않습니다.</summary>
        <returns>현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 단순히 변경 하지 않고 현재 문자열 반환 되므로 직접 호출할 필요가 없습니다. 합성 형식 지정의 예제와 같이 작업에에서는 암시적으로 호출 일반적으로 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.ToString%2A> 메서드. 이 예제에서는 명시적으로 호출 하지 않는 참고는 <xref:System.String.ToString%2A> 메서드. 대신 메서드가 의해 암시적으로 호출 됩니다는 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 기능입니다.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(예약됨) 문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>
          <see cref="T:System.String" />의 이 인스턴스를 반환하며, 이때 실제 변환은 수행되지 않습니다.</summary>
        <returns>현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` 예약 되며이 작업에 관여 하지 않습니다.  
  
 이 메서드는 단순히 변경 하지 않고 현재 문자열 반환 되므로 직접 호출할 필요가 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열의 복사본을 대문자로 변환하여 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 복사본을 대문자로 변환하여 반환합니다.</summary>
        <returns>대문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 인스턴스에 있는 각 문자를 해당 대문자로 변환 하는 현재 문화권의 대/소문자 규칙을 사용 합니다. 문자에 해당 하는 대문자 이거나 없는 경우 포함 되었습니다 반환 된 문자열에서 변경 되지 않습니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스의 모든 문자는 대문자로 변환 하는 새 문자열을 반환 합니다.  
  
 <xref:System.String.ToUpper%2A> 메서드는 대/소문자 비구분 비교에 사용할 수 있도록 문자열을 대문자로 변환 하는 데 자주 사용 됩니다. 대/소문자 구분 비교를 수행 하는 향상 된 방법을 변수가 있는 문자열 비교 메서드를 호출 하는 것을 <xref:System.StringComparison> 매개 변수 값으로 설정 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> 문화권을 구분, 대/소문자 비구분 비교 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 대/소문자 구분 작업 호출의 결과로 생성 되는 <xref:System.String.ToUpper> 메서드는 현재 문화권의 대/소문자 규칙을 고려 합니다. 파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 모든 문화권에서 동일한 결과 (달리는 <xref:System.String.ToUpper> 메서드) 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.ToUpper%2A> 일련의 기본 라틴, 라틴어-1 추가 및 라틴 문자 확장 A 문자 집합의 각 문자를 포함 하는 한 문자로 문자열을 변환 하는 메서드입니다. 대문자 문자는 소문자와에서 다른 각 문자열을 표시 합니다.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 Strings](~/docs/standard/base-types/best-practices-strings.md)에 대 한 모범 사례 권장 기본값을 대체 대신 매개 변수 수 필요로 하는 메서드를 호출 하는 문자열 대/소문자 구분 메서드를 호출 하지 명시적으로 지정 합니다. 문자열을 현재 문화권의 대/소문자 규칙을 사용 하 여 대문자로 변환할 호출는 <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> 메서드 오버 로드의 값을 가진 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 에 대 한 해당 <paramref name="culture" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">문화권별 대/소문자 규칙을 제공하는 개체입니다.</param>
        <summary>지정한 문화권의 대/소문자 규칙을 사용하여 대문자로 변환된 이 문자열의 복사본을 반환합니다.</summary>
        <returns>대문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 문화권의 대/소문자 규칙은 `culture` 매개 변수 변경 되는 문자열의 대/소문자 방식을 결정 합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스의 모든 문자는 대문자로 변환 하는 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 전달 하는 경우는 <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> 메서드는 <xref:System.Globalization.CultureInfo> 이외의 개체 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, 대/소문자 구분 작업 계정에는 culture 별 규칙 걸립니다. 파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 이 모든 문화권에서 동일한 결과 생성 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 대문자, 영어-미국 및 터키어-터키 문화권을 사용 하 여 문자열을 소문자 문자열로 변환한 다음 대문자 문자열을 비교 합니다. 제외 하는 유니코드 LATIN CAPITAL LETTER I 한 문자열에서 발생할 때마다, LATIN CAPITAL LETTER I와 점 위에 포함 하는 다른 문자열 대문자 문자열과 동일 합니다.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>고정 문화권의 대/소문자 규칙을 사용하여 대문자로 변환된 이 <see cref="T:System.String" /> 개체의 복사본을 반환합니다.</summary>
        <returns>대문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 고정 문화권을 문화권을 구분 하지 않으므로 하는 culture를 나타냅니다. 연결 된 영어 있고 특정 국가 또는 지역을 사용 하지 않습니다. 자세한 내용은 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성을 참조하세요.  
  
 응용 프로그램이 사용 하 여 현재 문화권에 따라 영향을 받지 않는 예측 가능한 방식으로 변경 하는 문자열의 대/소문자에 따라 달라 지는 <xref:System.String.ToUpperInvariant%2A> 메서드. <xref:System.String.ToUpperInvariant%2A> 메서드 `ToUpper(CultureInfo.InvariantCulture)`합니다. 문자열 컬렉션을 사용자 인터페이스 컨트롤에 예측 가능한 순서로 나타나야 하는 경우 메서드는 것이 좋습니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스의 모든 문자는 대문자로 변환 하는 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 언어에서에서 한 단어를 포함 하는 문자열 배열을 정의 합니다. <xref:System.String.ToUpperInvariant%2A> 메서드 각 단어의 대/소문자 구분 버전과 병렬 배열의 요소를 채우는 데 사용 됩니다. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 배열을 정렬 하 여 대/소문자 구분 요소 언어에 관계 없이 동일한 순서로 표시 되도록 대문자 배열의 요소 순서를 기반으로 메서드를 사용 합니다.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체에서 지정된 문자 집합의 선행 항목과 후행 항목이 모두 제거되는 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체에서 선행 공백과 후행 공백을 모두 제거합니다.</summary>
        <returns>모든 공백 뒤에 있는 문자열이 현재 문자열의 시작 부분과 끝 부분에서 제거됩니다. 현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> 메서드 모든 선행 및 후행 공백 문자는 현재 문자열에서 제거 합니다. 공백이 아닌 문자가 발견 되는 각 선행 및 후행 지우기 작업이 중지 합니다. 예를 들어, 현재 문자열 "abc xyz"는 <xref:System.String.Trim%2A> 메서드는 "abc xyz"를 반환 합니다. 사용 하 여 문자열에서 단어 사이 공백 문자를 제거 하려면 한 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md)합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.Trim%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스에서 모든 선행 및 후행 공백 문자가 제거 됩니다는 새 문자열을 반환 합니다.  
  
 현재 문자열 절과 같을 경우 <xref:System.String.Empty> 메서드 반환 현재 인스턴스에 있는 모든 문자가 공백 문자로 구성 또는 <xref:System.String.Empty>합니다.  
  
 공백 문자는 유니코드 표준에서 정의 됩니다. <xref:System.String.Trim> 메서드 반환 값을 생성 하는 선행 및 후행 문자 제거 `true` 에 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Trim?displayProperty=nameWithType> 메서드를 연결 하기 전에 사용자가 입력 문자열에서 모든 추가 공백을 제거 합니다.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전에이 메서드를 삭제 합니다. 공백 문자의 내부 목록을 유지 관리 합니다. 부터는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 메서드가 모든 유니코드 공백 문자를 삭제 합니다. (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 반환 값은 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 이상 버전을 제거 하지 않습니다. 또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 선행 항목과 후행 항목을 모두 제거합니다.</summary>
        <returns>
          <paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 시작 부분과 끝 부분에서 모두 제거된 후 남아 있는 문자열입니다. <paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 공백 문자가 대신 제거됩니다. 현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> 메서드는 현재 문자열에서 선행 및 후행 문자를 모두 제거에 `trimChars` 매개 변수입니다. 각 선행 및 후행 지우기 작업이 중지 중이 아닌 문자가 `trimChars` 발생 합니다. 예를 들어, 현재 문자열은 "123abc456xyz789" 및 `trimChars` "9", "1"에서 숫자가 포함 되어는 <xref:System.String.Trim%2A> 메서드 "abc456xyz"를 반환 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.Trim%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 새 문자열을 모두에서 반환 선행 및 후행 `trimChars` 현재 인스턴스에서 문자가 제거 됩니다.  
  
 현재 문자열 절과 같을 경우 <xref:System.String.Empty> 문자로 구성 된 현재 인스턴스의 모든 문자가 또는 `trimChars` 메서드 반환 배열 <xref:System.String.Empty>합니다.  
  
 경우 `trimChars` 은 `null` 빈 배열이 면이 메서드를 반환 하는 메서드에에서 발생 하는 선행 또는 후행 문자 제거 또는 `true` 에 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드를 공간, 별표 (*) 및 아포스트로피 (') 문자는 문자열에서 제거 합니다.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 이전 버전의 경우 삭제 합니다.이 메서드는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 은 <see langword="null" /> 이거나 빈 배열입니다. 부터는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 경우 <paramref name="trimChars" /> 은 <see langword="null" /> 빈 배열인 경우 메서드는 모든 유니코드 공백 문자 또는 (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 반환 값은 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 이상 버전을 제거 하지 않습니다. 또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 후행 항목을 모두 제거합니다.</summary>
        <returns>
          <paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 끝 부분에서 모두 제거된 후 남아 있는 문자열입니다. <paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 유니코드 공백 문자가 대신 제거됩니다. 현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A> 메서드에 있는 모든 후행 문자가 현재 문자열에서 제거 된 `trimChars` 매개 변수입니다. 첫 번째 문자에 있지 않은 지우기 작업이 중지 `trimChars` 문자열의 끝에서 발생 합니다. 예를 들어, 현재 문자열은 "123abc456xyz789" 및 `trimChars` "9", "1"에서 숫자가 포함 되어는 <xref:System.String.TrimEnd%2A> 메서드 "123abc456xyz"를 반환 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.TrimEnd%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 새 문자열에 있는 모든 후행 문자에 반환 `trimChars` 는 현재 문자열에서 제거 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.String.TrimEnd%28System.Char%5B%5D%29> 메서드 공백 또는 문장 부호는 문자열의 끝에서 지울 수 있습니다.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 이전 버전의 경우 삭제 합니다.이 메서드는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 은 <see langword="null" /> 이거나 빈 배열입니다. 부터는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 경우 <paramref name="trimChars" /> 은 <see langword="null" /> 빈 배열인 경우 메서드는 모든 유니코드 공백 문자 또는 (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 반환 값은 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 이상 버전을 제거 하지 않습니다. 또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 선행 항목을 모두 제거합니다.</summary>
        <returns>
          <paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 시작 부분에서 모두 제거된 후 남아 있는 문자열입니다. <paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 공백 문자가 대신 제거됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimStart%2A> 메서드에 있던 모든 선행 문자가 현재 문자열에서 제거 된 `trimChars` 매개 변수입니다. 지우기 작업이 중지 중이 아닌 문자가 `trimChars` 발생 합니다. 예를 들어, 현재 문자열은 "123abc456xyz789" 및 `trimChars` "9", "1"에서 숫자가 포함 되어는 <xref:System.String.TrimStart%2A> 메서드 "abc456xyz789"를 반환 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.TrimStart%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 현재 인스턴스 선행 공백 문자를 모두 제거 됩니다는 새 문자열을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.TrimStart%2A> 메서드는 소스 코드 줄에서 주석 문자 및 공백을 지울 수 있습니다. `StripComments` 메서드 호출을 래핑합니다 <xref:System.String.TrimStart%2A> Visual Basic 및 C#에서 슬래시 (/)에서 공백 및 아포스트로피 (')는 주석 문자를 포함 하는 문자 배열을 전달 합니다. <xref:System.String.TrimStart%2A> 문자열로 주석을 인지 확인할 때 선행 공백을 제거 하려면 메서드도 호출 됩니다.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 다음 예제에서는 `StripComments` 메서드를 호출하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 이전 버전의 경우 삭제 합니다.이 메서드는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 은 <see langword="null" /> 이거나 빈 배열입니다. 부터는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 경우 <paramref name="trimChars" /> 은 <see langword="null" /> 빈 배열인 경우 메서드는 모든 유니코드 공백 문자 또는 (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 반환 값은 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 및 이상 버전을 제거 하지 않습니다. 또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [! INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>