<Type Name="String" FullName="System.String">
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ad3d8-101">텍스트를 UTF-16 코드 단위의 시퀀스로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-101">Represents text as a sequence of UTF-16 code units.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="ad3d8-102">문자열은 텍스트를 나타내는 데 사용 되는 문자의 순차적인 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-102">A string is a sequential collection of characters that is used to represent text.</span></span> <span data-ttu-id="ad3d8-103">A <xref:System.String> 개체의 순차적인 컬렉션을는 <xref:System.Char?displayProperty=nameWithType> 문자열 있으며 나타내는 개체를 개체 <xref:System.Char?displayProperty=nameWithType> utf-16 코드 단위에 해당 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-103">A <xref:System.String> object is a sequential collection of <xref:System.Char?displayProperty=nameWithType> objects that represent a string; a <xref:System.Char?displayProperty=nameWithType> object corresponds to a UTF-16 code unit.</span></span> <span data-ttu-id="ad3d8-104">값은 <xref:System.String> 개체의 순차 컬렉션의 콘텐츠는 <xref:System.Char?displayProperty=nameWithType> 개체 및 값은 변경할 수 없습니다 (즉,이 읽기 전용).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-104">The value of the <xref:System.String> object is the content of the sequential collection of <xref:System.Char?displayProperty=nameWithType> objects, and that value is immutable (that is, it is read-only).</span></span> <span data-ttu-id="ad3d8-105">문자열의 불변성에 대 한 자세한 내용은 참조는 [불변성 및 StringBuilder 클래스](#Immutability) 이 항목의 뒷부분에 나오는 섹션.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-105">For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic.</span></span> <span data-ttu-id="ad3d8-106">최대 크기는 <xref:System.String> 개체가 메모리에 2 GB 되었거나 약 1 십억 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-106">The maximum size of a <xref:System.String> object in memory is 2GB, or about 1 billion characters.</span></span>  
  
 <span data-ttu-id="ad3d8-107">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="ad3d8-107">In this section:</span></span>  
  
 <span data-ttu-id="ad3d8-108">[문자열 개체 인스턴스화](#Instantiation) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-108">[Instantiating a String object](#Instantiation) </span></span>  
 <span data-ttu-id="ad3d8-109">[Char 개체 및 유니코드 문자](#Characters) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-109">[Char objects and Unicode characters](#Characters) </span></span>  
 <span data-ttu-id="ad3d8-110">[문자열과 유니코드 표준](#Unicode) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-110">[Strings and The Unicode Standard](#Unicode) </span></span>  
 <span data-ttu-id="ad3d8-111">[문자열 및 포함 된 null 문자](#EmbeddedNulls) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-111">[Strings and embedded null characters](#EmbeddedNulls) </span></span>  
 <span data-ttu-id="ad3d8-112">[문자열 및 인덱스](#Indexes) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-112">[Strings and indexes](#Indexes) </span></span>  
 <span data-ttu-id="ad3d8-113">[Null 문자열 및 빈 문자열](#Nulls) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-113">[Null strings and empty strings](#Nulls) </span></span>  
 <span data-ttu-id="ad3d8-114">[불변성이 및 StringBuilder 클래스](#Immutability) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-114">[Immutability and the StringBuilder class](#Immutability) </span></span>  
 <span data-ttu-id="ad3d8-115">[문화권 구분 작업 및 서 수](#CultureSensitive) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-115">[Ordinal vs. culture-sensitive operations](#CultureSensitive) </span></span>  
 <span data-ttu-id="ad3d8-116">[정규화](#Normalization) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-116">[Normalization](#Normalization) </span></span>  
 [<span data-ttu-id="ad3d8-117">범주별으로 문자열 작업</span><span class="sxs-lookup"><span data-stu-id="ad3d8-117">String operations by category</span></span>](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a><span data-ttu-id="ad3d8-118">문자열 개체 인스턴스화</span><span class="sxs-lookup"><span data-stu-id="ad3d8-118">Instantiating a String object</span></span>  
 <span data-ttu-id="ad3d8-119">인스턴스화할 수 있습니다는 <xref:System.String> 다음과 같은 방법으로 개체:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-119">You can instantiate a <xref:System.String> object in the following ways:</span></span>  
  
-   <span data-ttu-id="ad3d8-120">문자열 리터럴을 할당 하 여 한 <xref:System.String> 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-120">By assigning a string literal to a <xref:System.String> variable.</span></span> <span data-ttu-id="ad3d8-121">이 문자열을 만들기 위해 자주 사용 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-121">This is the most commonly used method for creating a string.</span></span> <span data-ttu-id="ad3d8-122">다음 예제에서는 할당을 사용 하 여 여러 문자열을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-122">The following example uses assignment to create several strings.</span></span> <span data-ttu-id="ad3d8-123">때문에 C#에서 유의 백슬래시 (\\)는 이스케이프 문자, 문자열의 리터럴 백슬래시를 이스케이프 처리 해야 또는 전체 문자열 이어야 합니다 @-quoted합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-123">Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   <span data-ttu-id="ad3d8-124">호출 하 여 한 <xref:System.String> 클래스 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-124">By calling a <xref:System.String> class constructor.</span></span> <span data-ttu-id="ad3d8-125">다음 예제에서는 여러 클래스 생성자를 호출 하 여 문자열을 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-125">The following example instantiates strings by calling several class constructors.</span></span> <span data-ttu-id="ad3d8-126">Note 문자 배열 또는 매개 변수로 부호 있는 바이트 배열에 대 한 포인터를 포함 하는 생성자의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-126">Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</span></span> <span data-ttu-id="ad3d8-127">Visual Basic에서 이러한 생성자에 대 한 호출을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-127">Visual Basic does not support calls to these constructors.</span></span> <span data-ttu-id="ad3d8-128">에 대 한 자세한 내용은 <xref:System.String> 생성자, 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-128">For detailed information about <xref:System.String> constructors, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   <span data-ttu-id="ad3d8-129">문자열 연결 연산자를 사용 하 여 (+, C# 및 & 또는 +, Visual basic에서) 조합에서 단일 문자열을 만드는 <xref:System.String> 인스턴스 및 문자열 리터럴을 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-129">By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of <xref:System.String> instances and string literals.</span></span> <span data-ttu-id="ad3d8-130">다음 예제에서는 문자열 연결 연산자의 사용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-130">The following example illustrates the use of the string concatenation operator.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   <span data-ttu-id="ad3d8-131">한 속성을 검색 하거나 문자열을 반환 하는 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-131">By retrieving a property or calling a method that returns a string.</span></span> <span data-ttu-id="ad3d8-132">메서드를 사용 하는 다음 예제는 <xref:System.String> 더 큰 문자열에서 하위 문자열을 추출 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-132">The following example uses the methods of the <xref:System.String> class to extract a substring from a larger string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   <span data-ttu-id="ad3d8-133">값 이나 개체를 문자열 표현으로 변환 하는 서식 지정 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-133">By calling a formatting method to convert a value or object to its string representation.</span></span> <span data-ttu-id="ad3d8-134">다음 예제에서는 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문자열로 두 개체의 문자열 표현을 포함 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-134">The following example uses the                [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature to embed the string representation of two objects into a string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a><span data-ttu-id="ad3d8-135">Char 개체 및 유니코드 문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-135">Char objects and Unicode characters</span></span>  
 <span data-ttu-id="ad3d8-136">문자열의 각 문자는 유니코드 코드 포인트 또는 서 수 (숫자) 값의 유니코드 문자를 유니코드 스칼라 값으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-136">Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</span></span> <span data-ttu-id="ad3d8-137">Utf-16 인코딩을 사용 하 여 각 코드 포인트를 인코딩하고 인코딩의 각 요소의 숫자 값으로 표시 됩니다는 <xref:System.Char> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-137">Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-138">때문에 <xref:System.String> utf-16 코드 단위의 순차 컬렉션의 인스턴스 구성 됩니다, 만들 수는 <xref:System.String> 개체는 올바른 형식의 유니코드 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-138">Note that, because a <xref:System.String> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <xref:System.String> object that is not a well-formed Unicode string.</span></span> <span data-ttu-id="ad3d8-139">예를 들어 해당 상위 서로게이트 없이 하위 서로게이트가 포함 된 문자열을 만들 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-139">For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</span></span> <span data-ttu-id="ad3d8-140">하지만 인코딩 및 디코딩에 있는 개체의 메서드와 같은 일부 메서드는 <xref:System.Text> 네임 스페이스 문자열은 올바른 형식을 갖추도록 되도록 검사를 수행 될 수 있습니다 <xref:System.String> 클래스 멤버는 문자열은 올바른 형식의 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-140">Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, <xref:System.String> class members don't ensure that a string is well-formed.</span></span>  
  
 <span data-ttu-id="ad3d8-141">단일 <xref:System.Char> 개체는 일반적으로 단일 나타냅니다 코드 포인트입니다; 즉,의 숫자 값은 <xref:System.Char> 코드 포인트를 같음.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-141">A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point.</span></span> <span data-ttu-id="ad3d8-142">예를 들어, 코드 포인트는 "문자에 대 한 a"는 U + 0061 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-142">For example, the code point for the character "a" is U+0061.</span></span> <span data-ttu-id="ad3d8-143">그러나, 코드 포인트에서 인코딩된 요소가 둘 이상 필요할 수 있습니다 (둘 이상의 <xref:System.Char> 개체).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-143">However, a code point might require more than one encoded element (more than one <xref:System.Char> object).</span></span> <span data-ttu-id="ad3d8-144">다중 두 가지 유형의 해당 하는 문자를 정의 하는 유니코드 표준 <xref:System.Char> 개체: 제자, 및 유니코드 보조 평면에 있는 문자에 해당 하는 유니코드 보조 문자 코드 포인트입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-144">The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</span></span>  
  
-   <span data-ttu-id="ad3d8-145">단일 기본 문자 뒤에 하나 이상의 결합 문자가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-145">A grapheme is represented by a base character followed by one or more combining characters.</span></span> <span data-ttu-id="ad3d8-146">예를 들어 ä는 문자가 a에서 <xref:System.Char> 코드 포인트가 U + 0061 a가 개체 <xref:System.Char> 코드 포인트가 U + 0308 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-146">For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308.</span></span> <span data-ttu-id="ad3d8-147">이 문자는 단일 정의할 수도 있습니다 <xref:System.Char> 개체는 코드 포인트가 U + 00 e 4 인입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-147">This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4.</span></span> <span data-ttu-id="ad3d8-148">다음 예제와 같이 같음에 대 한 문화권 구분 비교는 서 수 비교 아니지 이러한 두 표현은 이상이 면 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-148">As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</span></span> <span data-ttu-id="ad3d8-149">그러나 두 문자열을 정규화 하는 경우 서 수 비교 나타내기도 같은지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-149">However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</span></span> <span data-ttu-id="ad3d8-150">(문자열을 정규화 자세한 내용은 참조는 [정규화](#Normalization) 섹션.)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-150">(For more information on normalizing strings, see the [Normalization](#Normalization) section.)</span></span>  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   <span data-ttu-id="ad3d8-151">유니코드 보조 문자 코드 포인트 (예: 서로게이트 쌍)으로 표시 됩니다는 <xref:System.Char> 코드 포인트가 high surrogate 인지 개체 뒤는 <xref:System.Char> 개체 코드 포인트가 하위 서로게이트입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-151">A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate.</span></span> <span data-ttu-id="ad3d8-152">높은 서로게이트가 범위 U + d 800에서 U + DBFF의 코드 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-152">The code units of high surrogates range from U+D800 to U+DBFF.</span></span> <span data-ttu-id="ad3d8-153">U + d c 00부터 U + dfff 낮은 서로게이트가 범위의 코드 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-153">The code units of low surrogates range from U+DC00 to U+DFFF.</span></span> <span data-ttu-id="ad3d8-154">서로게이트 쌍이 16 유니코드 보조 평면에 있는 문자를 나타내는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-154">Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</span></span> <span data-ttu-id="ad3d8-155">다음 예제에서는 서로게이트 문자를 만들고 전달 하는 <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> 메서드는 서로게이트 쌍 인지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-155">The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> method to determine whether it is a surrogate pair.</span></span>  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a><span data-ttu-id="ad3d8-156">문자열과 유니코드 표준</span><span class="sxs-lookup"><span data-stu-id="ad3d8-156">Strings and The Unicode Standard</span></span>  
 <span data-ttu-id="ad3d8-157">문자열의 문자에 해당 하는 u t F-16으로 인코딩된 코드 단위도 표현 됩니다 <xref:System.Char> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-157">Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.</span></span>  
  
 <span data-ttu-id="ad3d8-158">각 문자는 문자열에 의해.NET Framework에서 표현 되는 연결 된 유니코드 문자 범주에는 <xref:System.Globalization.UnicodeCategory> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-158">Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <xref:System.Globalization.UnicodeCategory> enumeration.</span></span> <span data-ttu-id="ad3d8-159">문자 또는 서로게이트 쌍의 범주를 호출 하 여 확인할 수 있습니다는 <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-159">The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ad3d8-160">.NET의 문자와 해당 범주에는 특정 버전의 다른 플랫폼에서 실행 되는.NET 구현이 동일한 문자 범주 정보를 반환 하는지 자체 테이블 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-160">.NET maintains its own table of characters and their corresponding categories, which ensures that a specific version of a .NET implementation running on different platforms returns identical character category information.</span></span> <span data-ttu-id="ad3d8-161">다음 표에서.NET 버전 및 문자 범주에 기반 하는 유니코드 표준의 버전을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-161">The following table lists .NET versions and the versions of the Unicode Standard on which their character categories are based.</span></span>  
  
|<span data-ttu-id="ad3d8-162">.NET Framework 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-162">.NET Framework version</span></span>|<span data-ttu-id="ad3d8-163">유니코드 표준의 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-163">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="ad3d8-164">유니코드 표준 버전 4.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-164">The Unicode Standard, Version 4.0.0</span></span>](http://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="ad3d8-165">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-165">The .NET Framework 2.0</span></span>|[<span data-ttu-id="ad3d8-166">유니코드 표준 버전 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-166">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="ad3d8-167">유니코드 표준 버전 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-167">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="ad3d8-168">유니코드 표준 버전 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-168">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[<span data-ttu-id="ad3d8-169">유니코드 표준 6.3.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-169">The Unicode Standard, Version 6.3.0</span></span>](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[<span data-ttu-id="ad3d8-170">유니코드 표준 6.3.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-170">The Unicode Standard, Version 6.3.0</span></span>](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[<span data-ttu-id="ad3d8-171">유니코드 표준 6.3.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-171">The Unicode Standard, Version 6.3.0</span></span>](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[<span data-ttu-id="ad3d8-172">유니코드 표준 6.3.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-172">The Unicode Standard, Version 6.3.0</span></span>](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[<span data-ttu-id="ad3d8-173">유니코드 표준 6.3.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-173">The Unicode Standard, Version 6.3.0</span></span>](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[<span data-ttu-id="ad3d8-174">유니코드 표준 8.0.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-174">The Unicode Standard, Version 8.0.0</span></span>](http://www.unicode.org/versions/Unicode8.0.0/)|  
|<span data-ttu-id="ad3d8-175">.NET core (모든 버전)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-175">.NET Core (all versions)</span></span>|[<span data-ttu-id="ad3d8-176">유니코드 표준 8.0.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-176">The Unicode Standard, Version 8.0.0</span></span>](http://www.unicode.org/versions/Unicode8.0.0/)|
  
 <span data-ttu-id="ad3d8-177">또한.NET Framework에서는 문자열 비교를 지원 하 고 유니코드 표준에 따라 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-177">In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</span></span> <span data-ttu-id="ad3d8-178">통해.NET Framework의 버전에는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],.NET Framework에 문자열 데이터의 자체 테이블 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-178">In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data.</span></span> <span data-ttu-id="ad3d8-179">부터는.NET Framework 버전의 경우에이 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-179">This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Windows 7.</span></span> <span data-ttu-id="ad3d8-180">부터는 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Window 8 및 이후 버전의 Windows 운영 체제에서 실행, 런타임 대리자 문자열 비교 및 정렬 작업의 운영 체제입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-180">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</span></span> <span data-ttu-id="ad3d8-181">다음 표에서.NET Framework의 버전 및 문자 비교 및 정렬은 기반으로 하는 유니코드 표준의 버전을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-181">The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</span></span>  
  
|<span data-ttu-id="ad3d8-182">.NET Framework 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-182">.NET Framework version</span></span>|<span data-ttu-id="ad3d8-183">유니코드 표준의 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-183">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="ad3d8-184">유니코드 표준 버전 4.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-184">The Unicode Standard, Version 4.0.0</span></span>](http://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="ad3d8-185">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-185">The .NET Framework 2.0</span></span>|[<span data-ttu-id="ad3d8-186">유니코드 표준 버전 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-186">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="ad3d8-187">유니코드 표준 버전 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-187">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="ad3d8-188">유니코드 표준 버전 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-188">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="ad3d8-189"> Windows 7 이상</span><span class="sxs-lookup"><span data-stu-id="ad3d8-189"> and later on Windows 7</span></span>|[<span data-ttu-id="ad3d8-190">유니코드 표준 버전 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-190">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="ad3d8-191"> 나중에 Windows 8 및 이상의 Windows 운영 체제와</span><span class="sxs-lookup"><span data-stu-id="ad3d8-191"> and later on Windows 8 and later Windows operating systems</span></span>|[<span data-ttu-id="ad3d8-192">유니코드 표준 6.3.0 버전</span><span class="sxs-lookup"><span data-stu-id="ad3d8-192">The Unicode Standard, Version 6.3.0</span></span>](http://www.unicode.org/versions/Unicode6.3.0/)|  

<span data-ttu-id="ad3d8-193">.NET Core에서는 정렬 및 비교 연산에 따라은 [유니코드 표준의 버전 8.0.0](http://www.unicode.org/versions/Unicode8.0.0/)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-193">In .NET Core, sorting and comparison operations are based on [Version 8.0.0 of the Unicode Standard](http://www.unicode.org/versions/Unicode8.0.0/).</span></span>

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a><span data-ttu-id="ad3d8-194">문자열 및 포함 된 null 문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-194">Strings and embedded null characters</span></span>  
 <span data-ttu-id="ad3d8-195">.NET framework에서는 <xref:System.String> 개체는 문자열 길이의 일부로 계산 포함 된 null 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-195">In the .NET Framework, a <xref:System.String> object can include embedded null characters, which count as a part of the string's length.</span></span> <span data-ttu-id="ad3d8-196">그러나 C 및 c + +와 같은 일부 언어에서는 null 문자는 문자열의 끝을 나타내는 이며 문자열의 일부로 간주 되지 않습니다는 문자열 길이의 일부로 계산 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-196">However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</span></span> <span data-ttu-id="ad3d8-197">즉, C 및 c + + 프로그래머 또는 라이브러리 C 또는 c + +로 작성 된 문자열에 대 한 하도록 할 수 있는 다음과 같은 일반적인 가정에 적용 될 때 반드시 유효한 지 <xref:System.String> 개체:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-197">This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <xref:System.String> objects:</span></span>  
  
-   <span data-ttu-id="ad3d8-198">반환한 값은 `strlen` 또는 `wcslen` 함수 같지 않을 수도 <xref:System.String.Length%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-198">The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ad3d8-199">만든 문자열은 `strcpy_s` 또는 `wcscpy_s` 함수에서 만든 문자열을 반드시 일치 하지 않습니다는 <xref:System.String.Copy%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-199">The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ad3d8-200">인스턴스화하는 해당 네이티브 C 및 c + + 코드를 확인 해야 <xref:System.String> 개체 및 전달 되는 코드 <xref:System.String> 플랫폼을 통해 개체 호출을 포함 된 null 문자는 문자열의 끝을 표시 가정 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-200">You should ensure that native C and C++ code that instantiates <xref:System.String> objects, and code that is passed <xref:System.String> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</span></span>  
  
 <span data-ttu-id="ad3d8-201">또한 문자열에 포함 된 null 문자는 문자열은 정렬 또는 (비교)와 문자열을 검색할 경우 다르게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-201">Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</span></span> <span data-ttu-id="ad3d8-202">고정 문화권을 사용 하 여 비교를 포함 하 여 두 문자열 간의 문화권 구분 비교를 수행할 때 null 문자는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-202">Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</span></span> <span data-ttu-id="ad3d8-203">서 수 또는 대/소문자 비구분 서 수 비교에 대 한 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-203">They are considered only for ordinal or case-insensitive ordinal comparisons.</span></span> <span data-ttu-id="ad3d8-204">반면에 포함 된 null 문자를 항상 고려와 같은 방법으로는 문자열을 검색할 때 <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, 및 <xref:System.String.IndexOf%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-204">On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.</span></span>  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a><span data-ttu-id="ad3d8-205">문자열 및 인덱스</span><span class="sxs-lookup"><span data-stu-id="ad3d8-205">Strings and indexes</span></span>  
 <span data-ttu-id="ad3d8-206">인덱스는의 위치는 <xref:System.Char> (유니코드 문자)의 개체는 <xref:System.String>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-206">An index is the position of a <xref:System.Char> object (not a Unicode character) in a <xref:System.String>.</span></span> <span data-ttu-id="ad3d8-207">인덱스는 인덱스 0 위치 하는 문자열의 첫 번째 위치에서 시작 하는 음수가 아닌 숫자 0부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-207">An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</span></span> <span data-ttu-id="ad3d8-208">다양 한 검색 메서드는 같은 <xref:System.String.IndexOf%2A> 및 <xref:System.String.LastIndexOf%2A>, 문자의 인덱스를 반환 또는 문자열 인스턴스에서 부분 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-208">A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.</span></span>  
  
 <span data-ttu-id="ad3d8-209"><xref:System.String.Chars%2A> 속성에 액세스할 수 있게 개별 <xref:System.Char> 문자열의 인덱스 위치에 의해 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-209">The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string.</span></span> <span data-ttu-id="ad3d8-210">때문에 <xref:System.String.Chars%2A> 속성 (Visual Basic)의 기본 속성 또는 인덱서 (C#)은, 개별에 액세스할 수 있습니다 <xref:System.Char> 다음과 같은 코드를 사용 하 여 문자열에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-210">Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following.</span></span> <span data-ttu-id="ad3d8-211">이 코드 공백 또는 문자열에 단어의 개수를 결정 하는 문자열의 문장 부호 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-211">This code looks for white space or punctuation characters in a string to determine how many words the string contains.</span></span>  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <span data-ttu-id="ad3d8-212">때문에 <xref:System.String> 클래스가 구현 하는 <xref:System.Collections.IEnumerable> 인터페이스를 반복할 수도 있습니다를 통해는 <xref:System.Char> 를 사용 하 여 문자열에서 `foreach` 다음 예제와 같이 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-212">Because the <xref:System.String> class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.</span></span>  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 <span data-ttu-id="ad3d8-213">연속 된 인덱스 값 서로 다를 수 연속 유니코드 문자를 유니코드 문자 수 개 이상의 때문에 <xref:System.Char> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-213">Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object.</span></span> <span data-ttu-id="ad3d8-214">특히, 문자열로 기본 문자 뒤에 하나 이상의 결합 문자 또는 서로게이트 쌍으로 형성 된 텍스트 단위 여러 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-214">In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</span></span> <span data-ttu-id="ad3d8-215">대신 유니코드 문자로 작업 해야 <xref:System.Char> 개체를 사용 하 여는 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 및 <xref:System.Globalization.TextElementEnumerator> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-215">To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> and <xref:System.Globalization.TextElementEnumerator> classes.</span></span> <span data-ttu-id="ad3d8-216">다음 예제 코드를 사용 하는 차이점을 보여 줍니다. <xref:System.Char> 개체 및 유니코드 문자를 사용 하는 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-216">The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters.</span></span> <span data-ttu-id="ad3d8-217">문자 또는 문장의 각 단어의 텍스트 요소 수를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-217">It compares the number of characters or text elements in each word of a sentence.</span></span> <span data-ttu-id="ad3d8-218">문자열에는 기본 문자 뒤에 결합 문자 시퀀스를 두 개의 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-218">The string includes two sequences of a base character followed by a combining character.</span></span>  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 <span data-ttu-id="ad3d8-219">이 예제에서는 텍스트 요소를 사용 하 여 작업의 <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> 메서드 및 <xref:System.Globalization.TextElementEnumerator> 문자열의 모든 텍스트 요소를 열거 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-219">This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string.</span></span> <span data-ttu-id="ad3d8-220">호출 하 여 각 텍스트 요소의 시작 하는 인덱스를 포함 하는 배열을 검색할 수도 있습니다는 <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-220">You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ad3d8-221">개별이 아닌 텍스트의 단위를 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Char> 값, 참조는 <xref:System.Globalization.StringInfo> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-221">For more information about working with units of text rather than individual <xref:System.Char> values, see the <xref:System.Globalization.StringInfo> class.</span></span>  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="ad3d8-222">Null 문자열 및 빈 문자열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-222">Null strings and empty strings</span></span>  
 <span data-ttu-id="ad3d8-223">선언 되었지만 값 할당 되지 않았습니다 문자열은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-223">A string that has been declared but has not been assigned a value is `null`.</span></span> <span data-ttu-id="ad3d8-224">해당 문자열의 메서드를 호출 하는 동안 throw 된 <xref:System.NullReferenceException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-224">Attempting to call methods on that string throws a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="ad3d8-225">Null 문자열은 단일 값이 빈 문자열인 경우 간에 차이가 있는 "" 또는 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-225">A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-226">일부 경우에 메서드 호출에서 인수로 null 문자열이 나 빈 문자열로 전달 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-226">In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</span></span> <span data-ttu-id="ad3d8-227">예를 들어, null 문자열을 전달는 <xref:System.Int32.Parse%2A?displayProperty=nameWithType> 메서드가 throw는 <xref:System.ArgumentNullException>, throw 빈 문자열을 전달 하는 <xref:System.FormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-227">For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=nameWithType> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="ad3d8-228">다른 경우에 메서드 인수는 null 문자열 또는 빈 문자열일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-228">In other cases, a method argument can be either a null string or an empty string.</span></span> <span data-ttu-id="ad3d8-229">예를 제공 하는 경우는 <xref:System.IFormattable> 클래스에 대 한 구현 하려면 일반 ("G") 형식 지정자와 함께 null 문자열 및 빈 문자열을 모두와 동등 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-229">For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</span></span>  
  
 <span data-ttu-id="ad3d8-230"><xref:System.String> 클래스 문자열이 여부를 테스트할 수 있도록 하는 다음 두 개의 편리한 메서드를 포함 `null` 이거나 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-230">The <xref:System.String> class includes the following two convenience methods that enable you to test whether a string is `null` or empty:</span></span>  
  
-   <span data-ttu-id="ad3d8-231"><xref:System.String.IsNullOrEmpty%2A>문자열이 중 하나 인지를 나타내는 `null` 같은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-231"><xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-232">이 메서드는 다음과 같은 코드를 사용 하 여 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-232">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <span data-ttu-id="ad3d8-233"><xref:System.String.IsNullOrWhiteSpace%2A>문자열이 인지를 나타내는 `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, 또는 공백 문자로 구성 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-233"><xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, or consists exclusively of white-space characters.</span></span> <span data-ttu-id="ad3d8-234">이 메서드는 다음과 같은 코드를 사용 하 여 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-234">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 <span data-ttu-id="ad3d8-235">다음 예제에서는 <xref:System.String.IsNullOrEmpty%2A> 에서 메서드는 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 사용자 지정 구현의 `Temperature` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-235">The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation of a custom `Temperature` class.</span></span> <span data-ttu-id="ad3d8-236">메서드는 "G", "C", "F" 및 "K" 형식 문자열을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-236">The method supports the "G", "C", "F", and "K" format strings.</span></span> <span data-ttu-id="ad3d8-237">형식 문자열이 비어 나 형식 문자열 값인 경우 `null` 전달 메서드로 "G" 형식 문자열에 해당 값을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-237">If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.</span></span>  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a><span data-ttu-id="ad3d8-238">불변성이 및 StringBuilder 클래스</span><span class="sxs-lookup"><span data-stu-id="ad3d8-238">Immutability and the StringBuilder class</span></span>  
 <span data-ttu-id="ad3d8-239">A <xref:System.String> 개체를 변경할 수 없는 호출 (읽기 전용)를 만든 후 해당 값을 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-239">A <xref:System.String> object is called immutable (read-only), because its value cannot be modified after it has been created.</span></span> <span data-ttu-id="ad3d8-240">수정 하는 메서드는 <xref:System.String> 개체는 실제로 새 반환 <xref:System.String> 해당 수정 사항을 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-240">Methods that appear to modify a <xref:System.String> object actually return a new <xref:System.String> object that contains the modification.</span></span>  
  
 <span data-ttu-id="ad3d8-241">문자열은 변경 때문에 수행 하는 문자열 조작 루틴에 추가 또는 삭제 것 처럼 단일 문자열에는 성능이 크게 저하 정확한 수를 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-241">Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</span></span> <span data-ttu-id="ad3d8-242">예를 들어 다음 코드는 0x0001 ~ 0x052F 범위에서 1000 자 문자열을 만드는 난수 생성기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-242">For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</span></span> <span data-ttu-id="ad3d8-243">새 문자 이라는 기존 문자열에 추가할 문자열 연결을 사용 하는 코드 표시 되지만 `str`를 실제로 만드는 새 <xref:System.String> 각 연결 작업에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-243">Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new <xref:System.String> object for each concatenation operation.</span></span>  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 <span data-ttu-id="ad3d8-244">사용할 수는 <xref:System.Text.StringBuilder> 클래스 대신는 <xref:System.String> 문자열의 값에 대 한 여러 가지 변경 작업에 대 한 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-244">You can use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class for operations that make multiple changes to the value of a string.</span></span> <span data-ttu-id="ad3d8-245">인스턴스와 달리는 <xref:System.String> 클래스 <xref:System.Text.StringBuilder> 개체는 변경할 수, 연결, 추가 또는 문자열에서 하위 문자열을 삭제 작업이 단일 문자열에 대해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-245">Unlike instances of the <xref:System.String> class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</span></span> <span data-ttu-id="ad3d8-246">값을 수정 완료 했을 때는 <xref:System.Text.StringBuilder> 개체를 호출할 수 있습니다는 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 메서드를 문자열로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-246">When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert it to a string.</span></span> <span data-ttu-id="ad3d8-247">다음 예제에서는 대체는 <xref:System.String> 0x0001 0x052F ~ 범위에 1000 개의 임의 문자를 연결 하는 앞의 예에서 사용 되는 한 <xref:System.Text.StringBuilder> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-247">The following example replaces the <xref:System.String> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.</span></span>  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a><span data-ttu-id="ad3d8-248">문화권 구분 작업 및 서 수</span><span class="sxs-lookup"><span data-stu-id="ad3d8-248">Ordinal vs. culture-sensitive operations</span></span>  
 <span data-ttu-id="ad3d8-249">멤버는 <xref:System.String> 서 수 또는 문화권 구분 (언어) 작업을 수행 하는 클래스는 <xref:System.String> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-249">Members of the <xref:System.String> class perform either ordinal or culture-sensitive (linguistic) operations on a <xref:System.String> object.</span></span> <span data-ttu-id="ad3d8-250">각각의 숫자 값에서 서 수는 작업이 실행 <xref:System.Char> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-250">An ordinal operation acts on the numeric value of each <xref:System.Char> object.</span></span> <span data-ttu-id="ad3d8-251">값에는 문화권 구분 작업 수행은 <xref:System.String> 개체 및 하나 문화권별 대/소문자, 정렬, 서식 지정 및 구문 분석 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-251">A culture-sensitive operation acts on the value of the <xref:System.String> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</span></span> <span data-ttu-id="ad3d8-252">문화권 구분 작업은 명시적으로 선언 된 문화권 이나 현재 문화권 암시적의 컨텍스트에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-252">Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</span></span> <span data-ttu-id="ad3d8-253">두 종류의 작업이 동일한 문자열에 수행 될 때 아주 다른 결과 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-253">The two kinds of operations can produce very different results when they are performed on the same string.</span></span>  
  
 <span data-ttu-id="ad3d8-254">또한.NET Framework 고정 문화권을 사용 하 여 문화권을 구분 하지 않는 언어적 문자열 작업을 지원 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), 영어 영역의 독립적인의 culture 설정을 기준으로 하는 느슨하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-254">The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), which is loosely based on the culture settings of the English language independent of region.</span></span> <span data-ttu-id="ad3d8-255">다른 달리 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 설정, 고정 문화권의 설정 및.NET Framework의 버전에 시스템에 시스템에서 단일 컴퓨터에서 일관성을 유지 하려면 보장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-255">Unlike other <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</span></span> <span data-ttu-id="ad3d8-256">고정 문화권 대기 모든 문화권에서 문자열 비교의 안정성을 보장 하 블랙 박스에의 한 종류로 표시 및 주문 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-256">The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ad3d8-257">응용 프로그램 파일 이름과 같은 기호 식별자에 대 한 보안 결정을 내리는 또는 명명 된 파이프 하는 경우 또는 XML 파일에 텍스트 기반 데이터와 같은 지속형된 데이터에 대 한, 작업 대신 문화권 구분 비교는 서 수 비교를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-257">If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-258">비교 된 문자의 이진 값에 따라서만 서 수 비교 결과가 결정 하는 반면 문화권 구분 비교는 실제로 문화권에 따라 다른 결과 생성할 수 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-258">This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ad3d8-259">형식의 매개 변수를 포함 하는 오버 로드를 포함 하는 문자열 연산을 수행 하는 대부분의 메서드와 <xref:System.StringComparison>, 메서드는 서 수 또는 문화권 구분 작업 수행 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-259">Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</span></span> <span data-ttu-id="ad3d8-260">일반적으로 하 게 하려면 메서드 호출을 분명이 오버 로드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-260">In general, you should call this overload to make the intent of your method call clear.</span></span> <span data-ttu-id="ad3d8-261">모범 사례 및 서 수와 문화권 구분 문자열에 작업을 사용 하기 위한 지침에 대 한 참조 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-261">For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ad3d8-262">에 대 한 작업 [대/소문자](#casing), [구문 분석 및 서식을](#parsing), [비교 및 정렬](#comparison), 및 [같음 테스트](#equality) 서 수 또는 문화권 구분 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-262">Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive.</span></span> <span data-ttu-id="ad3d8-263">다음 섹션에서는 작업의 각 범주를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-263">The following sections discuss each category of operation.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="ad3d8-264">메서드 호출을 분명 의도 하는 메서드 오버 로드를 항상 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-264">You should always call a method overload that makes the intent of your method call clear.</span></span> <span data-ttu-id="ad3d8-265">예를 들어 호출 하는 대신는 <xref:System.String.Compare%28System.String%2CSystem.String%29> 현재 문화권의 규칙을 사용 하 여 두 문자열의 문화권 구분 비교를 수행 하는 메서드를 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드 값이 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 에 대 한는 `comparisonType` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-265">For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> for the `comparisonType` argument.</span></span> <span data-ttu-id="ad3d8-266">자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-266">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
<a name="casing"></a>   
### <a name="casing"></a><span data-ttu-id="ad3d8-267">대/소문자 구분</span><span class="sxs-lookup"><span data-stu-id="ad3d8-267">Casing</span></span>  
 <span data-ttu-id="ad3d8-268">대/소문자 규칙에는 유니코드 문자의 대/소문자를 변경 하는 방법 결정 예를 들어 대문자 소문자에서.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-268">Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</span></span> <span data-ttu-id="ad3d8-269">종종, 대/소문자 구분 작업 문자열 비교 하기 전에 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-269">Often, a casing operation is performed before a string comparison.</span></span> <span data-ttu-id="ad3d8-270">예를 들어 다른 대문자 문자열로 비교할 수 있도록 문자열을 대문자로 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-270">For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</span></span> <span data-ttu-id="ad3d8-271">호출 하 여 소문자로 문자열의에서 문자를 변환할 수는 <xref:System.String.ToLower%2A> 또는 <xref:System.String.ToLowerInvariant%2A> 메서드를 호출 하 여 대문자로 변환할 수는 <xref:System.String.ToUpper%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-271">You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ad3d8-272">또한 사용할 수 있습니다는 <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> 제목 대/소문자를 문자열로 변환 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-272">In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> method to convert a string to title case.</span></span>  
  
 <span data-ttu-id="ad3d8-273">대/소문자 구분 작업은 현재 문화권, 지정 된 문화권 이나 고정 문화권의 규칙 기반 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-273">Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</span></span> <span data-ttu-id="ad3d8-274">대/소문자 매핑 사용 되는 문화권에 따라 달라질 수 있으므로 대/소문자 구분 작업의 결과 문화권에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-274">Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</span></span> <span data-ttu-id="ad3d8-275">대/소문자의 실제 차이 다음 세 종류가:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-275">The actual differences in casing are of three kinds:</span></span>  
  
-   <span data-ttu-id="ad3d8-276">LATIN CAPITAL LETTER I 대/소문자 매핑의 차이점 (U + 0049), LATIN SMALL LETTER I (U + 0069), LATIN CAPITAL LETTER I (U + 0130), 위에 점 및 LATIN SMALL 문자 점이 없는 I (U + 0131).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-276">Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</span></span> <span data-ttu-id="ad3d8-277">TR-TR (터키어 (터키)) 및 az-Latn-AZ (아제르바이잔, 라틴 문자) 문화권 및 tr, az, 및 az Latn 중립 문화권의 라틴어 대문자 I 해당 하는 소문자 라틴어 작은 문자 점이 없는 I, 이며 해당 하는 대문자 라틴어 작은 문자 I 라틴어 대문자 I와 점 보다 높은 지.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-277">In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span> <span data-ttu-id="ad3d8-278">다른 모든 문화권에서 LATIN SMALL LETTER I 및 LATIN CAPITAL LETTER 소문자, 대문자 해당 항목을 고정 문화권을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-278">In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</span></span>  
  
     <span data-ttu-id="ad3d8-279">다음 예제에서는 방법을 보여 줍니다 설계 하는 문자열 비교 파일 시스템 액세스를 방지 하는 문화권별 대/소문자 구분 비교에 사용 하는 경우 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-279">The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</span></span> <span data-ttu-id="ad3d8-280">(고정 문화권의 대/소문자 규칙을 사용 합니다.)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-280">(The casing conventions of the invariant culture should have been used.)</span></span>  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   <span data-ttu-id="ad3d8-281">대/소문자 매핑 고정 문화권 및 다른 모든 문화권 간의 차이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-281">Differences in case mappings between the invariant culture and all other cultures.</span></span> <span data-ttu-id="ad3d8-282">이러한 경우 고정 문화권의 대/소문자 규칙을 사용 하 여 문자를 대문자 또는 소문자로 변경 하는 동일한 문자를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-282">In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</span></span> <span data-ttu-id="ad3d8-283">다른 모든 문화권에 대 한 다른 문자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-283">For all other cultures, it returns a different character.</span></span> <span data-ttu-id="ad3d8-284">일부 영향을 받는 문자는 다음 표에 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-284">Some of the affected characters are listed in the following table.</span></span>  
  
    |<span data-ttu-id="ad3d8-285">문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-285">Character</span></span>|<span data-ttu-id="ad3d8-286">로 변경 된 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-286">If changed to</span></span>|<span data-ttu-id="ad3d8-287">반환 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-287">Returns</span></span>|  
    |---------------|-------------------|-------------|  
    |<span data-ttu-id="ad3d8-288">미크론 SIGN (U + 00B5)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-288">MICRON SIGN (U+00B5)</span></span>|<span data-ttu-id="ad3d8-289">대문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-289">Uppercase</span></span>|<span data-ttu-id="ad3d8-290">그리스어 대문자 MU (U +-39 C)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-290">GREEK CAPITAL LETTER MU (U+-39C)</span></span>|  
    |<span data-ttu-id="ad3d8-291">라틴어 대문자 I 점으로 (U + 0130) 위에</span><span class="sxs-lookup"><span data-stu-id="ad3d8-291">LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</span></span>|<span data-ttu-id="ad3d8-292">소문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-292">Lowercase</span></span>|<span data-ttu-id="ad3d8-293">작은 라틴 문자 I (U + 0069)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-293">LATIN SMALL LETTER I (U+0069)</span></span>|  
    |<span data-ttu-id="ad3d8-294">라틴어 소문자 점이 없는 I (U + 0131)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-294">LATIN SMALL LETTER DOTLESS I (U+0131)</span></span>|<span data-ttu-id="ad3d8-295">대문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-295">Uppercase</span></span>|<span data-ttu-id="ad3d8-296">라틴어 대문자 I (U + 0049)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-296">LATIN CAPITAL LETTER I (U+0049)</span></span>|  
    |<span data-ttu-id="ad3d8-297">라틴어 소문자 긴 S (U + 017F)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-297">LATIN SMALL LETTER LONG S (U+017F)</span></span>|<span data-ttu-id="ad3d8-298">대문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-298">Uppercase</span></span>|<span data-ttu-id="ad3d8-299">LATIN CAPITAL LETTER S (U + 0053)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-299">LATIN CAPITAL LETTER S (U+0053)</span></span>|  
    |<span data-ttu-id="ad3d8-300">파이프 기호 있는 작은 문자 Z로 D 영문 대문자 (U + 01C 5)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-300">LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</span></span>|<span data-ttu-id="ad3d8-301">소문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-301">Lowercase</span></span>|<span data-ttu-id="ad3d8-302">파이프 기호 있는 DZ 영문 소문자 (U + 01C 6)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-302">LATIN SMALL LETTER DZ WITH CARON (U+01C6)</span></span>|  
    |<span data-ttu-id="ad3d8-303">결합 그리스어 YPOGEGRAMMENI (U + 0345)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-303">COMBINING GREEK YPOGEGRAMMENI (U+0345)</span></span>|<span data-ttu-id="ad3d8-304">대문자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-304">Uppercase</span></span>|<span data-ttu-id="ad3d8-305">그리스어 대문자 IOTA (U + 0399)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-305">GREEK CAPITAL LETTER IOTA (U+0399)</span></span>|  
  
-   <span data-ttu-id="ad3d8-306">ASCII 문자 범위에서 두 문자의 소문자가 혼합 된 쌍의 대/소문자 매핑의 차이 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-306">Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</span></span> <span data-ttu-id="ad3d8-307">대부분의 문화권에서 두 문자의 소문자가 혼합 된 쌍은 해당 하는 두 문자의 대문자 또는 소문자 쌍과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-307">In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</span></span> <span data-ttu-id="ad3d8-308">이 다음 문화권에서 다음 두 문자 쌍에 대 한 때문에 사실이 아닙니다에 digraph 비교는 각각의 경우:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-308">This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</span></span>  
  
    -   <span data-ttu-id="ad3d8-309">"lJ" 및 "nJ" HR-HR (크로아티아어 (크로아티아)) 문화권에서.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-309">"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</span></span>  
  
    -   <span data-ttu-id="ad3d8-310">"cH" CS-CZ (체코어 (체코 공화국)) 및 디스크-디스크 (슬로바키아어 (슬로바키아)) 문화권에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-310">"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</span></span>  
  
    -   <span data-ttu-id="ad3d8-311">"aA" DA-DK (덴마크어 (덴마크)) 문화권에서.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-311">"aA" in the da-DK (Danish (Denmark)) culture.</span></span>  
  
    -   <span data-ttu-id="ad3d8-312">"cS", "dZ", "dZS", "nY", "sZ", "tY" 및 "zS" HU-HU (헝가리어 (헝가리)) 문화권에서</span><span class="sxs-lookup"><span data-stu-id="ad3d8-312">"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</span></span>  
  
    -   <span data-ttu-id="ad3d8-313">"cH" 및 "lL" es-es_tradnl (스페인어 (스페인, 전통 정렬)) 문화권에서.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-313">"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</span></span>  
  
    -   <span data-ttu-id="ad3d8-314">"cH", "gI", "kH", "nG" "nH", "pH", "qU',"tH"및"tR"vi-VN (베트남어 (베트남)) 문화권에서.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-314">"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</span></span>  
  
     <span data-ttu-id="ad3d8-315">그러나 이러한 쌍의 고정된 문자열 또는 식별자에서 일반적이 지 않은 상황에서 이러한 쌍의 문화권 구분 비교 만들어 문제를 발생 하는 데 평소있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-315">However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</span></span>  
  
 <span data-ttu-id="ad3d8-316">다음 예제에서는 문화권 문자열을 대문자로 변환 하는 경우 대/소문자 규칙의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-316">The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</span></span>  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a><span data-ttu-id="ad3d8-317">구문 분석 및 서식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-317">Parsing and formatting</span></span>  
 <span data-ttu-id="ad3d8-318">서식 지정 및 구문 분석은 역 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-318">Formatting and parsing are inverse operations.</span></span> <span data-ttu-id="ad3d8-319">서식 지정 규칙 구문 분석 규칙 문자열 표현을 같은 날짜 및 시간 값으로 변환 하는 방법을 결정 하는 반면 숫자 및 날짜 또는 시간 등의 값을 문자열 표현으로 변환 하는 방법을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-319">Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</span></span> <span data-ttu-id="ad3d8-320">서식 지정 및 구문 분석 규칙 둘 다 문화권 규칙에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-320">Both formatting and parsing rules are dependent on cultural conventions.</span></span> <span data-ttu-id="ad3d8-321">다음 예에서는 culture 관련 날짜 문자열을 해석할 때 발생할 수 있는 모호성을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-321">The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</span></span> <span data-ttu-id="ad3d8-322">날짜 문자열을 생성 하는 데 사용 된 문화권의 규칙을 몰라도 2011-03-01, 2011 년 3 월 1 일 및 2011/01/03 2011 년 1 월 3 일 또는 2011 년 3 월 1 일 나타냅니다 있는지 여부를 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-322">Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</span></span>  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 <span data-ttu-id="ad3d8-323">마찬가지로, 다음 예제와 같이 단일 문자열 구문 분석 작업에서 해당 규칙 사용 되는 문화권에 따라 다른 날짜를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-323">Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</span></span>  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a><span data-ttu-id="ad3d8-324">문자열 비교 및 정렬</span><span class="sxs-lookup"><span data-stu-id="ad3d8-324">String comparison and sorting</span></span>  
 <span data-ttu-id="ad3d8-325">비교 및 정렬 문자열에 대 한 규칙에는 문화권 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-325">Conventions for comparing and sorting strings vary from culture to culture.</span></span> <span data-ttu-id="ad3d8-326">예를 들어 윗주 또는 문자의 시각적 표시 정렬 순서를 기반으로 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-326">For example, the sort order may be based on phonetics or on the visual representation of characters.</span></span> <span data-ttu-id="ad3d8-327">동아시아 언어에서는 표의 문자의 부수와 획에 따라 문자가 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-327">In East Asian languages, characters are sorted by the stroke and radical of ideographs.</span></span> <span data-ttu-id="ad3d8-328">언어와 문화권이 알파벳에 사용하는 순서에 따라 정렬 순서가 달라지기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-328">Sorting also depends on the order languages and cultures use for the alphabet.</span></span> <span data-ttu-id="ad3d8-329">예를 들어 덴마크어 알파벳의 "Æ" 문자는 "Z" 다음에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-329">For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</span></span> <span data-ttu-id="ad3d8-330">또한 비교는 대/소문자 구분 또는 대/소문자를 구분 될 수 있습니다 및 경우에 따라 대/소문자 규칙 또한 다 문화권에 의해 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-330">In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</span></span> <span data-ttu-id="ad3d8-331">반면에 서 수 비교를 비교 하 고 문자열을 정렬 하는 경우 문자열의 개별 문자의 유니코드 코드 포인트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-331">Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</span></span>  
  
 <span data-ttu-id="ad3d8-332">정렬 규칙을 서로 비교 하는 두 문자열 및 유니코드 문자의 알파벳 순서를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-332">Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</span></span> <span data-ttu-id="ad3d8-333">예를 들어는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 메서드를 기반으로 하는 두 개의 문자열 비교는 <xref:System.StringComparison> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-333">For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method compares two strings based on the <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ad3d8-334">매개 변수 값이 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, 매개 변수 값이 메서드가 현재 문화권의 규칙을 사용 하는 언어 비교를 수행할 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>,이 메서드는 서 수 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-334">If the parameter value is <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, the method performs an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-335">따라서 다음 예제에서는 현재 문화권이 미국 인 경우 영어, 첫 번째 호출에서 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (문화권 구분 비교를 사용 하 여) 메서드 "A", 보다 작음 "a" 되었지만 두 번째 호출 (서 수 비교를 사용 하 여)는 동일한 메서드로 간주 "a" "A" 보다 큼.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-335">Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</span></span>  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 <span data-ttu-id="ad3d8-336">.NET Framework에서는 단어, 문자열 및 정렬 서 수 규칙을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-336">The .NET Framework supports word, string, and ordinal sort rules:</span></span>  
  
-   <span data-ttu-id="ad3d8-337">특정 영숫자가 아닌 유니코드 문자에 특별 한 가중치 할당 있을 수 있는 문자열의 문화권 구분 비교를 수행 하는 단어 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-337">A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</span></span> <span data-ttu-id="ad3d8-338">예를 들어, 하이픈 (-)는 매우 작은 가중치가 할당 "coop" 및 "co-op" 정렬된 된 목록에서 서로 인접 표시 되도록 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-338">For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</span></span> <span data-ttu-id="ad3d8-339">목록은 <xref:System.String> 단어 정렬 규칙을 사용 하 여 두 문자열을 비교 하는 방법을 참조는 [문자열 작업을 범주별으로](#ByCategory) 섹션.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-339">For a list of the <xref:System.String> methods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
-   <span data-ttu-id="ad3d8-340">또한 문자열 정렬 문화권 구분 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-340">A string sort also performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-341">비슷합니다 단어 정렬 없는 특수 한 상황이 영숫자 모든 유니코드 문자 앞에 야 하는 모든 영숫자가 아닌 기호가 된다는 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-341">It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</span></span> <span data-ttu-id="ad3d8-342">호출 하 여 문자열 정렬 규칙을 사용 하 여 두 문자열을 비교할 수는 <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> 메서드 오버 로드는 `options` 의 값을 제공 하는 매개 변수를 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-342">Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-343">.NET Framework에서는 문자열 정렬 규칙을 사용 하 여 두 문자열을 비교 하는 유일한 방법은 인지 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-343">Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</span></span>  
  
-   <span data-ttu-id="ad3d8-344">각각의 숫자 값에 따라 문자열을 비교 하는 서 수 정렬 <xref:System.Char> 문자열에는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-344">An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string.</span></span> <span data-ttu-id="ad3d8-345">서 수 비교는 대 / 소문자 버전의 문자는 다른 코드 점이 하기 때문에 자동으로 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-345">An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</span></span> <span data-ttu-id="ad3d8-346">그러나 대/소문자는 중요 하지 않습니다, 대/소문자를 무시 하는 서 수 비교를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-346">However, if case is not important, you can specify an ordinal comparison that ignores case.</span></span> <span data-ttu-id="ad3d8-347">문자열을 고정 문화권을 사용 하 여 다음 결과에 서 수 비교를 수행 하 여 대문자로 변환 하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-347">This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</span></span> <span data-ttu-id="ad3d8-348">목록은 <xref:System.String> 정렬 서 수 규칙을 사용 하 여 두 문자열을 비교 하는 메서드를 참조는 [문자열 작업을 범주별으로](#ByCategory) 섹션.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-348">For a list of the <xref:System.String> methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
 <span data-ttu-id="ad3d8-349">문화권 구분 비교는 명시적 또는 암시적으로 사용 하는 모든 비교는 <xref:System.Globalization.CultureInfo> 를 변수로 지정 된 고정 문화권을 포함 한 개체는 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-349">A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ad3d8-350">암시적 문화권은 현재 문화권으로 지정 되는 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-350">The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="ad3d8-351">영문자의 정렬 순서에서 상당한 변형이 있습니다 (즉, 한 문자는 <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> 속성에서 반환 `true`) 문화권에 걸쳐 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-351">There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> property returns `true`) across cultures.</span></span> <span data-ttu-id="ad3d8-352">제공 하 여 특정 문화권의 규칙을 사용 하는 문화권 구분 비교를 지정할 수는 <xref:System.Globalization.CultureInfo> 와 같은 개체는 문자열 비교 메서드를 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-352">You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span></span> <span data-ttu-id="ad3d8-353">제공 하 여 현재 문화권의 규칙을 사용 하는 문화권 구분 비교를 지정할 수 있습니다 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, 또는의 모든 멤버는 <xref:System.Globalization.CompareOptions> 이외의 다른 열거형 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 또는 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 의 적절 한 오버 로드에는 <xref:System.String.Compare%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-353">You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> or <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> to an appropriate overload of the <xref:System.String.Compare%2A> method.</span></span> <span data-ttu-id="ad3d8-354">문화권 구분 비교는 서 수 비교 하는 반면 정렬에 대 한 일반적으로 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-354">A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</span></span> <span data-ttu-id="ad3d8-355">서 수 비교는 일반적으로 두 문자열이 같은지 여부를 결정 하기 위한 적절 한 (즉, id 확인에 대 한) 문화권 구분 비교는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-355">An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</span></span>  
  
 <span data-ttu-id="ad3d8-356">다음 예제에서는 문화권 구분 및 서 수 비교 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-356">The following example illustrates the difference between culture-sensitive and ordinal comparison.</span></span> <span data-ttu-id="ad3d8-357">이 예제에서는 세 개의 문자열, "Apple", "æ b l e" 및 "AEble"를 서 수 비교와 DA-DK 및 EN-US 문화권의 규칙을 사용 하 여 계산 (때 기본 문화권은 각각는 <xref:System.String.Compare%2A> 메서드는).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-357">The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called).</span></span> <span data-ttu-id="ad3d8-358">덴마크어 "Æ" 문자는 개별 문자로 처리는 알파벳의 "z" 정렬 하기 때문에 문자열 "æ b l e는" "Apple" 보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-358">Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</span></span> <span data-ttu-id="ad3d8-359">그러나 "æ b l e" 간주 되지 않습니다 "AEble" 같음 "æ b l e" "AEble" 보다 큰 이기도 하므로.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-359">However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</span></span> <span data-ttu-id="ad3d8-360">EN-US 문화권 "Æ" 문자를 포함 하지 않는 하지만 "ae" 이유 "æ b l e는" "Apple" 보다 작지만 "AEble" 같은 설명으로 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-360">The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</span></span> <span data-ttu-id="ad3d8-361">서 수 비교는 반면에 "Apple" "æ b l e" 및 "æ b l e" "AEble" 보다 클 수 보다 작을 것으로 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-361">Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</span></span>  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 <span data-ttu-id="ad3d8-362">다음 일반 지침을 사용 하 여 적절 한 정렬 또는 문자열 비교 방법을 선택 하려면:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-362">Use the following general guidelines to choose an appropriate sorting or string comparison method:</span></span>  
  
-   <span data-ttu-id="ad3d8-363">순서를 지정할 수 있는 문자열을 사용자의 culture에 따라 하려는 경우 현재 문화권의 규칙에 따라를 주문 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-363">If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</span></span> <span data-ttu-id="ad3d8-364">사용자의 문화권 변경 되는 경우 정렬 된 문자열의 순서도 그에 따라 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-364">If the user's culture changes, the order of sorted strings will also change accordingly.</span></span> <span data-ttu-id="ad3d8-365">예를 들어 동의어 사전 응용 프로그램 사용자의 culture에 따라 단어를 항상 정렬 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-365">For example, a thesaurus application should always sort words based on the user's culture.</span></span>  
  
-   <span data-ttu-id="ad3d8-366">순서를 지정할 수 있는 문자열을 특정 문화권의 규칙에 따라 하려는 경우를 제공 하 여 정렬 해야 하는 <xref:System.Globalization.CultureInfo> 비교 메서드를 해당 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-366">If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method.</span></span> <span data-ttu-id="ad3d8-367">예를 들어 특정 언어 학생 방법을 응용 프로그램에서 원하는 문자열을 정렬할 익히면 해당 하는 문화권 중 하나의 규칙에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-367">For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</span></span>  
  
-   <span data-ttu-id="ad3d8-368">문화권에 걸쳐 변경 되지 않을 문자열의 순서를 사용 하도록 하려는 경우에 고정 문화권의 규칙에 따라 정렬 하거나 서 수 비교를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-368">If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-369">예를 들어 파일, 프로세스, 뮤텍스의 이름을 구성 하는 서 수 정렬 사용 또는 명명 된 파이프 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-369">For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</span></span>  
  
-   <span data-ttu-id="ad3d8-370">보안 결정 (예: 사용자가 유효한 지 여부)를 포함 하는 비교를 위해 항상 수행 해야 같음에 대 한 서 수는 테스트의 오버 로드를 호출 하 여는 <xref:System.String.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-370">For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-371">문화권 구분 정렬 및 문자열 비교에 사용 되는 규칙을 대/소문자는.NET Framework의 버전에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-371">The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</span></span> <span data-ttu-id="ad3d8-372">.NET Framework에서 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 에서 실행 되는 [!INCLUDE[win8](~/includes/win8-md.md)] 유니코드 6.0 표준을 따르는 운영 체제, 정렬, 대/소문자 구분, 정규화 및 유니코드 문자 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-372">In the .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on the [!INCLUDE[win8](~/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</span></span> <span data-ttu-id="ad3d8-373">다른 운영 체제에서 유니코드 5.0 표준을 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-373">On other operating systems, it conforms to the Unicode 5.0 standard.</span></span>  
  
 <span data-ttu-id="ad3d8-374">Word, 문자열 및 정렬 서 수 규칙에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-374">For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> topic.</span></span> <span data-ttu-id="ad3d8-375">각 규칙을 사용 하는 경우에 추가 권장 사항 참조 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-375">For additional recommendations on when to use each rule, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ad3d8-376">일반적으로 호출 하지 않으면 문자열 비교 방법와 같은 <xref:System.String.Compare%2A> 문자열의 정렬 순서를 결정 하는 직접 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-376">Ordinarily, you don't call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings.</span></span> <span data-ttu-id="ad3d8-377">와 같은 메서드를 정렬 하 여 비교 메서드는 호출 하는 대신 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 또는 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-377">Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-378">다음 예에서는 사용할 비교 유형을 지정 수행 되지만 명시적으로 문자열 비교 메서드를 호출 하지 않고 네 가지 정렬 작업 (현재 문화권, 고정 문화권을 사용 하 여 단어 정렬, 서 수 정렬 및 고정 문화권을 사용 하 여 문자열 정렬을 사용 하 여 word 정렬)을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-378">The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</span></span> <span data-ttu-id="ad3d8-379">참고 각 유형의 정렬 배열에서 문자열의 고유한 순서를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-379">Note that each type of sort produces a unique ordering of strings in its array.</span></span>  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  <span data-ttu-id="ad3d8-380">내부적으로.net Framework culturallysensitive 문자열 비교를 지원 하기 위해 정렬 키를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-380">Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</span></span> <span data-ttu-id="ad3d8-381">문자열의 각 문자에는 사전순, 대/소문자 및 분음 부호를 포함하여 여러 범주의 정렬 가중치가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-381">Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</span></span> <span data-ttu-id="ad3d8-382">정렬 키가 나타내는 <xref:System.Globalization.SortKey> 클래스, 특정 문자열에 대 한 이러한 가중치의 저장소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-382">A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string.</span></span> <span data-ttu-id="ad3d8-383">응용 프로그램의 많은 수의 검색 또는 정렬 동일한 문자열 집합에 대 한 작업을 실행 하는 경우 생성 하 고 사용 하 여 모든 문자열에 대 한 정렬 키를 저장 하 여 성능을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-383">If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</span></span> <span data-ttu-id="ad3d8-384">정렬 또는 비교 작업이 필요한 경우에 문자열 대신 정렬 키를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-384">When a sort or comparison operation is required, you use the sort keys instead of the strings.</span></span> <span data-ttu-id="ad3d8-385">자세한 내용은 <xref:System.Globalization.SortKey> 클래스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-385">For more information, see the <xref:System.Globalization.SortKey> class.</span></span>  
  
 <span data-ttu-id="ad3d8-386">문자열 비교 규칙을 지정 하지 않으면, 같은 정렬 메서드 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 문자열에서 문화권을 구분, 대/소문자 구분 정렬을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-386">If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> perform a culture-sensitive, case-sensitive sort on strings.</span></span> <span data-ttu-id="ad3d8-387">다음 예에서는 현재 문화권을 변경 하 배열에 정렬 된 문자열의 순서를 적용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-387">The following example illustrates how changing the current culture affects the order of sorted strings in an array.</span></span> <span data-ttu-id="ad3d8-388">세 문자열의 배열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-388">It creates an array of three strings.</span></span> <span data-ttu-id="ad3d8-389">우선 `System.Threading.Thread.CurrentThread.CurrentCulture` 속성을 "en-US"로 설정하고 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-389">First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ad3d8-390">결과 정렬 순서가 정렬 영어 (미국) 문화권에 대 한 규칙은 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-390">The resulting sort order is based on sorting conventions for the English (United States) culture.</span></span> <span data-ttu-id="ad3d8-391">다음으로 예제에서는 `System.Threading.Thread.CurrentThread.CurrentCulture` 속성을 da-DK로 설정하고 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 메서드를 다시 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-391">Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method again.</span></span> <span data-ttu-id="ad3d8-392">덴마크어(덴마크)의 정렬 규칙을 사용하는 경우 결과 정렬 순서가 en-US 결과와 어떻게 다른지 확인해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-392">Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</span></span>  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-393">문자열 비교의 기본 용도 호출 해야 이러한 값이 같은지 여부를 결정 하는 경우는 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-393">If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ad3d8-394">일반적으로 사용 해야 <xref:System.String.Equals%2A> 서 수 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-394">Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-395"><xref:System.String.Compare%2A?displayProperty=nameWithType> 방법은 문자열 정렬 하는 데 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-395">The <xref:System.String.Compare%2A?displayProperty=nameWithType> method is intended primarily to sort strings.</span></span>  
  
 <span data-ttu-id="ad3d8-396">와 같은 문자열 검색 메서드를 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 및 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 또한 문화권 구분 또는 서 수 문자열 비교를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-396">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons.</span></span> <span data-ttu-id="ad3d8-397">다음 예제에서는 서 수와 문화권 구분 비교를 사용 하 여 차이 보여 줍니다.는 <xref:System.String.IndexOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-397">The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ad3d8-398">현재 문화권의 영어 (미국) 문화권 구분 검색에서는 합자 "œ"와 일치 하도록 "oe" 하위 문자열을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-398">A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</span></span> <span data-ttu-id="ad3d8-399">하이픈이 (U + 00AD)는 너비가 0 인 문자 이기 때문에 검색 취급 동등 하 게 <xref:System.String.Empty> 문자열의 시작 부분에서 일치 하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-399">Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty> and finds a match at the beginning of the string.</span></span> <span data-ttu-id="ad3d8-400">서 수 검색을 사용 하는 반면에 찾을 수 없습니다 일치 하는 두 경우 모두.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-400">An ordinal search, on the other hand, does not find a match in either case.</span></span>  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a><span data-ttu-id="ad3d8-401">문자열 검색</span><span class="sxs-lookup"><span data-stu-id="ad3d8-401">Searching Strings</span></span>  
 <span data-ttu-id="ad3d8-402">와 같은 문자열 검색 메서드를 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 및 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 또한 문화권 구분을 수행할 수 있습니다 또는 지정된 된 문자열에 문자 또는 하위 문자열이 있는지 여부를 결정 하는 서 수 문자열 비교를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-402">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</span></span>  
  
 <span data-ttu-id="ad3d8-403">검색 메서드는 <xref:System.String> 와 같은 개별 문자를 검색 하는 클래스는 <xref:System.String.IndexOf%2A> 메서드 또는의 문자 집합 중 하나와 같은 <xref:System.String.IndexOfAny%2A> 메서드를 모든 서 수 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-403">The search methods in the <xref:System.String> class that search for an individual character, such as the <xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search.</span></span> <span data-ttu-id="ad3d8-404">문자에 대 한 문화권 구분 검색을 수행 하려면 호출 해야 합니다는 <xref:System.Globalization.CompareInfo> 메서드와 같은 <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 또는 <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-404">To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-405">참고 서 수와 문화권 구분 비교를 사용 하 여 문자에 대 한 검색 결과를 매우 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-405">Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</span></span> <span data-ttu-id="ad3d8-406">합자 "Æ"와 같은 미리 구성 된 유니코드 문자에 대 한 검색 (U + 00 C 6) 해당 구성 요소가 올바른 순서로 "AE" 등의 모든 항목 수 일치 하는 예를 들어 (U + 041U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-406">For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</span></span> <span data-ttu-id="ad3d8-407">다음 예제에서는 차이점을 보여 줍니다.는 <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 개별 문자를 검색할 때 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-407">The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> methods when searching for an individual character.</span></span> <span data-ttu-id="ad3d8-408">합자 "æ" (U + 00E6)를 찾을 수는 문자열에 "항공" EN-US 문화권의 규칙을 사용 하는 경우 하지만 DA-DK 문화권의 규칙을 사용 하 여 때가 아니라 또는 서 수 비교를 수행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-408">The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 <span data-ttu-id="ad3d8-409">반면에 <xref:System.String> 검색할 문자가 아니라 문자열 검색 옵션 형식의 매개 변수를 통해 명시적으로 지정 하지 않은 경우 문화권 구분 검색을 수행 하는 메서드를 클래스 <xref:System.StringComparison>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-409">On the other hand, <xref:System.String> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>.</span></span> <span data-ttu-id="ad3d8-410">유일한 예외는 <xref:System.String.Contains%2A>를 서 수 검색을 수행 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-410">The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.</span></span>  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a><span data-ttu-id="ad3d8-411">같음에 대 한 테스트</span><span class="sxs-lookup"><span data-stu-id="ad3d8-411">Testing for equality</span></span>  
 <span data-ttu-id="ad3d8-412">사용 하 여는 <xref:System.String.Compare%2A?displayProperty=nameWithType> 정렬 순서에서 두 문자열의 관계를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-412">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to determine the relationship of two strings in the sort order.</span></span> <span data-ttu-id="ad3d8-413">일반적으로 문화권 구분 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-413">Typically, this is a culture-sensitive operation.</span></span> <span data-ttu-id="ad3d8-414">반면, 호출 된 <xref:System.String.Equals%2A?displayProperty=nameWithType> 같은지 테스트 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-414">In contrast, call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test for equality.</span></span> <span data-ttu-id="ad3d8-415">같음에 대 한 테스트는 일반적으로 유효한 사용자 이름, 암호 또는 파일 시스템 경로 같은 몇 가지 알려진된 문자열을 사용 하 여 사용자 입력을 비교 되므로 일반적으로 서 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-415">Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-416">호출 하 여 같음 여부를 테스트할 수는 <xref:System.String.Compare%2A?displayProperty=nameWithType> 메서드와 반환 값은 0이 있는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-416">It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=nameWithType> method and determining whether the return value is zero.</span></span> <span data-ttu-id="ad3d8-417">그러나이 방법은 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-417">However, this practice is not recommended.</span></span> <span data-ttu-id="ad3d8-418">두 문자열이 같은지 여부를 확인 하려면 호출 해야 오버 로드 중 하나는 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-418">To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ad3d8-419">호출할 기본 오버 로드 되는 인스턴스 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 메서드 또는 정적 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드를 두 방법 모두 포함 되어 있으므로 <xref:System.StringComparison?displayProperty=nameWithType> 명시적으로 비교 유형을 지정 하는 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-419">The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=nameWithType> parameter that explicitly specifies the type of comparison.</span></span>  
  
 <span data-ttu-id="ad3d8-420">다음 예제에서는 같음 경우 하나를 대신 사용 해야 하는 서 수에 대 한 문화권 구분 비교를 수행 하는 위험을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-420">The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</span></span> <span data-ttu-id="ad3d8-421">이 경우 코드의 의도가 "FILE://" 문자열을 사용 하 여 URL 시작 하는 대/소문자 구분 비교를 수행 하 여 "FILE://" 또는 "file://"로 시작 하는 Url에서 파일 시스템 액세스를 금지 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-421">In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</span></span> <span data-ttu-id="ad3d8-422">그러나 터키어 (터키) 문화권 "file://"로 시작 하는 URL에서 사용 하 여 문화권 구분 비교 수행 되 같은지 비교 실패, 터키어 대문자 소문자 "i"는 "I" 대신 "İ" 이므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-422">However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</span></span> <span data-ttu-id="ad3d8-423">결과적으로, 파일 시스템 액세스 실수로 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-423">As a result, file system access is inadvertently permitted.</span></span> <span data-ttu-id="ad3d8-424">반면에 서 수 비교에 같음 비교 성공 하 고 파일 시스템 액세스가 거부 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-424">On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</span></span>  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a><span data-ttu-id="ad3d8-425">표준화</span><span class="sxs-lookup"><span data-stu-id="ad3d8-425">Normalization</span></span>  
 <span data-ttu-id="ad3d8-426">일부 유니코드 문자에 여러 표현이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-426">Some Unicode characters have multiple representations.</span></span> <span data-ttu-id="ad3d8-427">예를 들어 다음 코드 포인트의 문자 "ắ"을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-427">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="ad3d8-428">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="ad3d8-428">U+1EAF</span></span>  
  
-   <span data-ttu-id="ad3d8-429">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="ad3d8-429">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="ad3d8-430">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="ad3d8-430">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="ad3d8-431">단일 문자에 대 한 여러 표현을 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-431">Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</span></span>  
  
 <span data-ttu-id="ad3d8-432">유니코드 표준 이진 표현을 해당 하는 이진 표현에 대 한 유니코드 문자를 반환 하는 정규화 라는 프로세스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-432">The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</span></span> <span data-ttu-id="ad3d8-433">정규화에는 다양 한 규칙에 따라 정규화 형식 이라는 하는 여러 가지 알고리즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-433">Normalization can use several algorithms, called normalization forms, that follow different rules.</span></span> <span data-ttu-id="ad3d8-434">.NET Framework는 유니코드 정규화 형식 C, D, KC 및 KD를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-434">The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</span></span> <span data-ttu-id="ad3d8-435">문자열 정규화 동일한 형식으로 표준화 되었으므로 때 서 수 비교를 사용 하 여 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-435">When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ad3d8-436">서 수 비교는 해당 하는 유니코드 스칼라 값의 이진 비교 <xref:System.Char> 각 문자열에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-436">An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string.</span></span> <span data-ttu-id="ad3d8-437"><xref:System.String> 클래스는 다양 한 다음을 포함 한 서 수 비교를 수행할 수 있는 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-437">The <xref:System.String> class includes a number of methods that can perform an ordinal comparison, including the following:</span></span>  
  
-   <span data-ttu-id="ad3d8-438">오버 로드는 <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, 및 <xref:System.String.LastIndexOf%2A> 메서드를 포함 하는 <xref:System.StringComparison> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-438">Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ad3d8-439">값을 제공 하는 경우이 메서드는 서 수 비교를 수행 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase> 이 매개 변수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-439">The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase> for this parameter.</span></span>  
  
-   <span data-ttu-id="ad3d8-440">오버 로드는 <xref:System.String.CompareOrdinal%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-440">The overloads of the <xref:System.String.CompareOrdinal%2A> method.</span></span>  
  
-   <span data-ttu-id="ad3d8-441">기본적으로 같은 서 수 비교를 사용 하는 메서드 <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, 및 <xref:System.String.Split%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-441">Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.</span></span>  
  
-   <span data-ttu-id="ad3d8-442">검색 하는 메서드는 <xref:System.Char> 값 또는 요소에 대 한는 <xref:System.Char> 문자열 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-442">Methods that search for a <xref:System.Char> value or for the elements in a <xref:System.Char> array in a string instance.</span></span> <span data-ttu-id="ad3d8-443">이러한 메서드에 <xref:System.String.IndexOf%28System.Char%29> 및 <xref:System.String.Split%28System.Char%5B%5D%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-443">Such methods include <xref:System.String.IndexOf%28System.Char%29> and <xref:System.String.Split%28System.Char%5B%5D%29>.</span></span>  
  
 <span data-ttu-id="ad3d8-444">호출 하 여 문자열을 정규화 형식 C 정규화 되는지 여부를 확인할 수 있습니다는 <xref:System.String.IsNormalized?displayProperty=nameWithType> 하거나 메서드를 호출할 수는 <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 문자열에 지정 된 정규화 형식인 정규화 되는지 여부를 결정 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-444">You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=nameWithType> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to determine whether a string is normalized to a specified normalization form.</span></span> <span data-ttu-id="ad3d8-445">호출할 수도 있습니다는 <xref:System.String.Normalize?displayProperty=nameWithType> 정규화 형식 C에 문자열을 변환 하는 메서드를 호출할 수는 <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 지정한 정규화 형식 문자열로 변환 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-445">You can also call the <xref:System.String.Normalize?displayProperty=nameWithType> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to convert a string to a specified normalization form.</span></span> <span data-ttu-id="ad3d8-446">정규화 및 문자열 비교 하는 방법에 대 한 단계별 정보를 참조 하십시오.는 <xref:System.String.Normalize> 및 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-446">For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.</span></span>  
  
 <span data-ttu-id="ad3d8-447">다음의 간단한 예제에서는 문자열 정규화를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-447">The following simple example illustrates string normalization.</span></span> <span data-ttu-id="ad3d8-448">세 개의 서로 다른 문자열에 세 가지 방법으로 "ố" 문자를 정의 하 고 같음에 대 한 서 수 비교를 사용 하 여 각 문자열이 다른 두 개의 문자열에서 다른 것을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-448">It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</span></span> <span data-ttu-id="ad3d8-449">그런 다음 지원 되는 정규화 형식으로 각 문자열을 변환 하 고 다시 지정 된 정규화 형식인 각 문자열의 서 수 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-449">It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</span></span> <span data-ttu-id="ad3d8-450">같음에 대 한 두 번째 테스트 각각의 경우에는 문자열이 동일 하다 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-450">In each case, the second test for equality shows that the strings are equal.</span></span>  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 <span data-ttu-id="ad3d8-451">정규화 및 정규화 형식에 대 한 자세한 내용은 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>,으로 [Unicode Standard Annex #15: 유니코드 정규화 형식](http://unicode.org/reports/tr15/) 및 [정규화 FAQ](http://www.unicode.org/faq/normalization.html) 에 unicode.org 웹 사이트입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-451">For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](http://unicode.org/reports/tr15/) and the [Normalization FAQ](http://www.unicode.org/faq/normalization.html) on the unicode.org website.</span></span>  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a><span data-ttu-id="ad3d8-452">범주별으로 문자열 작업</span><span class="sxs-lookup"><span data-stu-id="ad3d8-452">String operations by category</span></span>  
 <span data-ttu-id="ad3d8-453"><xref:System.String> 클래스 문자열 비교, 문자열이 같은지를 테스트 하 고, 문자 찾기에 대 한 멤버를 제공 하거나 문자열 결합, 값의 서식 지정, 문자열, 복사 및 문자열 정규화 문자열의 부분 문자열을 추출 하는 문자열을 수정 하는 문자열에 부분 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-453">The <xref:System.String> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</span></span>  
  
### <a name="comparing-strings"></a><span data-ttu-id="ad3d8-454">문자열 비교</span><span class="sxs-lookup"><span data-stu-id="ad3d8-454">Comparing strings</span></span>  
 <span data-ttu-id="ad3d8-455">다음을 사용 하 여 정렬 순서에서의 상대 위치를 결정 하는 문자열을 비교할 수 <xref:System.String> 메서드:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-455">You can compare strings to determine their relative position in the sort order by using the following <xref:System.String> methods:</span></span>  
  
-   <span data-ttu-id="ad3d8-456"><xref:System.String.Compare%2A> 정렬 순서에서 두 번째 문자열을 하나의 문자열로의 관계를 나타내는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-456"><xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.</span></span>  
  
-   <span data-ttu-id="ad3d8-457"><xref:System.String.CompareOrdinal%2A> 코드 포인트 비교를 기반으로 하는 두 번째 문자열을 하나의 문자열로의 관계를 나타내는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-457"><xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</span></span>  
  
-   <span data-ttu-id="ad3d8-458"><xref:System.String.CompareTo%2A> 정렬 순서에서 두 번째 문자열을 현재 문자열 인스턴스 관계를 나타내는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-458"><xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</span></span> <span data-ttu-id="ad3d8-459"><xref:System.String.CompareTo%28System.String%29> 메서드는 제공 된 <xref:System.IComparable> 및 <xref:System.IComparable%601> 에 대 한 구현을 <xref:System.String> 클래스.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-459">The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the <xref:System.String> class.</span></span>  
  
### <a name="testing-strings-for-equality"></a><span data-ttu-id="ad3d8-460">문자열이 같은지를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-460">Testing strings for equality</span></span>  
 <span data-ttu-id="ad3d8-461">호출 하는 <xref:System.String.Equals%2A> 메서드를 두 문자열이 같은지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-461">You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal.</span></span> <span data-ttu-id="ad3d8-462">인스턴스 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 및 정적 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 오버 로드를 통해 문화권을 구분 또는 서 수 비교 인지 및 대/소문자 고려 또는 무시 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-462">The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</span></span> <span data-ttu-id="ad3d8-463">같음에 대 한 대부분의 테스트는 서 수 이며 및 시스템 리소스 (예: 파일 시스템 개체)에 대 한 액세스를 결정 하는 같음 비교 항상 서 수 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-463">Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</span></span>  
  
### <a name="finding-characters-in-a-string"></a><span data-ttu-id="ad3d8-464">문자열에서 문자를 찾는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-464">Finding characters in a string</span></span>  
 <span data-ttu-id="ad3d8-465"><xref:System.String> 클래스는 두 종류의 검색 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-465">The <xref:System.String> class includes two kinds of search methods:</span></span>  
  
-   <span data-ttu-id="ad3d8-466">반환 하는 메서드는 <xref:System.Boolean> 를 특정 하위 문자열이 문자열 인스턴스에서 있는지 여부를 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-466">Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance.</span></span> <span data-ttu-id="ad3d8-467">여기에 <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, 및 <xref:System.String.StartsWith%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-467">These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.</span></span>  
  
-   <span data-ttu-id="ad3d8-468">문자열 인스턴스에서 부분 문자열의 시작 위치를 나타내는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-468">Methods that indicate the starting position of a substring in a string instance.</span></span> <span data-ttu-id="ad3d8-469">여기에 <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, 및 <xref:System.String.LastIndexOfAny%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-469">These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-470">특정 부분 문자열 보다는 특정 패턴에 대 한 문자열을 검색 하려는 경우 정규식을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-470">If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</span></span> <span data-ttu-id="ad3d8-471">자세한 내용은 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-471">For more information, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
### <a name="modifying-a-string"></a><span data-ttu-id="ad3d8-472">문자열을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-472">Modifying a string</span></span>  
 <span data-ttu-id="ad3d8-473"><xref:System.String> 클래스는 문자열 값을 수정 하는 다음 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-473">The <xref:System.String> class includes the following methods that appear to modify the value of a string:</span></span>  
  
-   <span data-ttu-id="ad3d8-474"><xref:System.String.Insert%2A> 현재 문자열 삽입 <xref:System.String> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-474"><xref:System.String.Insert%2A> inserts a string into the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-475"><xref:System.String.PadLeft%2A> 문자열의 시작 부분에 하나 이상의 지정 된 문자를 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-475"><xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-476"><xref:System.String.PadRight%2A> 문자열의 끝에 하나 이상의 지정 된 문자를 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-476"><xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the end of a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-477"><xref:System.String.Remove%2A> 현재에서 부분 문자열을 삭제 <xref:System.String> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-477"><xref:System.String.Remove%2A> deletes a substring from the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-478"><xref:System.String.Replace%2A> 현재에서 다른 하위 문자열로 하위 문자열 대체 <xref:System.String> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-478"><xref:System.String.Replace%2A> replaces a substring with another substring in the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-479"><xref:System.String.ToLower%2A> 및 <xref:System.String.ToLowerInvariant%2A> 문자열의 모든 문자를 소문자로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-479"><xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.</span></span>  
  
-   <span data-ttu-id="ad3d8-480"><xref:System.String.ToUpper%2A> 및 <xref:System.String.ToUpperInvariant%2A> 문자열에 있는 모든 문자를 대문자로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-480"><xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.</span></span>  
  
-   <span data-ttu-id="ad3d8-481"><xref:System.String.Trim%2A> 모든 문자를 문자열의 시작과 끝에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-481"><xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-482"><xref:System.String.TrimEnd%2A> 모든 문자를 문자열의 끝에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-482"><xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-483"><xref:System.String.TrimStart%2A> 모든 문자를 문자열의 시작 부분에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-483"><xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ad3d8-484">모든 문자열 수정 메서드가 반환 새 <xref:System.String> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-484">All string modification methods return a new <xref:System.String> object.</span></span> <span data-ttu-id="ad3d8-485">현재 인스턴스의 값을 수정 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-485">They don't modify the value of the current instance.</span></span>  
  
### <a name="extracting-substrings-from-a-string"></a><span data-ttu-id="ad3d8-486">문자열에서 부분 문자열을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-486">Extracting substrings from a string</span></span>  
 <span data-ttu-id="ad3d8-487"><xref:System.String.Split%2A?displayProperty=nameWithType> 메서드는 여러 문자열으로 단일 문자열을 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-487">The <xref:System.String.Split%2A?displayProperty=nameWithType> method separates a single string into multiple strings.</span></span> <span data-ttu-id="ad3d8-488">메서드의 오버 로드를 사용 하면 메서드를 추출 하는 부분 문자열의 최대 수를 확인 하 고 빈 문자열 (구분 기호는 인접 한 경우)는 반환 된 문자열 중에서 포함 되는지 여부를 결정 하 여러 개의 구분 기호를 지정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-488">Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</span></span>  
  
### <a name="combining-strings"></a><span data-ttu-id="ad3d8-489">문자열 결합</span><span class="sxs-lookup"><span data-stu-id="ad3d8-489">Combining strings</span></span>  
 <span data-ttu-id="ad3d8-490">다음 <xref:System.String> 메서드 문자열 연결에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-490">The following <xref:System.String> methods can be used for string concatenation:</span></span>  
  
-   <span data-ttu-id="ad3d8-491"><xref:System.String.Concat%2A> 하나 이상의 부분 문자열을 단일 문자열로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-491"><xref:System.String.Concat%2A> combines one or more substrings into a single string.</span></span>  
  
-   <span data-ttu-id="ad3d8-492"><xref:System.String.Join%2A> 단일 요소에 하나 이상의 부분 문자열을 연결 하 고 각 부분 문자열 사이 구분 기호를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-492"><xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.</span></span>  
  
### <a name="formatting-values"></a><span data-ttu-id="ad3d8-493">값의 서식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-493">Formatting values</span></span>  
 <span data-ttu-id="ad3d8-494"><xref:System.String.Format%2A?displayProperty=nameWithType> 메서드는 일부 개체 또는 값의 문자열 표현으로 문자열에서 하나 이상의 자리 표시자를 바꾸려면 합성 서식 지정 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-494">The <xref:System.String.Format%2A?displayProperty=nameWithType> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</span></span> <span data-ttu-id="ad3d8-495"><xref:System.String.Format%2A> 메서드는 다음을 수행 하는 데 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-495">The <xref:System.String.Format%2A> method is often used to do the following:</span></span>  
  
-   <span data-ttu-id="ad3d8-496">문자열에 숫자 값의 문자열 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-496">To embed the string representation of a numeric value in a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-497">문자열의 날짜 및 시간 값의 문자열 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-497">To embed the string representation of a date and time value in a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-498">문자열에서 열거형 값의 문자열 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-498">To embed the string representation of an enumeration value in a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-499">지 원하는 일부 개체의 문자열 표현을 포함 하는 <xref:System.IFormattable> 문자열에 대 한 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-499">To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.</span></span>  
  
-   <span data-ttu-id="ad3d8-500">오른쪽 맞춤 또는 더 큰 문자열 내에서 필드의 하위 문자열을 왼쪽으로 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-500">To right-justify or left-justify a substring in a field within a larger string.</span></span>  
  
 <span data-ttu-id="ad3d8-501">작업 및 예제 서식 지정 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.String.Format%2A> 요약 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-501">For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.</span></span>  
  
### <a name="copying-a-string"></a><span data-ttu-id="ad3d8-502">문자열 복사</span><span class="sxs-lookup"><span data-stu-id="ad3d8-502">Copying a string</span></span>  
 <span data-ttu-id="ad3d8-503">다음을 호출할 수 있습니다 <xref:System.String> 문자열의 복사본을 만드는 방법:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-503">You can call the following <xref:System.String> methods to make a copy of a string:</span></span>  
  
-   <span data-ttu-id="ad3d8-504"><xref:System.String.Clone%2A> 기존에 대 한 참조를 반환 <xref:System.String> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-504"><xref:System.String.Clone%2A> returns a reference to an existing <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="ad3d8-505"><xref:System.String.Copy%2A> 기존 문자열의 복사본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-505"><xref:System.String.Copy%2A> creates a copy of an existing string.</span></span>  
  
-   <span data-ttu-id="ad3d8-506"><xref:System.String.CopyTo%2A> 문자열의 일부가 문자 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-506"><xref:System.String.CopyTo%2A> copies a portion of a string to a character array.</span></span>  
  
### <a name="normalizing-a-string"></a><span data-ttu-id="ad3d8-507">문자열 정규화</span><span class="sxs-lookup"><span data-stu-id="ad3d8-507">Normalizing a string</span></span>  
 <span data-ttu-id="ad3d8-508">유니코드, 단일 문자 코드 포인트를 여러 개 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-508">In Unicode, a single character can have multiple code points.</span></span> <span data-ttu-id="ad3d8-509">정규화 같은 이진 표현에 해당 하는 이러한 문자를 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-509">Normalization converts these equivalent characters into the same binary representation.</span></span> <span data-ttu-id="ad3d8-510"><xref:System.String.Normalize%2A?displayProperty=nameWithType> 메서드 정규화, 수행 및 <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> 메서드 문자열 정규화 되는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-510">The <xref:System.String.Normalize%2A?displayProperty=nameWithType> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> method determines whether a string is normalized.</span></span>  
  
 <span data-ttu-id="ad3d8-511">자세한 내용 및 예제에 대 한 참조는 [정규화](#Normalization) 이 항목의 앞부분에 나오는 섹션.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-511">For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ad3d8-512">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-512">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-513"><see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-513">Initializes a new instance of the <see cref="T:System.String" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-514">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="ad3d8-514">In this section:</span></span>  
  
 <span data-ttu-id="ad3d8-515">[오버 로드 된 생성자 구문](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-515">[Overloaded constructor syntax](#Syntax) </span></span>  
 <span data-ttu-id="ad3d8-516">[매개 변수](#Params) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-516">[Parameters](#Params) </span></span>  
 <span data-ttu-id="ad3d8-517">[예외](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-517">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="ad3d8-518">[어떤 방법을 호출할 수 있습니까?](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-518">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="ad3d8-519">[문자열 만들기](#Creating_Strings) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-519">[Creating strings](#Creating_Strings) </span></span>  
 <span data-ttu-id="ad3d8-520">[반복적인 문자열 처리](#Repetitive) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-520">[Handling repetitive strings](#Repetitive) </span></span>  
 <span data-ttu-id="ad3d8-521">인스턴스화하는 동안 문자열의 예:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-521">Examples of instantiating strings:</span></span>   
 [<span data-ttu-id="ad3d8-522">문자열 할당 사용</span><span class="sxs-lookup"><span data-stu-id="ad3d8-522">Using string assignment</span></span>](#Ctor1_Example)  
 [<span data-ttu-id="ad3d8-523">문자 배열을 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="ad3d8-523">Using a character array</span></span>](#Ctor2_Example)  
 [<span data-ttu-id="ad3d8-524">문자 배열의 일부를 사용 하 고 단일 문자를 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-524">Using a portion of a character array and repeating a single character</span></span>](#Ctor3_Example)  
 [<span data-ttu-id="ad3d8-525">문자 배열에 대 한 포인터를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="ad3d8-525">Using a pointer to a character array</span></span>](#Ctor4_Example)  
 [<span data-ttu-id="ad3d8-526">포인터가 되 고 배열 범위를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="ad3d8-526">Using  a pointer and a range of an array</span></span>](#Ctor5_Example)  
 [<span data-ttu-id="ad3d8-527">부호 있는 바이트 배열에 대 한 포인터를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="ad3d8-527">Using a pointer to a signed byte array</span></span>](#Ctor6_Example)  
[<span data-ttu-id="ad3d8-528">버전 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-528">Version information</span></span>](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a><span data-ttu-id="ad3d8-529">오버 로드 된 생성자 구문</span><span class="sxs-lookup"><span data-stu-id="ad3d8-529">Overloaded constructor syntax</span></span>  
 <span data-ttu-id="ad3d8-530">두 가지 범주로 나뉩니다 문자열 생성자: 포인터 매개 변수 없이 포인터 매개 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-530">String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</span></span> <span data-ttu-id="ad3d8-531">포인터를 사용 하는 생성자는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-531">The constructors that use pointers are not CLS-compliant.</span></span> <span data-ttu-id="ad3d8-532">또한 Visual Basic 포인터의 사용을 지원 하지 않습니다 및 C# 코드 포인터를 사용 하 여 안전 하지 않은 컨텍스트에서 실행 하는 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-532">In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</span></span> <span data-ttu-id="ad3d8-533">자세한 내용은 [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-533">For more information, see [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span></span>  
  
 <span data-ttu-id="ad3d8-534">오버 로드를 선택 하는 방법 추가 지침을 참조 하세요. [방법을 호출 수행 합니까?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-534">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 `String(Char[] value)`  
 <span data-ttu-id="ad3d8-535">유니코드 문자 배열에서 나타내는 값으로 새 인스턴스를 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-535">Initializes the new instance to the value indicated by an array of Unicode characters.</span></span> <span data-ttu-id="ad3d8-536">이 생성자는 유니코드 문자를 복사 ([예제](#Ctor2_Example)).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-536">This constructor copies Unicode characters([example](#Ctor2_Example)).</span></span>  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ad3d8-537">이 고 길이 해당 배열 내의 시작 문자 위치는 유니코드 문자의 배열에서 나타내는 값으로 새 인스턴스를 초기화 합니다 ([예제](#Ctor3_Example)).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-537">Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).</span></span>  
  
 `String(Char c, Int32 count)`  
 <span data-ttu-id="ad3d8-538">지정 된 유니코드 문자로 표시 된 값으로 새 인스턴스를 초기화 합니다. 지정 된 횟수 만큼 반복 ([예제](#Ctor3_Example)).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-538">Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).</span></span>  
  
 `String(char* value)`  
 <span data-ttu-id="ad3d8-539">**(CLS 규격이 아닙니다.) ** Null 문자로 끝나는 유니코드 문자 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다 (U + 0000 또는 '\0').</span><span class="sxs-lookup"><span data-stu-id="ad3d8-539">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</span></span> <span data-ttu-id="ad3d8-540">([예제](#Ctor4_Example)).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-540">([example](#Ctor4_Example)).</span></span>  
  
 <span data-ttu-id="ad3d8-541">권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-541">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-542">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-542">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ad3d8-543">**(CLS 규격이 아닙니다.) ** 길이 및 해당 배열 내의 시작 문자 위치, 유니코드 문자 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-543">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span> <span data-ttu-id="ad3d8-544">생성자에서 유니코드 문자를 복사 `value` 인덱스에서 시작 `startIndex` 인덱스에서 끝나는 `startIndex`  +  `length` – 1 ([예제](#Ctor5_Example)).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-544">The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` – 1 ([example](#Ctor5_Example)).</span></span>  
  
 <span data-ttu-id="ad3d8-545">권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-545">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-546">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-546">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value)`  
 <span data-ttu-id="ad3d8-547">**(CLS 규격이 아닙니다.) ** 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-547">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="ad3d8-548">현재 시스템 코드 페이지를 사용 하 여 인코딩된 문자열을 나타내도록 배열 가정 됩니다 (즉, 지정한 인코딩을 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-548">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ad3d8-549">문자를 처리 하는 생성자 `value` null 문자 (0x00)에 도달할 때까지 포인터에 의해 지정 된 위치에서 시작 ([예제](#Ctor6_Example)).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-549">The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="ad3d8-550">권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-550">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-551">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-551">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ad3d8-552">**(CLS 규격이 아닙니다.) ** 길이 및 해당 배열 내의 시작 위치, 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-552">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span>  <span data-ttu-id="ad3d8-553">현재 시스템 코드 페이지를 사용 하 여 인코딩된 문자열을 나타내도록 배열 가정 됩니다 (즉, 지정한 인코딩을 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-553">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ad3d8-554">시작 하는 값에서 문자를 처리 하는 생성자 `startIndex` 에서 끝나는 `startIndex`  +  `length` – 1 ([예제](#Ctor6_Example)).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-554">The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` – 1 ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="ad3d8-555">권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-555">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-556">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-556">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 <span data-ttu-id="ad3d8-557">**(CLS 규격이 아닙니다.) ** 길이, 해당 배열 내의 시작 위치를 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 및 <xref:System.Text.Encoding> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-557">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.</span></span>  
  
 <span data-ttu-id="ad3d8-558">권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-558">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-559">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-559">This member cannot be used by partially trusted or transparent code.</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="ad3d8-560">매개 변수</span><span class="sxs-lookup"><span data-stu-id="ad3d8-560">Parameters</span></span>  
 <span data-ttu-id="ad3d8-561">사용 하는 매개 변수의 전체 목록은 다음과 같습니다 <xref:System.String> 포인터 매개 변수를 포함 하지 않는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-561">Here is a complete list of parameters used by <xref:System.String> constructors that don't include a pointer parameter.</span></span> <span data-ttu-id="ad3d8-562">각 오버 로드에서 사용 하는 매개 변수를 위 구문 오버 로드를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-562">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="ad3d8-563">매개 변수</span><span class="sxs-lookup"><span data-stu-id="ad3d8-563">Parameter</span></span>|<span data-ttu-id="ad3d8-564">형식</span><span class="sxs-lookup"><span data-stu-id="ad3d8-564">Type</span></span>|<span data-ttu-id="ad3d8-565">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-565">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<span data-ttu-id="ad3d8-566"><xref:System.Char>[]</span><span class="sxs-lookup"><span data-stu-id="ad3d8-566"><xref:System.Char>[]</span></span>|<span data-ttu-id="ad3d8-567">유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-567">An array of Unicode characters.</span></span>|  
|`c`|<xref:System.Char>|<span data-ttu-id="ad3d8-568">유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-568">A Unicode character.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="ad3d8-569">시작 위치 `value` 새 문자열의 첫 번째 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-569">The starting position in `value` of the first character in the new string.</span></span><br /><br /> <span data-ttu-id="ad3d8-570">기본 값: 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-570">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="ad3d8-571">에 있는 문자의 수 `value` 새 문자열에 포함 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-571">The number of characters in `value` to include in the new string.</span></span><br /><br /> <span data-ttu-id="ad3d8-572">기본값: <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ad3d8-572">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`count`|<xref:System.Int32>|<span data-ttu-id="ad3d8-573">문자 시간 단위로 `c` 새 문자열에서 반복 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-573">The number of times the character `c` is repeated in the new string.</span></span> <span data-ttu-id="ad3d8-574">경우 `count` 가 0 인 새 개체의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-574">If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="ad3d8-575">사용 하는 매개 변수의 전체 목록은 다음과 같습니다 <xref:System.String> 포인터 매개 변수를 포함 하는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-575">Here is a complete list of parameters used by <xref:System.String> constructors that include a pointer parameter.</span></span> <span data-ttu-id="ad3d8-576">각 오버 로드에서 사용 하는 매개 변수를 위 구문 오버 로드를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-576">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="ad3d8-577">매개 변수</span><span class="sxs-lookup"><span data-stu-id="ad3d8-577">Parameter</span></span>|<span data-ttu-id="ad3d8-578">형식</span><span class="sxs-lookup"><span data-stu-id="ad3d8-578">Type</span></span>|<span data-ttu-id="ad3d8-579">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-579">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> <span data-ttu-id="ad3d8-580">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-580">-or-</span></span><br /><br /> <xref:System.SByte>\*|<span data-ttu-id="ad3d8-581">유니코드 문자의 null로 끝나는 배열 또는 8 비트 부호 있는 정수 배열에 대 한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-581">A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</span></span> <span data-ttu-id="ad3d8-582">경우 `value` 은 `null` 이거나 빈 배열이 면 새 문자열의 값이 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-582">If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="ad3d8-583">새 문자열의 첫 번째 문자를 정의 하는 배열 요소의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-583">The index of the array element that defines the first character in the new string.</span></span><br /><br /> <span data-ttu-id="ad3d8-584">기본 값: 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-584">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="ad3d8-585">새 문자열을 만드는 데 사용 되는 배열 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-585">The number of array elements to use to create the new string.</span></span> <span data-ttu-id="ad3d8-586">생성자는 값이 문자열로 만듭니다 길이가 0 인 경우 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-586">If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="ad3d8-587">기본값: <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ad3d8-587">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`enc`|<xref:System.Text.Encoding>|<span data-ttu-id="ad3d8-588">지정 하는 개체는 어떻게 `value` 배열 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-588">An object that specifies how the `value` array is encoded.</span></span><br /><br /> <span data-ttu-id="ad3d8-589">기본값: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, 또는 시스템의 현재 ANSI 코드 페이지</span><span class="sxs-lookup"><span data-stu-id="ad3d8-589">Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, or the system's current ANSI code page</span></span>|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="ad3d8-590">예외</span><span class="sxs-lookup"><span data-stu-id="ad3d8-590">Exceptions</span></span>  
 <span data-ttu-id="ad3d8-591">포인터 매개 변수를 포함 하지 않는 생성자에서 throw 된 예외 목록은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-591">Here's a list of exceptions thrown by constructors that don't include pointer parameters.</span></span>  
  
|<span data-ttu-id="ad3d8-592">예외</span><span class="sxs-lookup"><span data-stu-id="ad3d8-592">Exception</span></span>|<span data-ttu-id="ad3d8-593">조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-593">Condition</span></span>|<span data-ttu-id="ad3d8-594">throw</span><span class="sxs-lookup"><span data-stu-id="ad3d8-594">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="ad3d8-595">`value`가 `null`인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-595">`value` is `null`.</span></span>|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="ad3d8-596">`startIndex``length`, 또는 `count` 가 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-596">`startIndex`,`length`, or `count` is less than zero.</span></span><br /><br /> <span data-ttu-id="ad3d8-597">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-597">-or-</span></span><br /><br /> <span data-ttu-id="ad3d8-598">`startIndex`와 `length`의 합계가 `value`에 포함된 요소의 수보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-598">The sum of `startIndex` and `length` is greater than the number of elements in `value`.</span></span><br /><br /> <span data-ttu-id="ad3d8-599">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-599">-or-</span></span><br /><br /> <span data-ttu-id="ad3d8-600">`count`가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-600">`count` is less than zero.</span></span>|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 <span data-ttu-id="ad3d8-601">포인터 매개 변수를 포함 하는 생성자에서 throw 된 예외 목록은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-601">Here's a list of exceptions thrown by constructors that include pointer parameters.</span></span>  
  
|<span data-ttu-id="ad3d8-602">예외</span><span class="sxs-lookup"><span data-stu-id="ad3d8-602">Exception</span></span>|<span data-ttu-id="ad3d8-603">조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-603">Condition</span></span>|<span data-ttu-id="ad3d8-604">throw</span><span class="sxs-lookup"><span data-stu-id="ad3d8-604">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="ad3d8-605">`value` 잘못 된 유니코드 문자가 포함 된 배열을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-605">`value` specifies an array that contains an invalid Unicode character.</span></span><br /><br /> <span data-ttu-id="ad3d8-606">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-606">-or-</span></span><br /><br /> <span data-ttu-id="ad3d8-607">`value` 또는 `value`  +  `startIndex` 64k 미만 되는 주소를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-607">`value` or `value` + `startIndex` specifies an address that is less than 64K.</span></span><br /><br /> <span data-ttu-id="ad3d8-608">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-608">-or-</span></span><br /><br /> <span data-ttu-id="ad3d8-609">새 <xref:System.String> 에서 인스턴스를 초기화 하지 못했습니다 된 `value` 바이트 배열 `value` 기본 코드 페이지 인코딩을 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-609">A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.</span></span>|<span data-ttu-id="ad3d8-610">포인터를 사용 하는 모든 생성자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-610">All constructors with pointers.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="ad3d8-611">`value`가 null인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-611">`value` is null.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="ad3d8-612">현재 프로세스에 주소가 지정된 모든 문자에 대한 읽기 액세스 권한이 있는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-612">The current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="ad3d8-613">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-613">-or-</span></span><br /><br /> <span data-ttu-id="ad3d8-614">`startIndex` 또는 `length`가 0보다 작거나 `value` + `startIndex`로 인해 포인터 오버플로가 발생하거나, 현재 프로세스에서 주소가 지정된 모든 문자에 대한 읽기 액세스 권한을 갖지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-614">`startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="ad3d8-615">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-615">-or-</span></span><br /><br /> <span data-ttu-id="ad3d8-616">새 문자열의 길이가 너무 커서 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-616">The length of the new string is too large to allocate.</span></span>|<span data-ttu-id="ad3d8-617">포인터를 사용 하는 모든 생성자</span><span class="sxs-lookup"><span data-stu-id="ad3d8-617">All constructors with pointers.</span></span>|  
|<xref:System.AccessViolationException>|<span data-ttu-id="ad3d8-618">`value`또는 `value`  +  `startIndex`  +  `length` – 1, 잘못 된 주소를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-618">`value`, or `value` + `startIndex` + `length` – 1, specifies an invalid address.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="ad3d8-619">어떤 방법을 호출할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-619">Which method do I call?</span></span>  
  
|<span data-ttu-id="ad3d8-620">대상</span><span class="sxs-lookup"><span data-stu-id="ad3d8-620">To</span></span>|<span data-ttu-id="ad3d8-621">호출 또는 사용</span><span class="sxs-lookup"><span data-stu-id="ad3d8-621">Call or use</span></span>|  
|--------|-----------------|  
|<span data-ttu-id="ad3d8-622">문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-622">Create a string.</span></span>|<span data-ttu-id="ad3d8-623">문자열 리터럴 또는 기존 문자열의 할당 ([예제](#Ctor1_Example))</span><span class="sxs-lookup"><span data-stu-id="ad3d8-623">Assignment from a string literal or an existing string ([example](#Ctor1_Example))</span></span>|  
|<span data-ttu-id="ad3d8-624">전체 문자 배열에서 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-624">Create a string from an entire character array.</span></span>|<span data-ttu-id="ad3d8-625"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([예제](#Ctor2_Example))</span><span class="sxs-lookup"><span data-stu-id="ad3d8-625"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))</span></span>|  
|<span data-ttu-id="ad3d8-626">문자 배열의 일부에서 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-626">Createa string from a portion of a character array.</span></span>|<span data-ttu-id="ad3d8-627"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([예제](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="ad3d8-627"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="ad3d8-628">같은 문자를 여러 번 반복 되는 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-628">Create a string that repeats the same character multiple times.</span></span>|<span data-ttu-id="ad3d8-629"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([예제](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="ad3d8-629"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="ad3d8-630">유니코드 또는 와이드 문자 배열에 대 한 포인터에서 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-630">Create a string from a pointer to a Unicode or wide character array.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|<span data-ttu-id="ad3d8-631">포인터를 사용 하 여 일부 유니코드 또는 와이드 문자 배열에서에서 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-631">Create a string from a portion of a Unicode or wide character array by using its pointer.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|<span data-ttu-id="ad3d8-632">C + +에서 문자열을 만드는 `char` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-632">Create a string from a C++ `char` array.</span></span>|<span data-ttu-id="ad3d8-633"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="ad3d8-633"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span></span><br /><br /> <span data-ttu-id="ad3d8-634">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-634">-or-</span></span><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<span data-ttu-id="ad3d8-635">ASCII 문자에서 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-635">Create a string from ASCII characters.</span></span>|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a><span data-ttu-id="ad3d8-636">문자열 만들기</span><span class="sxs-lookup"><span data-stu-id="ad3d8-636">Creating strings</span></span>  
 <span data-ttu-id="ad3d8-637">가장 일반적으로 사용 되는 기술을 단순 할당은 문자열을 프로그래밍 방식으로 만들기에 설명 된 대로 [이 예제](#Ctor1_Example)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-637">The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example).</span></span> <span data-ttu-id="ad3d8-638"><xref:System.String> 클래스 생성자 오버 로드에서 다음 값 문자열을 만들 수 있는 네 가지 유형의 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-638">The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:</span></span>  
  
-   <span data-ttu-id="ad3d8-639">문자 배열 (u t F-16으로 인코딩된 문자 배열)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-639">From a character array (an array of UTF-16-encoded characters).</span></span> <span data-ttu-id="ad3d8-640">새를 만들 수 있습니다 <xref:System.String> 개체에서 배열 전체 또는 일부에 있는 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-640">You can create a new <xref:System.String> object from the characters in the entire array or a portion of it.</span></span> <span data-ttu-id="ad3d8-641"><xref:System.String.%23ctor%28System.Char%5B%5D%29> 생성자 새 문자열을 배열에 있는 모든 문자를 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-641">The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string.</span></span> <span data-ttu-id="ad3d8-642"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자는 문자 인덱스에서 복사 `startIndex` 인덱스로 `startIndex`  +  `length` – 새 문자열을 1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-642">The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` – 1 to the new string.</span></span> <span data-ttu-id="ad3d8-643">경우 `length` 가 0 인 새 문자열의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-643">If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
     <span data-ttu-id="ad3d8-644">코드에 동일한 값을 가진 문자열 반복 해 서 인스턴스화할 경우 문자열을 작성 하는 대체 방법을 사용 하 여 응용 프로그램의 성능을 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-644">If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</span></span> <span data-ttu-id="ad3d8-645">자세한 내용은 참조 [반복적인 문자열 처리](#Repetitive)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-645">For more information, see [Handling repetitive strings](#Repetitive).</span></span>  
  
-   <span data-ttu-id="ad3d8-646">단일에서 문자 즉, 한 번 이상를 사용 하 여 중복 된 0은 <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-646">From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="ad3d8-647">경우 `count` 가 0 인 새 문자열의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-647">If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ad3d8-648">Null로 끝나는 문자 배열에 대 한 포인터에서 사용 하 여는 <xref:System.String.%23ctor%28System.Char%2A%29> 또는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-648">From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="ad3d8-649">전체 배열 또는 지정된 된 범위 수 데 사용할 문자열을 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-649">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="ad3d8-650">생성자는 지정된 된 포인터가 더하기 또는 지정된 된 포인터에서 시작 하는 유니코드 문자 시퀀스로 복사 `startIndex` 또는 배열의 끝까지 계속 `length` 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-650">The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters.</span></span> <span data-ttu-id="ad3d8-651">경우 `value` 가 null 포인터 또는 `length` 0 이면 생성자의 값이 문자열을 만듭니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-651">If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-652">배열의 끝에 복사 작업을 진행 하 고 null로 끝나는 배열 하지 않는 경우 생성자 동작은 시스템에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-652">If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</span></span> <span data-ttu-id="ad3d8-653">이러한 조건을 액세스 위반이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-653">Such a condition might cause an access violation.</span></span>  
  
     <span data-ttu-id="ad3d8-654">배열에 포함 된 null 문자가 포함 된 경우 (U + 0000 또는 '\0')와 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드를 호출한, 포함 된 문자열 인스턴스 `length` 문자를 포함 하 여 null 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-654">If the array contains any embedded null characters (U+0000 or '\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="ad3d8-655">다음 예제에서는 두 개의 null 문자를 포함 하는 10 개 요소의 배열에 대 한 포인터에 전달 될 때 어떤 일이 생기는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-655">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ad3d8-656">주소는 배열의 시작이 고 배열의 모든 요소는 문자열에 추가할 때문에 생성자 내장된 된 null이 두 가지를 포함 하 여 10 개의 문자로 이루어진 문자열을 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-656">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="ad3d8-657">반면, 같은 배열을 전달 하는 경우에 <xref:System.String.%23ctor%28System.Char%2A%29> 생성자의 결과 첫 번째 null 문자를 포함 하지 않는 4 자의 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-657">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     <span data-ttu-id="ad3d8-658">유니코드 문자 배열에 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-658">The array must contain Unicode characters.</span></span> <span data-ttu-id="ad3d8-659">C + +에서는이 되어야 함을 의미 하는 문자열 배열에서 관리 되는 것으로 정의 하거나 <xref:System.Char>형식 또는 관리 되지 않는`wchar_t`형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-659">In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.</span></span>  
  
     <span data-ttu-id="ad3d8-660">경우는 <xref:System.String.%23ctor%28System.Char%2A%29> 오버 로드는 호출 되 고 null로 끝나는 배열은 있지 않습니다 또는 경우에는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드를 호출한 및 `startIndex`  +  `length`문자의 시퀀스에 할당 된 메모리 외부 범위를 포함 하는-1 생성자의 동작은 시스템 종속적 이며 액세스 위반이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-660">If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</span></span> <span data-ttu-id="ad3d8-661">또한 Intel Itanium 프로세서에 대 한 호출이 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자 throw 될 수 있습니다는 <xref:System.DataMisalignedException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-661">In addition, on the Intel Itanium processor, calls to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor may throw a <xref:System.DataMisalignedException> exception.</span></span> <span data-ttu-id="ad3d8-662">이 경우 호출 된 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-662">If this occurs, call the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> instead.</span></span>  
  
-   <span data-ttu-id="ad3d8-663">부호 있는 바이트 배열에 대 한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-663">From a pointer to a signed byte array.</span></span> <span data-ttu-id="ad3d8-664">전체 배열 또는 지정된 된 범위 수 데 사용할 문자열을 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-664">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="ad3d8-665">인코딩, 기본 코드 페이지를 사용 하 여 바이트 시퀀스를 해석할 수 있습니다 또는 생성자 호출에 인코딩을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-665">The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</span></span> <span data-ttu-id="ad3d8-666">생성자를 null로 종결 되지 않은 전체 배열에서 문자열을 인스턴스화하려고 하면 또는 경우에서 배열의 범위를 `value`  +  `startIndex` 를 `value`  +  `startIndex`  +  `length` 배열에 할당 된 메모리 외에-1은,이 생성자의 동작은 시스템에 따라 다름 및 액세스 위반이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-666">If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</span></span>  
  
     <span data-ttu-id="ad3d8-667">부호 있는 바이트 배열을 매개 변수로 포함 하는 세 명의 생성자는 c + +를 변환 하는 데 주로 만들어진 `char` 이 예제에 표시 된 대로 문자열로 배열:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-667">The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:</span></span>  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     <span data-ttu-id="ad3d8-668">값이 0 인 모든 null 문자 ('\0') 또는 바이트 배열에 들어 있으면 및 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드를 호출한, 포함 된 문자열 인스턴스 `length` 문자를 포함 하 여 null 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-668">If the array contains any null characters ('\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="ad3d8-669">다음 예제에서는 두 개의 null 문자를 포함 하는 10 개 요소의 배열에 대 한 포인터에 전달 될 때 어떤 일이 생기는 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-669">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ad3d8-670">주소는 배열의 시작이 고 배열의 모든 요소는 문자열에 추가할 때문에 생성자 내장된 된 null이 두 가지를 포함 하 여 10 개의 문자로 이루어진 문자열을 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-670">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="ad3d8-671">반면, 같은 배열을 전달 하는 경우에 <xref:System.String.%23ctor%28System.SByte%2A%29> 생성자의 결과 첫 번째 null 문자를 포함 하지 않는 4 자의 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-671">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <span data-ttu-id="ad3d8-672">때문에 <xref:System.String.%23ctor%28System.SByte%2A%29> 및 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자 해석 `value` 기본 ANSI 코드 페이지를 사용 하 여 동일한 바이트 배열이 포함 된 이러한 생성자를 호출 만들 수 있습니다 다른 시스템에서 다른 값이 있는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-672">Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</span></span>  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a><span data-ttu-id="ad3d8-673">반복적인 문자열 처리</span><span class="sxs-lookup"><span data-stu-id="ad3d8-673">Handling repetitive strings</span></span>  
 <span data-ttu-id="ad3d8-674">구문 분석 하거나 자주 텍스트 스트림을 디코딩하는 앱에서 사용 하는 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자 또는 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자의 시퀀스를 문자열로 변환 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-674">Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to convert sequences of characters into a string.</span></span> <span data-ttu-id="ad3d8-675">만들기 및 단일 문자열을 다시 사용 하는 대신 같은 값을 갖는 새 문자열을 반복 해 서 만들기 메모리가 낭비 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-675">Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</span></span> <span data-ttu-id="ad3d8-676">동일한 문자열 값을 반복적으로 호출 하 여 만들 수 있는 경우는 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자에서 알 수 없는 경우에 이동할 수 있는 이러한 동일한 문자열 값, 조회 테이블을 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-676">If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</span></span>  
  
 <span data-ttu-id="ad3d8-677">예를 들어 읽고 XML 태그 및 특성을 포함 하는 파일에서 문자 스트림을 구문 분석 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-677">For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</span></span> <span data-ttu-id="ad3d8-678">스트림 구문 분석 하 여, 특정 토큰 (즉, 기호화 된 의미를 갖는 문자 시퀀스)이 반복적으로 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-678">When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</span></span> <span data-ttu-id="ad3d8-679">문자열 "0", "1", "true" 및 "false"에 해당 하는 토큰이 XML 스트림에서 자주 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-679">Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</span></span>  
  
 <span data-ttu-id="ad3d8-680">각 토큰 새 문자열을 변환 하는 대신 만들 수는 <xref:System.Xml.NameTable?displayProperty=nameWithType> 일반적으로 발생 하는 문자열을 저장 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-680">Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=nameWithType> object to hold commonly occurring strings.</span></span> <span data-ttu-id="ad3d8-681"><xref:System.Xml.NameTable> 개체 임시 메모리를 할당 하지 않고 저장 된 문자열을 검색 하므로 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-681">The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory.</span></span> <span data-ttu-id="ad3d8-682">사용 하 여 토큰을 발견할 때는 <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 테이블에서 토큰을 검색 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-682">When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to retrieve the token from the table.</span></span> <span data-ttu-id="ad3d8-683">토큰이 있으면 메서드는 해당 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-683">If the token exists, the method returns the corresponding string.</span></span> <span data-ttu-id="ad3d8-684">토큰이 존재 하지 않는 경우 사용 하 여는 <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 토큰 테이블에 삽입 하 고 메서드를 해당 문자열을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-684">If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to insert the token into the table and to get the corresponding string.</span></span>  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a><span data-ttu-id="ad3d8-685">예제 1: 문자열 할당 사용</span><span class="sxs-lookup"><span data-stu-id="ad3d8-685">Example 1: Using string assignment</span></span>  
 <span data-ttu-id="ad3d8-686">다음 예제에서는 문자열 리터럴을 할당 하 여 새 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-686">The following example creates a new string by assigning it a string literal.</span></span> <span data-ttu-id="ad3d8-687">첫 번째 문자열의 값을 할당 하 여 두 번째 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-687">It creates a second string by assigning the value of the first string to it.</span></span> <span data-ttu-id="ad3d8-688">인스턴스화하는 새로운 두 개의 가장 일반적인 방법은 다음과 같습니다 <xref:System.String> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-688">These are the two most common ways to instantiate a new <xref:System.String> object.</span></span>  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a><span data-ttu-id="ad3d8-689">예제 2:를 사용 하는 문자 배열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-689">Example 2: Using a character array</span></span>  
 <span data-ttu-id="ad3d8-690">다음 예제에서는 새로 만들려면 <xref:System.String> 는 문자 배열에서 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-690">The following example demonstrates how to create a new <xref:System.String> object from a character array.</span></span>  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a><span data-ttu-id="ad3d8-691">예제 3: 문자 배열의 일부를 사용 하 고 단일 문자를 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-691">Example 3: Using a portion of a character array and repeating a single character</span></span>  
 <span data-ttu-id="ad3d8-692">다음 예제에서는 새로 만들려면 <xref:System.String> 는 문자 배열 및 새 하는 방법의 부분에서 개체 <xref:System.String> 단일 문자를 여러 번 포함 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-692">The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.</span></span>  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a><span data-ttu-id="ad3d8-693">문자 배열에 대 한 포인터를 사용 하는 예 4:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-693">Example 4: Using a pointer to a character array</span></span>  
 <span data-ttu-id="ad3d8-694">다음 예제에서는 새로 만들려면 <xref:System.String> 문자의 배열에 대 한 포인터에서 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-694">The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters.</span></span> <span data-ttu-id="ad3d8-695">C# 예제를 사용 하 여 컴파일해야 합니다.는 `/unsafe` 컴파일러 스위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-695">The C# example must be compiled by using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a><span data-ttu-id="ad3d8-696">예 5: 인스턴스화는 포인터가 되 고 배열 범위에서 문자열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-696">Example 5: Instantiating a string from a pointer and a range of an array</span></span>  
 <span data-ttu-id="ad3d8-697">다음 예제에서는 마침표 또는 느낌표 문자 배열의 요소를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-697">The following example examines the elements of a character array for either a period or an exclamation point.</span></span> <span data-ttu-id="ad3d8-698">가 있는 경우 문장 부호 기호가 앞에 있는 배열에 문자에서 문자열을 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-698">If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</span></span> <span data-ttu-id="ad3d8-699">그렇지 않으면 배열의 전체 내용으로 문자열을 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-699">If not, it instantiates a string with the entire contents of the array.</span></span> <span data-ttu-id="ad3d8-700">C# 예제를 사용 하 여 컴파일해야는 `/unsafe` 컴파일러 스위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-700">The C# example must be compiled using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a><span data-ttu-id="ad3d8-701">예 6: 인스턴스화는 부호 있는 바이트 배열에 대 한 포인터에서 문자열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-701">Example 6: Instantiating a string from a pointer to a signed byte array</span></span>  
 <span data-ttu-id="ad3d8-702">다음 예제에서는의 인스턴스를 만드는 방법을 보여 줍니다.는 <xref:System.String> 클래스와 <xref:System.String.%23ctor%28System.SByte%2A%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-702">The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.</span></span>  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="ad3d8-703">버전 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-703">Version information</span></span>  
 <span data-ttu-id="ad3d8-704">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="ad3d8-704">.NET Framework</span></span>  
 <span data-ttu-id="ad3d8-705">모든 오버 로드에서 지원 됩니다: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-705">All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
  
 <span data-ttu-id="ad3d8-706">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="ad3d8-706">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="ad3d8-707">모든 오버 로드에서 지원 됩니다: 4, 3.5 SP1</span><span class="sxs-lookup"><span data-stu-id="ad3d8-707">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="ad3d8-708">이식 가능한 클래스 라이브러리</span><span class="sxs-lookup"><span data-stu-id="ad3d8-708">Portable Class Library</span></span>  
 <span data-ttu-id="ad3d8-709">없이 모든 오버 로드는 <xref:System.SByte> `*` 매개 변수를 지원</span><span class="sxs-lookup"><span data-stu-id="ad3d8-709">All overloads without an <xref:System.SByte>`*` parameter are supported</span></span>  
  
 <span data-ttu-id="ad3d8-710">Windows 스토어 앱용 .NET</span><span class="sxs-lookup"><span data-stu-id="ad3d8-710">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="ad3d8-711">없이 모든 오버 로드는 <xref:System.SByte> `*` 매개 변수에서 지원 됩니다: Windows 8</span><span class="sxs-lookup"><span data-stu-id="ad3d8-711">All overloads without an <xref:System.SByte>`*` parameter are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-712">null로 끝나는 유니코드 문자 배열에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-712">A pointer to a null-terminated array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="ad3d8-713">유니코드 문자 배열에 대한 지정된 포인터가 가리키는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-713">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-714">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-714">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-715">현재 프로세스에 주소가 지정된 모든 문자에 대한 읽기 액세스 권한이 있는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-715">The current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-716"><paramref name="value" />에 잘못된 유니코드 문자가 들어 있는 배열이 지정되거나 <paramref name="value" />에 64000보다 작은 주소가 지정된 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-716"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ad3d8-717">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-717">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-718">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-718">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-719">유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-719">An array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="ad3d8-720">유니코드 문자 배열에서 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-720">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-721">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-721">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-722">null로 끝나는 8비트 부호 있는 정수 배열에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-722">A pointer to a null-terminated array of 8-bit signed integers.</span></span> <span data-ttu-id="ad3d8-723">정수는 현재 시스템 코드 페이지 인코딩(즉, <see cref="P:System.Text.Encoding.Default" />로 지정된 인코딩)을 사용하여 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-723">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <summary><span data-ttu-id="ad3d8-724">8비트 부호 있는 정수 배열에 대한 포인터가 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-724">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-725">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-725">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-726"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-726"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ad3d8-727"><paramref name="value" />가 ANSI로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-727">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-728"><paramref name="value" />의 null 종결 문자로 결정되는 초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-728">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</span></span></exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="ad3d8-729"><paramref name="value" />가 잘못된 주소를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-729"><paramref name="value" /> specifies an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ad3d8-730">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-730">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-731">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-731">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="ad3d8-732">유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-732">A Unicode character.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-733"><c>c</c>가 발생하는 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-733">The number of times <c>c</c> occurs.</span></span></param>
        <summary><span data-ttu-id="ad3d8-734">지정한 횟수만큼 반복되는 지정된 유니코드 문자가 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-734">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-735">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-735">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-736"><paramref name="count" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-736"><paramref name="count" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-737">유니코드 문자 배열에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-737">A pointer to an array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-738"><c>값</c> 내의 시작 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-738">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-739"><c>value</c> 내에서 사용할 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-739">The number of characters within <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="ad3d8-740">유니코드 문자 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 문자 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-740">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-741">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-741">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-742"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작거나 <paramref name="value" /> + <paramref name="startIndex" />로 인해 포인터 오버플로가 발생하거나, 현재 프로세스에서 주소가 지정된 모든 문자에 대한 읽기 액세스 권한을 갖지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-742"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-743"><paramref name="value" />는 잘못된 유니코드 문자가 포함된 배열을 지정하거나 <paramref name="value" /> + <paramref name="startIndex" />가 64000보다 작은 주소를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-743"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ad3d8-744">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-744">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-745">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-745">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-746">유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-746">An array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-747"><c>값</c> 내의 시작 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-747">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-748"><c>value</c> 내에서 사용할 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-748">The number of characters within <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="ad3d8-749">유니코드 문자 배열에서 나타내는 값, 해당 배열 내의 시작 문자 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-749">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-750">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-750">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-751"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-751"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-752"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-752"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-753">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-753">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-754"><paramref name="startIndex" />와 <paramref name="length" />의 합계가 <paramref name="value" />에 포함된 요소의 수보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-754">The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-755">8비트 부호 있는 정수에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-755">A pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="ad3d8-756">정수는 현재 시스템 코드 페이지 인코딩(즉, <see cref="P:System.Text.Encoding.Default" />로 지정된 인코딩)을 사용하여 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-756">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-757"><c>값</c> 내의 시작 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-757">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-758"><c>value</c> 내에서 사용할 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-758">The number of characters within <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="ad3d8-759">8비트 부호 있는 정수 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-759">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-760">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-760">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-761"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-761"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-762"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-762"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-763">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-763">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-764"><paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 현재 플랫폼에 비해 너무 큽니다. 즉, 주소 계산이 오버플로됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-764">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
 <span data-ttu-id="ad3d8-765">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-765">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-766">초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-766">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ad3d8-767"><paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 64K 미만입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-767">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
 <span data-ttu-id="ad3d8-768">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-768">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-769"><paramref name="value" />가 ANSI로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-769">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="ad3d8-770"><paramref name="value" />, <paramref name="startIndex" /> 및 <paramref name="length" />가 전체적으로 잘못된 주소를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-770"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ad3d8-771">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-771">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-772">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-772">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-773">8비트 부호 있는 정수에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-773">A pointer to an array of 8-bit signed integers.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-774"><c>값</c> 내의 시작 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-774">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-775"><c>value</c> 내에서 사용할 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-775">The number of characters within <c>value</c> to use.</span></span></param>
        <param name="enc"><span data-ttu-id="ad3d8-776"><c>value</c>에서 참조하는 배열이 인코딩되는 방법을 지정하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-776">An object that specifies how the array referenced by <c>value</c> is encoded.</span></span> <span data-ttu-id="ad3d8-777"><c>enc</c>가 <see langword="null" />이면 ANSI 인코딩으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-777">If <c>enc</c> is <see langword="null" />, ANSI encoding is assumed.</span></span></param>
        <summary><span data-ttu-id="ad3d8-778">8비트 부호 있는 정수 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 문자 위치, 길이 및 <see cref="T:System.String" /> 개체로 <see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-778">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-779">예제 및이 오류 코드 및 기타 하는 방법에 대 한 포괄적인 사용 정보에 대 한 `String` 생성자 오버 로드 참조는 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-779">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-780"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-780"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-781"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-781"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-782">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-782">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-783"><paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 현재 플랫폼에 비해 너무 큽니다. 즉, 주소 계산이 오버플로됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-783">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
 <span data-ttu-id="ad3d8-784">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-784">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-785">초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-785">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ad3d8-786"><paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 64K 미만입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-786">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
 <span data-ttu-id="ad3d8-787">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-787">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-788"><paramref name="value" />가 <paramref name="value" />에 지정된 대로 인코딩되는 것으로 간주되어 <paramref name="enc" />를 사용하여 <see cref="T:System.String" />의 새 인스턴스를 초기화할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-788">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</span></span></exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="ad3d8-789"><paramref name="value" />, <paramref name="startIndex" /> 및 <paramref name="length" />가 전체적으로 잘못된 주소를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-789"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ad3d8-790">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-790">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ad3d8-791">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-791">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="ad3d8-792">현재 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-792">A position in the current string.</span></span></param>
        <summary><span data-ttu-id="ad3d8-793">현재 <see cref="T:System.Char" /> 개체에서 지정된 문자 위치에 있는 <see cref="T:System.String" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-793">Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="ad3d8-794"><paramref name="index" /> 위치에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-794">The object at position <paramref name="index" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-795">`index` 매개 변수는 0부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-795">The `index` parameter is zero-based.</span></span>  
  
 <span data-ttu-id="ad3d8-796">이 속성은 반환 된 <xref:System.Char> 로 지정 된 위치에 개체는 `index` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-796">This property returns the <xref:System.Char> object at the position specified by the `index` parameter.</span></span> <span data-ttu-id="ad3d8-797">하지만 개 이상의 유니코드 문자 표현 될 수 있습니다 <xref:System.Char>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-797">However, a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="ad3d8-798">사용 하 여는 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 유니코드를 사용 하는 클래스 문자 대신 <xref:System.Char> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-798">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with Unicode characters instead of <xref:System.Char> objects.</span></span> <span data-ttu-id="ad3d8-799">자세한 내용은의 "개체 및 유니코드 문자 Char" 섹션을 참조는 <xref:System.String> 클래스 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-799">For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.</span></span>  
  
 <span data-ttu-id="ad3d8-800">C#에서 <xref:System.String.Chars%2A> 속성 인덱서입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-800">In C#, the <xref:System.String.Chars%2A> property is an indexer.</span></span> <span data-ttu-id="ad3d8-801">Visual basic에서은의 기본 속성은 <xref:System.String> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-801">In Visual Basic, it is the default property of the <xref:System.String> class.</span></span> <span data-ttu-id="ad3d8-802">각 <xref:System.Char> 다음과 같은 코드를 사용 하 여 문자열에서 개체를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-802">Each <xref:System.Char> object in the string can be accessed by using code such as the following.</span></span>  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-803">다음 예제에서는 문자열로 유효성을 검사 하는 루틴에이 인덱서를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-803">The following example demonstrates how you can use this indexer in a routine to validate a string.</span></span>  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="ad3d8-804"><paramref name="index" />가 이 개체의 길이보다 크거나 같거나 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-804"><paramref name="index" /> is greater than or equal to the length of this object or less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-805">이 <see cref="T:System.String" />의 이 인스턴스에 대한 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-805">Returns a reference to this instance of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-806">이 <see cref="T:System.String" />의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-806">This instance of <see cref="T:System.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-807">반환 값이이 인스턴스에;의 독립 복사본 동일한 데이터의 다른 단순히 뷰입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-807">The return value is not an independent copy of this instance; it is simply another view of the same data.</span></span> <span data-ttu-id="ad3d8-808">사용 하 여는 <xref:System.String.Copy%2A> 또는 <xref:System.String.CopyTo%2A> 메서드를 별도 <xref:System.String> 이 인터페이스와 동일한 값을 가진 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-808">Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-809">때문에 <xref:System.String.Clone%2A> 직접 호출할 필요가 거의 메서드는 기존 문자열 인스턴스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-809">Because the <xref:System.String.Clone%2A> method simply returns the existing string instance, there is little reason to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-810">지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-810">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-811"><xref:System.String.Compare%2A> 메서드의 모든 오버로드는 두 비교 대상 간의 어휘 관계를 나타내는 부호 있는 32비트 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-811">All overloads of the <xref:System.String.Compare%2A> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
|<span data-ttu-id="ad3d8-812">값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-812">Value</span></span>|<span data-ttu-id="ad3d8-813">조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-813">Condition</span></span>|  
|-----------|---------------|  
|<span data-ttu-id="ad3d8-814">0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-814">Less than zero</span></span>|<span data-ttu-id="ad3d8-815">첫 번째 부분 문자열 정렬 순서에서 두 번째 부분 문자열 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-815">The first substring precedes the second substring in the sort order.</span></span>|  
|<span data-ttu-id="ad3d8-816">0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-816">Zero</span></span>|<span data-ttu-id="ad3d8-817">부분 문자열이 정렬 순서에서 같은 위치에 나오거나 `length`가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-817">The substrings occur in the same position in the sort order, or `length` is zero.</span></span>|  
|<span data-ttu-id="ad3d8-818">0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-818">Greater than zero</span></span>|<span data-ttu-id="ad3d8-819">첫 번째 부분 문자열 정렬 순서에서 두 번째 부분 문자열을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-819">The first substring follows the second substring in the sort order.</span></span>|  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-820">가능한 경우 항상 오버 로드를 호출 해야는 <xref:System.String.Compare%2A> 메서드를 포함 하는 <xref:System.StringComparison> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-820">Whenever possible, you should call an overload of the <xref:System.String.Compare%2A> method that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ad3d8-821">자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-821">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-822">비교할 첫째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-822">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-823">비교할 둘째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-823">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="ad3d8-824">지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-824">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-825">두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-825">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-826"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-826"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-827"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-827"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-828"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-828"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-829"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-829"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-830"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-830"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-831"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-831"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-832"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-832"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-833"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-833"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-834">비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-834">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ad3d8-835">예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-835">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ad3d8-836">단어 정렬 규칙을 사용 하 여 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-836">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ad3d8-837">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-837">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-838">문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-838">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ad3d8-839">자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-839">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ad3d8-840">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-840">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-841">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-841">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-842">비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-842">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ad3d8-843">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-843">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-844">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-844">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-845">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-845">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-846">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-846">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 <span data-ttu-id="ad3d8-847">"file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-847">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-848">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-848">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-849">다음 예제에서는 <xref:System.String.Compare%28System.String%2CSystem.String%29> 메서드를 세 개의 문자열을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-849">The following example calls the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to compare three sets of strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 <span data-ttu-id="ad3d8-850">다음 예제에서는 `ReverseStringComparer` 클래스와 두 개의 문자열을 계산 하는 방법을 보여 줍니다.는 <xref:System.String.Compare%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-850">In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the <xref:System.String.Compare%2A> method.</span></span>  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-851">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-851">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-852"><see cref="M:System.String.Compare(System.String,System.String)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-852">The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-853">예를 들어, 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물"와 "ani 메일" (소프트 하이픈 또는 U + 00AD 사용)의 문화권 구분 비교 두 문자열은 해당을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-853">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)]
 [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]  
  
 <span data-ttu-id="ad3d8-854">문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드 중 하나의 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 `comparisonType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-854">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-855">비교할 첫째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-855">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-856">비교할 둘째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-856">The second string to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="ad3d8-857">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-857"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-858">대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체를 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-858">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-859">두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-859">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-860"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-860"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-861"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-861"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-862"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-862"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-863"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-863"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-864"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-864"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-865"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-865"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-866"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-866"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-867"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-867"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-868">비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-868">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ad3d8-869">예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-869">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ad3d8-870">단어 정렬 규칙을 사용 하 여 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-870">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ad3d8-871">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-871">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-872">문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-872">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ad3d8-873">자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-873">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ad3d8-874">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-874">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-875">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-875">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-876">비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-876">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ad3d8-877">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-877">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-878">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-878">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-879">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-879">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-880">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-880">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 <span data-ttu-id="ad3d8-881">"file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-881">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-882">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-882">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-883">다음 예제에서는 하는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> 사용 하는 것과 같습니다 <xref:System.String.ToUpper%2A> 또는 <xref:System.String.ToLower%2A> 문자열을 비교할 때.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-883">The following example demonstrates that the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-884">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-884">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-885"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-885">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-886">예를 들어, 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물"와 "Ani 메일" (소프트 하이픈 또는 U + 00AD 사용)의 문화권을 구분, 대/소문자 비구분 비교 두 문자열은 해당을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-886">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)]
 [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]  
  
 <span data-ttu-id="ad3d8-887">문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드 중 하나의 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-887">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-888">비교할 첫째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-888">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-889">비교할 둘째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-889">The second string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-890">비교에 사용할 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-890">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ad3d8-891">지정된 규칙을 사용하여 지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-891">Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-892">두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-892">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-893"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-893"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-894"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-894"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-895"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-895"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-896"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-896"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-897"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-897"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-898"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에 있는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-898"></term><description><paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-899"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-899"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-900"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-900"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-901">`comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 대상의 대/소문자 무시 (문화권 구분) 단어를 사용 하 여 또는 서 수 (문화권) 정렬 규칙.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-901">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="ad3d8-902">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-902">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-903">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-903">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-904">비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-904">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ad3d8-905">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-905">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-906">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-906">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-907">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-907">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-908">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-908">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 <span data-ttu-id="ad3d8-909">"file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-909">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-910">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-910">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-911">다음 예제에서는 세 가지 버전의 문자를 비교 "I"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-911">The following example compares three versions of the letter "I".</span></span> <span data-ttu-id="ad3d8-912">결과는 문화권, 대/소문자 무시 여부 및 서 수 비교가 수행 되는지 여부는 선택한 항목에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-912">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-913"><paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-913"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ad3d8-914"><see cref="T:System.StringComparison" />은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-914"><see cref="T:System.StringComparison" /> is not supported.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-915">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-915">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-916"><see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-916">The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-917">비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-917">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-918">비교할 첫째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-918">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-919">비교할 둘째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-919">The second string to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="ad3d8-920">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-920"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ad3d8-921">문화권별 비교 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-921">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-922">대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체를 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다. 문화권별 정보가 비교에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-922">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-923">두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-923">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-924"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-924"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-925"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-925"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-926"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-926"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-927"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-927"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-928"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-928"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-929"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-929"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-930"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-930"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-931"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-931"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-932">비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-932">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ad3d8-933">예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-933">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ad3d8-934">단어 정렬 규칙을 사용 하 여 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-934">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ad3d8-935">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-935">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ad3d8-936">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-936">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-937">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-937">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-938">비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-938">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ad3d8-939">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-939">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-940">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-940">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-941">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-941">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-942">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-942">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 <span data-ttu-id="ad3d8-943">"file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-943">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-944">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-944">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-945">다음 예제에서는 문화권 비교에 영향을 줄 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-945">The following example demonstrates how culture can affect a comparison.</span></span> <span data-ttu-id="ad3d8-946">체코어-체코 공화국 문화권 "ch"는 "d" 보다 큰 단일 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-946">In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</span></span> <span data-ttu-id="ad3d8-947">그러나 영어-미국 문화권 "ch" 두 개의 문자로 구성 되어 있으며 "c"를 사용 하면 "d" 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-947">However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</span></span>  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-948"><paramref name="culture" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-948"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-949">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-949">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-950"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-950">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-951">예를 들어, 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 "동물"와 "Ani 메일" (소프트 하이픈 또는 U + 00AD 사용)의 대/소문자 비구분 비교 고정을 사용 하 여 이상 버전에서는 두 문자열은 해당 문화권 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-951">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)]
 [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]  
  
 <span data-ttu-id="ad3d8-952">문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드 중 하나의 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-952">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-953">비교할 첫째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-953">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-954">비교할 둘째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-954">The second string to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="ad3d8-955">문화권별 비교 정보를 제공하는 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-955">The culture that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="ad3d8-956">대/소문자 또는 기호 무시 여부와 같이 비교를 수행할 때 사용할 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-956">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="ad3d8-957">지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 문자열 간의 관계를 나타내는 정수를 반환합니다. 지정된 비교 옵션 및 문화권별 정보가 비교에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-957">Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-958">다음 표와 같이 <paramref name="strA" />와 <paramref name="strB" /> 간의 어휘 관계를 나타내는 부호 있는 32비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-958">A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table</span></span>  
  
 <span data-ttu-id="ad3d8-959"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-959"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-960"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-960"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-961"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-961"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-962"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-962"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-963"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-963"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-964"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-964"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-965"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-965"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-966"></term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-966"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-967">비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자 사전 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-967">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="ad3d8-968">예를 들어 특정 문화권 수 특정 문자 조합을 단일 문자로 취급 될, 대 / 소문자에 특정 한 방식으로 비교할 수 또는 지정 정렬 순서는 문자는 문자에 따라 달라 지는 앞 이나 뒤 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-968">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ad3d8-969"><xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-969">The <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ad3d8-970">메서드 호출의 주요 목적은 (즉, 메서드 호출의 목적은 인 경우 반환 값 0에 대 한 테스트) 두 문자열이 같은지 여부를 결정 하는 경우 하지 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-970">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="ad3d8-971">두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-971">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ad3d8-972">비교를 추가로 지정할 수는 `options` 의 하나 이상의 구성원으로 구성 되는 매개 변수는 <xref:System.Globalization.CompareOptions> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-972">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration.</span></span> <span data-ttu-id="ad3d8-973">그러나이 메서드는 문화권 구분 문자열 비교를 수행 하 고 이기 때문에 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 값은 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-973">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="ad3d8-974">비교 중 하나 또는 모두가 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-974">Either or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-975">기본적으로 모든 문자열을 포함 하 여 <xref:System.String.Empty?displayProperty=nameWithType>, null 참조와 두 개의 null 참조 보다 큰 것으로 간주 서로 같다고 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-975">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-976">비교 또는 같지 않음 검색은 모두 문자열 요소가 비교 된 때를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-976">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ad3d8-977">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 있는 나머지 문자로 문자열 큰 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-977">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-978">다음 예제에서는 세 가지 방법으로 두 문자열을 비교: EN-US 문화권에 대 한 언어 비교를 사용 하 여 EN-US 문화권에 대 한 언어의 대/소문자 구분 비교를 사용 하 여 및 서 수 비교를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-978">The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-979">비교의 세 가지 방법에서 세 가지 다른 결과 생성 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-979">It illustrates how the three methods of comparison produce three different results.</span></span>  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-980"><paramref name="options" />이 <see cref="T:System.Globalization.CompareOptions" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-980"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-981"><paramref name="culture" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-981"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-982">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-982">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-983"><see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-983">The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-984">비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-984">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-985">비교에 사용할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-985">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ad3d8-986"><c>strA</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-986">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-987">비교에 사용할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-987">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ad3d8-988"><c>strB</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-988">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-989">비교할 부분 문자열의 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-989">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="ad3d8-990">지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-990">Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-991">두 비교 대상 간의 어휘 관계를 나타내는 부호 있는 32비트 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-991">A 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-992"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-992"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-993"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-993"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-994"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-994"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-995"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-995"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-996"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-996"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-997"></term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-997"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="ad3d8-998"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-998"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-999"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-999"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1000">비교할 부분 문자열 시작 `strA` 에서 `indexA` 및 `strB` 에서 `indexB`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1000">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="ad3d8-1001">둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 는 위치 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1001">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="ad3d8-1002">첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1002">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ad3d8-1003">두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1003">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ad3d8-1004">비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1004">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ad3d8-1005">`indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1005">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ad3d8-1006">비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1006">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ad3d8-1007">예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1007">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ad3d8-1008">단어 정렬 규칙을 사용 하 여 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1008">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ad3d8-1009">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1009">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-1010">문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1010">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ad3d8-1011">자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1011">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ad3d8-1012">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1012">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-1013">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1013">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-1014">같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1014">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ad3d8-1015">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1015">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-1016">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1016">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-1017">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1017">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-1018">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1018">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 <span data-ttu-id="ad3d8-1019">"file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1019">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-1020">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1020">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1021">다음 예제에서는 두 부분 문자열을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1021">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1022"><paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1022"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1023">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1023">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1024"><paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1024"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1025">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1025">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1026"><paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1026"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-1027">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1027">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1028"><paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1028">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1029">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1029">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-1030"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1030">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1031">비교에는 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 값을 지정 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1031">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-1032">비교에 사용할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1032">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ad3d8-1033"><c>strA</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1033">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-1034">비교에 사용할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1034">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ad3d8-1035"><c>strB</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1035">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-1036">비교할 부분 문자열의 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1036">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="ad3d8-1037">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1037"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1038">대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1038">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1039">두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1039">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-1040"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1040"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1041"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1041"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1042"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1042"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1043"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1043"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-1044"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1044"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1045"></term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1045"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="ad3d8-1046"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1046"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1047"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1047"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1048">비교할 부분 문자열 시작 `strA` 에서 `indexA`, 및 `strB` 에서 `indexB`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1048">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="ad3d8-1049">둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 는 위치 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1049">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="ad3d8-1050">첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1050">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ad3d8-1051">두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1051">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ad3d8-1052">비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1052">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ad3d8-1053">`indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1053">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ad3d8-1054">비교 현재 문화권을 사용 하 여 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1054">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ad3d8-1055">예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1055">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ad3d8-1056">단어 정렬 규칙을 사용 하 여 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1056">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ad3d8-1057">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1057">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ad3d8-1058">문자열을 비교할 때 호출 해야는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드에서 사용 하는 문자열 비교의 형식을 명시적으로 지정 하는 시켜야 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1058">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ad3d8-1059">자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1059">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ad3d8-1060">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1060">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-1061">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1061">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-1062">같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1062">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ad3d8-1063">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1063">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-1064">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1064">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-1065">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1065">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-1066">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1066">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 <span data-ttu-id="ad3d8-1067">경로 이름을 고정 방식에서 비교 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1067">The path name needs to be compared in an invariant manner.</span></span> <span data-ttu-id="ad3d8-1068">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1068">The correct code to do this is as follows.</span></span>  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1069">다음 예제에서는 대/소문자만 다른 두 개의 부분 두 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1069">The following example performs two comparisons of two substrings that only differ in case.</span></span> <span data-ttu-id="ad3d8-1070">첫 번째 비교는 대/소문자를 무시 하 고 두 번째 비교는 대/소문자를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1070">The first comparison ignores case and the second comparison considers case.</span></span>  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1071"><paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1071"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1072">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1072">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1073"><paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1073"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1074">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1074">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1075"><paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1075"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-1076">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1076">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1077"><paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1077">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1078">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1078">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-1079"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1079">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1080">비교에는 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 값을 지정 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1080">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-1081">비교에 사용할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1081">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ad3d8-1082"><c>strA</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1082">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-1083">비교에 사용할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1083">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ad3d8-1084"><c>strB</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1084">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-1085">비교할 부분 문자열의 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1085">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-1086">비교에 사용할 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1086">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1087">지정된 규칙을 사용하여 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1087">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1088">두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1088">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-1089"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1089"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1090"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1090"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1091"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1091"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1092"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1092"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-1093"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1093"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1094"></term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1094"></term><description> The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.</span></span>  
  
 <span data-ttu-id="ad3d8-1095"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1095"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1096"></term><description> <paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1096"></term><description> The substring in <paramref name="strA" /> follllows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1097">비교할 부분 문자열 시작 `strA` 에서 `indexA` 및 `strB` 에서 `indexB`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1097">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="ad3d8-1098">둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 0, 하나를 배치 하지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1098">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="ad3d8-1099">첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1099">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ad3d8-1100">두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1100">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ad3d8-1101">비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1101">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ad3d8-1102">`indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1102">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ad3d8-1103">`comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 대상의 대/소문자 무시 (문화권 구분) 단어를 사용 하 여 또는 서 수 (문화권) 정렬 규칙.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1103">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="ad3d8-1104">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1104">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-1105">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1105">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-1106">같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1106">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ad3d8-1107">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1107">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-1108">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1108">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-1109">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1109">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-1110">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1110">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 <span data-ttu-id="ad3d8-1111">"file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1111">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-1112">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1112">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1113">다음 예제에서는 두 부분 문자열을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1113">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1114"><paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1114"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1115">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1115">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1116"><paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1116"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1117">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1117">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1118"><paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1118"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-1119">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1119">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1120"><paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1120">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-1121"><paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1121"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1122">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1122">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-1123"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1123">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1124">비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1124">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-1125">비교에 사용할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1125">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ad3d8-1126"><c>strA</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1126">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-1127">비교에 사용할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1127">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ad3d8-1128"><c>strB</c>에 있는 부분 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1128">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-1129">비교할 부분 문자열의 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1129">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="ad3d8-1130">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1130"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ad3d8-1131">문화권별 비교 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1131">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1132">대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다. 문화권별 정보가 비교에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1132">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1133">두 비교 대상 간의 어휘 관계를 나타내는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1133">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-1134"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1134"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1135"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1135"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1136"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1136"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1137"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1137"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-1138"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1138"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1139"></term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1139"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="ad3d8-1140"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1140"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1141"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1141"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1142">비교할 부분 문자열 시작 `strA` 에서 `indexA`, 및 `strB` 에서 `indexB`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1142">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="ad3d8-1143">둘 다 `indexA` 및 `indexB` 0부터 시작 됩니다; 즉, 첫 번째 문자의 `strA` 및 `strB` 0, 하나를 배치 하지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1143">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="ad3d8-1144">첫 번째 부분 문자열의 길이 길이의 `strA` 뺀 `indexA` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1144">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ad3d8-1145">두 번째 부분 문자열의 길이 길이의 `strB` 뺀 `indexB` 1을 더한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1145">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ad3d8-1146">비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1146">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ad3d8-1147">`indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1147">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ad3d8-1148">비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자의 알파벳 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1148">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ad3d8-1149">예를 들어, 특정 문자 조합을 단일 문자로 처리 또는 대문자 및 소문자 특별 한 방식에서으로 비교는 culture 지정할 수 또는 정렬 순서는 문자 앞에 있는 문자에 따라 달라 지 또는 이 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1149">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ad3d8-1150">단어 정렬 규칙을 사용 하 여 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1150">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ad3d8-1151">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1151">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ad3d8-1152">하나 또는 둘 다 비교 대상이 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1152">One or both comparands can be `null`.</span></span> <span data-ttu-id="ad3d8-1153">기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조; 보다 큰 것으로 간주 서로 다른 두 개의 null 참조 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1153">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-1154">같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1154">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ad3d8-1155">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 다음 문자가 남아 있는 문자열은 큰 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1155">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-1156">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1156">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ad3d8-1157">비교는 대/소문자 culture 별 규칙에 의해 영향을 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1157">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ad3d8-1158">예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "file"의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1158">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 <span data-ttu-id="ad3d8-1159">"file"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1159">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ad3d8-1160">이 작업을 수행 하는 올바른 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1160">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1161">다음 예제에서는 서로 다른 문화권을 사용 하 고 부분 문자열의 대/소문자를 무시 두 부분 문자열을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1161">The following example compares two substrings using different cultures and ignoring the case of the substrings.</span></span> <span data-ttu-id="ad3d8-1162">문화권 선택에 "어떻게 문자 I"가 영향을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1162">The choice of culture affects how the letter "I" is compared.</span></span>  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1163"><paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1163"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1164">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1164">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1165"><paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1165"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1166">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1166">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1167"><paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1167"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-1168">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1168">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1169"><paramref name="strA" /> 또는 <paramref name="strB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1169">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1170"><paramref name="culture" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1170"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1171">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1171">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-1172"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1172">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1173">비교에는 무시할 수 있는 문자를 인식 하려면 호출는 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드 값을 지정 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1173">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-1174">비교에 사용할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1174">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ad3d8-1175"><c>strA</c>에 있는 부분 문자열의 시작 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1175">The starting position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-1176">비교에 사용할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1176">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ad3d8-1177"><c>strB</c>에 있는 부분 문자열의 시작 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1177">The starting position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-1178">비교할 부분 문자열의 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1178">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="ad3d8-1179">문화권별 비교 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1179">An object that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="ad3d8-1180">대/소문자 또는 기호 무시 여부와 같이 비교를 수행할 때 사용할 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1180">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="ad3d8-1181">지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 부분 문자열 간의 관계를 나타내는 정수를 반환합니다. 지정된 비교 옵션 및 문화권별 정보가 비교에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1181">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1182">다음 표와 같이 두 부분 문자열 간의 어휘 관계를 나타내는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1182">An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</span></span>  
  
 <span data-ttu-id="ad3d8-1183"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1183"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1184"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1184"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1185"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1185"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1186"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1186"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="ad3d8-1187"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1187"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1188"></term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1188"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="ad3d8-1189"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1189"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1190"></term><description> <paramref name="strA" /> 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1190"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1191">비교할 부분 문자열 시작 `strA` 위치의 `indexA` 및 `strB` 위치의 `indexB`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1191">The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`.</span></span> <span data-ttu-id="ad3d8-1192">첫 번째 부분 문자열의 길이의 길이 `strA` 뺀 `indexA`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1192">The length of the first substring is the length of `strA` minus `indexA`.</span></span> <span data-ttu-id="ad3d8-1193">두 번째 부분 문자열의 길이의 길이 `strB` 뺀 `indexB`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1193">The length of the second substring is the length of `strB` minus `indexB`.</span></span>  
  
 <span data-ttu-id="ad3d8-1194">비교할 문자 수는 두 부분 문자열의 길이가 더 작은 값 및 `length`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1194">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ad3d8-1195">`indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1195">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ad3d8-1196">비교는 `culture` 매개 변수 대/소문자 규칙 및 개별 문자 사전 순서 등의 문화권 관련 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1196">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="ad3d8-1197">예를 들어 특정 문화권 수 특정 문자 조합을 단일 문자로 취급 될, 대 / 소문자에 특정 한 방식으로 비교할 수 또는 지정 정렬 순서는 문자는 문자에 따라 달라 지는 앞 이나 뒤 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1197">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ad3d8-1198"><xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1198">The <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ad3d8-1199">메서드 호출의 주요 목적은 (즉, 메서드 호출의 목적은 인 경우 반환 값 0에 대 한 테스트) 두 부분 문자열 동일한 지 여부를 결정 하는 경우 하지 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1199">It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="ad3d8-1200">두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1200">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ad3d8-1201">하나 또는 둘 다 `strA` 및 `strB` 수 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1201">One or both of `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ad3d8-1202">기본적으로 모든 문자열을 포함 하 여 <xref:System.String.Empty?displayProperty=nameWithType>, null 참조와 두 개의 null 참조 보다 큰 것으로 간주 서로 같다고 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1202">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ad3d8-1203">비교를 추가로 지정할 수는 `options` 의 하나 이상의 구성원으로 구성 되는 매개 변수는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1203">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="ad3d8-1204">그러나이 메서드는 문화권 구분 문자열 비교를 수행 하 고 이기 때문에 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 값은 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1204">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="ad3d8-1205">같지 않음이 검색 또는 두 부분 문자열 비교를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1205">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ad3d8-1206">그러나 두 문자열이 한 문자열의 끝을 비교 하는 경우 다른 문자열에 문자가 남아 있는 나머지 문자로 문자열 큰 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1206">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span> <span data-ttu-id="ad3d8-1207">반환 값은 마지막으로 수행한 비교의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1207">The return value is the result of the last comparison performed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1208">다음 예제에서는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 메서드를 마지막 두 사용자 이름을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1208">The following example uses the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method to compare the last names of two people.</span></span> <span data-ttu-id="ad3d8-1209">사전순에서으로 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1209">It then lists them in alphabetical order.</span></span>  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-1210"><paramref name="options" />이 <see cref="T:System.Globalization.CompareOptions" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1210"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1211"><paramref name="indexA" />가 <paramref name="strA" /><see langword=".Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1211"><paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1212">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1212">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1213"><paramref name="indexB" />가 <paramref name="strB" /><see langword=".Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1213"><paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1214">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1214">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1215"><paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1215"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-1216">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1216">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1217"><paramref name="strA" /> 또는 <paramref name="strB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1217">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1218"><paramref name="culture" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1218"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1219">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1219">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-1220"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드는 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1220">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1221">비교에는 무시할 수 있는 문자를 인식 하려면의 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1221">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1222">각 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산해서 두 <see cref="T:System.Char" /> 개체를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1222">Compares two <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-1223">비교할 첫째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1223">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-1224">비교할 둘째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1224">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1225">각 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산해서 두 지정된 <see cref="T:System.Char" /> 개체를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1225">Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1226">두 비교 대상 간의 어휘 관계를 나타내는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1226">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-1227"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1227"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1228"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1228"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1229"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1229"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1230"></term><description><paramref name="strA" />가 <paramref name="strB" />보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1230"></term><description><paramref name="strA" /> is less than <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1231"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1231"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1232"></term><description><paramref name="strA" />와 <paramref name="strB" />가 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1232"></term><description><paramref name="strA" /> and <paramref name="strB" /> are equal.</span></span>  
  
 <span data-ttu-id="ad3d8-1233"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1233"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1234"></term><description><paramref name="strA" />가 <paramref name="strB" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1234"></term><description><paramref name="strA" /> is greater than <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1235">이 메서드는 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1235">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="ad3d8-1236">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1236">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-1237">정렬 서 수 규칙을 사용 하 여 대/소문자 구분 비교를 수행 하려면 호출는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드는 `comparisonType` 인수로 설정 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1237">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ad3d8-1238">때문에 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 정적 메서드입니다 `strA` 및 `strB` 수 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1238">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ad3d8-1239">두 값이 `null`, 메서드가 반환 한다는 0 (영) `strA` 및 `strB` 같은지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1239">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="ad3d8-1240">하나만 값 중 하나 이면 `null`, 메서드는 큰 값으로 null이 아닌 값을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1240">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1241">다음 예제를 수행 하 고 문자열 2의 서 수 비교에서 대/소문자만 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1241">The following example performs and ordinal comparison of two strings that only differ in case.</span></span>  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ad3d8-1242">비교에 사용할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1242">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ad3d8-1243"><c>strA</c>에 있는 부분 문자열의 시작 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1243">The starting index of the substring in <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="ad3d8-1244">비교에 사용할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1244">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ad3d8-1245"><c>strB</c>에 있는 부분 문자열의 시작 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1245">The starting index of the substring in <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-1246">비교할 부분 문자열의 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1246">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1247">각 부분 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산하여 지정된 두 <see cref="T:System.Char" /> 개체의 부분 문자열을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1247">Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1248">두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1248">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="ad3d8-1249"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1249"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1250"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1250"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1251"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1251"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1252"></term><description> <paramref name="strA" />의 부분 문자열이 <paramref name="strB" />의 부분 문자열보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1252"></term><description> The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1253"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1253"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1254"></term><description> 부분 문자열이 같거나 <paramref name="length" />가 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1254"></term><description> The substrings are equal, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="ad3d8-1255"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1255"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1256"></term><description> <paramref name="strA" />의 부분 문자열이 <paramref name="strB" />의 부분 문자열보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1256"></term><description> The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1257">`indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1257">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ad3d8-1258">비교 하는 문자 수는 길이의 기간은 `strA` 덜 `indexA`, 길이의 `strB` 덜 `indexB`, 및 `length`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1258">The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.</span></span>  
  
 <span data-ttu-id="ad3d8-1259">이 메서드는 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1259">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="ad3d8-1260">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1260">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-1261">정렬 서 수 규칙을 사용 하 여 대/소문자 구분 비교를 수행 하려면 호출는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드는 `comparisonType` 인수로 설정 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1261">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ad3d8-1262">때문에 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 정적 메서드입니다 `strA` 및 `strB` 수 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1262">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ad3d8-1263">두 값이 `null`, 메서드가 반환 한다는 0 (영) `strA` 및 `strB` 같은지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1263">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="ad3d8-1264">하나만 값 중 하나 이면 `null`, 메서드는 큰 값으로 null이 아닌 값을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1264">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1265">다음 예제에서는 <xref:System.String.CompareOrdinal%2A> 및 <xref:System.String.Compare%2A> 서로 다른 정렬 순서를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1265">This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.</span></span>  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1266"><paramref name="strA" />가 <see langword="null" />이 아니고, <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1266"><paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1267">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1267">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1268"><paramref name="strB" />가 <see langword="null" />이 아니고, <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1268"><paramref name="strB" /> is not <see langword="null" /> and <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1269">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1269">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1270"><paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1270"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span></exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1271">이 인스턴스를 지정된 개체 또는 <see cref="T:System.String" />과 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 개체 또는 <see cref="T:System.String" />보다 앞인지, 뒤인지 또는 동일한지를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1271">Compares this instance with a specified object or <see cref="T:System.String" /> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <see cref="T:System.String" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1272">메서드의 두 오버 로드는 <xref:System.String.CompareTo%2A> 메서드는 문화권 구분 및 대/소문자 구분 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1272">Both overloads of the <xref:System.String.CompareTo%2A> method perform culture-sensitive and case-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1273">문화권을 구분 하지 않는 또는 서 수 비교를 수행 하려면이 메서드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1273">You cannot use this method to perform culture-insensitive or ordinal comparisons.</span></span> <span data-ttu-id="ad3d8-1274">코드의 명확성을 권장 하지는 <xref:System.String.CompareTo%2A> 메서드와 호출은 <xref:System.String.Compare%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1274">For code clarity, we recommend that you avoid the <xref:System.String.CompareTo%2A> method and call the <xref:System.String.Compare%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1275"><see cref="T:System.String" />이 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1275">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1276">이 인스턴스를 지정된 <see cref="T:System.Object" />와 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 <see cref="T:System.Object" />보다 앞인지, 뒤인지 또는 동일한지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1276">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1277">정렬 순서에서 이 인스턴스의 위치가 <paramref name="value" /> 매개 변수보다 앞인지, 뒤인지 또는 동일한지를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1277">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>  
  
 <span data-ttu-id="ad3d8-1278"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1278"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1279"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1279"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1280"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1280"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1281"></term><description> 이 인스턴스가 <paramref name="value" /> 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1281"></term><description> This instance precedes <paramref name="value" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1282"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1282"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1283"></term><description> 이 인스턴스의 위치가 정렬 순서에서 <paramref name="value" />와 같은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1283"></term><description> This instance has the same position in the sort order as <paramref name="value" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1284"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1284"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1285"></term><description> 이 인스턴스가 <paramref name="value" /> 다음에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1285"></term><description> This instance follows <paramref name="value" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1286">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1286">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1287"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1287"><paramref name="value" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1288">`value` 있어야는 <xref:System.String> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1288">`value` must be a <xref:System.String> object.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ad3d8-1289"><xref:System.String.CompareTo%2A> 메서드 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1289">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ad3d8-1290">메서드 호출의 주요 목적은 두 문자열이 같은지 여부를 결정 하는 경우 하지 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1290">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="ad3d8-1291">두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1291">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ad3d8-1292">이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1292">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="ad3d8-1293">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1293">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ad3d8-1294">이 방법의 동작에 대 한 자세한 내용은 설명 부분을 참조 하십시오.는 <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1294">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1295">다음 예제에서는 <xref:System.String.CompareTo%2A> 메서드는 <xref:System.Object>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1295">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="ad3d8-1296">비교 하려고 했기 때문에 <xref:System.String> 인스턴스는 `TestClass` 메서드에서 throw 개체는 <xref:System.ArgumentException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1296">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-1297"><paramref name="value" />가 <see cref="T:System.String" />가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1297"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1298">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1298">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-1299"><see cref="M:System.String.CompareTo(System.Object)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1299">The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1300">예를 들어, 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물" "ani 메일" (소프트 하이픈 또는 U + 00AD 사용)와 비교 두 문자열은 해당을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1300">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  
  
 <span data-ttu-id="ad3d8-1301">문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출 된 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1301">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB"><span data-ttu-id="ad3d8-1302">이 인스턴스와 비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1302">The string to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1303">이 인스턴스를 지정된 <see cref="T:System.String" /> 개체와 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 문자열보다 앞인지, 뒤인지 또는 동일한지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1303">Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1304">정렬 순서에서 이 인스턴스의 위치가 <paramref name="strB" /> 매개 변수보다 앞인지, 뒤인지 또는 동일한지를 나타내는 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1304">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.</span></span>  
  
 <span data-ttu-id="ad3d8-1305"><list type="table"><listheader><term> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1305"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="ad3d8-1306"></term><description> 조건</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1306"></term><description> Condition</span></span>  
  
 <span data-ttu-id="ad3d8-1307"></description></listheader><item><term> 0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1307"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1308"></term><description> 이 인스턴스가 <paramref name="strB" /> 앞에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1308"></term><description> This instance precedes <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1309"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1309"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="ad3d8-1310"></term><description> 이 인스턴스의 위치가 정렬 순서에서 <paramref name="strB" />와 같은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1310"></term><description> This instance has the same position in the sort order as <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1311"></description></item><item><term> 0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1311"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="ad3d8-1312"></term><description> 이 인스턴스가 <paramref name="strB" /> 다음에 오는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1312"></term><description> This instance follows <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="ad3d8-1313">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1313">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1314"><paramref name="strB" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1314"><paramref name="strB" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1315">이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1315">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="ad3d8-1316">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1316">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ad3d8-1317"><xref:System.String.CompareTo%2A> 메서드 정렬 또는 작업을 사전순으로 정렬에 사용 하기 위해 주로 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1317">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ad3d8-1318">메서드 호출의 주요 목적은 두 문자열이 같은지 여부를 결정 하는 경우 하지 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1318">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="ad3d8-1319">두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1319">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ad3d8-1320">이 방법의 동작에 대 한 자세한 내용은 설명 부분을 참조 하십시오.는 <xref:System.String.Compare%28System.String%2CSystem.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1320">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.</span></span>  
  
 <span data-ttu-id="ad3d8-1321">이 메서드를 구현 하는 <xref:System.IComparable%601?displayProperty=nameWithType> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> 메서드를 확인할 필요가 없기 때문에 여부는 `strB` 인수 box 수 해야 하는 변경할 수 있는 값 형식 이므로 캐스팅 하지 않아도 해당 매개 변수는 <xref:System.Object> 에 <xref:System.String>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1321">This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object> to a <xref:System.String>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1322">다음 예제에서는 <xref:System.String.CompareTo%2A> 메서드를 다른 문자열로 사용 하 여 현재 문자열 인스턴스를 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1322">The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.</span></span>  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 <span data-ttu-id="ad3d8-1323">다음 예제에서는 제네릭 및 제네릭이 아닌 여러 값 및 참조 형식에 대 한 버전을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1323">The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</span></span>  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1324">문자 집합에는 무시할 수 있는 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1324">Character sets include ignorable characters.</span></span> <span data-ttu-id="ad3d8-1325"><see cref="M:System.String.CompareTo(System.String)" /> 메서드는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1325">The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1326">예를 들어, 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 "동물" "ani 메일" (소프트 하이픈 또는 U + 00AD 사용)와 비교 두 문자열은 해당을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1326">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  
  
 <span data-ttu-id="ad3d8-1327">문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출 된 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1327">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1328"><see cref="T:System.String" />의 인스턴스를 하나 이상 연결하거나 <see cref="T:System.String" />의 인스턴스 값에 해당하는 <see cref="T:System.Object" /> 표현을 하나 이상 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1328">Concatenates one or more instances of <see cref="T:System.String" />, or the <see cref="T:System.String" /> representations of the values of one or more instances of <see cref="T:System.Object" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="ad3d8-1329"><see cref="T:System.Collections.Generic.IEnumerable`1" />을 구현하고 제네릭 형식 인수가 <see cref="T:System.String" />인 컬렉션 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1329">A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1330"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 형식의 생성된 <see cref="T:System.String" /> 컬렉션의 멤버를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1330">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1331"><paramref name="values" />의 연결된 문자열이거나, <paramref name="values" />가 빈 <see langword="IEnumerable(Of String)" />이면 <see cref="F:System.String.Empty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1331">The concatenated strings in <paramref name="values" />, or <see cref="F:System.String.Empty" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1332">각 개체에 연결 하는 메서드가 `values`; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1332">The method concatenates each object in `values`; it does not add any delimiters.</span></span> <span data-ttu-id="ad3d8-1333">각 멤버 사이 구분 기호를 지정 하려면 `values`, 호출 된 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1333">To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="ad3d8-1334"><xref:System.String.Empty> 문자열에서 null 요소 대신 사용 됩니다 `values`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1334">An <xref:System.String.Empty> string is used in place of any null element in `values`.</span></span>  
  
 <span data-ttu-id="ad3d8-1335">경우 `values` 은 빈 `IEnumerable(Of String)`, 메서드가 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1335">If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-1336">경우 `values` 은 `null`, 메서드에서 throw 된 <xref:System.ArgumentNullException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1336">If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.</span></span>  
  
 <span data-ttu-id="ad3d8-1337"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 각 요소에 연결할 수 있는 편리한 메서드입니다는 `IEnumerable(Of String)` 먼저 문자열 배열에 요소를 변환 하지 않고 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1337"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="ad3d8-1338">LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1338">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ad3d8-1339">다음 예제에서는 전달 된 `List(Of String)` 알파벳 문자 (즉, 예제에서는 "M")를 특정 문자 보다 크거나 같은 선택 하는 람다 식에 대 / 소문자 구분 문자가 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1339">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="ad3d8-1340">`IEnumerable(Of String)` 에서 반환 되는 컬렉션은 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 메서드에 전달 되는 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 단일 문자열 결과 표시 하려면 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1340">The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1341">다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1341">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ad3d8-1342">결과를 할당 한 <xref:System.Collections.Generic.List%601> 형식의 개체 <xref:System.String>에 전달 되는 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1342">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1343"><paramref name="values" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1343"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ad3d8-1344">나타낼 개체나 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1344">The object to represent, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1345">지정된 개체의 문자열 표현을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1345">Creates the string  representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1346"><paramref name="arg0" />이 <see cref="F:System.String.Empty" />인 경우 <paramref name="arg0" /> 또는 <see langword="null" /> 값의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1346">The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1347"><xref:System.String.Concat%28System.Object%29> 메서드가 `arg0` 는 매개 변수가 없는 호출 하 여 문자열로 `ToString` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1347">The <xref:System.String.Concat%28System.Object%29> method represents `arg0` as a string by calling its parameterless `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1348">다음 예제는 <xref:System.String.Concat%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1348">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="ad3d8-1349">연결할 요소가 포함된 개체 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1349">An object array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1350">지정된 <see cref="T:System.Object" /> 배열에 있는 요소의 문자열 표현을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1350">Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1351"><paramref name="args" />에 있는 요소 값의 연결된 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1351">The concatenated string representations of the values of the elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1352">각 개체에 연결 하는 메서드가 `args` 매개 변수가 없는 호출 하 여 `ToString` 해당 개체의 메서드 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1352">The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ad3d8-1353"><xref:System.String.Empty?displayProperty=nameWithType> 배열에 있는 빈 개체 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1353"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1354">다음 예제에서는 <xref:System.String.Concat%2A> 메서드는 <xref:System.Object> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1354">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.</span></span>  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1355"><paramref name="args" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1355"><paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ad3d8-1356">메모리가 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1356">Out of memory.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1357">C + + 코드에서이 메서드는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1357">This method is not called by C++ code.</span></span> <span data-ttu-id="ad3d8-1358">C + + 컴파일러에 대 한 호출을 해결 <see cref="Overload:System.String.Concat" /> 개체 매개 변수 4 개 이상에 대 한 호출으로 있는 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1358">The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</span></span></para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="ad3d8-1359">문자열 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1359">An array of string instances.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1360">지정된 <see cref="T:System.String" /> 배열의 요소를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1360">Concatenates the elements of a specified <see cref="T:System.String" /> array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1361"><paramref name="values" />의 연결된 요소를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1361">The concatenated elements of <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1362">각 개체에 연결 하는 메서드가 `values`; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1362">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ad3d8-1363"><xref:System.String.Empty> 문자열 배열에 있는 빈 개체 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1363">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1364">다음 예제에서는 <xref:System.String.Concat%2A> 메서드는 <xref:System.String> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1364">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.</span></span>  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1365"><paramref name="values" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1365"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ad3d8-1366">메모리가 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1366">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ad3d8-1367">연결할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1367">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ad3d8-1368">연결할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1368">The second object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1369">지정된 두 개체의 문자열 표현을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1369">Concatenates the string representations of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1370"><paramref name="arg0" /> 및 <paramref name="arg1" /> 값의 연결된 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1370">The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1371">메서드를 연결 `arg0` 및 `arg1` 매개 변수가 없는 호출 하 여 `ToString` 방식의 `arg0` 및 `arg1`; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1371">The method concatenates `arg0` and `arg1` by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ad3d8-1372"><xref:System.String.Empty?displayProperty=nameWithType> null 인수를 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1372"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="ad3d8-1373">경우 인수는 배열 참조, 해당 멤버 (예를 들어 "System.String[]") 대신 해당 배열을 나타내는 문자열을 연결 하는 메서드 중 하나.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1373">If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1374">다음 예제는 <xref:System.String.Concat%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1374">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ad3d8-1375">연결할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1375">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ad3d8-1376">연결할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1376">The second string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1377"><see cref="T:System.String" />의 지정된 두 인스턴스를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1377">Concatenates two specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1378">연결된 <paramref name="str0" /> 및 <paramref name="str1" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1378">The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1379">메서드를 연결 `str0` 및 `str1`; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1379">The method concatenates `str0` and `str1`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-1380">사용할 수도 있습니다 해당 언어의 문자열 연결 연산자와 같은 `+` C# 또는 `&` 및 `+` Visual basic에서)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1380">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="ad3d8-1381">문자열을 연결 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1381">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="ad3d8-1382"><xref:System.String.Empty> null 인수 문자열이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1382">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1383">다음 예제에서는 사용자의 이름 및 마지막을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1383">The following example concatenates a person's first, middle, and last name.</span></span>  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ad3d8-1384">연결할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1384">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ad3d8-1385">연결할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1385">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="ad3d8-1386">연결할 세 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1386">The third object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1387">지정된 세 개체의 문자열 표현을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1387">Concatenates the string representations of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1388"><paramref name="arg0" />, <paramref name="arg1" /> 및 <paramref name="arg2" /> 값의 연결된 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1388">The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1389">메서드를 연결 `arg0`, `arg1`, 및 `arg2` 매개 변수가 없는 호출 하 여 `ToString` ; 각 개체의 모든 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1389">The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ad3d8-1390"><xref:System.String.Empty?displayProperty=nameWithType> null 인수를 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1390"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1391">다음 예제는 <xref:System.String.Concat%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1391">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ad3d8-1392">연결할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1392">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ad3d8-1393">연결할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1393">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ad3d8-1394">연결할 세 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1394">The third string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1395"><see cref="T:System.String" />의 지정된 세 인스턴스를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1395">Concatenates three specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1396">연결된 <paramref name="str0" />, <paramref name="str1" /> 및 <paramref name="str2" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1396">The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1397">메서드를 연결 `str0`, `str1`, 및 `str2`; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1397">The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-1398">사용할 수도 있습니다 해당 언어의 문자열 연결 연산자와 같은 `+` C# 또는 `&` 및 `+` Visual basic에서)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1398">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="ad3d8-1399">문자열을 연결 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1399">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="ad3d8-1400"><xref:System.String.Empty> null 인수 문자열이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1400">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1401">다음 예제에서는 <xref:System.String.Concat%2A> 메서드 3 개를 연결 하는 문자열 및 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1401">The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.</span></span>  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ad3d8-1402">연결할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1402">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ad3d8-1403">연결할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1403">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="ad3d8-1404">연결할 세 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1404">The third object to concatenate.</span></span></param>
        <param name="arg3"><span data-ttu-id="ad3d8-1405">연결할 네 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1405">The fourth object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1406">지정된 네 개체의 문자열 표현과 선택적 변수 길이 매개 변수 목록에 지정된 개체를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1406">Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1407">매개 변수 목록에서 각 값의 연결된 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1407">The concatenated string representation of each value in the parameter list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-1408">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1408">This API is not CLS-compliant.</span></span> <span data-ttu-id="ad3d8-1409">CLS 규격 대체 항목은 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1409">The CLS-compliant alternative is <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-1410">C# 및 Visual Basic 컴파일러에 대 한 호출으로이 메서드에 대 한 호출을 자동으로 해결 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1410">The C# and Visual Basic compilers automatically resolve a call to this method as a call to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ad3d8-1411">메서드는 매개 변수가 없는 호출 하 여 매개 변수 목록에 있는 각 개체를 연결 `ToString` 메서드; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1411">The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ad3d8-1412"><xref:System.String.Empty?displayProperty=nameWithType> null 인수를 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1412"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-1413">마지막 매개 변수는 <xref:System.String.Concat%2A> 메서드는 연결할 하나 이상의 추가 개체의 선택적 쉼표로 구분 된 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1413">The last parameter of the  <xref:System.String.Concat%2A> method is an optional comma-delimited list of one or more additional objects to concatenate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1414">다음 예제에서는 <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 메서드 목록을 연결 하는 가변 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1414">The following example illustrates the use of the <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to concatenate a list of variable parameters.</span></span> <span data-ttu-id="ad3d8-1415">이 경우 9 개의 매개 변수가 있는 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1415">In this case, the method is called with nine parameters.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1416">이 메서드가로 표시 된 <see langword="vararg" /> 키워드 가변 개수의 매개 변수를 지원 한다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1416">This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters.</span></span> <span data-ttu-id="ad3d8-1417">Visual c + +에서 메서드를 호출할 수 있지만 C# 또는 Visual Basic 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1417">The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</span></span> <span data-ttu-id="ad3d8-1418">C# 및 Visual Basic 컴파일러에 대 한 호출을 해결 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> 에 호출로 <see cref="M:System.String.Concat(System.Object[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1418">The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ad3d8-1419">연결할 첫 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1419">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ad3d8-1420">연결할 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1420">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ad3d8-1421">연결할 세 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1421">The third string to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="ad3d8-1422">연결할 네 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1422">The fourth string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1423"><see cref="T:System.String" />의 지정된 네 인스턴스를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1423">Concatenates four specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1424">연결된 <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> 및 <paramref name="str3" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1424">The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1425">메서드를 연결 `str0`, `str1`, `str2`, 및 `str3`; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1425">The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-1426">사용할 수도 있습니다 해당 언어의 문자열 연결 연산자와 같은 `+` C# 또는 `&` 및 `+` Visual basic에서)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1426">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="ad3d8-1427">문자열을 연결 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1427">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="ad3d8-1428"><xref:System.String.Empty> 문자열 배열에 있는 빈 개체 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1428">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1429">다음 예제에서는 네 문자로 된 단어의 배열을 정의 하 고 스크램블 하기 위해 문자열 배열에 개별 문자를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1429">The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</span></span> <span data-ttu-id="ad3d8-1430">그런 다음 호출 하 여 <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> 메서드가를 다시 암호화 된 단어를 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1430">It then calls the <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> method to reassemble the scrambled words.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ad3d8-1431">구성원 유형을 <c>값</c>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1431">The type of the members of <c>values</c>.</span></span></typeparam>
        <param name="values"><span data-ttu-id="ad3d8-1432"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 인터페이스를 구현하는 컬렉션 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1432">A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1433"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 구현의 멤버를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1433">Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1434"><paramref name="values" />의 연결된 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1434">The concatenated members in <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1435">각 개체에 연결 하는 메서드가 `values`; 구분 기호를 추가 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1435">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ad3d8-1436"><xref:System.String.Empty> null 인수 문자열이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1436">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="ad3d8-1437"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 각 요소에 연결할 수 있는 편리한 메서드입니다는 <xref:System.Collections.Generic.IEnumerable%601> 먼저 요소를 문자열로 변환 하지 않고 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1437"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each element in an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting the elements to strings.</span></span> <span data-ttu-id="ad3d8-1438">것은 예제와 같이 LINQ (Language-Integrated Query) 쿼리 식, 특히 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1438">It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</span></span> <span data-ttu-id="ad3d8-1439">에 있는 각 개체의 문자열 표현을 <xref:System.Collections.Generic.IEnumerable%601> 해당 개체를 호출 하 여 파생 된 컬렉션은 `ToString` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1439">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1440">다음 예제에서는 매우 간단한 정의 `Animal` 동물 속해 있는 주문의 이름을 포함 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1440">The following example defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="ad3d8-1441">그런 다음 정의 <xref:System.Collections.Generic.List%601> 개체의 번호를 포함 하도록 `Animal` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1441">It then defines a <xref:System.Collections.Generic.List%601> object to contain a number of `Animal` objects.</span></span> <span data-ttu-id="ad3d8-1442"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 확장 메서드를 호출을 추출 하는 `Animal` 개체 `Order` 속성 "설치류" 값은입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1442">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="ad3d8-1443">결과에 전달 되는 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드 및 콘솔에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1443">The result is passed to the <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method and displayed to the console.</span></span>  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1444"><paramref name="values" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1444"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1445">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1445">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1446">이 문자열 내에서 지정한 하위 문자열이 발생하는지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1446">Returns a value indicating whether a specified substring occurs within this string.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1447">이 문자열 내에서 <see langword="true" /> 매개 변수가 발생하거나 <paramref name="value" />가 빈 문자열("")이면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1447"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1448">이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1448">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span> <span data-ttu-id="ad3d8-1449">검색이이 문자열의 첫 번째 문자 위치에서 시작 하 고 마지막 문자 위치를 통해 계속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1449">The search begins at the first character position of this string and continues through the last character position.</span></span>  
  
 <span data-ttu-id="ad3d8-1450">문자열로 여부를 확인 하려면 이외의 노드 (예: 문화권 구분 비교 또는 대/소문자 비구분 서 수 비교)는 서 수 비교를 사용 하 여 지정된 된 부분 문자열을 포함, 사용자 지정 메서드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1450">To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</span></span> <span data-ttu-id="ad3d8-1451">다음 예제에서는 이러한 방법을 중 하나를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1451">The following example illustrates one such approach.</span></span> <span data-ttu-id="ad3d8-1452">정의 <xref:System.String> 포함 된 확장 메서드는 <xref:System.StringComparison> 매개 변수가 지정 된 형식의 문자열 비교를 사용 하는 경우 부분 문자열을 포함 하는 문자열 인지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1452">It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 <span data-ttu-id="ad3d8-1453">다음 예제에서는 다음 호출에서 `Contains` 확장 메서드를 서 수 비교와 대/소문자 비구분 서 수 비교를 사용 하는 경우 문자열에 부분 문자열은 찾을 지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1453">The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 <span data-ttu-id="ad3d8-1454">하는 경우에 관심이 있는 부분 문자열의 위치 `value` 현재 인스턴스를 호출할 수 있습니다는 <xref:System.String.IndexOf%2A> 여 처음으로 일치의 시작 위치를 가져올 메서드를 호출할 수는 <xref:System.String.LastIndexOf%2A> 메서드를 시작 하는 항목의 위치는 마지막으로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1454">If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence.</span></span> <span data-ttu-id="ad3d8-1455">예제에 대 한 호출에 포함 되어는 <xref:System.String.IndexOf%28System.String%29> 메서드 문자열 인스턴스에서 부분 문자열을 찾은 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1455">The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1456">다음 예제에서는 문자열 "fox" 일반적인 따옴표의 부분 문자열 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1456">The following example determines whether the string "fox" is a substring of a familiar quotation.</span></span> <span data-ttu-id="ad3d8-1457">문자열에서 "fox" 발견 되는 경우 또한 해당 시작 위치를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1457">If "fox" is found in the string, it also displays its starting position.</span></span>  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1458"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1458"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ad3d8-1459">복사할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1459">The string to copy.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1460">지정된 <see cref="T:System.String" />과 동일한 값을 갖는 <see cref="T:System.String" />의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1460">Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1461"><paramref name="str" />과 동일한 값을 갖는 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1461">A new string with the same value as <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1462"><xref:System.String.Copy%2A> 메서드가 반환 되는 <xref:System.String> 개체는 원래 문자열과 같은 값을 가진 하지만 다른 개체 참조를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1462">The <xref:System.String.Copy%2A> method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference.</span></span> <span data-ttu-id="ad3d8-1463">기존 문자열 참조를 추가 개체 변수에 할당 하는 할당 연산에서 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1463">It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</span></span> <span data-ttu-id="ad3d8-1464">이 예제에서는 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1464">The example illustrates the difference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1465">다음 예에서는 값이 서로 다른 두 string 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1465">The following example creates two string objects with different values.</span></span> <span data-ttu-id="ad3d8-1466">호출할 때는 <xref:System.String.Copy%2A> 두 번째 문자열이 첫 번째 값을 할당 하는 메서드 문자열 요소의 값은 이제 동일 하지만 다른 개체 참조를 나타내며 그 결과 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1466">When it calls the <xref:System.String.Copy%2A> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</span></span> <span data-ttu-id="ad3d8-1467">반면에 첫 번째 문자열이 두 번째 문자열에 할당 될 경우 두 문자열 값이 적용 동일한 같은 개체 참조를 나타내므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1467">On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</span></span>  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1468"><paramref name="str" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1468"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="ad3d8-1469">이 인스턴스에서 복사할 첫 번째 문자의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1469">The index of the first character in this instance to copy.</span></span></param>
        <param name="destination"><span data-ttu-id="ad3d8-1470">이 인스턴스의 문자가 복사되는 유니코드 문자의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1470">An array of Unicode characters to which characters in this instance are copied.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="ad3d8-1471"><c>destination</c>에서 복사 작업이 시작되는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1471">The index in <c>destination</c> at which the copy operation begins.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-1472">이 인스턴스에서 <c>destination</c>에 복사할 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1472">The number of characters in this instance to copy to <c>destination</c>.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1473">이 인스턴스의 지정한 위치에 있는 지정한 수의 문자를 유니코드 문자 배열의 특정 위치에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1473">Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1474">이 메서드는 복사 `count` 에서 문자는 `sourceIndex` 를이 인스턴스의 위치는 `destinationIndex` 항목의 위치 `destination` 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1474">This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array.</span></span> <span data-ttu-id="ad3d8-1475">이 메서드는 크기를 조정 하지는 `destination` 문자 배열; 요소 복사한 문자를 포함 하기에 충분 한 수 있어야 또는 메서드에서 throw 된 <xref:System.ArgumentOutOfRangeException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1475">This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="ad3d8-1476">`sourceIndex` 및 `destinationIndex` 0부터 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1476">`sourceIndex` and `destinationIndex` are zero-based.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1477">다음 예제는 <xref:System.String.CopyTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1477">The following example demonstrates the <xref:System.String.CopyTo%2A> method.</span></span>  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1478"><paramref name="destination" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1478"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1479"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />또는 <paramref name="count" />이(가) 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1479"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative</span></span>  
  
 <span data-ttu-id="ad3d8-1480">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1480">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1481"><paramref name="sourceIndex" />이(가) 현재 인스턴스의 위치를 식별하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1481"><paramref name="sourceIndex" /> does not identify a position in the current instance.</span></span>  
  
 <span data-ttu-id="ad3d8-1482">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1482">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1483"><paramref name="destinationIndex" />이(가) <paramref name="destination" /> 배열에서 유효한 인덱스를 식별하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1483"><paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.</span></span>  
  
 <span data-ttu-id="ad3d8-1484">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1484">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1485"><paramref name="count" />이(가) <paramref name="sourceIndex" />부터 이 인스턴스 끝까지의 하위 문자열 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1485"><paramref name="count" /> is greater than the length of the substring from <paramref name="sourceIndex" /> to the end of this instance</span></span>  
  
 <span data-ttu-id="ad3d8-1486">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1486">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1487"><paramref name="count" />이(가) <paramref name="destinationIndex" />부터 <paramref name="destination" /> 배열 끝까지의 하위 문자열 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1487"><paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1488">빈 문자열을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1488">Represents the empty string.</span></span> <span data-ttu-id="ad3d8-1489">이 필드는 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1489">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1490">이 필드의 값은 빈 문자열 ""입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1490">The value of this field is the zero-length string, "".</span></span>  
  
 <span data-ttu-id="ad3d8-1491">응용 프로그램 코드에서이 필드는 가장 일반적으로 할당에 문자열 변수를 빈 문자열로 초기화에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1491">In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</span></span> <span data-ttu-id="ad3d8-1492">문자열의 값 중 하나 인지를 테스트 하려면 `null` 또는 <xref:System.String.Empty?displayProperty=nameWithType>를 사용 하 여는 <xref:System.String.IsNullOrEmpty%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1492">To test whether the value of a string is either `null` or <xref:System.String.Empty?displayProperty=nameWithType>, use the <xref:System.String.IsNullOrEmpty%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1493">이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1493">Determines whether the end of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1494">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1494">The string to compare to the substring at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1495">이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1495">Determines whether the end of this string instance matches the specified string.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1496">이 인스턴스의 끝이 <see langword="true" />와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1496"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1497">이 메서드는 비교 `value` 와 같은 길이가이 인스턴스의 끝에 있는 부분 문자열과 `value`와 같은지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1497">This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="ad3d8-1498">하려면 `value` 동일한이 인스턴스에 대 한 참조 이거나이 인스턴스의 끝과 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1498">To be equal, `value` must be a reference to this same instance or match the end of this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-1499">이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1499">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1500">다음 예제에서는 배열의 각 문자열 마침표로 끝나는 있는지 여부를 나타냅니다 (".").</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1500">The following example indicates whether each string in an array ends with a period (".").</span></span>  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 <span data-ttu-id="ad3d8-1501">다음 예제에서는 정의 `StripEndTags` 메서드를 사용 하는 <xref:System.String.EndsWith%28System.String%29> 메서드 줄의 끝에서 HTML 끝 태그를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1501">The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line.</span></span> <span data-ttu-id="ad3d8-1502">`StripEndTags` 메서드는 재귀적으로 줄의 끝에 HTML 끝 태그를 여러가 제거 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1502">Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</span></span>  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1503"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1503"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1504">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1504">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-1505">확인 하려면 현재 문화권의 문자열 비교 규칙을 사용 하 여 문자열이 특정 하위 문자열로 끝나는지를 호출는 <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1505">To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1506">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1506">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-1507">이 문자열과 <c>value</c>를 비교하는 방법을 결정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1507">One of the enumeration values that determines how this string and <c>value</c> are compared.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1508">지정한 비교 옵션을 사용하여 비교할 때 지정한 문자열과 이 문자열 인스턴스의 끝 부분이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1508">Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1509">이 문자열의 끝이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1509"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1510"><xref:System.String.EndsWith%2A> 메서드 비교는 `value` 이 문자열의 끝에 있는 부분 문자열과 매개 변수가 같은지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1510">The <xref:System.String.EndsWith%2A> method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ad3d8-1511">하려면 `value` 이 동일한 문자열에 대 한 참조 여야, 빈 문자열 이어야 합니다 (""), 또는이 문자열의 끝 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1511">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string.</span></span> <span data-ttu-id="ad3d8-1512">비교를 수행 하 여 유형의 <xref:System.String.EndsWith%2A> 메서드는 값에 따라는 `comparisonType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1512">The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1513">다음 예에서는 문자열이 특정 하위 문자열로 끝나는지를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1513">The following example determines whether a string ends with a particular substring.</span></span> <span data-ttu-id="ad3d8-1514">결과는 문화권, 대/소문자 무시 여부 및 서 수 비교가 수행 되는지 여부는 선택한 항목에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1514">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1515"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1515"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-1516"><paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1516"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1517">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1517">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="ad3d8-1518">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1518"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ad3d8-1519">이 인스턴스와 <c>value</c>의 비교 방법을 결정하는 문화권 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1519">Cultural information that determines how this instance and <c>value</c> are compared.</span></span> <span data-ttu-id="ad3d8-1520"><c>culture</c>가 <see langword="null" />이면 현재 문화권이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1520">If <c>culture</c> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1521">지정한 문화권을 사용하여 비교할 때 이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1521">Determines whether the end of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1522">이 문자열의 끝이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1522"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1523">이 메서드는 비교는 `value` 와 같은 길이가이 문자열의 끝에 있는 부분 문자열과 매개 변수 `value`, 같은지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1523">This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ad3d8-1524">하려면 `value` 동일한이 인스턴스에 대 한 참조 하거나이 문자열의 끝과 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1524">To be equal, `value` must be a reference to this same instance or match the end of this string.</span></span>  
  
 <span data-ttu-id="ad3d8-1525">이 메서드는 지정 된 대/소문자 및 문화권을 사용 하 여 단어 (문화권별) 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1525">This method performs a word (culture-sensitive) comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1526">다음 예에서는 문자열이 다른 문자열의 끝에 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1526">The following example determines whether a string occurs at the end of another string.</span></span> <span data-ttu-id="ad3d8-1527"><xref:System.String.EndsWith%2A> 여러 번 대/소문자 구분, 대/소문자, 및 검색 결과 영향을 주는 다양 한 문화권을 사용 하 여 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1527">The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1528"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1528"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1529">두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1529">Determines whether two <see cref="T:System.String" /> objects have the same value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ad3d8-1530">이 인스턴스와 비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1530">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1531">이 인스턴스와 지정한 개체의 값이 같은지를 확인합니다. 이 개체도 <see cref="T:System.String" /> 개체여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1531">Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1532"><see langword="true" />가 <paramref name="obj" />이고 이 인스턴스와 같은 값을 가지면 <see cref="T:System.String" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1532"><see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="ad3d8-1533"><paramref name="obj" />가 <see langword="null" />이면 메서드에서 <see langword="false" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1533">If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1534">이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1534">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1535">다음 예제는 <xref:System.String.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1535">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1536">이 인스턴스와 비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1536">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1537">이 인스턴스와 지정한 다른 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1537">Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1538"><see langword="true" /> 매개 변수와 이 인스턴스의 값이 같으면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1538"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ad3d8-1539"><paramref name="value" />가 <see langword="null" />이면 메서드에서 <see langword="false" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1539">If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1540">이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1540">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1541">다음 예제는 <xref:System.String.Equals%2A> 메서드. 해당 하는 word, 해당 하는 소문자 이거나, 해당 대문자로 LATIN SMALL 문자 점이 없는 I를 포함 하는 단어와 제목 대/소문자 단어 "File"를 비교 (U + 0131) 대신 LATIN SMALL LETTER I (U + 0069).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1541">The following example demonstrates the <xref:System.String.Equals%2A> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</span></span> <span data-ttu-id="ad3d8-1542">때문에 <xref:System.String.Equals%28System.String%29> 는 서 수 비교를 수행 하는 메서드, 동일한 단어로 비교만 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1542">Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.</span></span>  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ad3d8-1543">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1543">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ad3d8-1544">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1544">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1545">지정된 두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1545">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1546"><see langword="true" />의 값이 <paramref name="a" />의 값과 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1546"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ad3d8-1547"><paramref name="a" /> 및 <paramref name="b" />가 <see langword="null" />인 경우 이 메서드는 <see langword="true" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1547">If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1548">이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1548">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1549">다음 예제는 <xref:System.String.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1549">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1550">이 인스턴스와 비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1550">The string to compare to this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-1551">문자열 비교 방법을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1551">One of the enumeration values that specifies how the strings will be compared.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1552">이 문자열과 지정한 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1552">Determines whether this string and a specified <see cref="T:System.String" /> object have the same value.</span></span> <span data-ttu-id="ad3d8-1553">매개 변수는 비교에 사용되는 문화권, 대/소문자 및 정렬 규칙을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1553">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1554"><see langword="true" /> 매개 변수와 이 문자열의 값이 같으면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1554"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1555">`comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야을 인식 하거나 비교 하 고 두 문자열의 대/소문자 무시 단어 또는 정렬 서 수 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1555">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1556">다음 예제에서는 구성 된 대문자 "I", "i", 소문자 및 점이 없는 "ı" 문자열 배열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1556">The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</span></span> <span data-ttu-id="ad3d8-1557">그런 다음 호출 하는 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 메서드 각각의 가능한 사용 하 여 비교할 <xref:System.StringComparison> 열거형 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1557">It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.</span></span>  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 <span data-ttu-id="ad3d8-1558">다음 예제에서는의 각 멤버를 사용 하 여 4 개의 집합이 단어를 비교는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1558">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="ad3d8-1559">비교는 영어 (미국) 및 라프어 (스웨덴 위) 문화권의 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1559">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="ad3d8-1560">Note 문자열 "encyclopædia" 및 "백과" 라프어 (스웨덴 북부) 문화권 있지만 EN-US 문화권에 해당 하는 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1560">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-1561"><paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1561"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ad3d8-1562">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1562">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ad3d8-1563">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1563">The second string to compare, or <see langword="null" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-1564">비교 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1564">One of the enumeration values that specifies the rules for the comparison.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1565">지정된 두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1565">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span> <span data-ttu-id="ad3d8-1566">매개 변수는 비교에 사용되는 문화권, 대/소문자 및 정렬 규칙을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1566">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-1567"><see langword="true" /> 매개 변수와 <paramref name="a" /> 매개 변수의 값이 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1567"><see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1568">`comparisonType` 매개 변수 여부를 나타냅니다 비교는 현재 또는 고정 문화권을 사용 해야을 인식 하거나 비교 하 고 두 문자열의 대/소문자 무시 단어 또는 정렬 서 수 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1568">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1569">다음 예제에서는의 각 멤버를 사용 하 여 4 개의 집합이 단어를 비교는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1569">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="ad3d8-1570">비교는 영어 (미국) 및 라프어 (스웨덴 위) 문화권의 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1570">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="ad3d8-1571">Note 문자열 "encyclopædia" 및 "백과" 라프어 (스웨덴 북부) 문화권 있지만 EN-US 문화권에 해당 하는 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1571">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-1572"><paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1572"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1573">지정된 형식에 따라 개체의 값을 문자열로 변환하여 다른 문자열에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1573">Converts the value of objects to strings based on the formats specified and inserts them into another string.</span></span>  
  
 <span data-ttu-id="ad3d8-1574">`String.Format` 메서드를 처음 사용하는 경우 [String.Format 메서드 시작](#Starting) 섹션에서 대략적인 내용을 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1574">If you are new to the `String.Format` method, see the [Get started with the String.Format method](#Starting) section for a quick overview.</span></span>  
  
 <span data-ttu-id="ad3d8-1575">`String.Format` 메서드에 대한 일반 설명서는 [설명](#remarks-top) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1575">See the [Remarks](#remarks-top) section for general documentation for the `String.Format` method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 <span data-ttu-id="ad3d8-1576">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1576">In this section:</span></span>  
  
 <span data-ttu-id="ad3d8-1577">[String.Format 메서드 시작](#Starting) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1577">[Get started with the String.Format method](#Starting) </span></span>  
 <span data-ttu-id="ad3d8-1578">[어떤 방법을 호출할 수 있습니까?](#FTaskList) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1578">[Which method do I call?](#FTaskList) </span></span>  
 <span data-ttu-id="ad3d8-1579">[Brief에 Format 메서드](#Format_Brief) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1579">[The Format method in brief](#Format_Brief) </span></span>  
 <span data-ttu-id="ad3d8-1580">[서식 항목](#FormatItem) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1580">[The Format item](#FormatItem) </span></span>  
 <span data-ttu-id="ad3d8-1581">[인수는 형식을 지정 하는 방법을](#HowFormatted) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1581">[How arguments are formatted](#HowFormatted) </span></span>  
 <span data-ttu-id="ad3d8-1582">[동일한 인덱스에 있는 서식 항목](#SameIndex) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1582">[Format items that have the same index](#SameIndex) </span></span>  
 <span data-ttu-id="ad3d8-1583">[서식 지정 및 문화권](#Format_Culture) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1583">[Formatting and culture](#Format_Culture) </span></span>  
 <span data-ttu-id="ad3d8-1584">[사용자 지정 서식 지정 작업](#Format_Custom) </span><span class="sxs-lookup"><span data-stu-id="ad3d8-1584">[Custom formatting operations](#Format_Custom) </span></span>  
 [<span data-ttu-id="ad3d8-1585">String.Format Q & A</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1585">String.Format Q & A</span></span>](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a><span data-ttu-id="ad3d8-1586">String.Format 메서드 시작</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1586">Get started with the String.Format method</span></span>  
 <span data-ttu-id="ad3d8-1587">사용 하 여 <xref:System.String.Format%2A?displayProperty=nameWithType> 다른 문자열에는 개체, 변수 또는 식의 값을 삽입 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1587">Use <xref:System.String.Format%2A?displayProperty=nameWithType> if you need to insert the value of an object, variable, or expression into another string.</span></span> <span data-ttu-id="ad3d8-1588">예를 들어 값을 삽입할 수 있습니다는 <xref:System.Decimal> 을 단일 문자열로 사용자에 게 표시 하는 문자열에는 값:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1588">For example, you can insert the value of a <xref:System.Decimal> value into a string to display it to the user as a single string:</span></span>  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 <span data-ttu-id="ad3d8-1589">및 해당 값의 서식을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1589">And you can control that value's formatting:</span></span>  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 <span data-ttu-id="ad3d8-1590">서식 지정 외에도 맞춤 및 간격을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1590">Besides formatting, you can also control alignment and spacing.</span></span>  
  
 ### <a name="inserting-a-string"></a><span data-ttu-id="ad3d8-1591">삽입</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1591">Inserting a string</span></span>  

 <span data-ttu-id="ad3d8-1592"><xref:System.String.Format%2A?displayProperty=nameWithType> 형식 문자열 뒤에 하나 이상의 개체 또는 문자열로 변환 되며 형식 문자열에서 지정된 된 위치에 삽입 하는 식으로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1592"><xref:System.String.Format%2A?displayProperty=nameWithType> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</span></span> <span data-ttu-id="ad3d8-1593">예:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1593">For example:</span></span>  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 <span data-ttu-id="ad3d8-1594">`{0}` 형식에서 문자열은 형식 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1594">The `{0}` in the format string is a format item.</span></span> <span data-ttu-id="ad3d8-1595">`0` 문자열 값을 해당 위치에 삽입할 개체의 인덱스가입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1595">`0` is the index of the object whose string value will be inserted at that position.</span></span> <span data-ttu-id="ad3d8-1596">(인덱스 0부터 시작)입니다. 삽입 될 개체가 문자열이 아닌 경우 해당 `ToString` 메서드를 호출 하는 결과 문자열에 삽입 하기 전에 하나를 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1596">(Indexes start at 0.) If the object to be inserted is not a string, its `ToString` method is called to convert it to one before inserting it in the result string.</span></span>  
  
 <span data-ttu-id="ad3d8-1597">두 개의 형식 항목 및 개체 2 개를 사용 하 여 개체 목록에는 또 다른 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1597">Here's another example that uses two format items and two objects in the object list:</span></span>  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 <span data-ttu-id="ad3d8-1598">형식 항목 수 만큼 있고 모든 서식 항목의 인덱스 개체 목록에서 일치 하는 개체의 개체와 개체 목록에서 원하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1598">You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</span></span> <span data-ttu-id="ad3d8-1599">또한 필요가 없습니다 걱정할 오버 로드에 대 한 호출입니다. 컴파일러는 적절 한 수를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1599">You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</span></span>  
  
 ### <a name="controlling-formatting"></a><span data-ttu-id="ad3d8-1600">서식 지정 제어</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1600">Controlling formatting</span></span>  
 <span data-ttu-id="ad3d8-1601">개체의 서식 지정 하는 방법을 제어 하는 형식 문자열 형식 항목의 인덱스를 따를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1601">You can follow the index in a format item with a format string to control how an object is formatted.</span></span> <span data-ttu-id="ad3d8-1602">예를 들어 `{0:d}` 개체 목록에서 첫 번째 개체 "d" 형식 문자열에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1602">For example, `{0:d}` applies the "d" format string to the first object in the object list.</span></span> <span data-ttu-id="ad3d8-1603">다음은 단일 개체와 예제 하 고 두 항목의 서식을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1603">Here is an example with a single object and two format items:</span></span>  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 <span data-ttu-id="ad3d8-1604">형식 문자열, 모든 숫자 형식을 포함 한 다양 한 형식 지원 (둘 다 [표준](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정](~/docs/standard/base-types/custom-numeric-format-strings.md) 형식 문자열), 모든 날짜 및 시간 (bot h [표준](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정](~/docs/standard/base-types/custom-date-and-time-format-strings.md) 형식 문자열) 및 시간 간격 (둘 다 [표준 d](~/docs/standard/base-types/standard-timespan-format-strings.md) 및 [사용자 지정](~/docs/standard/base-types/custom-timespan-format-strings.md) 형식 문자열), 모든 열거형 형식 [열거형 형식](~/docs/standard/base-types/enumeration-format-strings.md), 및                                          [Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1604">A number of types support format strings, including all numeric types (both                                          [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) and                                          [custom](~/docs/standard/base-types/custom-numeric-format-strings.md) format strings), all dates and times (both                                          [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and                                          [custom](~/docs/standard/base-types/custom-date-and-time-format-strings.md) format strings) and time intervals (both                                          [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) and                                          [custom](~/docs/standard/base-types/custom-timespan-format-strings.md) format strings), all enumeration types                                          [enumeration types](~/docs/standard/base-types/enumeration-format-strings.md), and                                          [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx).</span></span> <span data-ttu-id="ad3d8-1605">또한 사용자 고유의 형식에 형식 문자열에 대 한 지원을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1605">You can also add support for format strings to your own types.</span></span>  
  
 ### <a name="controlling-spacing"></a><span data-ttu-id="ad3d8-1606">간격을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1606">Controlling spacing</span></span>  
 <span data-ttu-id="ad3d8-1607">와 같은 구문을 사용 하 여 결과 문자열에 삽입 되는 문자열의 너비를 정의할 수 있습니다 `{0,12}`, 문자열 12를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1607">You can define the width of the string that is inserted into the result string by using syntax such as `{0,12}`, which inserts a 12-character string.</span></span> <span data-ttu-id="ad3d8-1608">이 경우 첫 번째 개체의 문자열 표현을 12 자 필드에 오른쪽 맞춤를입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1608">In this case, the string representation of the first object is right-aligned in the 12-character field.</span></span>  <span data-ttu-id="ad3d8-1609">(첫 번째 개체의 문자열 표현을 길이 12 자 이면 그러나 기본 필드 너비는 무시 됩니다 및 전체 문자열이 결과 문자열에 삽입 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1609">(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</span></span>  
  
 <span data-ttu-id="ad3d8-1610">다음 예제에서는 정의 문자열을 보관할 6 자 필드 "Year" 및 일부 연도 문자열으로 15 자 필드는 문자열을 보관할 "채우기"와 일부 인구 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1610">The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</span></span> <span data-ttu-id="ad3d8-1611">문자는 오른쪽 정렬 필드에 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1611">Note that the characters are right-aligned in the field.</span></span>  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a><span data-ttu-id="ad3d8-1612">맞춤을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1612">Controlling alignment</span></span>  
 <span data-ttu-id="ad3d8-1613">기본적으로 문자열은 해당 필드 내에서 오른쪽 정렬 필드 너비를 지정 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1613">By default, strings are right-aligned within their field if you specify a field width.</span></span> <span data-ttu-id="ad3d8-1614">문자열 필드에서를 왼쪽에 맞추려면 앞에 음수 기호를 사용 하 여 필드 너비와 같은 `{0,-12}` 12 자로 오른쪽 정렬 필드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1614">To left-align strings in a field, you preface the field width with a negative sign, such as `{0,-12}` to define a 12-character right-aligned field.</span></span>  
  
 <span data-ttu-id="ad3d8-1615">다음 예제에서는 왼쪽 맞춤 레이블과 데이터 한다는 점을 제외 하면 이전 쿼리와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1615">The following example is similar to the previous one, except that it left-aligns both labels and data.</span></span>  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <span data-ttu-id="ad3d8-1616"><xref:System.String.Format%2A?displayProperty=nameWithType> 에서는 합성 서식 지정 기능을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1616"><xref:System.String.Format%2A?displayProperty=nameWithType> makes use of the composite formatting feature.</span></span> <span data-ttu-id="ad3d8-1617">자세한 내용은 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1617">For more information, see [Composite Formatting](~/docs/standard/base-types/composite-formatting.md).</span></span>  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="ad3d8-1618">어떤 방법을 호출할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1618">Which method do I call?</span></span>  
  
|<span data-ttu-id="ad3d8-1619">대상</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1619">To</span></span>|<span data-ttu-id="ad3d8-1620">Call</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1620">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="ad3d8-1621">현재 문화권의 규칙을 사용 하 여 하나 이상의 개체를 포맷 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1621">Format one or more objects by using the conventions of the current culture.</span></span>|<span data-ttu-id="ad3d8-1622">포함 하는 오버 로드를 제외 하 고는 `provider` 매개 변수를 나머지 <xref:System.String.Format%2A> 오버 로드는 포함는 <xref:System.String> 매개 변수 뒤에 하나 이상의 개체 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1622">Except for the overloads that include a `provider` parameter, the remaining <xref:System.String.Format%2A> overloads include a <xref:System.String> parameter followed by one or more object parameters.</span></span> <span data-ttu-id="ad3d8-1623">이 인해 결정할 필요가 없습니다 <xref:System.String.Format%2A> 호출 하려는 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1623">Because of this, you don't have to determine which <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="ad3d8-1624">적합 한 오버 헤드로 없는 오버 로드 중에서 선택 하는 언어 컴파일러는 `provider` 매개 변수를 인수 목록에 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1624">Your language compiler selects the appropriate overload from among the overloads that don't have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="ad3d8-1625">예를 들어 인수 목록에 다섯 개의 인수, 있는 경우 컴파일러 호출 하 여는 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1625">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="ad3d8-1626">특정 문화권의 규칙을 사용 하 여 하나 이상의 개체를 포맷 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1626">Format one or more objects by using the conventions of a specific culture.</span></span>|<span data-ttu-id="ad3d8-1627">각 <xref:System.String.Format%2A> 로 시작 하는 오버 로드는 `provider` 매개 변수 뒤에 <xref:System.String> 매개 변수 또는 하나 이상의 매개 변수 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1627">Each <xref:System.String.Format%2A> overload that begins with a `provider` parameter is followed by a <xref:System.String> parameter and one or more object parameters.</span></span> <span data-ttu-id="ad3d8-1628">이 때문에 어떤 확인할 필요가 없습니다 <xref:System.String.Format%2A> 호출 하려는 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1628">Because of this, you don't have to determine which specific <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="ad3d8-1629">오버 로드 중에서 적절 한 오버 로드를 선택 하는 언어 컴파일러는 `provider` 매개 변수를 인수 목록에 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1629">Your language compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="ad3d8-1630">예를 들어 인수 목록에 다섯 개의 인수, 있는 경우 컴파일러 호출 하 여는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1630">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="ad3d8-1631">사용자 지정 서식 지정 작업을 사용 하 여 수행는 <xref:System.ICustomFormatter> 구현 또는 <xref:System.IFormattable> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1631">Perform a custom formatting operation either with an <xref:System.ICustomFormatter> implementation or an <xref:System.IFormattable> implementation.</span></span>|<span data-ttu-id="ad3d8-1632">4 개의 오버 로드 중 하나는 `provider` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1632">Any of the four overloads with a `provider` parameter.</span></span> <span data-ttu-id="ad3d8-1633">오버 로드 중에서 적절 한 오버 로드를 선택 하는 컴파일러는 `provider` 매개 변수를 인수 목록에 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1633">The compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span>|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a><span data-ttu-id="ad3d8-1634">Brief에 Format 메서드</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1634">The Format method in brief</span></span> 

 <span data-ttu-id="ad3d8-1635">각 오버 로드는 <xref:System.String.Format%2A> 메서드는 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 호출는 0부터 시작 인덱싱된 자리 표시자를 포함 하도록 *항목의 서식을 지정*, 복합 형식 문자열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1635">Each overload of the <xref:System.String.Format%2A> method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to include zero-based indexed placeholders, called *format items*, in a composite format string.</span></span> <span data-ttu-id="ad3d8-1636">런타임 시 각 형식 항목이 매개 변수 목록에서 해당 인수의 문자열 표현으로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1636">At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</span></span> <span data-ttu-id="ad3d8-1637">인수의 값이 `null`, 형식 항목으로 대체 되 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1637">If the value of the argument is `null`, the format item is replaced with <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-1638">다음을 호출 하는 예를 들어는 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 메서드에 세 개의 형식 항목와 {0}, {1 \}, {2 \}, 하는 형식 문자열과 세 개 항목으로 인수 목록에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1638">For example, the following call to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</span></span>  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a><span data-ttu-id="ad3d8-1639">서식 항목</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1639">The format item</span></span>  
 <span data-ttu-id="ad3d8-1640">서식 항목이이 구문은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1640">A format item has this syntax:</span></span>  
  
```  
{index[,alignment][ :formatString] }  
```  
 
 <span data-ttu-id="ad3d8-1641">대괄호는 선택적 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1641">Brackets denote optional elements.</span></span> <span data-ttu-id="ad3d8-1642">여는 태그와 닫는 중괄호는 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1642">The opening and closing braces are required.</span></span> <span data-ttu-id="ad3d8-1643">(리터럴 여 포함 하거나의 "중괄호를 이스케이프 처리" 섹션을 참조 닫는 중괄호 형식 문자열에는 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문서입니다.)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1643">(To include a literal opening or closing brace in the format string, see the "Escaping Braces" section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.)</span></span>  
  
 <span data-ttu-id="ad3d8-1644">예를 들어 통화 값의 서식을 지정 하려면 형식 항목은 다음과 같이 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1644">For example, a format item to format a currency value might appear like this:</span></span>  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 <span data-ttu-id="ad3d8-1645">형식 항목에는 다음과 같은 요소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1645">A format item has the following elements:</span></span>  
  
 <span data-ttu-id="ad3d8-1646">*index*</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1646">*index*</span></span>  
 <span data-ttu-id="ad3d8-1647">문자열 표현의 되도록 형식이 인수의 0부터 시작 인덱스는 문자열의이 위치에 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1647">The zero-based index of the argument whose string representation is to be included at this position in the string.</span></span> <span data-ttu-id="ad3d8-1648">이 인수가 `null`, 문자열에서이 위치에 빈 문자열이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1648">If this argument is `null`, an empty string will be included at this position in the string.</span></span>  
  
 <span data-ttu-id="ad3d8-1649">*alignment*</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1649">*alignment*</span></span>  
 <span data-ttu-id="ad3d8-1650">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1650">Optional.</span></span> <span data-ttu-id="ad3d8-1651">인수를 삽입 하는 지, 오른쪽 맞춤 (양의 정수) 왼쪽 맞춤 (음의 정수)에 필드의 총 길이 나타내는 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1651">A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</span></span> <span data-ttu-id="ad3d8-1652">생략 하면 *맞춤*, 선행 또는 후행 공백 없이 필드에 해당 인수의 문자열 표현을 삽입 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1652">If you omit *alignment*, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</span></span>  
  
 <span data-ttu-id="ad3d8-1653">하는 경우의 값 *맞춤* 을 삽입할 수는 인수의 길이 보다 작으면 *맞춤* 무시 됩니다 및 인수의 문자열 표현의 길이가 필드 너비로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1653">If the value of *alignment* is less than the length of the argument to be inserted, *alignment* is ignored and the length of the string representation of the argument is used as the field width.</span></span>  
  
 <span data-ttu-id="ad3d8-1654">*formatString*</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1654">*formatString*</span></span>  
 <span data-ttu-id="ad3d8-1655">선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1655">Optional.</span></span> <span data-ttu-id="ad3d8-1656">해당 인수가 결과 문자열의 형식을 지정 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1656">A string that specifies the format of the corresponding argument's result string.</span></span> <span data-ttu-id="ad3d8-1657">생략 하면 *formatString*, 해당 인수의 매개 변수가 없는 `ToString` 메서드는 문자열 표현이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1657">If you omit *formatString*, the corresponding argument's parameterless `ToString` method is called to produce its string representation.</span></span> <span data-ttu-id="ad3d8-1658">지정 하는 경우 *formatString*, 형식 항목으로 참조 하는 인수를 구현 해야 합니다는 <xref:System.IFormattable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1658">If you specify *formatString*, the argument referenced by the format item must implement the <xref:System.IFormattable> interface.</span></span> <span data-ttu-id="ad3d8-1659">형식 문자열을 지 원하는 유형은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1659">Types that support format strings include:</span></span>  
  
-   <span data-ttu-id="ad3d8-1660">모든 정수 계열 및 부동 소수점 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1660">All integral and floating-point types.</span></span> <span data-ttu-id="ad3d8-1661">(참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1661">(See [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ad3d8-1662"><xref:System.DateTime>와 <xref:System.DateTimeOffset>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1662"><xref:System.DateTime> and <xref:System.DateTimeOffset>.</span></span> <span data-ttu-id="ad3d8-1663">(참조 [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1663">(See [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ad3d8-1664">모든 열거형 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1664">All enumeration types.</span></span> <span data-ttu-id="ad3d8-1665">(참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1665">(See [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ad3d8-1666"><xref:System.TimeSpan> 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1666"><xref:System.TimeSpan> values.</span></span> <span data-ttu-id="ad3d8-1667">(참조 [표준 TimeSpan 형식 문자열](~/docs/standard/base-types/standard-timespan-format-strings.md) 및 [사용자 지정 TimeSpan 형식 문자열](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1667">(See [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ad3d8-1668">GUID입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1668">GUIDs.</span></span> <span data-ttu-id="ad3d8-1669">(참조는 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 메서드.)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1669">(See the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> method.)</span></span>  
  
 <span data-ttu-id="ad3d8-1670">그러나 모든 사용자 지정 형식 구현할 수를 메모 <xref:System.IFormattable> 기존 형식을 확장할 또는 <xref:System.IFormattable> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1670">However, note that any custom type can implement <xref:System.IFormattable> or extend an existing type's <xref:System.IFormattable> implementation.</span></span>  
  
 <span data-ttu-id="ad3d8-1671">다음 예제에서는 `alignment` 및 `formatString` 인수 형식이 지정 된 출력을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1671">The following example uses the `alignment` and `formatString` arguments to produce formatted output.</span></span>  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a><span data-ttu-id="ad3d8-1672">인수는 형식을 지정 하는 방법을</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1672">How arguments are formatted</span></span>  
 <span data-ttu-id="ad3d8-1673">서식 항목이 문자열의 시작 부분에서 순차적으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1673">Format items are processed sequentially from the beginning of the string.</span></span> <span data-ttu-id="ad3d8-1674">각 형식 항목에는 메서드의 인수 목록에 있는 개체에 해당 하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1674">Each format item has an index that corresponds to an object in the method's argument list.</span></span> <span data-ttu-id="ad3d8-1675"><xref:System.String.Format%2A> 메서드 인수를 검색 하 고 해당 문자열 표현에 다음과 같이 파생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1675">The <xref:System.String.Format%2A> method retrieves the argument and derives its string representation as follows:</span></span>  
  
-   <span data-ttu-id="ad3d8-1676">인수가 `null`, 삽입 <xref:System.String.Empty?displayProperty=nameWithType> 는 결과 문자열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1676">If the argument is `null`, the method inserts <xref:System.String.Empty?displayProperty=nameWithType> into the result string.</span></span> <span data-ttu-id="ad3d8-1677">Converned 처리가 포함 될 필요가 없습니다는 <xref:System.NullReferenceException> null 인수를 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1677">You don't have to be converned with handling an <xref:System.NullReferenceException> for null arguments.</span></span> 
  
-   <span data-ttu-id="ad3d8-1678">호출 하는 경우는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 오버 로드 및 `provider` 매개 변수를 구현 하는 <xref:System.ICustomFormatter> 인터페이스를 인수에 전달 되는 `provider` 개체의 <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1678">If you call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> overload and the `provider` parameter implements the <xref:System.ICustomFormatter> interface, the argument is passed to the `provider` object's <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ad3d8-1679">형식 항목을 포함 하는 경우는 *formatString* 인수를 것은 첫 번째 인수로 메서드에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1679">If the format item includes a *formatString* argument, it is passed as the first argument to the method.</span></span> <span data-ttu-id="ad3d8-1680">경우는 <xref:System.ICustomFormatter> 구현 형식 지정 서비스를 제공할 수, 인수의 문자열 표현을 반환 이며 그렇지 않으면 반환 `null` 하 고 다음 단계를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1680">If the <xref:System.ICustomFormatter> implementation is able to provide formatting services, it returns the string representation of the argument; otherwise, it returns `null` and the next step executes.</span></span>  
  
-   <span data-ttu-id="ad3d8-1681">인수를 구현 하는 경우는 <xref:System.IFormattable> 인터페이스를 해당 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 구현이 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1681">If the argument implements the <xref:System.IFormattable> interface, its <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation is called.</span></span>  
  
-   <span data-ttu-id="ad3d8-1682">인수의 매개 변수가 없는 `ToString` 재정의 되었거나에서 상속 된 메서드는 <xref:System.Object> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1682">The argument's parameterless `ToString` method, which is either overridden or inherited from the <xref:System.Object> class, is called.</span></span>  
  
 <span data-ttu-id="ad3d8-1683">예에 대 한 호출을 가로채는 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 메서드 정보를 볼 수 있습니다 및는 <xref:System.String.Format%2A> 합성 형식 문자열의 각 형식 항목에 대 한 서식 지정 메서드에 메서드가 전달 참조 [예제: 절편 공급자 및 로마 숫자 포맷터](#Format7_Example)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1683">For an example that intercepts calls to the <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> method and allows you to see what information the <xref:System.String.Format%2A> method passes to a formatting method for each format item in a composite format string, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a><span data-ttu-id="ad3d8-1684">동일한 인덱스에 있는 서식 항목</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1684">Format items that have the same index</span></span>  
 <span data-ttu-id="ad3d8-1685"><xref:System.String.Format%2A> 메서드가 throw 한 <xref:System.FormatException> 경우 인수 목록에는 수의 인수 보다 크거나 인덱스 항목의 인덱스는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1685">The <xref:System.String.Format%2A> method throws a <xref:System.FormatException> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</span></span> <span data-ttu-id="ad3d8-1686">그러나 `format` 같은 인덱스를 보유 하는 여러 개의 형식 항목이 인수 보다 더 많은 형식 항목을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1686">However, `format` can include more format items than there are arguments, as long as multiple format items have the same index.</span></span> <span data-ttu-id="ad3d8-1687">에 대 한 호출에는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 다음 예제에서는 인수 목록에에서는 메서드는 단일 인수를 형식 문자열에는 두 개의 형식 항목이 포함 되어 있지만: 숫자의 10 진수 값을 16 진수 값을 표시, 다른 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1687">In the call to the <xref:System.String.Format%28System.String%2CSystem.Object%29> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a><span data-ttu-id="ad3d8-1688">서식 지정 및 문화권</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1688">Formatting and culture</span></span>  
 <span data-ttu-id="ad3d8-1689">일반적으로 인수 목록에는 개체에서 반환 되는 현재 문화권의 규칙을 사용 하 여 해당 문자열 표현으로 변환 됩니다는 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1689">Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ad3d8-1690">오버 로드 중 하나를 호출 하 여이 동작을 제어할 수 <xref:System.String.Format%2A> 포함 하는 `provider` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1690">You can control this behavior by calling one of the overloads of <xref:System.String.Format%2A> that includes a `provider` parameter.</span></span> <span data-ttu-id="ad3d8-1691">`provider` 매개 변수는 한 <xref:System.IFormatProvider> 서식을 중재 하는 데 사용 되는 사용자 지정 및 culture 별 서식 지정 정보를 제공 하는 구현 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1691">The `provider` parameter is an <xref:System.IFormatProvider> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</span></span>  
  
 <span data-ttu-id="ad3d8-1692"><xref:System.IFormatProvider> 인터페이스에는 단일 멤버 <xref:System.IFormatProvider.GetFormat%2A>, 하는 서식 지정 정보를 제공 하는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1692">The <xref:System.IFormatProvider> interface has a single member, <xref:System.IFormatProvider.GetFormat%2A>, which is responsible for returning the object that provides formatting information.</span></span> <span data-ttu-id="ad3d8-1693">.NET Framework에는 3 개의 <xref:System.IFormatProvider> culture 별 서식 지정을 제공 하는 구현:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1693">The .NET Framework has three <xref:System.IFormatProvider> implementations that provide culture-specific formatting:</span></span>  
  
-   <span data-ttu-id="ad3d8-1694"><xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1694"><xref:System.Globalization.CultureInfo>.</span></span> <span data-ttu-id="ad3d8-1695">해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드 반환 culture 별 <xref:System.Globalization.NumberFormatInfo> 숫자 값 및 culture 별 서식 지정에 대 한 개체 <xref:System.Globalization.DateTimeFormatInfo> 날짜 및 시간 값의 서식을 지정 하기 위한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1695">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns a culture-specific <xref:System.Globalization.NumberFormatInfo> object for formatting numeric values and a culture-specific <xref:System.Globalization.DateTimeFormatInfo> object for formatting date and time values.</span></span>  
  
-   <span data-ttu-id="ad3d8-1696"><xref:System.Globalization.DateTimeFormatInfo>날짜 및 시간 값의 culture 별 서식 지정에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1696"><xref:System.Globalization.DateTimeFormatInfo>, which is used for culture-specific formatting of date and time values.</span></span> <span data-ttu-id="ad3d8-1697">해당 <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> 메서드 자체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1697">Its <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> method returns itself.</span></span>  
  
-   <span data-ttu-id="ad3d8-1698"><xref:System.Globalization.NumberFormatInfo>를 숫자 값의 culture 별 서식 지정에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1698"><xref:System.Globalization.NumberFormatInfo>, which is used for culture-specific formatting of numeric values.</span></span> <span data-ttu-id="ad3d8-1699">해당 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 속성 자체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1699">Its <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> property returns itself.</span></span> 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a><span data-ttu-id="ad3d8-1700">사용자 지정 서식 지정 작업</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1700">Custom formatting operations</span></span>  
 <span data-ttu-id="ad3d8-1701">오버 로드 중 하나를 호출할 수도 수는 <xref:System.String.Format%2A> 메서드에 `provider` 형식의 매개 변수 <xref:System.IFormatProvider> 사용자 지정 서식 지정 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1701">You can also call the any of the overloads of the <xref:System.String.Format%2A> method that have a `provider` parameter of type <xref:System.IFormatProvider> to perform custom formatting operations.</span></span> <span data-ttu-id="ad3d8-1702">예를 들어 전화 번호 또는 id 번호도 정수 서식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1702">For example, you could format an integer as an identification number or as a telephone number.</span></span> <span data-ttu-id="ad3d8-1703">사용자 지정 형식 지정을 수행 하 여 `provider` 인수 둘 다 구현 해야 합니다는 <xref:System.IFormatProvider> 및 <xref:System.ICustomFormatter> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1703">To perform custom formatting, your `provider` argument must implement both the <xref:System.IFormatProvider> and <xref:System.ICustomFormatter> interfaces.</span></span> <span data-ttu-id="ad3d8-1704">경우는 <xref:System.String.Format%2A> 메서드에 전달 됩니다는 <xref:System.ICustomFormatter> 구현을으로 `provider` 인수를는 <xref:System.String.Format%2A> 메서드 호출의 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 구현 형식의 개체를 요청 하 고 <xref:System.ICustomFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1704">When the <xref:System.String.Format%2A> method is passed an <xref:System.ICustomFormatter> implementation as the `provider` argument, the <xref:System.String.Format%2A> method calls its   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation and requests an object of type <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="ad3d8-1705">그런 다음 반환 된 호출 <xref:System.ICustomFormatter> 개체의 <xref:System.ICustomFormatter.Format%2A> 복합 문자열의 각 형식 항목의 형식을 지정 메서드를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1705">It then calls the returned <xref:System.ICustomFormatter> object's <xref:System.ICustomFormatter.Format%2A> method to format each format item in the composite string passed to it.</span></span>  
  
 <span data-ttu-id="ad3d8-1706">사용자 지정 형식 지정 솔루션을 제공 하는 방법에 대 한 자세한 내용은 참조 [하는 방법: 정의 및 사용 하 여 사용자 지정 숫자 형식 공급자](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) 및 <xref:System.ICustomFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1706">For more information about providing custom formatting solutions, see [How to: Define and Use Custom Numeric Format Providers](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) and <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="ad3d8-1707">서식이 지정 된 사용자 지정 번호에 정수를 변환 하는 예제를 보려면 [예제: 사용자 지정 서식 지정 작업](#Format6_Example)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1707">For an example that converts integers to formatted custom numbers, see [Example: A custom formatting operation](#Format6_Example).</span></span> <span data-ttu-id="ad3d8-1708">부호 없는 바이트 로마 숫자 변환 하는 예제를 보려면 [예제: 절편 공급자 및 로마 숫자 포맷터](#Format7_Example)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1708">For an example that converts unsigned bytes to Roman numerals, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a><span data-ttu-id="ad3d8-1709">예: 사용자 지정 서식 지정 작업</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1709">Example: A custom formatting operation</span></span>  
 <span data-ttu-id="ad3d8-1710">이 예제에서는 양식 x-xxxxx-xx에서 고객 계정 번호도 정수 값의 형식을 지정 하는 형식 공급자를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1710">This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</span></span>  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a><span data-ttu-id="ad3d8-1711">예:는 절편 공급자 및 로마 숫자 포맷터</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1711">Example: An intercept provider and Roman numeral formatter</span></span>  
 <span data-ttu-id="ad3d8-1712">구현 하는 사용자 지정 형식 공급자를 정의 하는이 예제는 <xref:System.ICustomFormatter> 및 <xref:System.IFormatProvider> 다음 두 가지 작업을 수행 하는 인터페이스:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1712">This example defines a custom format provider that implements the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces to do two things:</span></span>  
  
-   <span data-ttu-id="ad3d8-1713">에 전달 된 매개 변수 표시는 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1713">It displays the parameters passed to its <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="ad3d8-1714">이렇게 하면를 매개 변수를 볼 수는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드가 서식을 시도 하는 각 개체에 대 한 사용자 지정 서식 구현에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1714">This enables us to see what parameters the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is passing to the custom formatting implementation for each object that it tries to format.</span></span> <span data-ttu-id="ad3d8-1715">응용 프로그램을 디버깅할 때 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1715">This can be useful when you're debugging your application.</span></span>  
  
-   <span data-ttu-id="ad3d8-1716">형식을 지정할 개체는 "R" 표준 형식 문자열을 사용 하 여 형식을 지정할 수 있는 부호 없는 바이트 값 이면 사용자 지정 포맷터 형식을 로마 숫자도 숫자 값을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1716">If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</span></span>  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a><span data-ttu-id="ad3d8-1717">String.Format 질문 및 답변</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1717">String.Format Q & A</span></span>  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a><span data-ttu-id="ad3d8-1718">이유 합니까 문자열 보간 호출에 대해는 `String.Format` 메서드?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1718">Why do you recommend string interpolation over calls to the `String.Format` method?</span></span>

<span data-ttu-id="ad3d8-1719">문자열 보간은입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1719">String interpolation is:</span></span>

- <span data-ttu-id="ad3d8-1720">보다 유연 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1720">More flexible.</span></span> <span data-ttu-id="ad3d8-1721">복합 형식을 지 원하는 메서드를 호출 하지 않고도 문자열에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1721">It can be used in any string without requiring a call to a method that supports composite formatting.</span></span> <span data-ttu-id="ad3d8-1722">그렇지 않으면 호출 할는 <xref:System.String.Format%2A> 메서드 또는 복합 형식을 지 원하는와 같은 다른 방법을 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1722">Otherwise, you have to call the <xref:System.String.Format%2A> method or another method that supports composite formatting, such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span></span> 

- <span data-ttu-id="ad3d8-1723">더 쉽게 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1723">More readable.</span></span> <span data-ttu-id="ad3d8-1724">인수 목록이 아닌 보간된 식에는 문자열에 삽입할 식 나타나므로 보간된 문자열은 코드를 읽을를 훨씬 간편 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1724">Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</span></span> <span data-ttu-id="ad3d8-1725">큰 여 가독성 때문에 보간된 문자열 뿐만 아니라 메서드 호출에 복합 형식, 바꿀 수는 있지만 수도 수 문자열 연결 작업에 더 간결 하 고 명확 하 게 코드를 생성 하기 위해.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1725">Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</span></span> 

<span data-ttu-id="ad3d8-1726">비교는 다음 두 코드 예제에서는 문자열을 연결 및 복합 형식 지정 메서드를 호출 보간된 문자열 우수성을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1726">A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</span></span> <span data-ttu-id="ad3d8-1727">다음 예제에서 여러 문자열 연결 작업을 사용 하 여 자세한 정보 보기 및 읽기 하드 코드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1727">The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</span></span>

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

<span data-ttu-id="ad3d8-1728">다음 예에서 보간된 문자열을 사용 하 문자열 연결 문과에 대 한 호출 보다 훨씬 더 명확 하 게, 더 간결한 코드를 생성 하는 반면,는 <xref:System.String.Format%2A> 이전 예제의 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1728">In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <xref:System.String.Format%2A> method in the previous example.</span></span>

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a><span data-ttu-id="ad3d8-1729">형식 항목에 사용할 수 있는 미리 정의 된 형식 문자열의 목록을 어디에 있습니까?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1729">Where can I find a list of the predefined format strings that can be used with format items?</span></span>  
  
-   <span data-ttu-id="ad3d8-1730">모든 정수 계열 및 부동 소수점 형식에 대 한 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1730">For all integral and floating-point types, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ad3d8-1731">날짜 및 시간 값에 대 한 참조 [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1731">For date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ad3d8-1732">열거형 값에 대 한 참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1732">For enumeration values, see [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ad3d8-1733">에 대 한 <xref:System.TimeSpan> 값, 참조 [표준 TimeSpan 형식 문자열](~/docs/standard/base-types/standard-timespan-format-strings.md) 및 [사용자 지정 TimeSpan 형식 문자열](~/docs/standard/base-types/custom-timespan-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1733">For <xref:System.TimeSpan> values, see  [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ad3d8-1734">에 대 한 <xref:System.Guid> 의 설명 섹션을 참조 하는 값은 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1734">For <xref:System.Guid> values, see the Remarks section of the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> reference page.</span></span>  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a><span data-ttu-id="ad3d8-1735">형식 항목을 대체 하는 경우 결과 문자열의 맞춤을 제어 하는 방법</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1735">How do I control the alignment of the result strings that replace format items?</span></span>  
 <span data-ttu-id="ad3d8-1736">형식 항목의 일반 구문은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1736">The general syntax of a format item is:</span></span>  
  
```  
{index[,alignment][: formatString]}  
```  
  
 <span data-ttu-id="ad3d8-1737">여기서 *맞춤* 필드 너비를 정의 하는 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1737">where *alignment* is a signed integer that defines the field width.</span></span> <span data-ttu-id="ad3d8-1738">이 값이 음수 이면 필드의 텍스트가 왼쪽 맞춤입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1738">If this value is negative, text in the field is left-aligned.</span></span> <span data-ttu-id="ad3d8-1739">양수 이면 텍스트가 오른쪽 맞춤 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1739">If it is positive, text is right-aligned.</span></span>  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a><span data-ttu-id="ad3d8-1740">소수 구분 기호 뒤의 자릿수를 제어 하는 방법</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1740">How do I control the number of digits after the decimal separator?</span></span>  
 <span data-ttu-id="ad3d8-1741">모든 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) (정수만 사용 됨)입니다 "D", "G", "R", except 및 "X"는 결과 문자열의 소수 자릿수를 정의 하는 전체 자릿수 지정자를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1741">All [standard numeric format strings](~/docs/standard/base-types/standard-numeric-format-strings.md) except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</span></span> <span data-ttu-id="ad3d8-1742">다음 예제에서는 표준 숫자 형식 문자열을 사용 하 여 결과 문자열의 소수 자릿수의 수를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1742">The following example uses standard numeric format strings to control the number of decimal digits in the result string.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 <span data-ttu-id="ad3d8-1743">사용 중인 경우는 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md), "0" 형식 지정자를 사용 하 여 다음 예제와 같이 결과 문자열의 소수 자릿수 수를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1743">If you're using a [custom numeric format string](~/docs/standard/base-types/custom-numeric-format-strings.md), use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a><span data-ttu-id="ad3d8-1744">정수 자릿수를 제어 하는 방법</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1744">How do I control the number of integral digits?</span></span>  
 <span data-ttu-id="ad3d8-1745">기본적으로 형식 지정 작업만 0이 아닌 정수 자릿수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1745">By default, formatting operations only display non-zero integral digits.</span></span> <span data-ttu-id="ad3d8-1746">정수 형식을 지정 하는 경우 숫자의 수를 제어 하려면 "X" 표준 형식 문자열 "D"와 전체 자릿수 지정자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1746">If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 <span data-ttu-id="ad3d8-1747">"0"을 사용 하 여 지정된 하는 정수 개수의 함께 결과 문자열을 생성 하는 정수 또는 부동 소수점 숫자 앞에 오는 0을 채울 수 있습니다 [사용자 지정 숫자 서식 지정자](~/docs/standard/base-types/custom-numeric-format-strings.md)다음 예제와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1747">You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" [custom numeric format specifier](~/docs/standard/base-types/custom-numeric-format-strings.md), as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a><span data-ttu-id="ad3d8-1748">형식 목록에 포함할 수 있는 항목 수는 있습니까?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1748">How many items can I include in the format list?</span></span>  
 <span data-ttu-id="ad3d8-1749">실용적인 제한은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1749">There is no practical limit.</span></span> <span data-ttu-id="ad3d8-1750">두 번째 매개 변수는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드는 태그로 지정는 <xref:System.ParamArrayAttribute> 특성 구분 된 목록 또는 형식 목록으로 개체 배열을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1750">The second parameter of the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is tagged with the <xref:System.ParamArrayAttribute> attribute, which allows you to include either a delimited list or an object array as your format list.</span></span>  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a><span data-ttu-id="ad3d8-1751">리터럴 중괄호 포함 방법 ("{" 및 "}")는 결과 문자열에 있습니까?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1751">How do I include literal braces ("{" and "}") in the result string?</span></span>  
 <span data-ttu-id="ad3d8-1752">예를 들어 영향을 최소화 하는 다음 메서드 호출에서 throw 한 <xref:System.FormatException> 예외?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1752">For example, how do you prevent the following method call from throwing a <xref:System.FormatException> exception?</span></span>  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 <span data-ttu-id="ad3d8-1753">여는 중괄호와 닫는 중괄호의 단일는 항상 시작 또는 형식 항목의 끝으로 해석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1753">A single opening or closing brace is always interpreted as the beginning or end of a format item.</span></span> <span data-ttu-id="ad3d8-1754">문자 그대로 해석 되도록 이스케이프 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1754">To be interpreted literally, it must be escaped.</span></span> <span data-ttu-id="ad3d8-1755">다른 중괄호를 추가 하 여는 중괄호를 이스케이프 ("{{" 및 "}}" 대신 "{" 및 "}")와 같이, 다음과 같은 메서드 호출:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1755">You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</span></span>  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 <span data-ttu-id="ad3d8-1756">그러나 이스케이프 된 중괄호는 쉽게 잘못 해석 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1756">However, even escaped braces are easily misinterpreted.</span></span> <span data-ttu-id="ad3d8-1757">형식 목록에서에 중괄호를 사용할 형식 항목을 사용 하 여 다음 예제와 같이 결과 문자열에 삽입 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1757">We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a><span data-ttu-id="ad3d8-1758">String.Format 메서드 호출 내는 FormatException를 throw 하는 이유</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1758">Why does my call to the String.Format method throw a FormatException?</span></span>  
 <span data-ttu-id="ad3d8-1759">예외의 가지 가장 일반적인 원인은 형식 항목의 인덱스는 개체 형식 목록에서에 해당 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1759">The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</span></span> <span data-ttu-id="ad3d8-1760">일반적으로 형식 항목의 인덱스가 misnumbered 했습니다 또는 형식 목록에서 개체를 포함 하려면 잊었으며 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1760">Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</span></span> <span data-ttu-id="ad3d8-1761">문자는 이스케이프 되지 않은 왼쪽 또는 오른쪽 중괄호를 포함 하는 또한 throw 한 <xref:System.FormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1761">Attempting to include an unescaped left or right brace character also throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="ad3d8-1762">경우에 따라 예외가 오타가; 결과 일반적인 실수는 잘못 입력 하는 되는 예를 들어, "[" (왼쪽된 대괄호) 대신 "{" (왼쪽된 중괄호)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1762">Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</span></span>  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a><span data-ttu-id="ad3d8-1763">Format(System.IFormatProvider,System.String,System.Object[]) 메서드 매개 변수 배열을 지 원하는 경우 이유 코드 예외를 throw지 않습니다 배열을 사용 하는 경우?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1763">If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</span></span>  
 <span data-ttu-id="ad3d8-1764">예를 들어 다음 코드 throw 한 <xref:System.FormatException> 예외:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1764">For example, the following code throws a <xref:System.FormatException> exception:</span></span>  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 <span data-ttu-id="ad3d8-1765">컴파일러가 오버 로드 확인의 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1765">This is a problem of compiler overload resolution.</span></span> <span data-ttu-id="ad3d8-1766">호출 하므로 단일 인수로 정수 배열로 처리 컴파일러 정수의 배열 개체 배열을 변환할 수 없습니다는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1766">Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <xref:System.String.Format%28System.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="ad3d8-1767">4 개의 형식 항목이 있지만 형식 목록에서 항목을 단일 있기 때문에 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1767">The exception is thrown because there are four format items but only a single item in the format list.</span></span>  
  
 <span data-ttu-id="ad3d8-1768">호출 하기 전에 사용자가 직접 변환을 수행 해야 하는 Visual Basic 또는 C# 아닙니다 개체 배열에 정수 배열로 변환할 수는 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1768">Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="ad3d8-1769">다음 예제에는 하나의 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1769">The following example provides one implementation.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

<span data-ttu-id="ad3d8-1770">호출 하는 다양 한 예제는 <xref:System.String.Format%2A> 메서드를 통해 섞여는 [주의](#remarks) 이 문서의 섹션.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1770">Numerous examples that call the <xref:System.String.Format%2A> method are interspersed through the [Remarks](#remarks) section of this article.</span></span>  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="ad3d8-1771">완전 한 집합을 다운로드할 수 있습니다 `String.Format` 포함 되어 있는 예제는 [C#.NET Core 2.0 프로젝트](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip) 및 [Visual basic.NET Core 2.0 프로젝트](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)에서 [dotnet/docs GitHub 리포지토리](https://github.com/dotnet/docs)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1771">You can also download a complete set of `String.Format` examples, which are included a [.NET Core 2.0 project for C#](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip) and a [.NET Core 2.0 project for Visual Basic](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip), from the [dotnet/docs GitHub repository](https://github.com/dotnet/docs).</span></span>

<span data-ttu-id="ad3d8-1772">다음은 문서에 포함 된 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1772">The following are some of the examples included in the article:</span></span>

### <a name="create-a-format-string"></a><span data-ttu-id="ad3d8-1773">형식 문자열 만들기</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1773">Create a format string</span></span>

[<span data-ttu-id="ad3d8-1774">삽입</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1774">Inserting a string</span></span>](#inserting-a-string)  
[<span data-ttu-id="ad3d8-1775">서식 항목</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1775">The format item</span></span>](#the-format-item)  
[<span data-ttu-id="ad3d8-1776">동일한 인덱스에 있는 서식 항목</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1776">Format items that have the same index</span></span>](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a><span data-ttu-id="ad3d8-1777">형식이 지정 된 출력을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1777">Control formatted output</span></span>

[<span data-ttu-id="ad3d8-1778">서식 지정 제어</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1778">Controlling formatting</span></span>](#controlling-formatting)  
[<span data-ttu-id="ad3d8-1779">간격을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1779">Controlling spacing</span></span>](#controlling-spacing)  
[<span data-ttu-id="ad3d8-1780">맞춤을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1780">Controlling alignment</span></span>](#controlling-alignment)  
[<span data-ttu-id="ad3d8-1781">정수 자릿수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1781">Controlling the number of integral digits</span></span>](#how-do-i-control-the-number-of-integral-digits)  
[<span data-ttu-id="ad3d8-1782">소수 구분 기호 뒤 자릿수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1782">Controlling the number of digits after the decimal separator</span></span>](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[<span data-ttu-id="ad3d8-1783">결과 문자열에 리터럴 중괄호를 포함 하 여</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1783">Including literal braces in a result string</span></span>](#braces)  

### <a name="make-format-strings-culture-sensitive"></a><span data-ttu-id="ad3d8-1784">문화권 구분 형식 문자열 확인</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1784">Make format strings culture-sensitive</span></span>

[<span data-ttu-id="ad3d8-1785">문화권 구분 서식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1785">Culture-sensitive formatting</span></span>](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a><span data-ttu-id="ad3d8-1786">서식 지정 작업을 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1786">Customize the formatting operation</span></span>

[<span data-ttu-id="ad3d8-1787">사용자 지정 서식 지정 작업</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1787">A custom formatting operation</span></span>](#example-a-custom-formatting-operation)  
[<span data-ttu-id="ad3d8-1788">절편 공급자 및 로마 숫자 포맷터</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1788">An intercept provider and Roman numeral formatter</span></span>](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ad3d8-1789">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1789">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ad3d8-1790">형식을 지정할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1790">The object to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1791">문자열에 있는 하나 이상의 형식 항목을 지정된 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1791">Replaces one or more format items in a string with the string representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1792">서식 지정 항목이 <paramref name="format" />의 문자열 표현으로 바뀌는 <paramref name="arg0" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1792">A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1793">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에서 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1793">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a><span data-ttu-id="ad3d8-1794">예: 단일 인수를 형식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1794">Example: Formatting a single argument</span></span>  
 
 <span data-ttu-id="ad3d8-1795">다음 예제에서는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 메서드 문자열에 특정 사용자의 나이 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1795">The following example uses the <xref:System.String.Format%28System.String%2CSystem.Object%29> method to embed an individual's age in the middle of a string.</span></span>  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1796"><paramref name="format" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1796"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-1797"><paramref name="format" />의 형식 항목이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1797">The format item in <paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1798">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1798">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1799">서식 항목의 인덱스가 0이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1799">The index of a format item is not zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ad3d8-1800">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1800">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="ad3d8-1801">형식을 지정할 개체를 0개 이상 포함하는 개체 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1801">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1802">지정된 문자열의 형식 항목을 지정된 배열에 있는 해당 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1802">Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1803">형식 항목을 <paramref name="format" />에 있는 해당 개체의 문자열 표현으로 바꾼 <paramref name="args" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1803">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1804">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 의 4 개 이상의 식 값의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1804">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ad3d8-1805">이후는 `args` 으로 표시 된 매개 변수는 <xref:System.ParamArrayAttribute?displayProperty=nameWithType> 특성에 전달할 수 있습니다 개체 메서드 또는 개별 인수로 <xref:System.Object> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1805">Since the `args` parameter is marked with the <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribute, you can pass the objects to the method as individual arguments or as an <xref:System.Object> array.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a><span data-ttu-id="ad3d8-1806">예: 4 개 이상의 인수를 형식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1806">Example: Formatting more than three arguments</span></span>  
 
 <span data-ttu-id="ad3d8-1807">이 예제에서는 특정 날짜의 최고 / 최저 온도에 대 한 데이터를 포함 하는 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1807">This example creates a string that contains data on the high and low temperature on a particular date.</span></span> <span data-ttu-id="ad3d8-1808">합성 형식 문자열에는 C# 예제에서 다섯 개의 형식 항목 및 Visual Basic 예의 경우 6 개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1808">The composite format string has five format items in the C# example and six in the Visual Basic example.</span></span> <span data-ttu-id="ad3d8-1809">해당 값의 문자열 표현을 너비를 정의 하는 두 개의 형식 항목의 상태와 첫 번째 형식 항목인 아울러 표준 날짜 및 시간 서식 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1809">Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</span></span>  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 <span data-ttu-id="ad3d8-1810">배열 형식을 개체를 전달할 수도 있습니다는 인수 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1810">You can also pass the objects to be formatted as an array rather than a an argument list.</span></span>  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1811"><paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1811"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="ad3d8-1812"><paramref name="format" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1812"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1813">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1813">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1814">형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1814">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-1815">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1815">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ad3d8-1816">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1816">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ad3d8-1817">형식을 지정할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1817">The object to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1818">지정된 문자열에 있는 하나의 형식 항목 또는 여러 개의 형식 항목을 해당하는 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1818">Replaces the format item or items in a specified string with the string representation of the corresponding object.</span></span> <span data-ttu-id="ad3d8-1819">매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1819">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1820">하나의 형식 항목 또는 여러 개의 형식 항목이 <paramref name="format" />의 문자열 표현으로 바뀌는 <paramref name="arg0" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1820">A copy of <paramref name="format" /> in which the format item or items have been replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1821">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에서 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1821">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> <span data-ttu-id="ad3d8-1822">변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1822">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ad3d8-1823">메서드가 변환 `arg0` 호출 하 여 문자열 표현으로 해당 **ToString(IFormatProvider)** 메서드 또는 서식 항목 호출 하 여 형식 문자열을 포함 하는 개체의 해당 하는 경우 해당 **ToString ( String, IFormatProvider)** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1823">The method converts `arg0` to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ad3d8-1824">이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1824">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1825"><paramref name="format" /> 또는 <paramref name="arg0" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1825"><paramref name="format" /> or <paramref name="arg0" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="ad3d8-1826"><paramref name="format" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1826"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1827">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1827">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1828">형식 항목의 인덱스가 0보다 작거나, 1보다 크거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1828">The index of a format item is less than zero, or greater than or equal to one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-1829">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1829">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ad3d8-1830">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1830">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="ad3d8-1831">형식을 지정할 개체를 0개 이상 포함하는 개체 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1831">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1832">문자열의 형식 항목을 지정된 배열에 있는 해당 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1832">Replaces the format items in a string with the string representations of corresponding objects in a specified array.</span></span> <span data-ttu-id="ad3d8-1833">매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1833">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1834">형식 항목을 <paramref name="format" />에 있는 해당 개체의 문자열 표현으로 바꾼 <paramref name="args" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1834">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1835">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 4 개 이상의 식의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1835">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ad3d8-1836">변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1836">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ad3d8-1837">메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 또는 형식 항목 형식 문자열에 포함 되어 해당 를호출하여개체의해당하는경우**ToString(String,IFormatProvider)** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1837">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ad3d8-1838">이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1838">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a><span data-ttu-id="ad3d8-1839">예: 문화권 구분 서식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1839">Example: Culture-sensitive formatting</span></span>  
 <span data-ttu-id="ad3d8-1840">사용 하 여이 예제는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드를 여러 가지 서로 다른 문화권을 사용 하 여 일부 날짜 및 시간 값 및 숫자 값의 문자열 표현을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1840">This example uses the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method to display the string representation of some date and time values and numeric values by using several different cultures.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1841"><paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1841"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="ad3d8-1842"><paramref name="format" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1842"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1843">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1843">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1844">형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1844">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ad3d8-1845">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1845">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ad3d8-1846">서식을 지정할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1846">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ad3d8-1847">서식을 지정할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1847">The second object to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1848">문자열에 있는 서식 지정 항목을 지정된 두 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1848">Replaces the format items in a string with the string representation of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1849">서식 지정 항목이 <paramref name="format" /> 및 <paramref name="arg0" />의 문자열 표현으로 바뀌는 <paramref name="arg1" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1849">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1850">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 두 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1850">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of two expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a><span data-ttu-id="ad3d8-1851">예: 두 개의 인수를 형식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1851">Example: Formatting two arguments</span></span>  
 
 <span data-ttu-id="ad3d8-1852">사용 하 여이 예제는 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> 제네릭에 저장 된 시간 및 온도 데이터를 표시 하는 메서드 <xref:System.Collections.Generic.Dictionary%602> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1852">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="ad3d8-1853">형식 문자열의 서식을 지정 하려면 두 개체는 있지만 세 개의 형식 항목에 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1853">Note that the format string has three format items, although there are only two objects to format.</span></span> <span data-ttu-id="ad3d8-1854">가 두 형식 (날짜 및 시간 값) 목록에서 첫 번째 개체를 사용 하기 때문에 이것이: 첫 번째 형식 항목 표시 되는 경우 시간 및 두 번째 날짜를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1854">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1855"><paramref name="format" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1855"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="ad3d8-1856"><paramref name="format" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1856"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1857">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1857">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1858">형식 항목의 인덱스가 0 또는 1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1858">The index of a format item is not zero or one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-1859">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1859">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ad3d8-1860">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1860">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ad3d8-1861">서식을 지정할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1861">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ad3d8-1862">서식을 지정할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1862">The second object to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1863">문자열에 있는 서식 지정 항목을 지정된 두 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1863">Replaces the format items in a string with the string representation of two specified objects.</span></span> <span data-ttu-id="ad3d8-1864">매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1864">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1865">서식 지정 항목이 <paramref name="format" /> 및 <paramref name="arg0" />의 문자열 표현으로 바뀌는 <paramref name="arg1" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1865">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1866">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 두 식의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1866">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert two expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ad3d8-1867">변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1867">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ad3d8-1868">메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 또는 형식 항목 형식 문자열에 포함 되어 해당 를호출하여개체의해당하는경우**ToString(String,IFormatProvider)** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1868">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ad3d8-1869">이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1869">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1870"><paramref name="format" />, <paramref name="arg0" /> 또는 <paramref name="arg1" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1870"><paramref name="format" />, <paramref name="arg0" />, or <paramref name="arg1" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="ad3d8-1871"><paramref name="format" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1871"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1872">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1872">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1873">형식 항목의 인덱스가 0보다 작거나, 2보다 크거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1873">The index of a format item is less than zero, or greater than or equal to two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ad3d8-1874">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1874">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ad3d8-1875">서식을 지정할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1875">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ad3d8-1876">서식을 지정할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1876">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="ad3d8-1877">서식을 지정할 세 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1877">The third object to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1878">문자열에 있는 서식 지정 항목을 지정된 세 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1878">Replaces the format items in a string with the string representation of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1879">형식 항목이 <paramref name="format" />, <paramref name="arg0" /> 및 <paramref name="arg1" />의 문자열 표현으로 바뀌는 <paramref name="arg2" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1879">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1880">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 의 세 가지 식 값의 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1880">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of three expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a><span data-ttu-id="ad3d8-1881">예: 세 개의 인수를 형식 지정</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1881">Example: Formatting three arguments</span></span>  
 
 <span data-ttu-id="ad3d8-1882">사용 하 여이 예제는 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 부울 결과 나타내는 문자열을 만들려면 메서드 `And` 두 정수 값으로 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1882">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to create a string that illustrates the result of a Boolean `And` operation with two integer values.</span></span> <span data-ttu-id="ad3d8-1883">각 항목의 형식이 두 가지 방법으로 하기 때문에 형식 문자열에 6 개의 형식 항목을 포함 되지만 메서드가 매개 변수 목록에 대 한 세 개의 항목을 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1883">Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</span></span>  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1884"><paramref name="format" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1884"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="ad3d8-1885"><paramref name="format" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1885"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1886">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1886">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1887">형식 항목의 인덱스가 0보다 작거나, 2보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1887">The index of a format item is less than zero, or greater than two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-1888">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1888">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ad3d8-1889">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1889">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ad3d8-1890">서식을 지정할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1890">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ad3d8-1891">서식을 지정할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1891">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="ad3d8-1892">서식을 지정할 세 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1892">The third object to format.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1893">문자열에 있는 서식 지정 항목을 지정된 세 개체의 문자열 표현으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1893">Replaces the format items in a string with the string representation of three specified objects.</span></span> <span data-ttu-id="ad3d8-1894">매개 변수에서 문화권별 형식 지정 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1894">An parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1895">형식 항목이 <paramref name="format" />, <paramref name="arg0" /> 및 <paramref name="arg1" />의 문자열 표현으로 바뀌는 <paramref name="arg2" />의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1895">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ad3d8-1896">이 메서드는 사용 된 [합성 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 세 개의 식을 해당 문자열 표현으로 변환 하 고 문자열에 해당 표현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1896">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert three expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ad3d8-1897">변환을 수행할, 메서드는 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1897">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ad3d8-1898">메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 또는 형식 항목 형식 문자열에 포함 되어 해당 를호출하여개체의해당하는경우**ToString(String,IFormatProvider)** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1898">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ad3d8-1899">이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1899">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1900"><paramref name="format" />, <paramref name="arg0" />, <paramref name="arg1" /> 또는 <paramref name="arg2" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1900"><paramref name="format" />, <paramref name="arg0" />, <paramref name="arg1" />, or <paramref name="arg2" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="ad3d8-1901"><paramref name="format" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1901"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="ad3d8-1902">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1902">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-1903">형식 항목의 인덱스가 0보다 작거나, 3보다 크거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1903">The index of a format item is less than zero, or greater than or equal to three.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-1904">이 문자열의 개별 문자에서 반복될 수 있는 개체를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1904">Retrieves an object that can iterate through the individual characters in this string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1905">열거자 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1905">An enumerator object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <span data-ttu-id="ad3d8-1906">호출 하는 대신는 <xref:System.String.GetEnumerator%2A> 를 검색할 메서드는 <xref:System.CharEnumerator> 개체 다음 문자열을 열거할 때 사용, 해당 언어의 열거자를 대신 사용 해야 (C#, C + + /cli CLR, 및 Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1906">Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).</span></span>                   <span data-ttu-id="ad3d8-1907">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) C#에서는 [각각에 대해](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79) C + + CLR, 및 [각각에 대해](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1907">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#,                  [for each](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79) in C++/CLR, and                  [For Each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).</span></span>  
  
 <span data-ttu-id="ad3d8-1908">이 메서드를 사용 하면 문자열의 개별 문자를 반복할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1908">This method enables you to iterate the individual characters in a string.</span></span> <span data-ttu-id="ad3d8-1909">예를 들어, Visual Basic `For Each` 및 C# `foreach` 반환 하려면이 메서드를 호출 하는 문을 <xref:System.CharEnumerator> 는이 인스턴스의 문자를 문자열에 대 한 읽기 전용 액세스를 제공할 수 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1909">For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1910">다음 예제에서는 여러 개의 문자열에 문자를 반복 하 고 해당 개별 문자에 대 한 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1910">The following example iterates the characters in several strings and displays information about their individual characters.</span></span> <span data-ttu-id="ad3d8-1911">에 대 한 호출 하지 않고 언어 반복 구문을 사용 하 여는 <xref:System.String.GetEnumerator%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1911">It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.</span></span>  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-1912">해당 문자열에 대한 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1912">Returns the hash code for this string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1913">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1913">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1914">동작은 <xref:System.String.GetHashCode%2A> 공용 언어 런타임에의 한 버전에서 변경 될 수 있습니다 하는 구현에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1914">The behavior of <xref:System.String.GetHashCode%2A> is dependent on its implementation, which might change from one version of the common language runtime to another.</span></span> <span data-ttu-id="ad3d8-1915">성능을 향상 시키기 위해이 문제가 발생 하는 이유는 <xref:System.String.GetHashCode%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1915">A reason why this might happen is to improve the performance of <xref:System.String.GetHashCode%2A>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ad3d8-1916">두 string 개체 같으면는 <xref:System.String.GetHashCode%2A> 메서드 같은 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1916">If two string objects are equal, the <xref:System.String.GetHashCode%2A> method returns identical values.</span></span> <span data-ttu-id="ad3d8-1917">그러나 않습니다 각 고유한 문자열 값에 대 한 고유 해시 코드 값.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1917">However, there is not a unique hash code value for each unique string value.</span></span> <span data-ttu-id="ad3d8-1918">서로 다른 문자열이 동일한 해시 코드를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1918">Different strings can return the same hash code.</span></span>  
>   
>  <span data-ttu-id="ad3d8-1919">해시 코드 자체은 안정적인 것으로 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1919">The hash code itself is not guaranteed to be stable.</span></span> <span data-ttu-id="ad3d8-1920">동일한 문자열에 대 한 해시 코드 (예: 32 비트 및 64 비트)는 단일 버전의.NET Framework에 대 한 플랫폼 및 버전의.NET Framework에서 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1920">Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</span></span> <span data-ttu-id="ad3d8-1921">경우에 따라 응용 프로그램 도메인 별로 다도 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1921">In some cases, they can even differ by application domain.</span></span> <span data-ttu-id="ad3d8-1922">즉, 같은 프로그램의 후속 실행을 두 개의 다른 해시 코드를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1922">This implies two subsequent runs of the same program may return different hash codes.</span></span>  
>   
>  <span data-ttu-id="ad3d8-1923">결과적으로 해시 코드 작성 된 응용 프로그램 도메인 외부에서 사용할 수는 없습니다는 컬렉션의 키 필드와 사용 하지 않아야 하 고 유지 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1923">As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</span></span>  
>   
>  <span data-ttu-id="ad3d8-1924">마지막으로, 하지 않는 암호화 된 강력한 해시 해야 할 경우 암호화 해시 함수에서 반환 된 값 대신 해시 코드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1924">Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="ad3d8-1925">파생 된 클래스를 사용 하 여 암호화 해시에 대 한는 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 또는 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1925">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
>   
>  <span data-ttu-id="ad3d8-1926">해시 코드에 대 한 자세한 내용은 참조 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1926">For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ad3d8-1927">데스크톱 앱에서 사용할 수 있습니다는 [ \<UseRandomizedStringHashAlgorithm > 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) 에 고유한 해시 코드를 생성 하는 응용 프로그램 도메인 단위로.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1927">In desktop apps, you can use the             [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="ad3d8-1928">수 충돌 수 줄이고 삽입 및 해시 테이블을 사용 하는 조회의 전체 성능을 향상 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1928">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="ad3d8-1929">사용 하는 방법을 보여 주는 다음 예제는 [ \<UseRandomizedStringHashAlgorithm > 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1929">The following example shows how to use the                [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span> <span data-ttu-id="ad3d8-1930">정의 고유한 해시 코드를 생성에 응용 프로그램 도메인 단위로.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1930">It defines a  to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="ad3d8-1931">수 충돌 수 줄이고 삽입 및 해시 테이블을 사용 하는 조회의 전체 성능을 향상 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1931">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="ad3d8-1932">사용 하는 방법을 보여 주는 다음 예제는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1932">The following example shows how to use the .</span></span> <span data-ttu-id="ad3d8-1933">정의 `DisplayString` 개인 문자열 상수를 포함 하는 클래스 `s`, 해당 값은 "는 문자열입니다."</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1933">It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string."</span></span> <span data-ttu-id="ad3d8-1934">메서드를 실행하는 응용 프로그램 도메인의 이름과 함께 문자열 값 및 해시 코드를 표시하는 `ShowStringHashCode` 메서드도 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1934">It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</span></span>  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 <span data-ttu-id="ad3d8-1935">구성 파일을 지정하지 않고 이 예제를 실행할 경우 다음과 유사한 출력이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1935">When you run the example without supplying a configuration file, it displays output similar to the following.</span></span> <span data-ttu-id="ad3d8-1936">문자열의 해시 코드는 두 응용 프로그램 도메인에서 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1936">Note that the hash codes for the string are identical in the two application domains.</span></span>  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 <span data-ttu-id="ad3d8-1937">하지만 샘플 디렉터리에 다음의 구성을 추가하고 샘플을 실행하는 경우 동일 문자열의 해시 코드는 응용 프로그램 도메인에 의해 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1937">However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</span></span>  
  
```  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 <span data-ttu-id="ad3d8-1938">구성 파일이 있는 경우 예제는 다음과 같은 출력을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1938">When the configuration file is present, the example displays the following output:</span></span>  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  <span data-ttu-id="ad3d8-1939">해시 코드를 삽입 하 고 효율적으로 해시 테이블에서 키가 지정 된 개체를 검색 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1939">Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</span></span> <span data-ttu-id="ad3d8-1940">그러나 해시 코드 문자열을 고유 하 게 식별 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1940">However, hash codes don't uniquely identify strings.</span></span> <span data-ttu-id="ad3d8-1941">동일한 문자열 같은 해시 코드를 갖지만 공용 언어 런타임에서 다른 문자열에는 동일한 해시 코드 할당할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1941">Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</span></span> <span data-ttu-id="ad3d8-1942">또한.NET Framework의 버전, 단일 버전 내에서 플랫폼 및 응용 프로그램 도메인에서 해시 코드 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1942">In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</span></span> <span data-ttu-id="ad3d8-1943">이 때문에 serialize 하거나 해시 코드 값을 유지 해야 하거나 해시 테이블 또는 사전에 키로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1943">Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</span></span>  
  
 <span data-ttu-id="ad3d8-1944">해시 코드의 사용에 대 한 자세한 내용은 및 `GetHashCode` 메서드를 참조 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1944">For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1945">다음 예제는 <xref:System.String.GetHashCode%2A> 다양 한를 사용 하 여 메서드 입력 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1945">The following example demonstrates the <xref:System.String.GetHashCode%2A> method using various input strings.</span></span>  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1946">반환한 값 <see cref="M:System.String.GetHashCode" /> 플랫폼에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1946">The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent.</span></span> <span data-ttu-id="ad3d8-1947">32 비트 및 64 비트 버전의.NET Framework에 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1947">It differs on the 32-bit and 64-bit versions of the .NET Framework.</span></span> <span data-ttu-id="ad3d8-1948">.NET Framework의 버전 간에 달라질 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1948">It also can differ between versions of the .NET Framework.</span></span></para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-1949"><see cref="T:System.TypeCode" /> 클래스에 대한 <see cref="T:System.String" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1949">Returns the <see cref="T:System.TypeCode" /> for class <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1950">열거형 상수인 <see cref="F:System.TypeCode.String" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1950">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ad3d8-1951">다음 예제에서는 표시는 <xref:System.TypeCode> 에 대 한 열거형된 상수는 <xref:System.String> 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1951">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-1952">이 인스턴스에서 맨 처음 발견되는 지정된 유니코드 문자 또는 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1952">Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="ad3d8-1953">이 인스턴스에 해당 문자나 문자열이 없으면 이 메서드는 -1을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1953">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1954">검색할 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1954">A Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1955">이 문자열에서 맨 처음 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1955">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1956">해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1956">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1957">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1957">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ad3d8-1958">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1958">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-1959">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1959">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1960">다음 예제에서는 방법을 검색할 수 있습니다는 <xref:System.String> 사용 하 여 문자에 대 한는 <xref:System.String.IndexOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1960">The following example demonstrates how you can search a <xref:System.String> for a character using the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1961">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1961">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1962">이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1962">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1963">해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1963">The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-1964"><paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1964">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1965">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1965">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ad3d8-1966">이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1966">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ad3d8-1967">이 인스턴스의 첫 번째 문자 위치에서 시작 하 고 마지막 문자 위치까지 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1967">The search begins at the first character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="ad3d8-1968">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1968">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-1969">문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1969">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-1970">경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.IndexOf%28System.String%29> 메서드는 항상 현재 인스턴스의 시작 부분에서 일치 항목은 발견 되었음을 나타내려면 0 (영)을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1970">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%29> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span> <span data-ttu-id="ad3d8-1971">다음 예제에서는 <xref:System.String.IndexOf%28System.String%29> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1971">In the following example, the <xref:System.String.IndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ad3d8-1972">문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1972">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ad3d8-1973">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 각각의 경우에는 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 결과 동일에 붙은 사용자 지정 하이픈이 포함 되지 않았던 마치 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1973">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="ad3d8-1974">하이픈이를 검색할 때 메서드를 나타내는 문자열의 시작 부분에서 일치 하는 항목이 발견 했다는 0 (영)을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1974">When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</span></span>  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1975">다음 예제에서는 "동물"에서 "n"를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1975">The following example searches for the "n" in "animal".</span></span> <span data-ttu-id="ad3d8-1976">문자열 인덱스를 보다는 0부터 시작 하므로 <xref:System.String.IndexOf%28System.String%29> 메서드 위치 1에 "n" 임을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1976">Because string indexes begin at zero rather than one, the <xref:System.String.IndexOf%28System.String%29> method indicates that the "n" is at position 1.</span></span>  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 <span data-ttu-id="ad3d8-1977">다음 예제에서는 <xref:System.String.IndexOf%2A> 문장의 동물 이름의 시작 위치를 결정 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1977">The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence.</span></span> <span data-ttu-id="ad3d8-1978">다음이 위치를 사용 하 여는 문장으로 동물을 설명 하는 형용사를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1978">It then uses this position to insert an adjective that describes the animal into the sentence.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-1979"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1979"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-1980">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1980">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-1981">현재 문화권의 비교 규칙을 사용 하 여 문자열 인스턴스 내에서 부분 문자열의 첫 번째 인덱스를 찾으려면, 호출의 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 `comparisonType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1981">To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1982">검색할 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1982">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-1983">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1983">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1984">이 문자열에서 맨 처음 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1984">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="ad3d8-1985">검색은 지정된 문자 위치에서 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1985">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1986">해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치는 문자열의 시작 부분에서 0부터 시작되고 해당 문자열이 없으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1986">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-1987">인덱스 번호는 0에서 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1987">Index numbering starts from 0.</span></span> <span data-ttu-id="ad3d8-1988">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1988">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ad3d8-1989">경우 `startIndex` 문자열 인스턴스 길이 같으면, 메서드가-1을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1989">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ad3d8-1990">검색 범위에서 `startIndex` 문자열의 끝에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1990">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="ad3d8-1991">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1991">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-1992">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1992">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-1993">다음 예제는 <xref:System.String.IndexOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1993">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-1994"><paramref name="startIndex" />가 0보다 작거나 문자열의 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1994"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-1995">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1995">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-1996">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1996">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ad3d8-1997">이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1997">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="ad3d8-1998">검색은 지정된 문자 위치에서 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1998">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-1999">해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 인덱스 위치(0부터 시작)이고, 해당 문자열이 없으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-1999">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-2000"><paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2000">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2001">인덱스 번호는 0에서 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2001">Index numbering starts from 0.</span></span> <span data-ttu-id="ad3d8-2002">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2002">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ad3d8-2003">경우 `startIndex` 문자열 인스턴스 길이 같으면, 메서드가-1을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2003">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ad3d8-2004">이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2004">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ad3d8-2005">검색이 시작 된 `startIndex` 문자이 인스턴스의 위치 및 마지막 문자 위치까지 계속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2005">The search begins at the `startIndex` character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="ad3d8-2006">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2006">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2007">문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2007">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2008">경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2008">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ad3d8-2009">다음 예제에서는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 메서드 뒤에 두 개의 문자열에 "m" 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2009">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</span></span> <span data-ttu-id="ad3d8-2010">문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2010">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ad3d8-2011">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2011">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</span></span> <span data-ttu-id="ad3d8-2012">"m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2012">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2013">다음 예제에서는 대상 문자열에 지정된 된 문자열의 문자열을 모두 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2013">The following example searches for all occurrences of a specified string within a target string.</span></span>  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2014"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2014"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2015"><paramref name="startIndex" />가 0보다 작거나 이 문자열의 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2015"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2016">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2016">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-2017">현재 문화권의 비교 규칙을 사용 하 여 특정 문자 위치 후 발생 하는 부분 문자열의 첫 번째 인덱스를 찾으려면, 호출 된 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 `comparisonType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2017">To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2018">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2018">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-2019">검색 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2019">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2020">현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2020">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ad3d8-2021">매개 변수는 지정된 문자열에 사용할 검색 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2021">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2022">문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치이고, 그러지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2022">The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-2023"><paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2023">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2024">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2024">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2025">`comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2025">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2026">다음 exampledemonstrates 3 오버 로드는 <xref:System.String.IndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 첫 번째 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2026">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2027"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2027"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-2028"><paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2028"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2029">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2029">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2030">문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2030">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2031">경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드는 항상 현재 인스턴스의 시작 부분에서 일치 항목은 발견 되었음을 나타내려면 0 (영)을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2031">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2032">다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2032">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ad3d8-2033">문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2033">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ad3d8-2034">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 문화권 구분 검색 반환 하이픈 검색 문자열에 포함 되지 않은 경우 반환 된 값과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2034">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="ad3d8-2035">그러나 서 수 검색을 성공적으로 하이픈 한 문자열에서 찾아 보고 해주어에서 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2035">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
 [!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)]
 [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2036">검색할 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2036">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2037">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2037">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2038">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2038">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2039">이 인스턴스에서 맨 처음 발견되는 지정된 문자의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2039">Reports the zero-based index of the first occurrence of the specified character in this instance.</span></span> <span data-ttu-id="ad3d8-2040">검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2040">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2041">해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치는 문자열의 시작 부분에서 0부터 시작되고 해당 문자열이 없으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2041">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2042">검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2042">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ad3d8-2043">에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2043">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ad3d8-2044">인덱스 번호 0 (영)부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2044">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ad3d8-2045">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2045">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2046">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2046">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-2047">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2047">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2048">다음 예제는 <xref:System.String.IndexOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2048">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2049"><paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2049"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2050">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2050">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2051"><paramref name="startIndex" />가 이 문자열의 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2051"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
 <span data-ttu-id="ad3d8-2052">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2052">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2053"><paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2053"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2054">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2054">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2055">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2055">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2056">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2056">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2057">이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2057">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="ad3d8-2058">검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2058">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2059">해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 인덱스 위치(0부터 시작)이고, 해당 문자열이 없으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2059">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-2060"><paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2060">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2061">인덱스 번호 0 (영)부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2061">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ad3d8-2062">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2062">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2063">이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2063">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ad3d8-2064">검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2064">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ad3d8-2065">에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2065">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ad3d8-2066">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2066">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2067">문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2067">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2068">경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2068">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ad3d8-2069">다음 예제에서는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드 뒤에 "m"부터 두 문자열의 여섯 번째 문자 위치에서 세 번째 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2069">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="ad3d8-2070">문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2070">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ad3d8-2071">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2071">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2072">"m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2072">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2073">다음 예제에서는 문자열의 모든 항목의 인덱스를 찾습니다 다른 문자열의 부분 문자열에서 "he"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2073">The following example finds the index of all occurrences of the string "he" within a substring of another string.</span></span> <span data-ttu-id="ad3d8-2074">각 검색 반복에 대해 검색할 문자의 수를 다시 계산 해야 하는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2074">Note that the number of characters to be searched must be recalculated for each search iteration.</span></span>  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2075"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2075"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2076"><paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2076"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2077">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2077">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2078"><paramref name="startIndex" />가 이 문자열의 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2078"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
 <span data-ttu-id="ad3d8-2079">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2079">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2080"><paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2080"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2081">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2081">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-2082">이 작업을 수행 하려면 현재 문화권의 비교 규칙을 사용 하려면 호출는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 `comparisonType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2082">To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2083">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2083">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2084">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2084">The search starting position.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-2085">검색 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2085">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2086">현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2086">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ad3d8-2087">매개 변수는 현재 문자열의 검색 시작 위치와 지정된 문자열에 사용할 검색 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2087">Parameters specify the starting search position in the current string and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2088">해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 없으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2088">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-2089"><paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2089">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2090">인덱스 번호는 0에서 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2090">Index numbering starts from 0.</span></span> <span data-ttu-id="ad3d8-2091">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2091">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ad3d8-2092">경우 `startIndex` 문자열 인스턴스 길이 같으면, 메서드가-1을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2092">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ad3d8-2093">`comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2093">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2094">다음 exampledemonstrates 3 오버 로드는 <xref:System.String.IndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 첫 번째 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2094">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2095"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2095"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2096"><paramref name="startIndex" />가 0보다 작거나 이 문자열의 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2096"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-2097"><paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2097"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2098">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2098">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2099">문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2099">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2100">경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2100">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="ad3d8-2101">다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m"가 포함 된 두 문자열의 세 번째 문자 위치부터 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2101">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</span></span> <span data-ttu-id="ad3d8-2102">문자열 중 하나에만 필수 부분 문자열이 포함 되어 있습니다. 이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2102">Only one of the strings contains the required substring.If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2103">"m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2103">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="ad3d8-2104">메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2104">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)]
 [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2105">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2105">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2106">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2106">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2107">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2107">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-2108">검색 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2108">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2109">현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2109">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ad3d8-2110">매개 변수는 현재 문자열의 검색 시작 위치, 검색할 현재 문자열의 문자 수 및 지정된 문자열에 사용할 검색 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2110">Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2111">해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 없으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2111">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-2112"><paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2112">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2113">인덱스 번호 0 (영)부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2113">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ad3d8-2114">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2114">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2115">검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2115">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ad3d8-2116">에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2116">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ad3d8-2117">`comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2117">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2118">다음 exampledemonstrates 3 오버 로드는 <xref:System.String.IndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 첫 번째 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2118">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2119"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2119"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2120"><paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2120"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2121">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2121">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2122"><paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2122"><paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2123">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2123">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2124"><paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2124"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-2125"><paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2125"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2126">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2126">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2127">문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2127">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2128">경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2128">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="ad3d8-2129">다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m"부터 두 문자열의 여섯 번째 문자 위치에서 세 번째 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2129">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="ad3d8-2130">문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2130">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ad3d8-2131">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2131">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2132">그러나 서 수 비교를 수행 하는 경우 찾으면 부분 문자열이 첫 번째 문자열에만 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2132">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="ad3d8-2133">참고의 경우 첫 번째 문자열 뒤에 "m" 하이픈을 포함 하는 메서드는 사용자 지정 하이픈의 인덱스를 반환 하지 못하고 문화권 구분 비교를 수행 하는 경우 대신 "m"의 인덱스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2133">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2134">메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2134">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)]
 [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2135">지정된 유니코드 문자 배열에 있는 문자 중에서 이 인스턴스에서 맨 처음 발견되는 문자의 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2135">Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ad3d8-2136">이 인스턴스에 해당 문자가 없으면 메서드는 -1을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2136">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ad3d8-2137">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2137">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2138">지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2138">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2139">이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2139">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2140">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2140">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2141">에 대 한 검색 `anyOf` 대 소문자를 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2141">The search for `anyOf` is case-sensitive.</span></span> <span data-ttu-id="ad3d8-2142">경우 `anyOf` (가) 빈 배열에서 문자열의 시작 부분에서 일치 하는 방법 찾습니다 (즉, 인덱스 0에).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2142">If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</span></span>  
  
 <span data-ttu-id="ad3d8-2143">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2143">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-2144">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2144">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2145">다음 예제에서는 문자열에서 첫 번째 모음을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2145">The following example finds the first vowel in a string.</span></span>  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2146"><paramref name="anyOf" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2146"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ad3d8-2147">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2147">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2148">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2148">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2149">지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2149">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ad3d8-2150">검색은 지정된 문자 위치에서 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2150">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2151">이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2151">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2152">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2152">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2153">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 보다 1 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2153">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2154">검색 범위에서 `startIndex` 문자열의 끝에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2154">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="ad3d8-2155">에 대 한 검색 `anyOf` 대 소문자를 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2155">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2156">이 메서드 유니코드 스칼라 값의 동일 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2156">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ad3d8-2157">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2157">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2158">다음 예제에서는 다른 문자열의 부분 문자열에서 "is"는 문자열의 문자를 일치 하는 항목의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2158">The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2159"><paramref name="anyOf" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2159"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2160"><paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2160"><paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2161">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2161">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2162"><paramref name="startIndex" />가 이 인스턴스에 포함된 문자 수보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2162"><paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ad3d8-2163">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2163">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2164">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2164">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2165">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2165">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2166">지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2166">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ad3d8-2167">검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2167">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2168">이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2168">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2169">검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2169">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ad3d8-2170">에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2170">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ad3d8-2171">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2171">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2172">`startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 보다 1 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2172">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2173">에 대 한 검색 `anyOf` 대 소문자를 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2173">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2174">이 메서드 유니코드 스칼라 값의 동일 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2174">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ad3d8-2175">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2175">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2176">다음 예제에서는 다른 문자열의 부분 문자열에서 "aid" 문자열의 문자를 일치 하는 항목의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2176">The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2177"><paramref name="anyOf" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2177"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2178"><paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2178"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2179">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2179">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2180"><paramref name="count" /> + <paramref name="startIndex" />가 이 인스턴스의 문자 수보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2180"><paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ad3d8-2181">삽입의 0부터 시작하는 인덱스 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2181">The zero-based index position of the insertion.</span></span></param>
        <param name="value"><span data-ttu-id="ad3d8-2182">삽입할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2182">The string to insert.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2183">이 인스턴스의 지정된 인덱스 위치에 지정한 문자열이 삽입되는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2183">Returns a new string in which a specified string is inserted at a specified index position in this instance.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2184">이 인스턴스와 동일하지만 <paramref name="value" /> 위치에 <paramref name="startIndex" />가 삽입된 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2184">A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2185">경우 `startIndex` 이 인스턴스의 길이 같으면 `value` 이 인스턴스의 끝에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2185">If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2186">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2186">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2187">새 문자열을 반환 대신 `value` 가 현재 인스턴스에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2187">Instead, it returns a new string in which `value` is inserted into the current instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2188">반환 값의 예를 들어 `"abc".Insert(2, "XYZ")` "abXYZc" 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2188">For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2189">다음 예제에서는 문자열의 네 번째 문자 위치 (인덱스 3에 문자)에 나오는 공백 문자를 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2189">The following example inserts a space character in the fourth character position (the character at index 3) of a string.</span></span>  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 <span data-ttu-id="ad3d8-2190">다음 콘솔 응용 프로그램에는 사용자가 두 개의 동물을 설명 하기 위해 하나 이상의 형용사를 입력 하도록 메시지 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2190">The following console application prompts the users to enter one or more adjectives to describe two animals.</span></span> <span data-ttu-id="ad3d8-2191">그런 다음 호출 하는 <xref:System.String.Insert%2A> 메서드는 문자열에 사용자가 입력 한 텍스트를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2191">It then calls the <xref:System.String.Insert%2A> method to insert the text entered by the user into a string.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2192"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2192"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2193"><paramref name="startIndex" />가 음수이거나 이 인스턴스의 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2193"><paramref name="startIndex" /> is negative or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ad3d8-2194">내부 풀에서 검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2194">A string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2195">지정된 <see cref="T:System.String" />에 대한 시스템의 참조를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2195">Retrieves the system's reference to the specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2196"><paramref name="str" />이 내부 풀에 추가되었으면 해당 시스템 참조이고, 그러지 않으면 <paramref name="str" /> 값을 가진 문자열에 대한 새 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2196">The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2197">공용 언어 런타임 선언 또는 프로그램에서 프로그래밍 방식으로 만든 각 고유 리터럴 문자열에 대 한 단일 참조를 포함 하는 내부 풀 이라는 테이블을 유지 하 여 문자열 저장소를 절약 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2197">The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</span></span> <span data-ttu-id="ad3d8-2198">따라서 특정 값으로는 리터럴 문자열의 인스턴스만 한 번 시스템에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2198">Consequently, an instance of a literal string with a particular value only exists once in the system.</span></span>  
  
 <span data-ttu-id="ad3d8-2199">예를 들어 여러 변수에 동일한 리터럴 문자열을 할당 하는 경우 런타임 내부 풀에서 리터럴 문자열에 같은 참조를 검색 및 각 변수에 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2199">For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</span></span>  
  
 <span data-ttu-id="ad3d8-2200"><xref:System.String.Intern%2A> 메서드 내부 풀의 값과 같은 문자열 검색을 사용 하 여 `str`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2200">The <xref:System.String.Intern%2A> method uses the intern pool to search for a string equal to the value of `str`.</span></span> <span data-ttu-id="ad3d8-2201">해당 문자열이 있으면 해당 참조는 내부 풀에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2201">If such a string exists, its reference in the intern pool is returned.</span></span> <span data-ttu-id="ad3d8-2202">문자열 존재 하지 않는 경우에 대 한 참조 `str` 반환 되 고 참조 하는 내부 풀에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2202">If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.</span></span>  
  
 <span data-ttu-id="ad3d8-2203">다음 예제에서는 "mytest" 값이 문자열 s1은 이미 인턴 지정은 프로그램의 리터럴 이기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2203">In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</span></span> <span data-ttu-id="ad3d8-2204"><xref:System.Text.StringBuilder?displayProperty=nameWithType> 클래스 s 1과 동일한 값을 갖는 새 문자열 개체를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2204">The <xref:System.Text.StringBuilder?displayProperty=nameWithType> class generates a new string object that has the same value as s1.</span></span> <span data-ttu-id="ad3d8-2205">이 문자열에 대 한 참조는 s 2에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2205">A reference to that string is assigned to s2.</span></span> <span data-ttu-id="ad3d8-2206"><xref:System.String.Intern%2A> s 2와 동일한 값을 가진 문자열에 대 한 메서드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2206">The <xref:System.String.Intern%2A> method searches for a string that has the same value as s2.</span></span> <span data-ttu-id="ad3d8-2207">이러한 문자열 존재 하기 때문에 s 1에 할당 된 동일한 참조가 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2207">Because such a string exists, the method returns the same reference that is assigned to s1.</span></span> <span data-ttu-id="ad3d8-2208">참조 하는 s 3에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2208">That reference is then assigned to s3.</span></span> <span data-ttu-id="ad3d8-2209">참조 s1 및 s2 같지 않은 다른 개체 참조 하기 때문에 동일한 문자열 참조 하기 때문에 참조 s1 및 s 3 같은지 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2209">References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</span></span>  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 <span data-ttu-id="ad3d8-2210">이 <xref:System.String.IsInterned%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2210">Compare this method to the <xref:System.String.IsInterned%2A> method.</span></span>  
  
## <a name="version-considerations"></a><span data-ttu-id="ad3d8-2211">버전 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2211">Version Considerations</span></span>  
 <span data-ttu-id="ad3d8-2212">에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> 메서드는.NET Framework 1.0 및 1.1 빈 문자열 인터닝 관련 하 여 해당 동작으로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2212">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], the <xref:System.String.Intern%2A> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</span></span> <span data-ttu-id="ad3d8-2213">다음 예에서 변수 `str1` 에 대 한 참조를 할당 된 <xref:System.String.Empty>, 변수 및 `str2` 에 대 한 참조를 할당 된 <xref:System.String.Empty> 호출 하 여 반환 되는 <xref:System.String.Intern%2A> 메서드는 변환한후<xref:System.Text.StringBuilder>값을 가진 개체 <xref:System.String.Empty> 문자열로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2213">In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty>, and the variable `str2` is assigned the reference to <xref:System.String.Empty> that is returned by calling the <xref:System.String.Intern%2A> method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty> to a string.</span></span> <span data-ttu-id="ad3d8-2214">에 포함 된 참조 다음 `str1` 및 `str2` 동등한 지 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2214">Then the references contained in `str1` and `str2` are compared for equality.</span></span>  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 <span data-ttu-id="ad3d8-2215">에 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], 및 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` 및 `str2` 같은지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2215">In the [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal.</span></span> <span data-ttu-id="ad3d8-2216">에 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] 및 [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` 및 `str2` 같지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2216">In the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ad3d8-2217">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2217">Performance Considerations</span></span>  
 <span data-ttu-id="ad3d8-2218">총 메모리 양을 줄이기 위해 시도 하는 경우 응용 프로그램 할당, 하는 문자열 인터닝 두 원치 않는 부작용 염두에서에 둬야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2218">If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</span></span> <span data-ttu-id="ad3d8-2219">내부 풀에 추가 대 한 메모리가 할당 하는 첫째, <xref:System.String> 개체는 가능성이 해제 될 공용 언어 런타임 (CLR) 종료 될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2219">First, the memory allocated for interned <xref:System.String> objects is not likely be released until the common language runtime (CLR) terminates.</span></span> <span data-ttu-id="ad3d8-2220">이유는는 풀에 대 한 참조를 CLR의 <xref:System.String> 개체 내부 응용 프로그램 또는 사용자 응용 프로그램 도메인, 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2220">The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates.</span></span> <span data-ttu-id="ad3d8-2221">둘째, 문자열을 내부 화를 먼저 만들어야 합니다는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2221">Second, to intern a string, you must first create the string.</span></span> <span data-ttu-id="ad3d8-2222">사용 되는 메모리는 <xref:System.String> 개체 해야 여전히를 할당할 수 있지만 메모리 가비지 수집 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2222">The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.</span></span>  
  
 <span data-ttu-id="ad3d8-2223">.NET Framework 버전 2.0에 도입 된 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> 열거형 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2223">The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> enumeration member.</span></span> <span data-ttu-id="ad3d8-2224"><xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 멤버 문자열 리터럴 인턴 지정 필요 하지 않은 어셈블리를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2224">The <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> member marks an assembly as not requiring string-literal interning.</span></span> <span data-ttu-id="ad3d8-2225">적용할 수 있습니다 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 를 사용 하 여 어셈블리에는 <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2225">You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute.</span></span> <span data-ttu-id="ad3d8-2226">또한 사용 하는 경우는 [Ngen.exe (네이티브 이미지 생성기)](~/docs/framework/tools/ngen-exe-native-image-generator.md) 런타임 이전 어셈블리를 컴파일, 문자열은 모듈 간에 인턴 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2226">Also, when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to compile an assembly in advance of run time, strings are not interned across modules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2227">다음 예제에서는 세 개의 문자열 같은 새로 만든된 문자열과 지 여부를 결정 하는 값을 사용 하 여 및 인턴 지정된 문자열이 같은지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2227">The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</span></span>  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2228"><paramref name="str" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2228"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ad3d8-2229">내부 풀에서 검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2229">The string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2230">지정된 <see cref="T:System.String" />에 대한 참조를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2230">Retrieves a reference to a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2231"><paramref name="str" />이 공용 언어 런타임 내부 풀에 있으면 해당 참조이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2231">A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2232">공용 언어 런타임에서 자동으로 테이블을 유지 하는데의 모든 고유 인스턴스를 비롯 하 여 프로그램에 선언 된 각 고유한 리터럴 문자열 상수의 단일 인스턴스를 포함 하는 내부 풀 이라는 <xref:System.String> 호출 하 여 프로그래밍 방식으로 추가 <xref:System.String.Intern%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2232">The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="ad3d8-2233">내부 풀 문자열 저장소를 절약합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2233">The intern pool conserves string storage.</span></span> <span data-ttu-id="ad3d8-2234">각 변수는 내부 풀의 여러 인스턴스를 참조 하는 대신에 동일한 상수 참조로 설정 됩니다 여러 변수에 리터럴 문자열 상수를 할당 하는 경우 <xref:System.String> 동일한 값을 갖는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2234">If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.</span></span>  
  
 <span data-ttu-id="ad3d8-2235">이 메서드를 찾습니다 `str` 내부 풀에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2235">This method looks up `str` in the intern pool.</span></span> <span data-ttu-id="ad3d8-2236">경우 `str` 가 이미 반환 되 고, 그렇지 않으면 해당 인스턴스에 대 한 참조는 풀 `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2236">If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.</span></span>  
  
 <span data-ttu-id="ad3d8-2237">이 <xref:System.String.Intern%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2237">Compare this method to the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="ad3d8-2238">이 메서드는 부울 값을 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2238">This method does not return a Boolean value.</span></span> <span data-ttu-id="ad3d8-2239">특정 문자열은 인턴 지정 하는지 여부를 나타내는 부울 값을 반환 하기 때문에 메서드를 호출 하는 경우에 다음과 같은 코드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2239">If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</span></span>  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2240">.NET Framework 버전 2.0 부터는 재정의할 수 있습니다는 내부 풀의 사용 하 여 사용 하는 경우는 [Ngen.exe (네이티브 이미지 생성기)](~/docs/framework/tools/ngen-exe-native-image-generator.md) 로컬 컴퓨터의 네이티브 이미지 캐시에는 어셈블리를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2240">Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to install an assembly to the native image cache on a local computer.</span></span> <span data-ttu-id="ad3d8-2241">자세한 내용은 성능 고려 사항에 대 한 설명 섹션을 참조 하십시오.는 <xref:System.String.Intern%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2241">For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2242">다음 예에서는 리터럴 문자열 컴파일러에 의해 자동으로 수행 됩니다 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2242">The following example demonstrates that literal strings are interned automatically by the compiler.</span></span>  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2243"><paramref name="str" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2243"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2244">이 문자열의 형식이 특정 유니코드 정규화 형식인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2244">Indicates whether this string is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-2245">이 문자열의 형식이 유니코드 정규화 형식 C인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2245">Indicates whether this string is in Unicode normalization form C.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-2246">이 문자열의 형식이 정규화 형식 C이면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2246"><see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2247">일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2247">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ad3d8-2248">단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2248">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ad3d8-2249">표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2249">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ad3d8-2250">정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2250">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ad3d8-2251">.NET Framework는 현재 정규화 형식 C, D, KC 및 KD를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2251">The .NET Framework currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="ad3d8-2252">지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2252">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2253">다음 예제에서는 문자열 성공적으로 다양 한 정규화 형식으로 정규화 되어 있는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2253">The following example determines whether a string is successfully normalized to various normalization forms.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ad3d8-2254">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2254">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2255"><see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2255">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ad3d8-2256">따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2256">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="ad3d8-2257">유니코드 정규화 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2257">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2258">이 문자열의 형식이 지정한 유니코드 정규화 형식인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2258">Indicates whether this string is in the specified Unicode normalization form.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-2259">이 문자열의 형식이 <see langword="true" /> 매개 변수로 지정된 정규화 형식이면 <paramref name="normalizationForm" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2259"><see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2260">일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2260">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ad3d8-2261">단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2261">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ad3d8-2262">표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2262">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ad3d8-2263">정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2263">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ad3d8-2264">.NET Framework는 현재 정규화 형식 C, D, KC 및 KD를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2264">The .NET Framework currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="ad3d8-2265">지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2265">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2266">다음 예제는 <xref:System.String.IsNormalized%2A> 및 <xref:System.String.Normalize%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2266">The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ad3d8-2267">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2267">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2268"><see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2268">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ad3d8-2269">따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2269">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2270">테스트할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2270">The string to test.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2271">지정된 문자열이 <see langword="null" />이거나 <see cref="F:System.String.Empty" /> 문자열인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2271">Indicates whether the specified string is <see langword="null" /> or an <see cref="F:System.String.Empty" /> string.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-2272"><see langword="true" /> 매개 변수가 <paramref name="value" />이거나 빈 문자열("")이면 <see langword="null" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2272"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2273"><xref:System.String.IsNullOrEmpty%2A> 동시에 테스트할 수 있도록 하는 편리한 메서드입니다 여부는 <xref:System.String> 은 `null` 여부나 해당 값이 <xref:System.String.Empty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2273"><xref:System.String.IsNullOrEmpty%2A> is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String.Empty>.</span></span> <span data-ttu-id="ad3d8-2274">다음 코드를 하는 것이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2274">It is equivalent to the following code:</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 <span data-ttu-id="ad3d8-2275">사용할 수 있습니다는 <xref:System.String.IsNullOrWhiteSpace%2A> 메서드는 문자열이 있는지 여부를 테스트 `null`, 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>, 또는 공백 문자로 구성 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2275">You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=nameWithType>,  or it consists only of white-space characters.</span></span>  
  
## <a name="what-is-a-null-string"></a><span data-ttu-id="ad3d8-2276">Null 문자열 이란?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2276">What is a null string?</span></span>  
 <span data-ttu-id="ad3d8-2277">문자열은 `null` 에 명시적으로 할당 된 경우의 값 또는 값 (c + + 및 Visual Basic) 할당 하지 않은 경우 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2277">A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of `null`.</span></span> <span data-ttu-id="ad3d8-2278">하지만 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 기능 해당 멤버를 throw 하는 경우 하나를 호출 하는 다음 예제와 같이 null 문자열을 정상적으로 처리할 수는 <xref:System.NullReferenceException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2278">Although the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a><span data-ttu-id="ad3d8-2279">빈 문자열 이란?</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2279">What is an empty string?</span></span>  
 <span data-ttu-id="ad3d8-2280">문자열은 빈 문자열을 명시적으로 할당 된 경우에 빈 ("") 또는 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2280">A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-2281">빈 문자열에는 <xref:System.String.Length%2A> 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2281">An empty string has a <xref:System.String.Length%2A> of 0.</span></span>  <span data-ttu-id="ad3d8-2282">다음 예제에서는 빈 문자열을 만들고 해당 값 및 해당 길이 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2282">The following example creates an empty string and displays its value and its length.</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2283">다음 예제에서는 세 개의 문자열을 검사 하 고 하는지를 결정 합니다. 각 문자열 값, 빈 문자열인은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2283">The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.</span></span>  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2284">테스트할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2284">The string to test.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2285">지정된 문자열이 <see langword="null" />이거나 비어 있거나 공백 문자로만 구성되어 있는지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2285">Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-2286"><see langword="true" /> 매개 변수가 <paramref name="value" /> 또는 <see langword="null" />이거나, <see cref="F:System.String.Empty" />가 모두 공백 문자로 구성되어 있으면 <paramref name="value" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2286"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2287"><xref:System.String.IsNullOrWhiteSpace%2A> 뛰어난 성능을 제공 한다는 점을 제외 하면 다음 코드와 유사 하는 편리한 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2287"><xref:System.String.IsNullOrWhiteSpace%2A> is a convenience method that is similar to the following  code, except that it offers superior performance:</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 <span data-ttu-id="ad3d8-2288">공백 문자는 유니코드 표준에서 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2288">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="ad3d8-2289"><xref:System.String.IsNullOrWhiteSpace%2A> 의 값을 반환 하는 임의의 문자 1 보다 크거나 `true` 를 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 공백 문자로 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2289">The <xref:System.String.IsNullOrWhiteSpace%2A> method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method as a white-space character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2290">다음 예제에서는 문자열 배열을 만들고 그런 다음에 배열의 각 요소에 전달 된 <xref:System.String.IsNullOrWhiteSpace%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2290">The following example creates a string array, and then passes each element of the array to the <xref:System.String.IsNullOrWhiteSpace%2A> method.</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2291">각 요소 또는 멤버 사이에 지정된 구분 기호를 사용하여 지정된 배열 요소나 컬렉션 멤버를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2291">Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</span></span></summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-2292">구분 기호로 사용할 문자열입니다. <c>separator</c>는 <c>values</c>에 요소가 둘 이상 있는 경우에만 반환 문자열에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2292">The string to use as a separator.<c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ad3d8-2293">연결할 문자열을 포함하는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2293">A collection that contains the strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2294">각 멤버 사이에 지정된 구분 기호를 사용하여 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 형식의 생성된 <see cref="T:System.String" /> 컬렉션의 멤버를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2294">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2295"><paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 멤버로 구성된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2295">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ad3d8-2296"><paramref name="values" />에 멤버가 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2296">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2297">경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2297">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ad3d8-2298">하는 경우의 모든 멤버가 `values` 은 `null`, 빈 문자열을 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2298">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="ad3d8-2299"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 각 요소에 연결할 수 있는 편리한 메서드입니다는 `IEnumerable(Of String)` 먼저 문자열 배열에 요소를 변환 하지 않고 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2299"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="ad3d8-2300">LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2300">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ad3d8-2301">다음 예제에서는 전달 된 `List(Of String)` 알파벳 문자 (즉, 예제에서는 "M")를 특정 문자 보다 크거나 같은 선택 하는 람다 식에 대 / 소문자 구분 문자가 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2301">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="ad3d8-2302">`IEnumerable(Of String)` 에서 반환 된 컬렉션의 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 메서드에 전달 되는 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 단일 문자열 결과 표시 하려면 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2302">The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2303">다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2303">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ad3d8-2304">결과를 할당 한 <xref:System.Collections.Generic.List%601> 형식의 개체 <xref:System.String>에 전달 되는 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2304">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2305"><paramref name="values" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2305"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-2306">구분 기호로 사용할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2306">The string to use as a separator.</span></span> <span data-ttu-id="ad3d8-2307"><c>values</c>에 둘 이상의 요소가 있는 경우에만 <c>separator</c>가 반환된 문자열에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2307"><c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ad3d8-2308">연결할 요소가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2308">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2309">각 요소 사이에 지정된 구분 기호를 사용하여 개체 배열의 요소를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2309">Concatenates the elements of an object array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2310">
          <paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 요소로 구성된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2310">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ad3d8-2311"><paramref name="values" />가 빈 배열인 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2311">If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2312">경우 `separator` 은 `null` 경우의 요소가 `values` 이외의 첫 번째 요소는 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2312">If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ad3d8-2313">경우에 호출자에 대 한 메모를 참조 하세요의 첫 번째 요소로 `values` 은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2313">See the Notes for Callers section if the first element of `values` is `null`.</span></span>  
  
 <span data-ttu-id="ad3d8-2314"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 명시적으로 해당 요소를 문자열로 변환 하지 않고 개체 배열의 각 요소에에서 연결할 수 있는 편리한 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2314"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</span></span> <span data-ttu-id="ad3d8-2315">배열에 있는 각 개체의 문자열 표현을 해당 개체를 호출 하 여 파생 된 `ToString` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2315">The string representation of each object in the array is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2316">다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2316">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ad3d8-2317">결과에 전달 되는 정수 배열에 할당 된 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2317">It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2318"><paramref name="values" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2318"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2319">하는 경우의 첫 번째 요소 <paramref name="values" /> 은 <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> 메서드의 요소를 연결 하지 않는 <paramref name="values" /> 않고 <see cref="F:System.String.Empty" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2319">If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ad3d8-2320">이 문제에 대 한 대안 다양을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2320">A number of workarounds for this issue are available.</span></span> <span data-ttu-id="ad3d8-2321">값을 할당 하는 가장 쉬운 방법은 <see cref="F:System.String.Empty" /> 배열의 첫 번째 요소에 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2321">The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)]
 [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-2322">구분 기호로 사용할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2322">The string to use as a separator.</span></span> <span data-ttu-id="ad3d8-2323"><c>value</c>에 둘 이상의 요소가 있는 경우에만 <c>separator</c>가 반환된 문자열에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2323"><c>separator</c> is included in the returned string only if <c>value</c> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="ad3d8-2324">연결할 요소가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2324">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2325">각 요소 사이에 지정된 구분 기호를 사용하여 문자열 배열의 모든 요소를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2325">Concatenates all the elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2326">
          <paramref name="value" /> 문자열로 구분된 <paramref name="separator" />의 요소로 구성된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2326">A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ad3d8-2327"><paramref name="value" />가 빈 배열인 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2327">If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2328">예를 들어 경우 `separator` 은 "," 및 요소의 `value` "apple", "주황색", "포도" 및 "배" `Join(separator, value)` "apple, 주황, 포도, 배"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2328">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".</span></span>  
  
 <span data-ttu-id="ad3d8-2329">경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2329">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ad3d8-2330">경우에 있는 모든 요소 `value` 은 `null`, 빈 문자열을 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2330">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2331">다음 예제는 <xref:System.String.Join%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2331">The following example demonstrates the <xref:System.String.Join%2A> method.</span></span>  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2332"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2332"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-2333">구분 기호로 사용할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2333">The string to use as a separator.</span></span> <span data-ttu-id="ad3d8-2334"><c>value</c>에 둘 이상의 요소가 있는 경우에만 <c>separator</c>가 반환된 문자열에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2334"><c>separator</c> is included in the returned string only if <c>value</c> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="ad3d8-2335">연결할 요소가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2335">An array that contains the elements to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2336">사용할 <c>value</c>의 첫 번째 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2336">The first element in <c>value</c> to use.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2337"><c>value</c> 중에서 사용할 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2337">The number of elements of <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2338">각 요소 사이에 지정된 구분 기호를 사용하여 문자열 배열의 지정된 요소를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2338">Concatenates the specified elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2339"><paramref name="value" /> 문자열로 구분된 <paramref name="separator" />의 문자열로 구성된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2339">A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span>  
  
 <span data-ttu-id="ad3d8-2340">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2340">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2341"><see cref="F:System.String.Empty" />가 0이거나, <paramref name="count" />에 요소가 없거나, <paramref name="value" />와 <paramref name="separator" />의 모든 요소가 <paramref name="value" />면 <see cref="F:System.String.Empty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2341"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2342">예를 들어 경우 `separator` 은 "," 및 요소의 `value` "apple", "주황색", "포도" 및 "배" `Join(separator, value, 1, 2)` 반환 "주황색, 포도"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2342">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".</span></span>  
  
 <span data-ttu-id="ad3d8-2343">경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2343">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ad3d8-2344">경우에 있는 모든 요소 `value` 은 `null`, 빈 문자열을 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2344">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2345">다음 예제에서는 과일 이름의 배열에서 두 요소를 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2345">The following example concatenates two elements from an array of names of fruit.</span></span>  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2346"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2346"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2347"><paramref name="startIndex" /> 또는 <paramref name="count" />가 0 미만입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2347"><paramref name="startIndex" /> or <paramref name="count" /> is less than 0.</span></span>  
  
 <span data-ttu-id="ad3d8-2348">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2348">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2349"><paramref name="startIndex" /> + <paramref name="count" />가 <paramref name="value" />의 요소 수보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2349"><paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ad3d8-2350">메모리가 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2350">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ad3d8-2351">구성원 유형을 <c>값</c>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2351">The type of the members of <c>values</c>.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="ad3d8-2352">구분 기호로 사용할 문자열입니다. <c>separator</c>는 <c>values</c>에 요소가 둘 이상 있는 경우에만 반환 문자열에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2352">The string to use as a separator.<c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ad3d8-2353">연결할 개체를 포함하는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2353">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2354">각 멤버 사이에 지정된 구분 기호를 사용하여 컬렉션의 멤버를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2354">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2355"><paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 멤버로 구성된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2355">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ad3d8-2356"><paramref name="values" />에 멤버가 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2356">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2357">경우 `separator` 은 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2357">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ad3d8-2358">하는 경우의 모든 멤버가 `values` 은 `null`, 빈 문자열을 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2358">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="ad3d8-2359"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 각 멤버를 연결할 수 있는 편리한 메서드입니다는 <xref:System.Collections.Generic.IEnumerable%601> 첫 번째 요소를 문자열로 변환 하지 않고 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2359"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each member of an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting them to strings.</span></span> <span data-ttu-id="ad3d8-2360">에 있는 각 개체의 문자열 표현을 <xref:System.Collections.Generic.IEnumerable%601> 해당 개체를 호출 하 여 파생 된 컬렉션은 `ToString` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2360">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
 <span data-ttu-id="ad3d8-2361">이 메서드는 특정 LINQ (Language-Integrated Query) 쿼리 식을 사용할 때 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2361">This method is particular useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ad3d8-2362">예를 들어 다음 코드는 매우 간단한 정의 `Animal` 동물 속해 있는 주문의 이름을 포함 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2362">For example, the following code defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="ad3d8-2363">그런 다음 정의 <xref:System.Collections.Generic.List%601> 의 수를 포함 하는 개체 `Animal` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2363">It then defines a <xref:System.Collections.Generic.List%601> object that contains a number of `Animal` objects.</span></span> <span data-ttu-id="ad3d8-2364"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 확장 메서드를 호출을 추출 하는 `Animal` 개체 `Order` 속성 "설치류" 값은입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2364">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="ad3d8-2365">결과에 전달 되는 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2365">The result is passed to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2366">다음 예제에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2366">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ad3d8-2367">결과를 할당 한 <xref:System.Collections.Generic.List%601> 에 전달 되는 정수 형식의 개체는 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2367">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type integer, which it then passes to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2368"><paramref name="values" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2368"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2369">이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자 또는 문자열의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2369">Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="ad3d8-2370">이 인스턴스에 해당 문자나 문자열이 없으면 이 메서드는 -1을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2370">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2371">검색할 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2371">The Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2372">이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2372">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2373">해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2373">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2374">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2374">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2375">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2375">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2376">이 메서드는이 인스턴스의 마지막 문자 위치에서 검색을 시작 하 고 될 때까지 시작 부분을 향해 뒤로 `value` 보수인 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2376">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ad3d8-2377">검색은 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2377">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2378">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2378">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-2379">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2379">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2380">다음 예제에서는 정의 `ExtractFilename` 메서드를 사용 하는 <xref:System.String.LastIndexOf%28System.Char%29> 메서드 문자열에서 마지막 디렉터리 구분 문자를 찾습니다 하 고 문자열의 파일 이름을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2380">The following example defines an `ExtractFilename` method that uses the <xref:System.String.LastIndexOf%28System.Char%29> method to find the last directory separator character in a string and to extract the string's file name.</span></span> <span data-ttu-id="ad3d8-2381">파일이 있는 경우 해당 경로 없이 파일 이름만을 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2381">If the file exists, the method returns the file name without its path.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2382">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2382">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2383">이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2383">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2384">해당 문자열이 있으면 <paramref name="value" />의 0부터 시작하는 인덱스 위치이고, 그러지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2384">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-2385"><paramref name="value" />가 <see cref="F:System.String.Empty" />이면 이 인스턴스의 마지막 인덱스 위치를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2385">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2386">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2386">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2387">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2387">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2388">이 인스턴스의 마지막 문자 위치에서 시작 하 고 될 때까지 시작 부분을 향해 뒤로 검색 `value` 발견 되 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2388">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
 <span data-ttu-id="ad3d8-2389">이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2389">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ad3d8-2390">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2390">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2391">문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2391">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2392">경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.LastIndexOf%28System.String%29> 메서드는 항상 반환 <xref:System.String.Length%2A?displayProperty=nameWithType> – 현재 인스턴스의 마지막 인덱스 위치를 나타내는 1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2392">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%29> method always returns <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, which represents the last index position in the current instance.</span></span> <span data-ttu-id="ad3d8-2393">다음 예제에서는 <xref:System.String.LastIndexOf%28System.String%29> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2393">In the following example, the <xref:System.String.LastIndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ad3d8-2394">문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2394">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ad3d8-2395">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 또는 이상 버전에서는 각각의 경우에는 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 결과 동일에 붙은 사용자 지정 하이픈이 포함 되지 않았던 마치 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2395">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="ad3d8-2396">하이픈이를 검색할 때 메서드 6, 5를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2396">When searching for a soft hyphen only, the method returns 6 and 5.</span></span> <span data-ttu-id="ad3d8-2397">이러한 값의 두 문자열의 마지막 문자 인덱스에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2397">These values correspond to the index of the last character in the two strings.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2398">다음 예제에서는 열고 닫는 태그를 시작 하는 경우 문자열 및 문자열 끝에서 HTML 태그를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2398">The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</span></span> <span data-ttu-id="ad3d8-2399">문자열에 닫는로 끝나는 경우 대괄호 문자 (">")를 사용 하 여는 <xref:System.String.LastIndexOf%2A> 끝 태그 시작을 찾을 방법.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2399">If a string ends with a closing bracket character (">"), the example uses the <xref:System.String.LastIndexOf%2A> method to locate the start of the end tag.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2400"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2400"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2401">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2401">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-2402">현재 문화권의 비교 규칙을 사용 하 여 문자열 인스턴스 내에서 부분 문자열의 마지막 인덱스를 찾으려면, 호출의 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2402">To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2403">검색할 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2403">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2404">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2404">The starting position of the search.</span></span> <span data-ttu-id="ad3d8-2405"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2405">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2406">이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2406">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span> <span data-ttu-id="ad3d8-2407">지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2407">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2408">해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자가 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2408">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2409">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2409">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2410">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1.가이 메서드 검색 시작 위치는 `startIndex` 문자이 인스턴스와 될 때까지 현재 인스턴스의 시작 부분을 향해 뒤로의 위치 `value` 보수인 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2410">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ad3d8-2411">예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1, 메서드 시작 부분에 문자열에 있는 모든 문자와 마지막 문자에서를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2411">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span> <span data-ttu-id="ad3d8-2412">검색은 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2412">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2413">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2413">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-2414">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2414">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2415">다음 예제에서는 문자열의 끝에서 작업 하는 문자열의 시작 부분에 문자열에서 문자의 모든의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2415">The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</span></span>  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-2416">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 이 인스턴스의 길이보다 크거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2416">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2417">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2417">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2418">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2418">The search starting position.</span></span> <span data-ttu-id="ad3d8-2419"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2419">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2420">이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2420">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ad3d8-2421">지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2421">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2422">해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2422">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ad3d8-2423"><paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2423">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2424">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2424">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2425">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2425">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2426">검색이 시작는 `startIndex` 문자이 인스턴스 위치 때까지 뒤로 `value` 발견 되 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2426">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ad3d8-2427">예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1, 메서드 시작 부분에 문자열에 있는 모든 문자와 마지막 문자에서를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2427">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="ad3d8-2428">이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2428">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ad3d8-2429">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2429">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2430">문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2430">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2431">경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2431">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ad3d8-2432">다음 예제에서는 <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 메서드 하이픈이 (U + 00AD)를 포함 하 고 앞 또는 마지막 "m" 문자열에 포함 하는 부분 문자열을 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2432">In the following example, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</span></span> <span data-ttu-id="ad3d8-2433">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 하거나 검색 문자열에 하이픈은 무시 되므로 나중를 substrin를 찾기 위해 호출 하는 반면 문자열에 "m"의 위치를 반환 하는 사용자 지정 하이픈 및 "m"으로 구성 된 부분 문자열을 찾을 수 메서드를 호출 사용자 지정 하이픈 및 "n"으로 구성 된 g "n"의 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2433">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</span></span> <span data-ttu-id="ad3d8-2434">검색 문자열만 하이픈을 포함 된 경우 메서드는 "m"의 값을 나타내는의 인덱스를 반환 하는 `startIndex`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2434">When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2435">다음 예제에서는 대상 문자열에 대상 문자열의 시작 부분에 대상 문자열의 끝에서 작업 하는 모든 문자열의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2435">The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</span></span>  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2436"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2436"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-2437">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 현재 인스턴스의 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2437">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2438">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2438">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2439">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같고 <paramref name="startIndex" />가 -1보다 작거나 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2439">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2440">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2440">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-2441">현재 문화권의 비교 규칙을 사용 하 여 특정 문자 위치를 앞에 있는 부분 문자열의 인덱스를 찾기 위해 호출 된 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2441">To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2442">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2442">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-2443">검색 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2443">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2444">현재 <see cref="T:System.String" /> 개체에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2444">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ad3d8-2445">매개 변수는 지정된 문자열에 사용할 검색 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2445">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2446">해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 0부터 시작하는 인덱스 위치이고, 그러지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2446">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ad3d8-2447"><paramref name="value" />가 <see cref="F:System.String.Empty" />이면 이 인스턴스의 마지막 인덱스 위치를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2447">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2448">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2448">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2449">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2449">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2450">`comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2450">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
 <span data-ttu-id="ad3d8-2451">이 인스턴스의 마지막 문자 위치에서 시작 하 고 될 때까지 시작 부분을 향해 뒤로 검색 `value` 발견 되 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2451">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2452">다음 exampledemonstrates 3 오버 로드는 <xref:System.String.LastIndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2452">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2453"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2453"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-2454"><paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2454"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2455">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2455">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2456">문화권 구분 검색(즉, <paramref name="options" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2456">In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2457">경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드는 항상 반환 <see cref="P:System.String.Length" /> – 현재 인스턴스의 마지막 인덱스 위치를 나타내는 1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2457">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> – 1, which represents the last index position in the current instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2458">다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드 두 문자열의 세 부분 문자열 (하이픈이 (U + 00AD), "n" 이어서 하이픈이 및 하이픈이 뒤에 "m")를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2458">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ad3d8-2459">문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2459">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ad3d8-2460">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 사용자 지정 하이픈은 무시할 수 있는 문자 이므로 문화권 구분 검색 반환 하이픈 검색 문자열에 포함 되지 않은 경우 반환 된 값과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2460">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="ad3d8-2461">그러나 서 수 검색을 성공적으로 하이픈 한 문자열에서 찾아 보고 해주어에서 두 번째 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2461">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)]
 [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2462">검색할 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2462">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2463">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2463">The starting position of the search.</span></span> <span data-ttu-id="ad3d8-2464"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2464">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2465">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2465">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2466">이 인스턴스의 부분 문자열에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2466">Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</span></span> <span data-ttu-id="ad3d8-2467">지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2467">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2468">해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자가 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2468">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2469">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2469">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2470">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2470">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2471">이 메서드 검색 시작 위치는 `startIndex` 위치 및 될 때까지이 인스턴스의 시작 부분을 향해 뒤로 문자 `value` 가 또는 `count` 문자 위치가 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2471">This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ad3d8-2472">예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자는 문자열의 마지막 문자를 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2472">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span> <span data-ttu-id="ad3d8-2473">검색은 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2473">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2474">이 메서드 유니코드 스칼라 값의 동일 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2474">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ad3d8-2475">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2475">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2476">다음 예제에서는 부분 문자열의 시작 부분에 있는 부분 문자열의 끝에서 작업 하는 부분 문자열에서 문자의 모든의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2476">The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-2477">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 이 인스턴스의 길이보다 크거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2477">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2478">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2478">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2479">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2479">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2480">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2480">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2481">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2481">The search starting position.</span></span> <span data-ttu-id="ad3d8-2482"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2482">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2483">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2483">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2484">이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2484">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ad3d8-2485">지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2485">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2486">해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2486">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ad3d8-2487"><paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2487">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2488">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2488">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2489">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2489">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2490">검색이 시작는 `startIndex` 문자이 인스턴스 위치 때까지 뒤로 `value` 를 찾을 수 또는 `count` 문자 위치가 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2490">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ad3d8-2491">예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자는 문자열의 마지막 문자를 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2491">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="ad3d8-2492">이 메서드는 현재 문화권을 사용 하는 word (대/소문자 구분 및 문화권을 구분) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2492">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ad3d8-2493">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2493">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2494">문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2494">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2495">경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어는 <xref:System.String.LastIndexOf%2A> 메서드는 항상 반환 `startIndex`, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2495">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%2A> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ad3d8-2496">다음 예제에서는 <xref:System.String.LastIndexOf%2A> 메서드 두 문자열의 최종 "m" 앞에 있는 두 문자에서 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2496">In the following example, the <xref:System.String.LastIndexOf%2A> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</span></span> <span data-ttu-id="ad3d8-2497">문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2497">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ad3d8-2498">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2498">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2499">"m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2499">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2500">다음 예제에서는 부분 문자열의 시작 부분에 있는 부분 문자열의 끝에서 작업 하는 부분 문자열에서 모든 문자열의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2500">The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2501"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2501"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2502"><paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2502"><paramref name="count" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2503">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2503">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2504">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2504">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2505">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2505">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2506">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2506">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2507">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2507">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2508">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 이 인스턴스 외부의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2508">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2509">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2509">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2510">현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="start" />가 -1보다 작거나 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2510">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2511">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2511">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2512">현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="count" />가 1보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2512">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2513">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2513">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-2514">현재 문화권의 비교 규칙을 사용 하 여이 작업을 수행 하려면 호출는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2514">To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2515">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2515">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2516">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2516">The search starting position.</span></span> <span data-ttu-id="ad3d8-2517"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2517">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-2518">검색 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2518">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2519">현재 <see cref="T:System.String" /> 개체에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2519">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ad3d8-2520">지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2520">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span> <span data-ttu-id="ad3d8-2521">매개 변수는 지정된 문자열을 검색할 때 수행할 비교 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2521">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2522">해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2522">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ad3d8-2523"><paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2523">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2524">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2524">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2525">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2525">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2526">검색이 시작 된 `startIndex` 위치 및 될 때까지 뒤로 문자 `value` 발견 되 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2526">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ad3d8-2527">예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1, 메서드 시작 부분에 문자열에 있는 모든 문자와 마지막 문자에서를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2527">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="ad3d8-2528">`comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2528">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2529">다음 exampledemonstrates 3 오버 로드는 <xref:System.String.LastIndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2529">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2530"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2530"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-2531">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 현재 인스턴스의 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2531">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2532">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2532">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2533">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같고 <paramref name="startIndex" />가 -1보다 작거나 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2533">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-2534"><paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2534"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2535">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2535">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2536">문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2536">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2537">경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2537">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="ad3d8-2538">다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m", 두 문자열의 마지막 "m"부터 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2538">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</span></span> <span data-ttu-id="ad3d8-2539">문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2539">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ad3d8-2540">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2540">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2541">"m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2541">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="ad3d8-2542">메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2542">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)]
 [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-2543">검색할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2543">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2544">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2544">The search starting position.</span></span> <span data-ttu-id="ad3d8-2545"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2545">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2546">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2546">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-2547">검색 규칙을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2547">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2548">이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2548">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ad3d8-2549">지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2549">The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</span></span> <span data-ttu-id="ad3d8-2550">매개 변수는 지정된 문자열을 검색할 때 수행할 비교 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2550">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2551">해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2551">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ad3d8-2552"><paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2552">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2553">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2553">Index numbering starts from zero.</span></span> <span data-ttu-id="ad3d8-2554">즉, 문자열의 첫 문자 인덱스 0에는 및 마지막 <xref:System.String.Length%2A> -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2554">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-2555">검색이 시작 된 `startIndex` 위치 및 될 때까지 뒤로 문자 `value` 발견 되 또는 `count` 문자 위치가 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2555">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ad3d8-2556">예를 들어 경우 `startIndex` 은 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자는 문자열의 마지막 문자를 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2556">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="ad3d8-2557">`comparisonType` 매개 변수를 검색 하도록 지정 된 `value` 현재 또는 고정 문화권을 사용 하 여, 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 및 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2557">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2558">다음 exampledemonstrates 3 오버 로드는 <xref:System.String.LastIndexOf%2A> 의 여러 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 메서드는 <xref:System.StringComparison> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2558">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2559"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2559"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2560"><paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2560"><paramref name="count" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2561">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2561">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2562">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2562">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2563">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2563">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2564">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2564">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2565">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2565">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2566">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 이 인스턴스 외부의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2566">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2567">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2567">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2568">현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="start" />가 -1보다 작거나 0보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2568">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2569">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2569">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2570">현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="count" />가 1보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2570">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-2571"><paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2571"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2572">문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2572">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2573">문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2573">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ad3d8-2574">경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 즉 검색을 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2574">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="ad3d8-2575">다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 뒤에 "m" 모든 하이픈이 (U + 00AD)의 위치를 알았지만 두 문자열의 "m"의 최종 하기 전에 첫 번째 문자 위치를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2575">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</span></span> <span data-ttu-id="ad3d8-2576">문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2576">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ad3d8-2577">이 예제에서 실행 되 면는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 하이픈은 무시할 수 있는 문자 이므로 메서드 반환 문자열에 "m"의 인덱스는 문화권 구분 비교를 수행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2577">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2578">그러나 서 수 비교를 수행 하는 경우 찾으면 부분 문자열이 첫 번째 문자열에만 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2578">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="ad3d8-2579">참고의 경우 첫 번째 문자열 뒤에 "m" 하이픈을 포함 하는 메서드는 사용자 지정 하이픈의 인덱스를 반환 하지 못하고 문화권 구분 비교를 수행 하는 경우 대신 "m"의 인덱스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2579">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ad3d8-2580">메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2580">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)]
 [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2581">유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2581">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ad3d8-2582">이 인스턴스에 해당 문자가 없으면 메서드는 -1을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2582">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ad3d8-2583">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2583">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2584">유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2584">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2585">이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2585">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2586">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2586">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2587">이 메서드는이 인스턴스의 마지막 문자 위치에서 검색을 시작 하 고의 문자 올 때까지 뒤로 `anyOf` 보수인 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2587">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="ad3d8-2588">검색은 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2588">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2589">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2589">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-2590">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2590">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2591">다음 예제에서는 다른 문자열 내에서 "is" 문자열에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2591">The following example finds the index of the last occurrence of any character in the string "is" within another string.</span></span>  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2592"><paramref name="anyOf" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2592"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ad3d8-2593">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2593">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2594">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2594">The search starting position.</span></span> <span data-ttu-id="ad3d8-2595"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2595">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2596">유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2596">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ad3d8-2597">지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2597">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2598">이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 동일하면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2598">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2599">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2599">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2600">이 메서드 검색 시작 위치는 `startIndex` 문자이 인스턴스의 위치에는 문자 올 때까지 뒤로 `anyOf` 가 찾거나 첫 번째 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2600">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="ad3d8-2601">검색은 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2601">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2602">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2602">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-2603">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2603">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2604">다음 예제에서는 다른 문자열의 부분 문자열에서 "is" 문자열에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2604">The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2605"><paramref name="anyOf" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2605"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-2606">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 인스턴스 외부의 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2606">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ad3d8-2607">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2607">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ad3d8-2608">검색을 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2608">The search starting position.</span></span> <span data-ttu-id="ad3d8-2609"><c>startIndex</c>에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2609">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2610">검사할 문자 위치의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2610">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2611">유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2611">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ad3d8-2612">지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2612">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2613">이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 동일하면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2613">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2614">인덱스 번호는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2614">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2615">이 메서드 검색 시작 위치는 `startIndex` 문자이 인스턴스의 위치에는 문자 올 때까지 뒤로 `anyOf` 가 또는 `count` 문자 위치가 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2615">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ad3d8-2616">검색은 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2616">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ad3d8-2617">이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2617">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ad3d8-2618">문화권 구분 검색을 수행 하려면는 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드를 여기서 미리 구성 된 문자를 나타내는 "Æ" 합자 같은 (U + 00 C 6), 유니코드 스칼라 값을 간주 될 수 있습니다 모든 구성 요소는 문자 앞에 "AE"와 같은 순서 (U + 0041, U + 0045) 문화권에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2618">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2619">다음 예제에서는 다른 문자열의 부분 문자열에서 문자열 "지원"에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2619">The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2620"><paramref name="anyOf" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2620"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-2621">현재 인스턴스가 <see cref="F:System.String.Empty" /> 같지 않고 <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2621">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="ad3d8-2622">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2622">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2623">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2623">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2624">현재 <see cref="T:System.String" /> 개체의 문자 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2624">Gets the number of characters in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="ad3d8-2625">현재 문자열의 문자 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2625">The number of characters in the current string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2626"><xref:System.String.Length%2A> 속성의 수를 반환 <xref:System.Char> 의이 인스턴스 개체, 유니코드 문자 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2626">The <xref:System.String.Length%2A> property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters.</span></span> <span data-ttu-id="ad3d8-2627">이유는 둘 이상의 유니코드 문자를 표현 될 수 있습니다 <xref:System.Char>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2627">The reason is that a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="ad3d8-2628">사용 하 여는 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 각 하는 대신 각 유니코드 문자를 사용 하는 클래스 <xref:System.Char>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2628">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with each Unicode character instead of each <xref:System.Char>.</span></span>  
  
 <span data-ttu-id="ad3d8-2629">C 및 c + +와 같은 일부 언어에서는 null 문자는 문자열의 끝을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2629">In some languages, such as C and C++, a null character indicates the end of a string.</span></span> <span data-ttu-id="ad3d8-2630">.NET Framework에서 문자열에 null 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2630">In the .NET Framework, a null character can be embedded in a string.</span></span> <span data-ttu-id="ad3d8-2631">문자열 하나 이상의 null 문자를 포함 하는 경우 전체 문자열의 길이에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2631">When a string includes one or more null characters, they are included in the length of the total string.</span></span> <span data-ttu-id="ad3d8-2632">예를 들어 다음 문자열을 부분 문자열 "abc"와 "def" null 문자로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2632">For example, in the following string, the substrings "abc" and "def" are separated by a null character.</span></span> <span data-ttu-id="ad3d8-2633"><xref:System.String.Length%2A> 속성 영문자 6 뿐 아니라 null 문자를 포함 하는 것이 나타내는 7을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2633">The <xref:System.String.Length%2A> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</span></span>  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2634">다음 예제는 <xref:System.String.Length%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2634">The following example demonstrates the <xref:System.String.Length%2A> property.</span></span>  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2635">이진 표현의 형식이 특정 유니코드 정규화 형식인 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2635">Returns a new string whose binary representation is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-2636">텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 유니코드 정규화 형식 C인 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2636">Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2637">텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 정규화 형식 C인 정규화된 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2637">A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2638">일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2638">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ad3d8-2639">예를 들어 다음 코드 포인트의 문자 "ắ"을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2639">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="ad3d8-2640">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2640">U+1EAF</span></span>  
  
-   <span data-ttu-id="ad3d8-2641">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2641">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="ad3d8-2642">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2642">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="ad3d8-2643">단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2643">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ad3d8-2644">표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2644">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ad3d8-2645">정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2645">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ad3d8-2646">.NET Framework 4 개의 정규화 형식을 (C, D, KC 및 KD)는 유니코드 표준에서 정의 된 지원 합니다. 두 문자열이 동일한 정규화 형식에 표시 되는 경우 theycan 서 수 비교를 사용 하 여 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2646">The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ad3d8-2647">정규화 하 고 두 문자열을 비교 하려면 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2647">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="ad3d8-2648">파일 또는 사용자 입력된 장치 등의 입력된 소스에서 비교할 문자열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2648">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="ad3d8-2649">호출 된 <xref:System.String.Normalize> C. 정규화 형식 문자열을 정교화 메서드</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2649">Call the <xref:System.String.Normalize> method to normalize the strings to normalization form C.</span></span>  
  
3.  <span data-ttu-id="ad3d8-2650">두 문자열을 비교 하려면와 같은 서 수 문자열 비교를 지 원하는 메서드를 호출는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드의 값을 제공 하 고 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 으로 <xref:System.StringComparison> 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2650">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="ad3d8-2651">정규화 된 문자열의 배열을 정렬 하려면 전달는 `comparer` 값 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 의 적절 한 오버 로드에 <xref:System.Array.Sort%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2651">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="ad3d8-2652">이전 단계에 설명 된 순서에 따라 정렬된 된 출력에서 문자열을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2652">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="ad3d8-2653">지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2653">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2654">다음 예제에서는 문자열을 각각 네 가지 정규화 형식으로 확인 문자열이 지정 된 정규화 형식인 정규화 된 다음 정규화 문자열에 코드 포인트를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2654">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ad3d8-2655">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2655">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2656"><see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2656">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ad3d8-2657">따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2657">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="ad3d8-2658">유니코드 정규화 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2658">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2659">텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 지정한 유니코드 정규화 형식인 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2659">Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2660">텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 <paramref name="normalizationForm" /> 매개 변수로 지정된 정규화 형식인 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2660">A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2661">일부 유니코드 문자는 동일한 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2661">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ad3d8-2662">단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2662">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ad3d8-2663">표준 유니코드 문자의 해당 이진 표현 중 어느 것을 전달 하는 경우 하나의 이진 표현을 반환 하는 정규화 라는 프로세스를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2663">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ad3d8-2664">정규화는 서로 다른 규칙을 따르는 정규화 형식 이라는 여러 알고리즘을 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2664">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ad3d8-2665">.NET Framework 4 개의 정규화 형식을 (C, D, KC 및 KD)는 유니코드 표준에서 정의 된 지원 합니다. 두 문자열이 동일한 정규화 형식에 표시 되는 경우 서 수 비교를 사용 하 여 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2665">The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ad3d8-2666">정규화 하 고 두 문자열을 비교 하려면 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2666">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="ad3d8-2667">파일 또는 사용자 입력된 장치 등의 입력된 소스에서 비교할 문자열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2667">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="ad3d8-2668">호출 된 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 메서드는 문자열을 지정 된 정규화 형식인 정규화를 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2668">Call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29> method to normalize the strings to a specified normalization form.</span></span>  
  
3.  <span data-ttu-id="ad3d8-2669">두 문자열을 비교 하려면와 같은 서 수 문자열 비교를 지 원하는 메서드를 호출는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드의 값을 제공 하 고 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 으로 <xref:System.StringComparison> 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2669">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="ad3d8-2670">정규화 된 문자열의 배열을 정렬 하려면 전달는 `comparer` 값 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 의 적절 한 오버 로드에 <xref:System.Array.Sort%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2670">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="ad3d8-2671">이전 단계에 설명 된 순서에 따라 정렬된 된 출력에서 문자열을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2671">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="ad3d8-2672">지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2672">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2673">다음 예제에서는 문자열을 각각 네 가지 정규화 형식으로 확인 문자열이 지정 된 정규화 형식인 정규화 된 다음 정규화 문자열에 코드 포인트를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2673">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ad3d8-2674">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2674">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2675"><see cref="Overload:System.String.IsNormalized" /> 메서드 반환 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자를 발견 되는 즉시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2675">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ad3d8-2676">따라서 문자열에 정규화 되지 않은 문자 뒤에 잘못 된 유니코드 문자가 포함 된 경우는 <see cref="Overload:System.String.Normalize" /> 메서드가 throw 할 수 있습니다는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2676">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ad3d8-2677">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2677">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ad3d8-2678">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2678">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2679">지정된 두 문자열의 값이 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2679">Determines whether two specified strings have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-2680"><see langword="true" />의 값이 <paramref name="a" />의 값과 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2680"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2681"><xref:System.String.op_Equality%2A> 같음 연산자에 대 한 작업을 정의 하는 메서드는 <xref:System.String> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2681">The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class.</span></span> <span data-ttu-id="ad3d8-2682">"예" 섹션에 표시 된 것과 같은 코드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2682">It enables code such as that shown in the Example section.</span></span> <span data-ttu-id="ad3d8-2683">연산자를 호출 하는 정적 <xref:System.String.Equals%28System.String%2CSystem.String%29> 메서드로 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2683">The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2684">Visual Basic 컴파일러 같음 연산자에 대 한 호출으로 해결 되지 않으면는 <xref:System.String.op_Equality%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2684">The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method.</span></span> <span data-ttu-id="ad3d8-2685">대신, 같음 연산자에 대 한 호출을 래핑하는 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2685">Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2686">다음 예제에서는 같음 연산자를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2686">The following example demonstrates the equality operator.</span></span>  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ad3d8-2687">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2687">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ad3d8-2688">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2688">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2689">지정된 두 문자열의 값이 다른지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2689">Determines whether two specified strings have different values.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-2690"><see langword="true" />의 값이 <paramref name="a" />의 값과 다르면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2690"><see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2691"><xref:System.String.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드는 <xref:System.String> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2691">The <xref:System.String.op_Inequality%2A> method defines the operation of the inequality operator for the <xref:System.String> class.</span></span>   <span data-ttu-id="ad3d8-2692">"예" 섹션에 표시 된 것과 같은 코드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2692">It enables code such as that shown in the Examples section.</span></span>  
  
 <span data-ttu-id="ad3d8-2693"><xref:System.String.op_Inequality%2A> 연산자 호출 하 여 정적 <xref:System.String.Equals%28System.String%2CSystem.String%29> 메서드로 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2693">The <xref:System.String.op_Inequality%2A> operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2694">Visual Basic 컴파일러 같지 않음 연산자에 대 한 호출으로 해결 되지 않으면는 <xref:System.String.op_Inequality%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2694">The Visual Basic compiler does not resolve the inequality operator as a call to the <xref:System.String.op_Inequality%2A> method.</span></span> <span data-ttu-id="ad3d8-2695">대신, 같지 않음 연산자에 대 한 호출을 래핑하는 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2695">Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2696">다음 예에서는 같지 않음 연산자를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2696">The following example demonstrates the inequality operator.</span></span>  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2697">현재 문자열의 시작 부분이 공백이나 지정된 유니코드 문자로 채워지는 지정된 길이의 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2697">Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ad3d8-2698">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2698">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2699">지정한 길이만큼 왼쪽의 안쪽 여백을 공백으로 채워서 이 인스턴스의 문자를 오른쪽에 맞추는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2699">Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2700">이 인스턴스와 동일하지만 오른쪽으로 맞춰지고 왼쪽의 안쪽 여백이 <paramref name="totalWidth" />의 길이만큼 공백 문자로 채워진 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2700">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ad3d8-2701">그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2701">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ad3d8-2702"><paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2702">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2703">유니코드 공백 문자는 16 진수 0x0020 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2703">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="ad3d8-2704"><xref:System.String.PadLeft%28System.Int32%29> 메서드는 반환 된 문자열의 시작 부분을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2704">The <xref:System.String.PadLeft%28System.Int32%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="ad3d8-2705">즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 오른쪽 부분을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2705">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2706">경우는 <xref:System.String.PadLeft%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2706">If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2707">대신, 새 문자열을 전체 길이가 되도록 선행 공백을 채운 반환 `totalWidth` 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2707">Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2708">다음 예제는 <xref:System.String.PadLeft%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2708">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2709"><paramref name="totalWidth" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2709"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ad3d8-2710">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2710">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="ad3d8-2711">유니코드 안쪽 여백 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2711">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2712">지정한 길이만큼 왼쪽의 안쪽 여백을 지정된 유니코드 문자로 채워서 이 인스턴스의 문자를 오른쪽에 맞추는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2712">Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2713">이 인스턴스와 동일하지만 오른쪽으로 맞춰지고 왼쪽의 안쪽 여백이 <paramref name="paddingChar" />의 길이만큼 <paramref name="totalWidth" /> 문자로 채워진 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2713">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ad3d8-2714">그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2714">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ad3d8-2715"><paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2715">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2716"><xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> 메서드는 반환 된 문자열의 시작 부분을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2716">The <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="ad3d8-2717">즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 오른쪽 부분을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2717">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2718">경우는 <xref:System.String.PadLeft%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2718">If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2719">대신, 새 문자열 앞에 오는 채운 반환 `paddingChar` 자 전체 길이가 `totalWidth` 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2719">Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2720">다음 예제는 <xref:System.String.PadLeft%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2720">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2721"><paramref name="totalWidth" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2721"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2722">현재 문자열의 끝 부분이 공백이나 지정된 유니코드 문자로 채워지는 지정된 길이의 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2722">Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ad3d8-2723">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2723">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2724">지정한 길이만큼 오른쪽의 안쪽 여백을 공백으로 채워서 이 문자열의 문자를 왼쪽에 맞추는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2724">Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2725">이 인스턴스와 동일하지만 왼쪽으로 맞춰지고 오른쪽의 안쪽 여백이 <paramref name="totalWidth" />의 길이만큼 공백 문자로 채워진 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2725">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ad3d8-2726">그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2726">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ad3d8-2727"><paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2727">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2728">유니코드 공백 문자는 16 진수 0x0020 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2728">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="ad3d8-2729"><xref:System.String.PadRight%28System.Int32%29> 메서드는 반환 된 문자열의 끝을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2729">The <xref:System.String.PadRight%28System.Int32%29> method pads the end of the returned string.</span></span> <span data-ttu-id="ad3d8-2730">즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 왼쪽된 부분을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2730">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2731">경우는 <xref:System.String.PadRight%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2731">If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2732">대신, 새 문자열을 전체 길이가 되도록 후행 공백 채운 반환 `totalWidth` 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2732">Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2733">다음 예제는 <xref:System.String.PadRight%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2733">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2734"><paramref name="totalWidth" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2734"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ad3d8-2735">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2735">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="ad3d8-2736">유니코드 안쪽 여백 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2736">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2737">지정한 길이만큼 오른쪽의 안쪽 여백을 지정된 유니코드 문자로 채워서 이 문자열의 문자를 왼쪽에 맞추는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2737">Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2738">이 인스턴스와 동일하지만 왼쪽으로 맞춰지고 오른쪽의 안쪽 여백이 <paramref name="paddingChar" />의 길이만큼 <paramref name="totalWidth" /> 문자로 채워진 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2738">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ad3d8-2739">그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2739">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ad3d8-2740"><paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2740">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2741"><xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> 메서드는 반환 된 문자열의 끝을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2741">The <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> method pads the end of the returned string.</span></span> <span data-ttu-id="ad3d8-2742">즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 왼쪽된 부분을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2742">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2743">경우는 <xref:System.String.PadRight%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2743">If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2744">대신, 후행 채운 새 문자열을 반환 `paddingChar` 자 전체 길이가 `totalWidth` 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2744">Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2745">다음 예제는 <xref:System.String.PadRight%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2745">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2746"><paramref name="totalWidth" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2746"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2747">현재 문자열에서 지정한 수의 문자가 삭제되는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2747">Returns a new string in which a specified number of characters from the current string are deleted.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ad3d8-2748">문자 삭제를 0부터 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2748">The zero-based position to begin deleting characters.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2749">지정된 위치부터 마지막 위치 사이에 현재 인스턴스의 모든 문자가 삭제되었던 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2749">Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2750">제거된 문자를 제외하고 이 문자열과 동일한 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2750">A new string that is equivalent to this string except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2751">에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], 문자열은 0부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2751">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="ad3d8-2752">값은 `startIndex` 매개 변수의 범위는 0-문자열 인스턴스 길이 보다 1 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2752">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2753">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2753">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2754">대신, 반환 새 문자열에 있는 모든 문자 위치에서 `startIndex` 원래 문자열의 끝에 제거 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2754">Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2755">다음 예제는 <xref:System.String.Remove%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2755">The following example demonstrates the <xref:System.String.Remove%2A> method.</span></span> <span data-ttu-id="ad3d8-2756">마지막-두 번째 경우 문자열의 끝을 통해 지정된 된 인덱스에서 시작 하는 모든 텍스트를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2756">The next-to-last case removes all text starting from the specified index through the end of the string.</span></span> <span data-ttu-id="ad3d8-2757">마지막 경우 지정된 된 인덱스에서 시작 하는 3 개의 문자를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2757">The last case removes three characters starting from the specified index.</span></span>  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-2758"><paramref name="startIndex" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2758"><paramref name="startIndex" /> is less than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2759">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2759">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2760"><paramref name="startIndex" />가 이 문자열의 범위에서 벗어난 위치를 지정하는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2760"><paramref name="startIndex" /> specifies a position that is not within this string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ad3d8-2761">문자 삭제를 0부터 시작할 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2761">The zero-based position to begin deleting characters.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2762">삭제할 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2762">The number of characters to delete.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2763">현재 인스턴스의 지정된 위치에서 시작하여 지정된 수의 문자가 삭제되었던 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2763">Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2764">제거된 문자를 제외하고 이 인스턴스와 동일한 새 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2764">A new string that is equivalent to this instance except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2765">에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], 문자열은 0부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2765">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="ad3d8-2766">값은 `startIndex` 매개 변수의 범위는 0-문자열 인스턴스 길이 보다 1 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2766">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2767">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2767">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2768">대신, 문자 수가 하 여 지정 된 새 문자열을 반환 된 `count` 매개 변수 제거 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2768">Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed.</span></span> <span data-ttu-id="ad3d8-2769">지정 된 위치에서의 문자 제거 `startIndex`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2769">The characters are removed at the position specified by `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2770">다음 예제에서는 전체 이름에서 중간 이름을 제거 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2770">The following example demonstrates how you can remove the middle name from a complete name.</span></span>  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ad3d8-2771"><paramref name="startIndex" /> 또는 <paramref name="count" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2771">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-2772">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2772">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-2773"><paramref name="startIndex" />와 <paramref name="count" />의 합이 이 인스턴스의 범위에서 벗어난 위치를 지정하는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2773"><paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2774">현재 문자열에서 발견되는 지정된 유니코드 문자 또는 <see cref="T:System.String" />을 모두 지정된 다른 유니코드 문자 또는 <see cref="T:System.String" />으로 바꾼 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2774">Returns a new string in which all occurrences of a specified Unicode character or <see cref="T:System.String" /> in the current string are replaced with another specified Unicode character or <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="ad3d8-2775">바꿀 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2775">The Unicode character to be replaced.</span></span></param>
        <param name="newChar"><span data-ttu-id="ad3d8-2776">모든 <c>oldChar</c>를 바꿀 유니코드 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2776">The Unicode character to replace all occurrences of <c>oldChar</c>.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2777">현재 인스턴스의 지정된 유니코드 문자가 지정된 다른 유니코드 문자로 모두 바뀌는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2777">Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2778"><paramref name="oldChar" />의 모든 인스턴스를 <paramref name="newChar" />로 바꾼다는 점을 제외하고 이 인스턴스와 동일한 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2778">A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />.</span></span> <span data-ttu-id="ad3d8-2779"><paramref name="oldChar" />를 현재 인스턴스에서 찾을 수 없으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2779">If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2780">이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 찾기 검색을 수행 `oldChar`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2780">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2781">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2781">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2782">모두 바뀌는 새 문자열을 반환 대신 `oldChar` 바뀝니다 `newChar`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2782">Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.</span></span>  
  
 <span data-ttu-id="ad3d8-2783">이 메서드는 수정 된 문자열을 반환 하므로 함께 결합할 수에 대 한 연속 호출은 <xref:System.String.Replace%2A> 원래 문자열에서 여러 교체를 수행 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2783">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="ad3d8-2784">메서드 호출 왼쪽에서 오른쪽으로 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2784">Method calls are executed from left to right.</span></span> <span data-ttu-id="ad3d8-2785">다음 예제에서 이에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2785">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2786">다음 예제에서는 일련의 숫자 사이 있는 공백에 대 한 쉼표를 대체 하 여 쉼표로 구분 된 값 목록을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2786">The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</span></span>  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="ad3d8-2787">바꿀 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2787">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="ad3d8-2788">모든 <c>oldValue</c>를 바꿀 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2788">The string to replace all occurrences of <c>oldValue</c>.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2789">현재 인스턴스의 지정된 문자열이 지정된 다른 문자열로 모두 바뀌는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2789">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2790"><paramref name="oldValue" />의 모든 인스턴스를 <paramref name="newValue" />로 바꾼다는 점을 제외하고 현재 문자열과 동일한 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2790">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="ad3d8-2791"><paramref name="oldValue" />를 현재 인스턴스에서 찾을 수 없으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2791">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2792">경우 `newValue` 은 `null`의 항목을 모두 `oldValue` 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2792">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-2793">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2793">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-2794">모두 바뀌는 새 문자열을 반환 대신 `oldValue` 바뀝니다 `newValue`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2794">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>  
  
 <span data-ttu-id="ad3d8-2795">이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 찾기 검색을 수행 `oldValue`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2795">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.</span></span>  
  
 <span data-ttu-id="ad3d8-2796">이 메서드는 수정 된 문자열을 반환 하므로 함께 결합할 수에 대 한 연속 호출은 <xref:System.String.Replace%2A> 원래 문자열에서 여러 교체를 수행 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2796">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="ad3d8-2797">메서드 호출 왼쪽에서 오른쪽으로 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2797">Method calls are executed from left to right.</span></span> <span data-ttu-id="ad3d8-2798">다음 예제에서 이에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2798">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2799">다음 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.String.Replace%2A> 맞춤법 오류를 해결 하려면 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2799">The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.</span></span>  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-2800"><paramref name="oldValue" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2800"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-2801"><paramref name="oldValue" />가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2801"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-2802">지정된 문자열 또는 유니코드 문자 배열의 요소로 구분된 이 인스턴스의 부분 문자열이 포함된 문자열 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2802">Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2803"><xref:System.String.Split%2A> 문자열을 부분 문자열로 구분된 된 문자열을 중단 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2803"><xref:System.String.Split%2A> is used to break a delimited string into substrings.</span></span> <span data-ttu-id="ad3d8-2804">0, 1 또는 여러 구분 문자를 지정 하는 문자 배열 중 하나를 사용할 수 있습니다 (의 <xref:System.String.Split%28System.Char%5B%5D%29> 메서드), 0, 1 또는 여러 개의 구분 기호 문자열을 지정 하는 문자 배열에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2804">You can use either a character array to specify zero, one, or multiple delimiting characters (the <xref:System.String.Split%28System.Char%5B%5D%29> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</span></span> <span data-ttu-id="ad3d8-2805">오버 로드는 <xref:System.String.Split%2A> 메서드를 통해 메서드에서 반환 되는 부분 문자열의 수를 제한할 수 있습니다 (의 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> 메서드)를 빈 문자열이 반환 된 부분 문자열에 포함할지 여부를 결정 하기 위해 (의 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> 및 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> 메서드 또는 모두 (의 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 및 <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 메서드).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2805">Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method), to determine whether empty strings are included in the returned substrings (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ad3d8-2806">자세한 내용을 보려면은 <xref:System.String.Split%2A> 개별 오버 로드에 대 한 설명서를 참조 하는 메서드를 호출 하는 예제는 물론 각 오버 로드 하는 대로 <xref:System.String.Split%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2806">For more detailed information on the <xref:System.String.Split%2A> method, as well as for examples that call each overload, see the documentation for the individual overloads of <xref:System.String.Split%2A>.</span></span>  
  
 <span data-ttu-id="ad3d8-2807"><xref:System.String.Split%2A> 메서드는 항상 문자열을 부분 문자열로 구분된 된 문자열을 중단 하는 가장 좋은 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2807">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="ad3d8-2808">구분된 된 문자열의 부분 문자열의 모든 추출 하지 않으려는 경우 또는 구분 기호 문자 집합이 아닌 패턴에 따라 문자열을 구문 분석 하려는 경우 다음과 같은 대안을 고려해.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2808">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
## <a name="regular-expressions"></a><span data-ttu-id="ad3d8-2809">정규식</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2809">Regular expressions</span></span>  
 <span data-ttu-id="ad3d8-2810">문자열에 고정된 패턴을 따르지를 추출 하 여 해당 요소를 처리 하는 정규식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2810">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="ad3d8-2811">예를 들어, 문자열 형태로 "*번호* *피연산자* *번호*" 사용할 수 있습니다는 [정규식](~/docs/standard/base-types/regular-expressions.md) 추출 및 처리 하는 문자열의 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2811">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="ad3d8-2812">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2812">Here's an example:</span></span>  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="ad3d8-2813">정규식 패턴 `(\d+)\s+([-+*/])\s+(\d+)` 다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2813">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="ad3d8-2814">무늬</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2814">Pattern</span></span>|<span data-ttu-id="ad3d8-2815">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2815">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="ad3d8-2816">하나 이상의 10진수 숫자가 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2816">Match one or more decimal digits.</span></span> <span data-ttu-id="ad3d8-2817">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2817">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ad3d8-2818">하나 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2818">Match one or more whitespace characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="ad3d8-2819">일치는 산술 연산자 기호 (+,-, \*, 또는 /).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2819">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="ad3d8-2820">이 그룹은 두 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2820">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ad3d8-2821">하나 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2821">Match one or more whitespace characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="ad3d8-2822">하나 이상의 10진수 숫자가 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2822">Match one or more decimal digits.</span></span> <span data-ttu-id="ad3d8-2823">이 그룹은 세 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2823">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="ad3d8-2824">또한 둘러싸인 문자 집합이 고정된 보다는 패턴을 기반으로 문자열에서 하위 문자열을 추출 하는 정규식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2824">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="ad3d8-2825">다음은 이러한 조건 중 하나가 발생 하는 경우 일반적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2825">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="ad3d8-2826">하나 이상의 구분 기호 문자 처리 하지 않는 경우 항상에 구분 기호로 <xref:System.String> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2826">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-2827">순서 및 구분 기호 문자 수는 변수 또는 알 수 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2827">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="ad3d8-2828">예를 들어는 <xref:System.String.Split%2A> 때문에 다음 문자열을 분할 메서드를 사용할 수 없습니다 수가 `\n` (C#에서) 또는 `vbCrLf` (Visual Basic)의 문자는 변수 이며 항상 구분 기호로 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2828">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 <span data-ttu-id="ad3d8-2829">정규식이이 문자열을 쉽게 다음 예제와 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2829">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="ad3d8-2830">정규식 패턴 `\[([^\[\]]+)\]` 다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2830">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="ad3d8-2831">무늬</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2831">Pattern</span></span>|<span data-ttu-id="ad3d8-2832">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2832">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="ad3d8-2833">여는 대괄호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2833">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="ad3d8-2834">하지 않은 중괄호와 닫는 대괄호는 한 번 이상 나타나는 모든 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2834">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="ad3d8-2835">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2835">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="ad3d8-2836">닫는 대괄호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2836">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="ad3d8-2837"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 거의 동일 <xref:System.String.Split%2A?displayProperty=nameWithType>제외 하 고 고정된 문자 집합 대신 정규식 패턴에 따라 문자열을 분할 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2837">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="ad3d8-2838">예를 들어 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 하이픈과 다른 문자를 조합으로 구분 하는 부분 문자열을 포함 하는 문자열을 분할 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2838">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="ad3d8-2839">정규식 패턴 `\s-\s?[+*]?\s?-\s` 다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2839">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="ad3d8-2840">무늬</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2840">Pattern</span></span>|<span data-ttu-id="ad3d8-2841">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2841">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="ad3d8-2842">하이픈 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2842">Match a whitespace character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="ad3d8-2843">0 개 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2843">Match zero or one whitespace character.</span></span>|  
|`[+*]?`|<span data-ttu-id="ad3d8-2844">중 0 개 또는 1 개 찾습니다는 + 또는 \* 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2844">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="ad3d8-2845">0 개 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2845">Match zero or one whitespace character.</span></span>|  
|`-\s`|<span data-ttu-id="ad3d8-2846">공백 문자로 이어지는 하이픈을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2846">Match a hyphen followed by a whitespace character.</span></span>|  
  
## <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="ad3d8-2847">검색 방법 및 Substring 메서드</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2847">Search methods and the Substring method</span></span>  
 <span data-ttu-id="ad3d8-2848">문자열의 부분 문자열의 모든 원하지 않는 경우에 일치 항목 찾기를 시작 되는 인덱스를 반환 하는 문자열 비교 방법 중 하나를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2848">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="ad3d8-2849">호출할 수 있습니다는 <xref:System.String.Substring%2A> 메서드를 원하는 하위 문자열을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2849">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="ad3d8-2850">다음과 같은 문자열 비교 방법</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2850">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="ad3d8-2851"><xref:System.String.IndexOf%2A>문자열 인스턴스에서 맨 처음 발견 되는 문자 또는 문자열의 0부터 시작 하는 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2851"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-2852"><xref:System.String.IndexOfAny%2A>을 문자 배열에 있는 문자 중 첫 번째 요소의 현재 문자열 인스턴스 0부터 시작 하는 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2852"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="ad3d8-2853"><xref:System.String.LastIndexOf%2A>문자열 인스턴스에서는 문자 또는 문자열의 마지막 항목의 0부터 시작 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2853"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-2854"><xref:System.String.LastIndexOfAny%2A>현재 문자열 인스턴스에서 문자 배열에 있는 문자 중 마지막 요소의 0 기반 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2854"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="ad3d8-2855">다음 예제에서는 <xref:System.String.IndexOf%2A> 메서드를 문자열에서 마침표를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2855">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="ad3d8-2856">다음 사용 하 여는 <xref:System.String.Substring%2A> 메서드를 완전 한 문장을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2856">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-2857">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2857">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2858">문자열을 배열 내 문자에 기초하는 하위 문자열로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2858">Splits a string into substrings that are based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2859">요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 인스턴스의 부분 문자열이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2859">An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ad3d8-2860">자세한 내용은 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2860">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2861">알려진된 문자 집합으로 구분 하는 문자열은 때 사용할 수 있습니다는 <xref:System.String.Split%28System.Char%5B%5D%29> 메서드 문자열을 부분 문자열로 구분 될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2861">When a string is delimited by a known set of characters, you can use the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate it into substrings.</span></span> <span data-ttu-id="ad3d8-2862">부분 문자열을 추출 문자열에서 다른 방법에 대 한 참조는 [String.Split에 대 한 대안](#Alternatives) 섹션.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2862">For other ways to extract substrings from a string, see the [Alternatives to String.Split](#Alternatives) section.</span></span>  
  
## <a name="return-value-details"></a><span data-ttu-id="ad3d8-2863">반환 값 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2863">Return value details</span></span>  
 <span data-ttu-id="ad3d8-2864">구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2864">Delimiter characters are not included in the elements of the returned array.</span></span> <span data-ttu-id="ad3d8-2865">예를 들어, 구분 기호 배열 문자를 포함 하는 경우 "-" 문자열 현재 인스턴스의 값이 "aa bb 참조", 세 개의 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2865">For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ad3d8-2866">이 인스턴스가 없는 경우에 문자 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2866">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-2867">각 요소 `separator` 별도 구분 기호 문자를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2867">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ad3d8-2868">두 개의 구분 기호는, 인접 한 경우 나이 인스턴스의 끝 부분에는 구분 기호를 찾을 수 반환된 배열에 있는 해당 요소 포함 <xref:System.String.Empty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2868">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String.Empty>.</span></span> <span data-ttu-id="ad3d8-2869">다음은 몇 가지 예입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2869">Here are some examples:</span></span>  
  
|<span data-ttu-id="ad3d8-2870">문자열 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2870">String value</span></span>|<span data-ttu-id="ad3d8-2871">구분 기호</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2871">Separator</span></span>|<span data-ttu-id="ad3d8-2872">반환 되는 배열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2872">Returned array</span></span>|  
|------------------|---------------|--------------------|  
|<span data-ttu-id="ad3d8-2873">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2873">"42, 12, 19"</span></span>|<span data-ttu-id="ad3d8-2874">새로운 문자 {',', ' '을 (를) (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2874">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2875">Char () = {"," c "" c}) (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2875">Char() = {","c, " "c}) (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2876">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2876">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="ad3d8-2877">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2877">"42..12..19"</span></span>|<span data-ttu-id="ad3d8-2878">새로운 문자 {'. '을 (를)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2878">new Char[] {'.'}</span></span> <span data-ttu-id="ad3d8-2879">(C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2879">(C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2880">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2880">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2881">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2881">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="ad3d8-2882">"바나나"</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2882">"Banana"</span></span>|<span data-ttu-id="ad3d8-2883">새로운 문자 {'. '을 (를)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2883">new Char[] {'.'}</span></span> <span data-ttu-id="ad3d8-2884">(C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2884">(C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2885">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2885">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2886">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2886">{"Banana"}</span></span>|  
|<span data-ttu-id="ad3d8-2887">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2887">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2888">"Darb" & vbLf "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2888">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2889">새 Char {} (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2889">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2890">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2890">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2891">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2891">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="ad3d8-2892">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2892">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2893">"Darb" & vbLf "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2893">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2894">null(C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2894">null (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2895">Nothing(Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2895">Nothing (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2896">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2896">{"Darb", "Smarba"}</span></span>|  
  
## <a name="the-separator-array"></a><span data-ttu-id="ad3d8-2897">구분 기호 배열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2897">The separator array</span></span>  
 <span data-ttu-id="ad3d8-2898">각 요소 구분 기호는 단일 문자 구성 된 별도 구분 기호를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2898">Each element of separator defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="ad3d8-2899">경우는 `separator` 인수가 `null` 포함 되지 않은 또는 메서드를 구분 기호로 공백 문자를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2899">If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters.</span></span> <span data-ttu-id="ad3d8-2900">공백 문자는 유니코드 표준; 정의 반환 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2900">White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a><span data-ttu-id="ad3d8-2901">오버 로드 확인에 String.Split(Char[]) 및 컴파일러</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2901">String.Split(Char[]) and compiler overload resolution</span></span>  
 <span data-ttu-id="ad3d8-2902">하지만이 오버 로드에 대 한 단일 매개 변수 <xref:System.String.Split%2A?displayProperty=nameWithType> 문자 배열에는 다음 예제와 같이 단일 문자를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2902">Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=nameWithType> is a character array, you can call it with a single character, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 <span data-ttu-id="ad3d8-2903">때문에 `separator` 으로 데코레이팅되 어 매개 변수는 <xref:System.ParamArrayAttribute> 특성, 컴파일러는 단일 요소 문자 배열로 단일 문자를 해석 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2903">Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array.</span></span> <span data-ttu-id="ad3d8-2904">이 다른 사례 <xref:System.String.Split%2A?displayProperty=nameWithType> 포함 하는 오버 로드는 `separator` parameter; 명시적으로 전달 해야 이러한 오버 로드와 문자 배열은 `separator` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2904">This is not the case for other <xref:System.String.Split%2A?displayProperty=nameWithType> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.</span></span>  
  
## <a name="comparison-details"></a><span data-ttu-id="ad3d8-2905">비교 세부 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2905">Comparison details</span></span>  
 <span data-ttu-id="ad3d8-2906"><xref:System.String.Split%28System.Char%5B%5D%29> 의 문자를 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 배열 및 배열 요소와 해당 부분 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2906">The <xref:System.String.Split%28System.Char%5B%5D%29> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ad3d8-2907"><xref:System.String.Split%28System.Char%5B%5D%29> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2907">The <xref:System.String.Split%28System.Char%5B%5D%29> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ad3d8-2908">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2908">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a><span data-ttu-id="ad3d8-2909">String.Split에 대 한 대안</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2909">Alternatives to String.Split</span></span>  
 <span data-ttu-id="ad3d8-2910"><xref:System.String.Split%2A> 메서드는 항상 문자열을 부분 문자열로 구분된 된 문자열을 중단 하는 가장 좋은 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2910">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="ad3d8-2911">구분된 된 문자열의 부분 문자열의 모든 추출 하지 않으려는 경우 또는 구분 기호 문자 집합이 아닌 패턴에 따라 문자열을 구문 분석 하려는 경우 다음과 같은 대안을 고려해.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2911">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
### <a name="regular-expressions"></a><span data-ttu-id="ad3d8-2912">정규식</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2912">Regular expressions</span></span>  
 <span data-ttu-id="ad3d8-2913">문자열에 고정된 패턴을 따르지를 추출 하 여 해당 요소를 처리 하는 정규식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2913">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="ad3d8-2914">예를 들어, 문자열 형태로 "*번호* *피연산자* *번호*" 사용할 수 있습니다는 [정규식](~/docs/standard/base-types/regular-expressions.md) 추출 및 처리 하는 문자열의 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2914">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="ad3d8-2915">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2915">Here's an example:</span></span>  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="ad3d8-2916">정규식 패턴 `(\d+)\s+([-+*/])\s+(\d+)` 다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2916">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="ad3d8-2917">무늬</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2917">Pattern</span></span>|<span data-ttu-id="ad3d8-2918">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2918">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="ad3d8-2919">하나 이상의 10진수 숫자가 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2919">Match one or more decimal digits.</span></span> <span data-ttu-id="ad3d8-2920">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2920">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ad3d8-2921">하나 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2921">Match one or more whitespace characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="ad3d8-2922">일치는 산술 연산자 기호 (+,-, \*, 또는 /).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2922">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="ad3d8-2923">이 그룹은 두 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2923">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ad3d8-2924">하나 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2924">Match one or more whitespace characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="ad3d8-2925">하나 이상의 10진수 숫자가 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2925">Match one or more decimal digits.</span></span> <span data-ttu-id="ad3d8-2926">이 그룹은 세 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2926">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="ad3d8-2927">또한 둘러싸인 문자 집합이 고정된 보다는 패턴을 기반으로 문자열에서 하위 문자열을 추출 하는 정규식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2927">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="ad3d8-2928">다음은 이러한 조건 중 하나가 발생 하는 경우 일반적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2928">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="ad3d8-2929">하나 이상의 구분 기호 문자 처리 하지 않는 경우 항상에 구분 기호로 <xref:System.String> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2929">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-2930">순서 및 구분 기호 문자 수는 변수 또는 알 수 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2930">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="ad3d8-2931">예를 들어는 <xref:System.String.Split%2A> 때문에 다음 문자열을 분할 메서드를 사용할 수 없습니다 수가 `\n` (C#에서) 또는 `vbCrLf` (Visual Basic)의 문자는 변수 이며 항상 구분 기호로 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2931">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 <span data-ttu-id="ad3d8-2932">정규식이이 문자열을 쉽게 다음 예제와 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2932">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="ad3d8-2933">정규식 패턴 `\[([^\[\]]+)\]` 다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2933">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="ad3d8-2934">무늬</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2934">Pattern</span></span>|<span data-ttu-id="ad3d8-2935">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2935">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="ad3d8-2936">여는 대괄호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2936">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="ad3d8-2937">하지 않은 중괄호와 닫는 대괄호는 한 번 이상 나타나는 모든 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2937">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="ad3d8-2938">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2938">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="ad3d8-2939">닫는 대괄호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2939">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="ad3d8-2940"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 거의 동일 <xref:System.String.Split%2A?displayProperty=nameWithType>제외 하 고 고정된 문자 집합 대신 정규식 패턴에 따라 문자열을 분할 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2940">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="ad3d8-2941">예를 들어 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 하이픈과 다른 문자를 조합으로 구분 하는 부분 문자열을 포함 하는 문자열을 분할 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2941">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="ad3d8-2942">정규식 패턴 `\s-\s?[+*]?\s?-\s` 다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2942">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="ad3d8-2943">무늬</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2943">Pattern</span></span>|<span data-ttu-id="ad3d8-2944">설명</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2944">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="ad3d8-2945">하이픈 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2945">Match a whitespace character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="ad3d8-2946">0 개 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2946">Match zero or one whitespace character.</span></span>|  
|`[+*]?`|<span data-ttu-id="ad3d8-2947">중 0 개 또는 1 개 찾습니다는 + 또는 \* 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2947">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="ad3d8-2948">0 개 이상의 공백 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2948">Match zero or one whitespace character.</span></span>|  
|`-\s`|<span data-ttu-id="ad3d8-2949">공백 문자로 이어지는 하이픈을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2949">Match a hyphen followed by a whitespace character.</span></span>|  
  
### <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="ad3d8-2950">검색 방법 및 Substring 메서드</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2950">Search methods and the Substring method</span></span>  
 <span data-ttu-id="ad3d8-2951">문자열의 부분 문자열의 모든 원하지 않는 경우에 일치 항목 찾기를 시작 되는 인덱스를 반환 하는 문자열 비교 방법 중 하나를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2951">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="ad3d8-2952">호출할 수 있습니다는 <xref:System.String.Substring%2A> 메서드를 원하는 하위 문자열을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2952">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="ad3d8-2953">다음과 같은 문자열 비교 방법</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2953">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="ad3d8-2954"><xref:System.String.IndexOf%2A>문자열 인스턴스에서 맨 처음 발견 되는 문자 또는 문자열의 0부터 시작 하는 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2954"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-2955"><xref:System.String.IndexOfAny%2A>을 문자 배열에 있는 문자 중 첫 번째 요소의 현재 문자열 인스턴스 0부터 시작 하는 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2955"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="ad3d8-2956"><xref:System.String.LastIndexOf%2A>문자열 인스턴스에서는 문자 또는 문자열의 마지막 항목의 0부터 시작 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2956"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ad3d8-2957"><xref:System.String.LastIndexOfAny%2A>현재 문자열 인스턴스에서 문자 배열에 있는 문자 중 마지막 요소의 0 기반 인덱스를 반환 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2957"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="ad3d8-2958">다음 예제에서는 <xref:System.String.IndexOf%2A> 메서드를 문자열에서 마침표를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2958">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="ad3d8-2959">다음 사용 하 여는 <xref:System.String.Substring%2A> 메서드를 완전 한 문장을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2959">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a><span data-ttu-id="ad3d8-2960">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2960">Performance Considerations</span></span>  
 <span data-ttu-id="ad3d8-2961"><xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2961">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ad3d8-2962">응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하 여 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2962">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method.</span></span> <span data-ttu-id="ad3d8-2963">사용할 수 있습니다는 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2963">You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ad3d8-2964">문자열 구분 기호 문자에서 분할을 사용 하 여는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2964">To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ad3d8-2965">문자열에서 구분 기호 문자열을 분할 하려면 사용는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2965">To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ad3d8-2966">다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2966">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ad3d8-2967">또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2967">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ad3d8-2968">각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2968">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-2969">다음 예제에는 구분 기호로 공백 및 문장 부호를 처리 하 여 텍스트 블록에서 개별 단어를 추출 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2969">The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</span></span> <span data-ttu-id="ad3d8-2970">에 전달 된 문자 배열에서 `separator` 의 매개 변수는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 방법은 단순히 공백 문자 및 탭 문자와 함께 몇 가지 공통 문장 부호 기호.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2970">The character array passed to the `separator` parameter of the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method consists of a space character and a tab character, together with some common punctuation symbols.</span></span>  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-2971">에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 버전, 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 보다 문자열을 분할는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 트리밍 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2971">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ad3d8-2972">에 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 두 가지 방법 유니코드 공백 문자의 것과 동일한 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2972">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-2973">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2973">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-2974">반환할 부분 문자열의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2974">The maximum number of substrings to return.</span></span></param>
        <summary><span data-ttu-id="ad3d8-2975">배열에 있는 문자에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2975">Splits a string into a maximum number of substrings based on the characters in an array.</span></span> <span data-ttu-id="ad3d8-2976">반환할 부분 문자열의 최대 수도 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2976">You also specify the maximum number of substrings to return.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-2977">해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 인스턴스의 부분 문자열이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2977">An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ad3d8-2978">자세한 내용은 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2978">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-2979">구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2979">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ad3d8-2980">이 인스턴스가 없는 경우에 문자 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2980">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ad3d8-2981">경우 `count` 가 0 인 경우 빈 배열이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2981">If `count` is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ad3d8-2982">경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2982">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ad3d8-2983">공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2983">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ad3d8-2984">각 요소 `separator` 별도 구분 기호 문자를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2984">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ad3d8-2985">두 개의 구분 기호는, 인접 한 경우 나이 인스턴스의 끝 부분에는 구분 기호를 찾을 수, 해당 배열 요소 포함 <xref:System.String.Empty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2985">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ad3d8-2986">있는 경우 이상 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 1 부분 문자열에서 뺀 첫 번째 범위에서 반환 됩니다 `count` 의 반환 값과 나머지이 인스턴스의 문자를이 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2986">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ad3d8-2987">경우 `count` 수보다 크면의 부분 문자열을 사용할 수 있는 부분 문자열이 반환 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2987">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
 <span data-ttu-id="ad3d8-2988">다음 표에서 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2988">The following table provides examples.</span></span>  
  
|<span data-ttu-id="ad3d8-2989">문자열 값</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2989">String value</span></span>|<span data-ttu-id="ad3d8-2990">구분 기호</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2990">Separator</span></span>|<span data-ttu-id="ad3d8-2991">개수</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2991">Count</span></span>|<span data-ttu-id="ad3d8-2992">반환 되는 배열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2992">Returned array</span></span>|  
|------------------|---------------|-----------|--------------------|  
|<span data-ttu-id="ad3d8-2993">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2993">"42, 12, 19"</span></span>|<span data-ttu-id="ad3d8-2994">새로운 문자 {',', ' '을 (를) (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2994">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-2995">Char () = {"," c "" c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2995">Char() = {","c, " "c} (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-2996">2</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2996">2</span></span>|<span data-ttu-id="ad3d8-2997">{"42", " 12, 19"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2997">{"42", " 12, 19"}</span></span>|  
|<span data-ttu-id="ad3d8-2998">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2998">"42..12..19"</span></span>|<span data-ttu-id="ad3d8-2999">새로운 문자 {'. '을 (를)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-2999">new Char[] {'.'}</span></span> <span data-ttu-id="ad3d8-3000">(C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3000">(C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3001">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3001">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-3002">4</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3002">4</span></span>|<span data-ttu-id="ad3d8-3003">{"42", "", "12", ".19"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3003">{"42", "", "12", ".19"}</span></span>|  
|<span data-ttu-id="ad3d8-3004">"바나나"</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3004">"Banana"</span></span>|<span data-ttu-id="ad3d8-3005">새로운 문자 {'. '을 (를)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3005">new Char[] {'.'}</span></span> <span data-ttu-id="ad3d8-3006">(C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3006">(C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3007">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3007">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-3008">2</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3008">2</span></span>|<span data-ttu-id="ad3d8-3009">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3009">{"Banana"}</span></span>|  
|<span data-ttu-id="ad3d8-3010">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3010">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3011">"Darb" & vbLf "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3011">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-3012">새 Char {} (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3012">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3013">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3013">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-3014">1</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3014">1</span></span>|<span data-ttu-id="ad3d8-3015">{"Darb\nSmarba"} (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3015">{"Darb\nSmarba"} (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3016">"Darb" & vbLf "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3016">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|  
|<span data-ttu-id="ad3d8-3017">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3017">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3018">"Darb" & vbLf "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3018">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-3019">새 Char] null (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3019">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3020">Char() = Nothing</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3020">Char() = Nothing</span></span>|<span data-ttu-id="ad3d8-3021">2</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3021">2</span></span>|<span data-ttu-id="ad3d8-3022">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3022">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="ad3d8-3023">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3023">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3024">"Darb" & vbLf "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3024">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ad3d8-3025">새 Char] null (C#)</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3025">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="ad3d8-3026">Char() = Nothing</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3026">Char() = Nothing</span></span>|<span data-ttu-id="ad3d8-3027">100</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3027">100</span></span>|<span data-ttu-id="ad3d8-3028">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3028">{"Darb", "Smarba"}</span></span>|  
  
## <a name="performance-considerations"></a><span data-ttu-id="ad3d8-3029">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3029">Performance Considerations</span></span>  
 <span data-ttu-id="ad3d8-3030"><xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3030">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ad3d8-3031">응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3031">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ad3d8-3032">사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3032">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ad3d8-3033">사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3033">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ad3d8-3034">다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3034">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ad3d8-3035">또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3035">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ad3d8-3036">각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3036">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3037">다음 예제에서는 어떻게 `count` 에서 반환 된 문자열의 수에 영향을 <xref:System.String.Split%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3037">The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.</span></span>  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-3038"><paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3038"><paramref name="count" /> is negative.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3039">에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 버전, 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 보다 문자열을 분할는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 트리밍 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3039">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ad3d8-3040">에 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 두 가지 방법 유니코드 공백 문자의 것과 동일한 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3040">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-3041">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3041">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options">
          <span data-ttu-id="ad3d8-3042">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3042"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3043">배열에 있는 문자에 따라 문자열을 부분 문자열로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3043">Splits a string into substrings based on the characters in an array.</span></span> <span data-ttu-id="ad3d8-3044">부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3044">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3045">해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3045">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ad3d8-3046">자세한 내용은 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3046">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a><span data-ttu-id="ad3d8-3047">반환 값 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3047">Return value details</span></span>  
 <span data-ttu-id="ad3d8-3048">구분 기호 문자 (의 문자는 `separator` 배열)의 반환된 된 배열 요소에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3048">Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array.</span></span> <span data-ttu-id="ad3d8-3049">예를 들어 경우는 `separator` 문자를 포함 하는 배열 "-" 문자열 현재 인스턴스의 값이 "aa bb 참조", 세 개의 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3049">For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ad3d8-3050">이 인스턴스가 없는 경우에 문자 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3050">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-3051">경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 하 고이 인스턴스의 길이 0, 메서드는 빈 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3051">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="ad3d8-3052">각 요소 `separator` 단일 문자 구성 된 별도 구분 기호를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3052">Each element of `separator` defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="ad3d8-3053">경우는 `options` 인수가 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3053">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-3054">예를 들어 경우 `separator` 두 개의 요소가 포함 됩니다 "-" 및 "\_", 문자열 인스턴스의 값이 "-\_aa-\_"의 값과는 `options` 인수는 <xref:System.StringSplitOptions.None>, 메서드가 문자열 배열을 반환 다음 5 개 요소:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3054">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a string array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="ad3d8-3055"><xref:System.String.Empty?displayProperty=nameWithType>를 앞에 빈 문자열을 나타내는 "-" 문자 인덱스 0에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3055"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" character at index 0.</span></span>  
  
2.  <span data-ttu-id="ad3d8-3056"><xref:System.String.Empty?displayProperty=nameWithType>사이의 빈 문자열을 나타내는 "-" 인덱스 0와 인덱스 1에 "_" 문자는 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3056"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</span></span>  
  
3.  <span data-ttu-id="ad3d8-3057">"aa",</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3057">"aa",</span></span>  
  
4.  <span data-ttu-id="ad3d8-3058"><xref:System.String.Empty?displayProperty=nameWithType>인덱스 4에서 "_" 문자 뒤에 오는 빈 문자열을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3058"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" character at index 4.</span></span>  
  
5.  <span data-ttu-id="ad3d8-3059"><xref:System.String.Empty?displayProperty=nameWithType>뒤에 오는 빈 문자열을 나타내는 "-"에서 인덱스 5 문자.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3059"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" character at index 5.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="ad3d8-3060">구분 기호 배열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3060">The separator array</span></span>  
 <span data-ttu-id="ad3d8-3061">경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3061">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ad3d8-3062">공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3062">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ad3d8-3063">경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3063">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ad3d8-3064">호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3064">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ad3d8-3065">다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3065">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a><span data-ttu-id="ad3d8-3066">비교 세부 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3066">Comparison details</span></span>  
 <span data-ttu-id="ad3d8-3067"><xref:System.String.Split%2A> 의 문자를 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소를 해당 부분 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3067">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ad3d8-3068"><xref:System.String.Split%2A> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3068">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ad3d8-3069">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3069">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ad3d8-3070">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3070">Performance Considerations</span></span>  
 <span data-ttu-id="ad3d8-3071"><xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3071">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ad3d8-3072">응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3072">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ad3d8-3073">사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3073">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ad3d8-3074">사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3074">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ad3d8-3075">다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3075">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ad3d8-3076">또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3076">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ad3d8-3077">각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3077">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3078">다음 예제에서는 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을는 <xref:System.String.Split%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3078">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-3079"><paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3079"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3080">에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 버전, 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 보다 문자열을 분할는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 트리밍 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3080">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ad3d8-3081">에 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 두 가지 방법 유니코드 공백 문자의 것과 동일한 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3081">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-3082">이 문자열의 부분 문자열을 구분하는 문자열 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3082">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options">
          <span data-ttu-id="ad3d8-3083">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3083"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3084">배열에 있는 문자열에 따라 문자열을 부분 문자열로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3084">Splits a string into substrings based on the strings in an array.</span></span> <span data-ttu-id="ad3d8-3085">부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3085">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3086">해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자열로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3086">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="ad3d8-3087">자세한 내용은 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3087">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3088">알려진된 일련의 문자열에서 구분은 문자열 때 사용할 수 있습니다는 <xref:System.String.Split%2A> 메서드 문자열을 부분 문자열로 구분 될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3088">When a string is delimited by a known set of strings, you can use the <xref:System.String.Split%2A> method to separate it into substrings.</span></span>  
  
## <a name="return-value-details"></a><span data-ttu-id="ad3d8-3089">반환 값 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3089">Return value details</span></span>  
 <span data-ttu-id="ad3d8-3090">구분 기호 문자열로 반환 된 배열의 요소에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3090">Delimiter strings are not included in the elements of the returned array.</span></span> <span data-ttu-id="ad3d8-3091">예를 들어 경우는 `separator` 문자열을 포함 하는 배열 "-" 문자열 현재 인스턴스의 값이 "aa-cc bb", 세 개의 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3091">For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ad3d8-3092">이 인스턴스가 없는 경우에 문자열이 `separator`, 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3092">If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-3093">경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 하 고이 인스턴스의 길이 0, 메서드는 빈 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3093">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="ad3d8-3094">각 요소 `separator` 하나 이상의 문자로 구성 된 별도 구분 기호를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3094">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="ad3d8-3095">경우는 `options` 인수가 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3095">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-3096">예를 들어 경우 `separator` 두 개의 요소가 포함 됩니다 "-" 및 "_", 문자열 인스턴스의 값이 "-_aa-\_"의 값과는 `options` 인수는 <xref:System.StringSplitOptions.None>, 메서드는 다음 5 개의 요소로 문자열 배열을 반환:</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3096">For example, if `separator` includes  two elements, "-" and "_", the value of the string instance is "-_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a sting array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="ad3d8-3097"><xref:System.String.Empty?displayProperty=nameWithType>를 앞에 빈 문자열을 나타내는 "-" 인덱스 0에 부분 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3097"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" substring at index 0.</span></span>  
  
2.  <span data-ttu-id="ad3d8-3098"><xref:System.String.Empty?displayProperty=nameWithType>사이의 빈 문자열을 나타내는 "-" 0 인덱스와 인덱스 1에 있는 "_" 부분 문자열에 부분 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3098"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</span></span>  
  
3.  <span data-ttu-id="ad3d8-3099">"aa",</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3099">"aa",</span></span>  
  
4.  <span data-ttu-id="ad3d8-3100"><xref:System.String.Empty?displayProperty=nameWithType>인덱스 4에서 "_" 부분 문자열 뒤에 오는 빈 문자열을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3100"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" substring at index 4.</span></span>  
  
5.  <span data-ttu-id="ad3d8-3101"><xref:System.String.Empty?displayProperty=nameWithType>뒤에 오는 빈 문자열을 나타내는 "-" 인덱스 5에 부분 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3101"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" substring at index 5.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="ad3d8-3102">구분 기호 배열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3102">The separator array</span></span>  
 <span data-ttu-id="ad3d8-3103">요소 하나라 `separator` 구성 되어 전체 부분 문자열이 여러 문자는 구분 기호 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3103">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="ad3d8-3104">예를 들어 하나에 있는 요소의 `separator` 은 "10", "This10is10a10string" 문자열을 분할 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3104">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="ad3d8-3105">다음 4 개 요소 배열을 반환: {"This", "is", "a", "문자열입니다."</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3105">returns the following four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="ad3d8-3106">}.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3106">}.</span></span>  
  
 <span data-ttu-id="ad3d8-3107">경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3107">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ad3d8-3108">공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3108">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ad3d8-3109">경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3109">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ad3d8-3110">호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3110">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ad3d8-3111">다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3111">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a><span data-ttu-id="ad3d8-3112">비교 세부 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3112">Comparison details</span></span>  
 <span data-ttu-id="ad3d8-3113"><xref:System.String.Split%2A> 있는 문자열 중 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소를 해당 부분 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3113">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ad3d8-3114"><xref:System.String.Split%2A> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3114">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ad3d8-3115">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3115">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="ad3d8-3116"><xref:System.String.Split%2A> 의 요소를 무시 하는 메서드 `separator` 값인 `null` 또는 빈 문자열 ("").</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3116">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="ad3d8-3117">모호한 결과 방지 하려면 때 문자열 `separator` 공통적인, 문자가 있는 <xref:System.String.Split%2A> 작업의 인스턴스 값의 끝에 처음부터 진행 되 고 첫 번째 요소에 일치 `separator` 의 구분 같거나는 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3117">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="ad3d8-3118">인스턴스에서 부분 문자열은 나타나는 순서에 있는 요소의 순서 보다 우선 `separator`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3118">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="ad3d8-3119">예를 들어 값이 "abcdef" 인스턴스를 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3119">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="ad3d8-3120">경우에 첫 번째 요소 `separator` "ef"와 두 번째 요소 "bcde" 이면 split 작업의 결과 두 개의 요소를 포함 하는 문자열 배열 "a"와 "f"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3120">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</span></span> <span data-ttu-id="ad3d8-3121">이 "bcde" 인스턴스에 있는 부분 문자열은와 일치 하기 때문에 요소 `separator` 전에 부분 문자열 "f"가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3121">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="ad3d8-3122">그러나 경우의 첫 번째 요소로 `separator` "bcd"와 두 번째 요소 "bc" 이면 split 작업의 결과 두 개의 요소를 포함 하는 문자열 배열 "a"와 "ef"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3122">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</span></span> <span data-ttu-id="ad3d8-3123">"Bcd"는 첫 번째 구분 기호 때문에 이것이 `separator` 인스턴스에서 구분 기호와 일치 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3123">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="ad3d8-3124">첫 번째 요소 기간은 "bc"는 구분 기호가 순서 취소 하 고 두 번째 요소가 "bcd" 이면 결과 두 요소를 포함 하는 문자열 배열 하는 경우 "a"와 "def"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3124">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ad3d8-3125">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3125">Performance considerations</span></span>  
 <span data-ttu-id="ad3d8-3126"><xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3126">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ad3d8-3127">응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3127">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ad3d8-3128">사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3128">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ad3d8-3129">사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3129">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ad3d8-3130">다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3130">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ad3d8-3131">또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3131">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ad3d8-3132">각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3132">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3133">다음 예제에서는 문자열의 호출 하 여 반환 된 배열에 있는 차이 보여 줍니다. <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> 메서드를 해당 `options` 매개 변수를 <xref:System.StringSplitOptions.None?displayProperty=nameWithType> 및 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3133">The following example illustrates the difference in the arrays returned by calling a string's <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> method with its `options` parameter equal to <xref:System.StringSplitOptions.None?displayProperty=nameWithType> and <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 <span data-ttu-id="ad3d8-3134">다음 예제에서는 문장 부호 및 공백 문자를 포함 하는 구분 기호 배열을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3134">The following example defines an array of separators that include punctuation and white-space characters.</span></span> <span data-ttu-id="ad3d8-3135">값과 함께이 배열을 전달 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 에 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> 문자열에서 개별 단어로 구성 된 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3135">Passing this array along with a value of <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> to the <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> method returns an array that consists of the individual words from the string.</span></span>  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 <span data-ttu-id="ad3d8-3136">여는 메서드를 호출 하는 `options` 인수로 설정 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3136">Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad3d8-3137">반환된 된 배열에서 포함 하지 않습니다 <xref:System.String.Empty?displayProperty=nameWithType> 문장 부호 및 공백 문자 사이 빈 부분 문자열 일치를 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3137">This prevents the returned array from including <xref:System.String.Empty?displayProperty=nameWithType> values that represent empty substring matches between punctuation marks and white-space characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-3138"><paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3138"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3139">에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 버전, 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 보다 문자열을 분할는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 트리밍 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3139">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ad3d8-3140">에 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 두 가지 방법 유니코드 공백 문자의 것과 동일한 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3140">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-3141">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3141">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-3142">반환할 부분 문자열의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3142">The maximum number of substrings to return.</span></span></param>
        <param name="options">
          <span data-ttu-id="ad3d8-3143">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3143"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3144">배열에 있는 문자에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3144">Splits a string into a maximum number of substrings based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3145">해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3145">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ad3d8-3146">자세한 내용은 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3146">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3147">구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3147">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ad3d8-3148">이 인스턴스가 없는 경우에 문자 `separator`, 또는 `count` 매개 변수가 1 이면 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3148">If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ad3d8-3149">경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3149">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ad3d8-3150">공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3150">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ad3d8-3151">그러나 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3151">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ad3d8-3152">호출된 된 메서드를 명확 하 게 식별 하려면 코드에는 null의 형식을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3152">To unambiguously identify the called method, your code must indicate the type of the null.</span></span> <span data-ttu-id="ad3d8-3153">다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3153">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 <span data-ttu-id="ad3d8-3154">경우는 `count` 매개 변수는 0 또는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 고이 인스턴스의 길이 0, 빈 배열이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3154">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ad3d8-3155">각 요소 `separator` 별도 구분 기호 문자를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3155">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ad3d8-3156">경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3156">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ad3d8-3157">있는 경우 이상 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 1 부분 문자열에서 뺀 첫 번째 범위에서 반환 됩니다 `count` 의 반환 값과 나머지이 인스턴스의 문자를이 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3157">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ad3d8-3158">경우 `count` 수보다 크면의 부분 문자열을 사용할 수 있는 부분 문자열이 반환 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3158">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ad3d8-3159">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3159">Performance Considerations</span></span>  
 <span data-ttu-id="ad3d8-3160"><xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3160">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ad3d8-3161">응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3161">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ad3d8-3162">사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3162">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ad3d8-3163">사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3163">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ad3d8-3164">다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3164">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ad3d8-3165">또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3165">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ad3d8-3166">각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3166">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3167">다음 예제에서는 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을는 <xref:System.String.Split%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3167">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-3168"><paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3168"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-3169"><paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3169"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3170">에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 버전, 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 보다 문자열을 분할는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 트리밍 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3170">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ad3d8-3171">에 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 두 가지 방법 유니코드 공백 문자의 것과 동일한 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3171">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ad3d8-3172">이 문자열의 부분 문자열을 구분하는 문자열 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3172">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ad3d8-3173">반환할 부분 문자열의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3173">The maximum number of substrings to return.</span></span></param>
        <param name="options">
          <span data-ttu-id="ad3d8-3174">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3174"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3175">배열에 있는 문자열에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3175">Splits a string into a maximum number of substrings based on the strings in an array.</span></span> <span data-ttu-id="ad3d8-3176">부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3176">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3177">해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자열로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3177">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="ad3d8-3178">자세한 내용은 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3178">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a><span data-ttu-id="ad3d8-3179">반환 값 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3179">Return value details</span></span>  
 <span data-ttu-id="ad3d8-3180">구분 기호 문자열로 반환 된 배열의 요소에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3180">Delimiter strings are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ad3d8-3181">이 인스턴스가 없는 경우에 문자열이 `separator`, 또는 `count` 매개 변수가 1 이면 반환 된 배열은이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3181">If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ad3d8-3182">경우는 `separator` 매개 변수는 `null` 포함 되지 않은 또는 공백 문자를 구분 기호로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3182">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ad3d8-3183">공백 문자는 유니코드 표준 및 반환 하 여 정의 된 `true` 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3183">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ad3d8-3184">그러나 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3184">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ad3d8-3185">호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3185">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ad3d8-3186">다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3186">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 <span data-ttu-id="ad3d8-3187">경우는 `count` 매개 변수는 0 또는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 고이 인스턴스의 길이 0, 빈 배열이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3187">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ad3d8-3188">각 요소 `separator` 하나 이상의 문자로 구성 된 별도 구분 기호를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3188">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="ad3d8-3189">경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.None>, 및 두 개의 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소를 포함 <xref:System.String.Empty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3189">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ad3d8-3190">있는 경우 이상 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 1 부분 문자열에서 뺀 첫 번째 범위에서 반환 됩니다 `count` 의 반환 값과 나머지이 인스턴스의 문자를이 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3190">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ad3d8-3191">경우 `count` 수보다 크면의 부분 문자열을 사용할 수 있는 부분 문자열이 반환 되 고 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3191">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="ad3d8-3192">구분 기호 배열</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3192">The separator array</span></span>  
 <span data-ttu-id="ad3d8-3193">요소 하나라 `separator` 구성 되어 전체 부분 문자열이 여러 문자는 구분 기호 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3193">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="ad3d8-3194">예를 들어 하나에 있는 요소의 `separator` 은 "10", "This10is10a10string" 문자열을 분할 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3194">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="ad3d8-3195">이 네 개의 요소로 배열을 반환: {"This", "is", "a", "문자열입니다."</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3195">returns this four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="ad3d8-3196">}.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3196">}.</span></span>  
  
## <a name="comparison-details"></a><span data-ttu-id="ad3d8-3197">비교 세부 정보</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3197">Comparison details</span></span>  
 <span data-ttu-id="ad3d8-3198"><xref:System.String.Split%2A> 있는 문자열 중 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소를 해당 부분 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3198">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ad3d8-3199"><xref:System.String.Split%2A> 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호에 대 한 메서드를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3199">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ad3d8-3200">Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3200">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="ad3d8-3201"><xref:System.String.Split%2A> 의 요소를 무시 하는 메서드 `separator` 값인 `null` 또는 빈 문자열 ("").</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3201">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="ad3d8-3202">모호한 결과 방지 하려면 때 문자열 `separator` 공통적인, 문자가 있는 <xref:System.String.Split%2A> 메서드는 인스턴스 값의 끝에 처음부터 진행 되 고 첫 번째 요소에 일치 `separator` 의 구분 같거나는 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3202">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="ad3d8-3203">인스턴스에서 부분 문자열은 나타나는 순서에 있는 요소의 순서 보다 우선 `separator`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3203">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="ad3d8-3204">예를 들어 값이 "abcdef" 인스턴스를 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3204">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="ad3d8-3205">경우에 첫 번째 요소 `separator` "ef"와 두 번째 요소 "bcde" 이면 split 작업의 결과 "a"와 "f"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3205">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</span></span> <span data-ttu-id="ad3d8-3206">이 "bcde" 인스턴스에 있는 부분 문자열은와 일치 하기 때문에 요소 `separator` 전에 부분 문자열 "f"가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3206">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="ad3d8-3207">그러나 경우의 첫 번째 요소로 `separator` "bcd"와 두 번째 요소 "bc" 이면 split 작업의 결과 "a"와 "ef"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3207">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</span></span> <span data-ttu-id="ad3d8-3208">"Bcd"는 첫 번째 구분 기호 때문에 이것이 `separator` 인스턴스에서 구분 기호와 일치 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3208">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="ad3d8-3209">첫 번째 요소 기간은 "bc"는 구분 기호가 순서 취소 하 고 두 번째 요소가 "bcd"을 결과로 "a"와 "def"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3209">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ad3d8-3210">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3210">Performance considerations</span></span>  
 <span data-ttu-id="ad3d8-3211"><xref:System.String.Split%2A> 반환 된 배열 개체에 대 한 메모리를 할당 하는 메서드 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3211">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ad3d8-3212">응용 프로그램에 필요한 성능을 최적화 하는 경우 또는 메모리 할당을 관리 하는 것이 응용 프로그램에서 중요 한 것이 좋습니다를 사용 하는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드를 선택적으로 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3212">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ad3d8-3213">사용 하 여 문자열 구분 기호 문자에서 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드는 문자열에서 구분 기호를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3213">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ad3d8-3214">사용 하 여 문자열에서 구분 기호 문자열을 분할 하는 경우는 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 구분 기호 문자열의 첫 번째 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3214">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ad3d8-3215">다음 사용 하 여는 <xref:System.String.Compare%2A> 메서드를 해당 첫 번째 문자 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3215">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ad3d8-3216">또한 동일한 설정의 문자는 사용에서 여러 문자열을 분리 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3216">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ad3d8-3217">각 메서드 호출의 추가 오버 헤드가 상당히 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3217">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3218">다음 예제에서는 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을는 <xref:System.String.Split%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3218">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-3219"><paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3219"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-3220"><paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3220"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3221">에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 버전, 하는 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다는 <paramref name="separator" /> 즉 <see langword="null" /> 포함 되지 않은 또는 메서드 집합이 약간 다른 문자를 사용 하 여 보다 문자열을 분할는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 트리밍 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3221">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ad3d8-3222">에 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 두 가지 방법 유니코드 공백 문자의 것과 동일한 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3222">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-3223">이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3223">Determines whether the beginning of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-3224">비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3224">The string to compare.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3225">이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3225">Determines whether the beginning of this string instance matches the specified string.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-3226">이 문자열의 시작 부분이 <see langword="true" />와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3226"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3227">이 메서드는 비교 `value` 와 같은 길이가이 인스턴스의 시작 부분에 있는 부분 문자열과 `value`와 같은지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3227">This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="ad3d8-3228">하려면 `value` 빈 문자열 이어야 합니다 (<xref:System.String.Empty?displayProperty=nameWithType>)이 같은 인스턴스에 대 한 참조 여야, 또는이 인스턴스의 시작 부분과 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3228">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-3229">이 메서드는 현재 문화권을 사용 하 여 word (대/소문자 구분 및 문화권을 구분) 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3229">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3230">다음 예제에서는 정의 `StripStartTags` 메서드를 사용 하는 <xref:System.String.StartsWith%28System.String%29> 문자열의 시작 부분에서 시작 태그를 HTML을 제거 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3230">The following example defines a `StripStartTags` method that uses the <xref:System.String.StartsWith%28System.String%29> method to remove HTML start tags from the beginning of a string.</span></span> <span data-ttu-id="ad3d8-3231">`StripStartTags` 메서드는 재귀적으로 줄의 시작 부분에는 여러 HTML 시작 태그가 제거 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3231">Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</span></span> <span data-ttu-id="ad3d8-3232">이 예제에서는 문자열에 포함 된 HTML 태그를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3232">The example does not remove HTML tags embedded in a string.</span></span>  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-3233"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3233"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3234">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3234">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-3235">확인 하려면 현재 문화권의 문자열 비교 규칙을 사용 하 여 특정 문자열이 부분 문자열로 시작 하는지 여부를 호출는 <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> 메서드 오버 로드의 값을 가진 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3235">To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-3236">비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3236">The string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ad3d8-3237">이 문자열과 <c>value</c>를 비교하는 방법을 결정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3237">One of the enumeration values that determines how this string and <c>value</c> are compared.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3238">지정한 비교 옵션을 사용하여 비교할 때 지정한 문자열과 이 문자열 인스턴스의 시작 부분이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3238">Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-3239">이 인스턴스가 <see langword="true" />로 시작하는 경우 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3239"><see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3240"><xref:System.String.StartsWith%2A> 메서드 비교는 `value` 이 문자열의 시작 부분에 부분 문자열에 매개 변수가 같은지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3240">The <xref:System.String.StartsWith%2A> method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ad3d8-3241">하려면 `value` 이 동일한 문자열에 대 한 참조 여야, 빈 문자열 이어야 합니다 (""), 또는이 문자열의 시작 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3241">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</span></span> <span data-ttu-id="ad3d8-3242">비교를 수행 하 여 유형의 <xref:System.String.StartsWith%2A> 메서드는 값에 따라는 `comparisonType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3242">The type of comparison performed by the <xref:System.String.StartsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span> <span data-ttu-id="ad3d8-3243">비교 현재 문화권의 규칙을 사용할 수 있습니다 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 및 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 이나 고정 문화권 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 및 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), 또는 코드 포인트를 문자 단위로 비교를 구성할 수 있습니다 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3243">The comparison can use the conventions of the current culture (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> and <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) or the invariant culture (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ad3d8-3244">비교도 대/소문자 구분 될 수 있습니다 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, 또는 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), 대/소문자를 무시할 수도 있습니다 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3244">The comparison can also be case-sensitive (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, or <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), or it can ignore case (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3245">다음 예에서는 문자열에 대 한 검색 단어로 시작 하는 긴 문자열의 시작 부분에서 "the" "The"입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3245">The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</span></span> <span data-ttu-id="ad3d8-3246">예제에 대 한 호출에서 출력으로의 <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> 메서드 문화권을 구분 하지 않지만 대/소문자 구분 비교를 수행 하는 문자열과 일치 하는 문화권 및 case insensitive 비교를 수행 하는 호출 하는 동안 문자열 일치에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3246">As the output from the example shows, a call to the <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</span></span>  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 <span data-ttu-id="ad3d8-3247">다음 예에서는 문자열이 특정 하위 문자열로 시작 하는지를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3247">The following example determines whether a string starts with a particular substring.</span></span> <span data-ttu-id="ad3d8-3248">2 차원 문자열 배열을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3248">It initializes a two-dimensional string array.</span></span> <span data-ttu-id="ad3d8-3249">두 번째 차원에 있는 첫 번째 요소는 문자열을 포함 하 고 두 번째 요소에 대 한 첫 번째 문자열의 시작 부분에 검색할 문자열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3249">The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</span></span> <span data-ttu-id="ad3d8-3250">결과는 문화권, 대/소문자 무시 여부 및 서 수 비교가 수행 되는지 여부는 선택한 항목에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3250">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span> <span data-ttu-id="ad3d8-3251">Note는 합자를 포함 하는 문자열 인스턴스를 연속 문자의 문화권 구분 비교 성공적으로 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3251">Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</span></span>  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-3252"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3252"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ad3d8-3253"><paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3253"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ad3d8-3254">비교할 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3254">The string to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="ad3d8-3255">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3255"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ad3d8-3256">이 문자열과 <c>value</c>의 비교 방법을 결정하는 문화권 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3256">Cultural information that determines how this string and <c>value</c> are compared.</span></span> <span data-ttu-id="ad3d8-3257"><c>culture</c>가 <see langword="null" />이면 현재 문화권이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3257">If <c>culture</c> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3258">지정한 문화권을 사용하여 비교할 때 이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3258">Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-3259">이 문자열의 시작 부분이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3259"><see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3260">이 메서드는 비교는 `value` 와 같은 길이가이 문자열의 시작 부분에 있는 부분 문자열과 매개 변수 `value`, 같은지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3260">This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ad3d8-3261">하려면 `value` 빈 문자열 이어야 합니다 (<xref:System.String.Empty?displayProperty=nameWithType>)이 같은 인스턴스에 대 한 참조 여야, 또는이 인스턴스의 시작 부분과 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3261">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-3262">이 메서드는 지정 된 대/소문자 및 문화권을 사용 하 여 비교를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3262">This method performs a comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3263">다음 예에서는 문자열이 다른 문자열의 시작 부분에 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3263">The following example determines whether a string occurs at the beginning of another string.</span></span> <span data-ttu-id="ad3d8-3264"><xref:System.String.StartsWith%2A> 여러 번 대/소문자 구분, 대/소문자, 및 검색 결과 영향을 주는 다양 한 문화권을 사용 하 여 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3264">The <xref:System.String.StartsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-3265"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3265"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-3266">이 인스턴스에서 부분 문자열을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3266">Retrieves a substring from this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-3267">이 멤버는 오버로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3267">This member is overloaded.</span></span> <span data-ttu-id="ad3d8-3268">구문, 사용법 및 예제를 비롯하여 이 멤버에 대한 자세한 내용을 보려면 오버로드 목록에서 이름을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3268">For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ad3d8-3269">이 인스턴스의 부분 문자열에 있는 0부터 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3269">The zero-based starting character position of a substring in this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3270">이 인스턴스에서 부분 문자열을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3270">Retrieves a substring from this instance.</span></span> <span data-ttu-id="ad3d8-3271">부분 문자열은 지정된 문자 위치에서 시작하고 문자열 끝까지 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3271">The substring starts at a specified character position and continues to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3272">이 인스턴스의 <paramref name="startIndex" />에서 시작하는 부분 문자열에 해당하는 문자열이거나, <see cref="F:System.String.Empty" />가 이 인스턴스의 길이와 같으면 <paramref name="startIndex" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3272">A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3273">호출 하는 <xref:System.String.Substring%2A> 메서드를 문자열로 지정된 된 문자 위치에서 시작 하 고 문자열의 끝에서 끝나는 부분 문자열을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3273">You call the <xref:System.String.Substring%2A> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</span></span> <span data-ttu-id="ad3d8-3274">시작 문자 위치는 0부터 시작 합니다. 즉, 문자열에서 첫 번째 문자는 인덱스 0, 1 인덱싱하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3274">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="ad3d8-3275">지정 된 문자 위치에서 시작 하는 문자열의 끝에 앞에서 끝납니다 하는 부분 문자열을 추출 하려면 호출 된 <xref:System.String.Substring%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3275">To extract a substring that begins at a specified character position and ends before to the end of the string, call the <xref:System.String.Substring%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3276">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3276">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3277">대신,에서 시작 하는 새 문자열을 반환 합니다는 `startIndex` 현재 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3277">Instead, it returns a new string that begins at the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="ad3d8-3278">특정 문자 또는 문자 시퀀스와 시작 하는 부분 문자열을 추출 하려면 메서드를와 같은 호출 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 의 값을 가져오는 `startIndex`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3278">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`.</span></span> <span data-ttu-id="ad3d8-3279">두 번째 예제에서는이; "=" 문자 다음 문자를 한 위치를 시작 하는 키 값을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3279">The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</span></span>  
  
 <span data-ttu-id="ad3d8-3280">경우 `startIndex` 0, 원래 문자열 변경 하지 않고 메서드가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3280">If `startIndex` is equal to zero, the method returns the original string unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3281">다음 예제에서는 문자열에서 하위 문자열을 얻는 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3281">The following example demonstrates obtaining a substring from a string.</span></span>  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 <span data-ttu-id="ad3d8-3282">다음 예제에서는 <xref:System.String.Substring%2A> 같음 구분 되는 키/값 쌍을 구분 하는 메서드 문자 ("=").</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3282">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="ad3d8-3283"><xref:System.String.IndexOf%2A> 메서드 문자열에 equals 문자의 위치를 가져오는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3283">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string..</span></span> <span data-ttu-id="ad3d8-3284">에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드 추출은 키 이름이 없습니다., 문자열의 첫 번째 문자에서 시작 하 고에 대 한 호출에서 반환 된 문자 수에 대 한 확장 하는 <xref:System.String.IndexOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3284">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ad3d8-3285">에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%29> 메서드는 키에 할당 된 값을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3285">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="ad3d8-3286">Equals 문자 뒤에 있는 한 문자 위치에서 시작 하 고 문자열의 끝까지 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3286">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-3287"><paramref name="startIndex" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3287"><paramref name="startIndex" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ad3d8-3288">이 인스턴스의 부분 문자열에 있는 0부터 시작할 문자 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3288">The zero-based starting character position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-3289">부분 문자열에 있는 문자의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3289">The number of characters in the substring.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3290">이 인스턴스에서 부분 문자열을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3290">Retrieves a substring from this instance.</span></span> <span data-ttu-id="ad3d8-3291">부분 문자열은 지정된 문자 위치에서 시작하고 길이도 지정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3291">The substring starts at a specified character position and has a specified length.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3292">이 인스턴스의 <paramref name="length" />에서 시작하는 <paramref name="startIndex" /> 길이의 부분 문자열에 해당하는 문자열이거나, <see cref="F:System.String.Empty" />가 이 인스턴스의 길이와 같고 <paramref name="startIndex" />가 0이면 <paramref name="length" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3292">A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3293">호출 하는 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드를 지정된 된 문자 위치에서 시작 하 고 문자열의 끝 이전 끝나는 문자열에서 하위 문자열을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3293">You call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</span></span> <span data-ttu-id="ad3d8-3294">시작 문자 위치는 0부터 시작 합니다. 즉, 문자열에서 첫 번째 문자는 인덱스 0, 1 인덱싱하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3294">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="ad3d8-3295">지정 된 문자 위치에서 시작 하는 문자열의 끝으로 계속 하는 부분 문자열을 추출 하려면 호출 된 <xref:System.String.Substring%28System.Int32%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3295">To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3296">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3296">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3297">대신,을 갖는 새 문자열을 반환 `length` 부터 문자는 `startIndex` 현재 문자열의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3297">Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="ad3d8-3298">`length` 매개 변수는 현재 문자열 인스턴스에서 추출할 문자의 총 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3298">The `length` parameter represents the total number of characters to extract from the current string instance.</span></span> <span data-ttu-id="ad3d8-3299">인덱스에서 시작 문자가 여기에 `startIndex`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3299">This includes the starting character found at index  `startIndex`.</span></span>  <span data-ttu-id="ad3d8-3300">즉,는 <xref:System.String.Substring%2A> 메서드 인덱스에서 문자를 추출 하려고 `startIndex` 인덱스로 `startIndex`  +  `length` -1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3300">In other words, the <xref:System.String.Substring%2A> method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.</span></span>  
  
 <span data-ttu-id="ad3d8-3301">특정 문자 또는 문자 시퀀스와 시작 하는 부분 문자열을 추출 하려면 메서드를와 같은 호출 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.LastIndexOf%2A> 의 값을 가져오는 `startIndex`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3301">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.</span></span>  
  
 <span data-ttu-id="ad3d8-3302">부분 문자열에서 확장 되 면 `startIndex` 지정 된 문자 시퀀스를 있습니다 메서드를 호출할 수와 같은 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.LastIndexOf%2A> 끝 문자 또는 문자 시퀀스의 인덱스를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3302">If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.</span></span>  <span data-ttu-id="ad3d8-3303">변환할 수 있습니다 다음 해당 값 문자열의 인덱스 위치를 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3303">You can then convert that value to an index position in the string as follows:</span></span>  
  
-   <span data-ttu-id="ad3d8-3304">부분 문자열의 끝을 표시 하는 단일 문자에 대 한 검색 하는 경우는 `length` 매개 변수와 같으면 `endIndex`  -  `startIndex` + 1, 여기서 `endIndex` 의 반환 값은 고 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3304">If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ad3d8-3305">다음 예제에서는 문자열에서 "b" 문자는 연속 된 블록을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3305">The following example extracts a continuous block of "b" characters from a string.</span></span>  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   <span data-ttu-id="ad3d8-3306">부분 문자열의 끝을 표시 하는 여러 문자에 대 한 검색 하는 경우는 `length` 매개 변수와 같으면 `endIndex`  +  `endMatchLength`  -  `startIndex`여기서 `endIndex` 는 의반환값은<xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다. 및 `endMatchLength` 부분 문자열의 끝을 표시 하는 문자 시퀀스의 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3306">If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method., and `endMatchLength` is the length of the character sequence that marks the end of the substring.</span></span> <span data-ttu-id="ad3d8-3307">다음 예제는 XML이 포함 된 텍스트 블록을 추출 `<definition>` 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3307">The following example extracts a block of text that contains an XML `<definition>` element.</span></span>  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   <span data-ttu-id="ad3d8-3308">문자 또는 문자 시퀀스는 문자열의 끝에 포함 되지 않은 경우는 `length` 매개 변수와 같으면 `endIndex`  -  `startIndex`여기서 `endIndex` 의 반환 값이 고 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3308">If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span>  
  
 <span data-ttu-id="ad3d8-3309">경우 `startIndex` 0와 equals 메서드는 현재 문자열의 길이 변경 하지 않고 원래 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3309">If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3310">다음 예제에 대 한 간단한 호출은 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 여섯 번째 문자 위치에서 시작 하는 문자열에서 두 개의 문자를 추출 하는 메서드 (즉, 인덱스에 포함 된 5).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3310">The following example illustrates a simple call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</span></span>  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 <span data-ttu-id="ad3d8-3311">다음 예제에서는 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드 다음 세 가지 경우 문자열 내에서 부분 문자열을 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3311">The following example uses the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method in the following three cases to isolate substrings within a string.</span></span> <span data-ttu-id="ad3d8-3312">두 가지 경우에는 부분 문자열을 비교에 사용 하 고 잘못 된 매개 변수를 지정 하기 때문에 세 번째 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3312">In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</span></span>  
  
-   <span data-ttu-id="ad3d8-3313">단일 문자 및 문자열 (인덱스 2)에서 세 번째 위치를 추출 하 고 "c"와 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3313">It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</span></span> <span data-ttu-id="ad3d8-3314">이 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3314">This comparison returns `true`.</span></span>  
  
-   <span data-ttu-id="ad3d8-3315">문자열 (인덱스 3)에서 네 번째 위치에서 시작 하는 0 개 문자를 추출 하 고에 전달 된 <xref:System.String.IsNullOrEmpty%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3315">It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method.</span></span> <span data-ttu-id="ad3d8-3316">이 true를 반환 하기 때문에에 대 한 호출에서 <xref:System.String.Substring%2A> 메서드 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3316">This returns true because the call to the <xref:System.String.Substring%2A> method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ad3d8-3317">문자열에서 네 번째 위치에서 시작 하는 한 문자를 추출 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3317">It attempts to extract one character starting at the fourth position in the string.</span></span> <span data-ttu-id="ad3d8-3318">해당 위치에서 문자가 있기 때문에 메서드 호출에서 throw 한 <xref:System.ArgumentOutOfRangeException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3318">Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.</span></span>  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ad3d8-3319">다음 예제에서는 <xref:System.String.Substring%2A> 같음 구분 되는 키/값 쌍을 구분 하는 메서드 문자 ("=").</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3319">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="ad3d8-3320"><xref:System.String.IndexOf%2A> 메서드 문자열에 equals 문자의 위치를 가져오는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3320">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string..</span></span> <span data-ttu-id="ad3d8-3321">에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드 추출은 키 이름이 없습니다., 문자열의 첫 번째 문자에서 시작 하 고에 대 한 호출에서 반환 된 문자 수에 대 한 확장 하는 <xref:System.String.IndexOf%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3321">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ad3d8-3322">에 대 한 호출에서 <xref:System.String.Substring%28System.Int32%29> 메서드는 키에 할당 된 값을 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3322">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="ad3d8-3323">Equals 문자 뒤에 있는 한 문자 위치에서 시작 하 고 문자열의 끝까지 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3323">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-3324"><paramref name="startIndex" /> + <paramref name="length" />는 문자 위치가 이 인스턴스 안에 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3324"><paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.</span></span>  
  
 <span data-ttu-id="ad3d8-3325">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3325">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-3326"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3326"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3327">현재 <see cref="T:System.String" /> 개체를 반복하는 열거자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3327">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3328">현재 <see cref="T:System.String" /> 개체를 반복하는 데 사용할 수 있는 강력한 형식의 열거자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3328">A strongly-typed enumerator that can be used to iterate through the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3329">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3329">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3330">사용할 수 있습니다 경우에만 <xref:System.String> 인스턴스로 캐스팅 되는 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3330">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface object.</span></span> <span data-ttu-id="ad3d8-3331">자세한 내용은 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3331">For more information, see the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3332">현재 <see cref="T:System.String" /> 개체를 반복하는 열거자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3332">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3333">현재 문자열을 반복하는 데 사용할 수 있는 열거자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3333">An enumerator that can be used to iterate through the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3334">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3334">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3335"><xref:System.String> 인스턴스가 <xref:System.Collections.IEnumerable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3335">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="ad3d8-3336">자세한 내용은 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3336">For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3337">이 매개 변수는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3337">This parameter is ignored.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3338">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3338">For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span></span></summary>
        <returns>
          <span data-ttu-id="ad3d8-3339">현재 문자열의 값이 <see langword="true" />이면 <see cref="F:System.Boolean.TrueString" />이고, 현재 문자열의 값이 <see langword="false" />이면 <see cref="F:System.Boolean.FalseString" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3339"><see langword="true" /> if the value of the current string is <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3340">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3340">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3341"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3341">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3342">메서드 대신 호출 하는 것은 <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3342">The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3343">현재 문자열의 값은 <see cref="F:System.Boolean.TrueString" /> 또는 <see cref="F:System.Boolean.FalseString" />이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3343">The value of the current string is not <see cref="F:System.Boolean.TrueString" /> or <see cref="F:System.Boolean.FalseString" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3344">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3344">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3345">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3345">For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3346">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3346">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3347">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3347">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3348"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3348">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3349">메서드 대신 호출 하는 것은 <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3349">The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3350">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3350">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ad3d8-3351">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Byte.MaxValue" />보다 크거나 <see cref="F:System.Byte.MinValue" />보다 작은 수인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3351">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3352">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3352">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3353">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3353">For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3354">현재 <see cref="T:System.String" /> 개체의 인덱스 0에 있는 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3354">The character at index 0 in the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3355">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3355">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3356"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3356">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3357">메서드 대신 호출 하는 것은 <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3357">The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3358">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3358">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3359">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3359">For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3360">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3360">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3361">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3361">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3362"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3362">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3363">메서드 대신 호출 하는 것은 <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3363">The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3364">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3364">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3365">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3365">For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3366">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3366">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3367">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3367">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3368"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3368">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3369">메서드 대신 호출 하는 것은 <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3369">The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3370">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3370">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ad3d8-3371">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Decimal.MinValue" />보다 작거나 <see cref="F:System.Decimal.MaxValue" />보다 큰 수인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3371">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3372">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3372">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3373">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3373">For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3374">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3374">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3375">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3375">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3376"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3376">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3377">메서드 대신 호출 하는 것은 <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3377">The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3378">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3378">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ad3d8-3379">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 수인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3379">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3380">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3380">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3381">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3381">For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3382">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3382">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3383">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3383">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3384"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3384">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3385">메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3385">The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3386">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3386">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ad3d8-3387">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Int16.MaxValue" />보다 크거나 <see cref="F:System.Int16.MinValue" />보다 작은 수인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3387">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3388">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3388">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3389">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3389">For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3390">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3390">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3391">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3391">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3392"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3392">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3393">메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3393">The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3394">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3394">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3395">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3395">For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3396">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3396">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3397">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3397">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3398"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3398">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3399">메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3399">The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3400">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3400">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3401">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3401">For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3402">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3402">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3403">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3403">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3404"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3404">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3405">메서드 대신 호출 하는 것은 <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3405">The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3406">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3406">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ad3d8-3407">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.SByte.MaxValue" />보다 크거나 <see cref="F:System.SByte.MinValue" />보다 작은 수인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3407">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3408">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3408">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3409">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3409">For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3410">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3410">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3411">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3411">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3412"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3412">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3413">메서드 대신 호출 하는 것은 <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3413">The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="ad3d8-3414">반환되는 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3414">The type of the returned object.</span></span></param>
        <param name="provider"><span data-ttu-id="ad3d8-3415">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3415">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3416">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3416">For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3417">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3417">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3418">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3418">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3419"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3419">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3420">메서드 대신 호출 하는 것은 <xref:System.Convert.ChangeType%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3420">The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-3421"><paramref name="type" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3421"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="ad3d8-3422">현재 <see cref="T:System.String" /> 개체의 값을 <paramref name="type" /> 매개 변수로 지정된 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3422">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3423">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3423">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3424">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3424">For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3425">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3425">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3426">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3426">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3427"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3427">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3428">메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3428">The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3429">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3429">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ad3d8-3430">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.UInt16.MaxValue" />보다 크거나 <see cref="F:System.UInt16.MinValue" />보다 작은 수인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3430">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3431">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3431">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3432">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3432">For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3433">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3433">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3434">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3434">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3435"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3435">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3436">메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3436">The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ad3d8-3437">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3437">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ad3d8-3438">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.UInt32.MaxValue" />보다 크거나 <see cref="F:System.UInt32.MinValue" />보다 작은 수인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3438">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3439">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3439">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3440">이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3440">For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3441">현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3441">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3442">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3442">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ad3d8-3443"><xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3443">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ad3d8-3444">메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3444">The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-3445">이 인스턴스의 문자를 유니코드 문자 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3445">Copies the characters in this instance to a Unicode character array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3446">이 인스턴스의 문자를 유니코드 문자 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3446">Copies the characters in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3447">해당 요소가 이 인스턴스의 각 문자로 이루어진 유니코드 문자 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3447">A Unicode character array whose elements are the individual characters of this instance.</span></span> <span data-ttu-id="ad3d8-3448">이 인스턴스가 빈 문자열이면 반환된 배열은 길이가 0인 빈 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3448">If this instance is an empty string, the returned array is empty and has a zero length.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3449">이 메서드는 각 문자를 복사 (즉, 각 <xref:System.Char> 개체) 문자열에 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3449">This method copies each character (that is, each <xref:System.Char> object) in a string to a character array.</span></span> <span data-ttu-id="ad3d8-3450">반환 된 문자 배열의; 인덱스 0에 복사 하는 첫 번째 문자는 인덱스에 복사 하는 마지막 문자는 <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3450">The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.</span></span>  
  
 <span data-ttu-id="ad3d8-3451">문자열에서 문자 배열에 있는 문자를 만들려면 호출의 <xref:System.String.%23ctor%28System.Char%5B%5D%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3451">To create a string from the characters in a character array, call the <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.</span></span>  
  
 <span data-ttu-id="ad3d8-3452">문자열에 인코딩된 문자를 포함 하는 바이트 배열을 만들려면 적절 한 인스턴스화할 <xref:System.Text.Encoding> 개체와 호출 해당 <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3452">To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ad3d8-3453">.NET Framework에서 사용할 수 있는 표준 인코딩 중 일부는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3453">Some of the standard encodings available in the .NET Framework include the following:</span></span>  
  
|<span data-ttu-id="ad3d8-3454">인코딩</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3454">Encoding</span></span>|<span data-ttu-id="ad3d8-3455">Object</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3455">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="ad3d8-3456">ASCII</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3456">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="ad3d8-3457">UTF-7</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3457">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="ad3d8-3458">UTF-8</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3458">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="ad3d8-3459">UTF-16</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3459">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="ad3d8-3460">UTF-32</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3460">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="ad3d8-3461">자세한 내용은 참조 [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3461">For more information, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3462">다음 예제에서는 <xref:System.String.ToCharArray%2A> 메서드 문자열 문자 배열에 문자를 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3462">The following example calls the <xref:System.String.ToCharArray%2A> method to extract the characters in a string to a character array.</span></span> <span data-ttu-id="ad3d8-3463">다음 배열에는 원래 문자열과 요소 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3463">It then displays the original string and the elements in the array.</span></span>  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 <span data-ttu-id="ad3d8-3464">다음 예제는 구분 기호로 분리 된 문자열에 구분 기호로 사용 되는 문자를 포함 하는 문자열을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3464">The following example defines a string containing the characters that serve as delimiters in a delimited string.</span></span> <span data-ttu-id="ad3d8-3465">그런 다음 호출 하는 <xref:System.String.ToCharArray%2A> 에 전달 될 수 있는 문자 배열을 만들려면 메서드는 <xref:System.String.Split%28System.Char%5B%5D%29> 해당 개별 부분 문자열로 구분된 된 문자열을 구분 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3465">It then calls the <xref:System.String.ToCharArray%2A> method to create a character array that can be passed to the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate the delimited string into its individual substrings.</span></span>  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ad3d8-3466">이 인스턴스에 있는 부분 문자열의 시작 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3466">The starting position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="ad3d8-3467">이 인스턴스에 있는 부분 문자열의 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3467">The length of the substring in this instance.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3468">이 인스턴스의 지정된 부분 문자열에 있는 문자를 유니코드 문자 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3468">Copies the characters in a specified substring in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3469">해당 요소가 이 인스턴스의 <paramref name="length" /> 문자 위치부터 <paramref name="startIndex" /> 개의 문자로 이루어진 유니코드 문자 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3469">A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3470">이 메서드는 문자 배열에는 문자열의 부분에는 문자를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3470">This method copies the characters in a portion of a string to a character array.</span></span> <span data-ttu-id="ad3d8-3471">문자열에서 문자 배열의 문자 범위를 만들려면 호출의 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3471">To create a string from a range of characters in a character array, call the  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="ad3d8-3472">`startIndex` 매개 변수는 0부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3472">The `startIndex` parameter is zero-based.</span></span> <span data-ttu-id="ad3d8-3473">즉, 문자열 인스턴스에서 첫 번째 문자의 인덱스는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3473">That is, the index of the first character in the string instance is zero.</span></span>  
  
 <span data-ttu-id="ad3d8-3474">경우 `length` 가 0 이면 반환 된 배열은 비어 있고 길이가 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3474">If `length` is zero, the returned array is empty and has a zero length.</span></span> <span data-ttu-id="ad3d8-3475">이 인스턴스가 `null` 또는 빈 문자열 (""), 반환 된 배열은 비어 있고 길이가 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3475">If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.</span></span>  
  
 <span data-ttu-id="ad3d8-3476">문자열의 일부에 인코딩된 문자를 포함 하는 바이트 배열을 만들려면 적절 한 인스턴스화할 <xref:System.Text.Encoding> 개체와 호출 해당 <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3476">To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ad3d8-3477">.NET Framework에서 사용할 수 있는 표준 인코딩 중 일부는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3477">Some of the standard encodings available in the .NET Framework include the following:</span></span>  
  
|<span data-ttu-id="ad3d8-3478">인코딩</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3478">Encoding</span></span>|<span data-ttu-id="ad3d8-3479">Object</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3479">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="ad3d8-3480">ASCII</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3480">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="ad3d8-3481">UTF-7</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3481">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="ad3d8-3482">UTF-8</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3482">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="ad3d8-3483">UTF-16</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3483">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="ad3d8-3484">UTF-32</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3484">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="ad3d8-3485">자세한 내용은 참조 [.NET Framework의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3485">For more information, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3486">다음 예제에서는 문자열에 부분 문자열을 문자 배열로 변환 다음 열거 하 고 배열의 요소를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3486">The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</span></span>  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ad3d8-3487"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3487"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="ad3d8-3488">또는</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3488">-or-</span></span>  
  
 <span data-ttu-id="ad3d8-3489"><paramref name="startIndex" />와 <paramref name="length" />의 합이 이 인스턴스의 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3489"><paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-3490">이 문자열의 복사본을 소문자로 변환하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3490">Returns a copy of this string converted to lowercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3491">이 문자열의 복사본을 소문자로 변환하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3491">Returns a copy of this string converted to lowercase.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3492">소문자 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3492">A string in lowercase.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3493">이 메서드는 현재 문화권의 대/소문자 규칙을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3493">This method takes into account the casing rules of the current culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3494">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3494">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3495">대신,는 현재 인스턴스의 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3495">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ad3d8-3496">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3496">Security Considerations</span></span>  
 <span data-ttu-id="ad3d8-3497">대/소문자 구분 작업 호출의 결과로 생성 되는 <xref:System.String.ToLower> 메서드는 현재 문화권의 대/소문자 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3497">The casing operation that results from calling the <xref:System.String.ToLower> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="ad3d8-3498">파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3498">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span> <span data-ttu-id="ad3d8-3499">모든 문화권에서 동일한 결과 (달리는 <xref:System.String.ToLower> 메서드) 하 고 보다 효율적으로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3499">This produces the same result in every culture (unlike the <xref:System.String.ToLower> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3500">다음 예제에서는 소문자가 혼합된 되어 있는 여러 문자열 소문자로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3500">The following example converts several mixed case strings to lowercase.</span></span>  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3501">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 대/소문자 구분 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3501">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-3502">문자를 현재 문화권의 대/소문자 규칙을 사용 하 여 소문자로 변환할 호출는 <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> 메서드 오버 로드의 값을 가진 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 에 대 한 해당 <paramref name="culture" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3502">To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ad3d8-3503">문화권별 대/소문자 규칙을 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3503">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3504">지정한 문화권의 대/소문자 규칙을 사용하여 소문자로 변환된 이 문자열의 복사본을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3504">Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3505">소문자로 표시된 현재 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3505">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3506">에 지정 된 문화권의 대/소문자 규칙은 `culture` 매개 변수 변경 되는 문자열의 대/소문자 방식을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3506">The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3507">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3507">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3508">대신,는 현재 인스턴스의 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3508">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ad3d8-3509">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3509">Security Considerations</span></span>  
 <span data-ttu-id="ad3d8-3510">전달 하는 경우는 <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> 메서드는 <xref:System.Globalization.CultureInfo> 이외의 개체 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, 대/소문자 구분 작업 계정에는 culture 별 규칙 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3510">If you pass the <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="ad3d8-3511">파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3511">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ad3d8-3512">이 모든 문화권에서 동일한 결과 생성 하 고 보다 효율적으로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3512">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3513">다음 예제에서는 두 문자열의 대문자를 영어-미국 및 터키어-터키 문화권을 사용 하 여 문자를 소문자로 변환한 다음 소문자 문자열을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3513">The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</span></span> <span data-ttu-id="ad3d8-3514">제외 하는 유니코드 LATIN CAPITAL LETTER I 한 문자열에서 발생할 때마다, LATIN CAPITAL LETTER I와 점 위에 포함 하는 다른 문자열 대문자 문자열과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3514">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-3515"><paramref name="culture" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3515"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3516">고정 문화권의 대/소문자 규칙을 사용하여 소문자로 변환된 이 <see cref="T:System.String" /> 개체의 복사본을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3516">Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3517">소문자로 표시된 현재 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3517">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3518">고정 문화권을 문화권을 구분 하지 않으므로 하는 culture를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3518">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="ad3d8-3519">연결 된 영어 있고 특정 국가 또는 지역을 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3519">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="ad3d8-3520">자세한 내용은 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3520">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ad3d8-3521">응용 프로그램이 사용 하 여 현재 문화권에 따라 영향을 받지 않는 예측 가능한 방식으로 변경 하는 문자열의 대/소문자에 따라 달라 지는 <xref:System.String.ToLowerInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3521">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToLowerInvariant%2A> method.</span></span> <span data-ttu-id="ad3d8-3522"><xref:System.String.ToLowerInvariant%2A> 메서드 `ToLower(CultureInfo.InvariantCulture)`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3522">The <xref:System.String.ToLowerInvariant%2A> method is equivalent to `ToLower(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="ad3d8-3523">문자열 컬렉션을 사용자 인터페이스 컨트롤에 예측 가능한 순서로 나타나야 하는 경우 메서드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3523">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3524">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3524">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3525">대신,는 현재 인스턴스의 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3525">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ad3d8-3526">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3526">Security Considerations</span></span>  
 <span data-ttu-id="ad3d8-3527">파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3527">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3528">다음 예제에서는 다양 한 언어에서에서 한 단어를 포함 하는 문자열 배열을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3528">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="ad3d8-3529"><xref:System.String.ToLowerInvariant%2A> 메서드 각 단어의 대/소문자 구분 버전과 병렬 배열의 요소를 채우는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3529">The <xref:System.String.ToLowerInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="ad3d8-3530"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 배열을 정렬 하 여 대/소문자 구분 요소 언어에 관계 없이 동일한 순서로 표시 되도록 소문자 배열의 요소 순서를 기반으로 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3530">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-3531">이 인스턴스의 값을 <see cref="T:System.String" />으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3531">Converts the value of this instance to a <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3532"><see cref="T:System.String" />의 이 인스턴스를 반환하며, 이때 실제 변환은 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3532">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3533">현재 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3533">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3534">이 메서드는 단순히 변경 하지 않고 현재 문자열 반환 되므로 직접 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3534">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span> <span data-ttu-id="ad3d8-3535">합성 형식 지정의 예제와 같이 작업에에서는 암시적으로 호출 일반적으로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3535">It is usually called implicitly in a composite formatting operation, as the example shows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3536">다음 예제는 <xref:System.String.ToString%2A> 메서드. 이 예제에서는 명시적으로 호출 하지 않는 참고는 <xref:System.String.ToString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3536">The following example demonstrates the <xref:System.String.ToString%2A> method.Note that the example does not explicitly call the <xref:System.String.ToString%2A> method.</span></span> <span data-ttu-id="ad3d8-3537">대신 메서드가 의해 암시적으로 호출 됩니다는 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3537">Instead, the method is called implicitly by the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature.</span></span>  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ad3d8-3538">(예약됨) 문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3538">(Reserved) An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3539"><see cref="T:System.String" />의 이 인스턴스를 반환하며, 이때 실제 변환은 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3539">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3540">현재 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3540">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3541">`provider` 예약 되며이 작업에 관여 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3541">`provider` is reserved, and does not currently participate in this operation.</span></span>  
  
 <span data-ttu-id="ad3d8-3542">이 메서드는 단순히 변경 하지 않고 현재 문자열 반환 되므로 직접 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3542">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-3543">이 문자열의 복사본을 대문자로 변환하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3543">Returns a copy of this string converted to uppercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3544">이 문자열의 복사본을 대문자로 변환하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3544">Returns a copy of this string converted to uppercase.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3545">대문자로 표시된 현재 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3545">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3546">이 메서드는 현재 인스턴스에 있는 각 문자를 해당 대문자로 변환 하는 현재 문화권의 대/소문자 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3546">This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</span></span> <span data-ttu-id="ad3d8-3547">문자에 해당 하는 대문자 이거나 없는 경우 포함 되었습니다 반환 된 문자열에서 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3547">If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3548">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3548">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3549">대신,는 현재 인스턴스의 모든 문자는 대문자로 변환 하는 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3549">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
 <span data-ttu-id="ad3d8-3550"><xref:System.String.ToUpper%2A> 메서드는 대/소문자 비구분 비교에 사용할 수 있도록 문자열을 대문자로 변환 하는 데 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3550">The <xref:System.String.ToUpper%2A> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</span></span> <span data-ttu-id="ad3d8-3551">대/소문자 구분 비교를 수행 하는 향상 된 방법을 변수가 있는 문자열 비교 메서드를 호출 하는 것을 <xref:System.StringComparison> 매개 변수 값으로 설정 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> 문화권을 구분, 대/소문자 비구분 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3551">A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> for a culture-sensitive, case-insensitive comparison.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ad3d8-3552">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3552">Security Considerations</span></span>  
 <span data-ttu-id="ad3d8-3553">대/소문자 구분 작업 호출의 결과로 생성 되는 <xref:System.String.ToUpper> 메서드는 현재 문화권의 대/소문자 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3553">The casing operation that results from calling the <xref:System.String.ToUpper> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="ad3d8-3554">파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3554">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ad3d8-3555">모든 문화권에서 동일한 결과 (달리는 <xref:System.String.ToUpper> 메서드) 하 고 보다 효율적으로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3555">This produces the same result in every culture (unlike the <xref:System.String.ToUpper> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3556">다음 예제에서는 <xref:System.String.ToUpper%2A> 일련의 기본 라틴, 라틴어-1 추가 및 라틴 문자 확장 A 문자 집합의 각 문자를 포함 하는 한 문자로 문자열을 변환 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3556">The following example calls the <xref:System.String.ToUpper%2A> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</span></span> <span data-ttu-id="ad3d8-3557">대문자 문자는 소문자와에서 다른 각 문자열을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3557">It then displays each string whose uppercase character is different from its lowercase character.</span></span>  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3558">에 설명 된 대로 [문자열 사용에 대 한 유용한](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 대/소문자 구분 메서드를 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3558">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ad3d8-3559">문자열을 현재 문화권의 대/소문자 규칙을 사용 하 여 대문자로 변환할 호출는 <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> 메서드 오버 로드의 값을 가진 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 에 대 한 해당 <paramref name="culture" /> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3559">To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ad3d8-3560">문화권별 대/소문자 규칙을 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3560">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3561">지정한 문화권의 대/소문자 규칙을 사용하여 대문자로 변환된 이 문자열의 복사본을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3561">Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3562">대문자로 표시된 현재 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3562">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3563">에 지정 된 문화권의 대/소문자 규칙은 `culture` 매개 변수 변경 되는 문자열의 대/소문자 방식을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3563">The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3564">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3564">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3565">대신,는 현재 인스턴스의 모든 문자는 대문자로 변환 하는 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3565">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ad3d8-3566">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3566">Security Considerations</span></span>  
 <span data-ttu-id="ad3d8-3567">전달 하는 경우는 <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> 메서드는 <xref:System.Globalization.CultureInfo> 이외의 개체 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, 대/소문자 구분 작업 계정에는 culture 별 규칙 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3567">If you pass the <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="ad3d8-3568">파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3568">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ad3d8-3569">이 모든 문화권에서 동일한 결과 생성 하 고 보다 효율적으로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3569">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3570">다음 예제에서는 두 개의 대문자, 영어-미국 및 터키어-터키 문화권을 사용 하 여 문자열을 소문자 문자열로 변환한 다음 대문자 문자열을 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3570">The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</span></span> <span data-ttu-id="ad3d8-3571">제외 하는 유니코드 LATIN CAPITAL LETTER I 한 문자열에서 발생할 때마다, LATIN CAPITAL LETTER I와 점 위에 포함 하는 다른 문자열 대문자 문자열과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3571">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ad3d8-3572"><paramref name="culture" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3572"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3573">고정 문화권의 대/소문자 규칙을 사용하여 대문자로 변환된 이 <see cref="T:System.String" /> 개체의 복사본을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3573">Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3574">대문자로 표시된 현재 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3574">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3575">고정 문화권을 문화권을 구분 하지 않으므로 하는 culture를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3575">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="ad3d8-3576">연결 된 영어 있고 특정 국가 또는 지역을 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3576">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="ad3d8-3577">자세한 내용은 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3577">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ad3d8-3578">응용 프로그램이 사용 하 여 현재 문화권에 따라 영향을 받지 않는 예측 가능한 방식으로 변경 하는 문자열의 대/소문자에 따라 달라 지는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3578">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ad3d8-3579"><xref:System.String.ToUpperInvariant%2A> 메서드 `ToUpper(CultureInfo.InvariantCulture)`합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3579">The <xref:System.String.ToUpperInvariant%2A> method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="ad3d8-3580">문자열 컬렉션을 사용자 인터페이스 컨트롤에 예측 가능한 순서로 나타나야 하는 경우 메서드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3580">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3581">이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3581">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3582">대신,는 현재 인스턴스의 모든 문자는 대문자로 변환 하는 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3582">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ad3d8-3583">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3583">Security Considerations</span></span>  
 <span data-ttu-id="ad3d8-3584">파일 이름 같은 운영 체제 식별자의 대 / 소문자 버전이 필요한 경우 명명 된 파이프 또는 레지스트리 키를 사용은 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3584">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3585">다음 예제에서는 다양 한 언어에서에서 한 단어를 포함 하는 문자열 배열을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3585">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="ad3d8-3586"><xref:System.String.ToUpperInvariant%2A> 메서드 각 단어의 대/소문자 구분 버전과 병렬 배열의 요소를 채우는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3586">The <xref:System.String.ToUpperInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="ad3d8-3587"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 배열을 정렬 하 여 대/소문자 구분 요소 언어에 관계 없이 동일한 순서로 표시 되도록 대문자 배열의 요소 순서를 기반으로 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3587">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ad3d8-3588">현재 <see cref="T:System.String" /> 개체에서 지정된 문자 집합의 선행 항목과 후행 항목이 모두 제거되는 새 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3588">Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <see cref="T:System.String" /> object are removed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ad3d8-3589">현재 <see cref="T:System.String" /> 개체에서 선행 공백과 후행 공백을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3589">Removes all leading and trailing white-space characters from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3590">모든 공백 뒤에 있는 문자열이 현재 문자열의 시작 부분과 끝 부분에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3590">The string that remains after all white-space characters are removed from the start and end of the current string.</span></span> <span data-ttu-id="ad3d8-3591">현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3591">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3592"><xref:System.String.Trim%2A> 메서드 모든 선행 및 후행 공백 문자는 현재 문자열에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3592">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing white-space characters.</span></span> <span data-ttu-id="ad3d8-3593">공백이 아닌 문자가 발견 되는 각 선행 및 후행 지우기 작업이 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3593">Each leading and trailing trim operation stops when a non-white-space character is encountered.</span></span> <span data-ttu-id="ad3d8-3594">예를 들어, 현재 문자열 "abc xyz"는 <xref:System.String.Trim%2A> 메서드는 "abc xyz"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3594">For example, if the current string is "   abc   xyz   ", the <xref:System.String.Trim%2A> method returns "abc   xyz".</span></span> <span data-ttu-id="ad3d8-3595">사용 하 여 문자열에서 단어 사이 공백 문자를 제거 하려면 한 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3595">To remove white-space characters between words in a string, use a [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3596">경우는 <xref:System.String.Trim%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3596">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3597">대신,는 현재 인스턴스에서 모든 선행 및 후행 공백 문자가 제거 됩니다는 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3597">Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="ad3d8-3598">현재 문자열 절과 같을 경우 <xref:System.String.Empty> 메서드 반환 현재 인스턴스에 있는 모든 문자가 공백 문자로 구성 또는 <xref:System.String.Empty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3598">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ad3d8-3599">공백 문자는 유니코드 표준에서 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3599">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="ad3d8-3600"><xref:System.String.Trim> 메서드 반환 값을 생성 하는 선행 및 후행 문자 제거 `true` 에 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3600">The <xref:System.String.Trim> method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3601">다음 예제에서는 <xref:System.String.Trim?displayProperty=nameWithType> 메서드를 연결 하기 전에 사용자가 입력 문자열에서 모든 추가 공백을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3601">The following example uses the <xref:System.String.Trim?displayProperty=nameWithType> method to remove any extra white space from strings entered by the user before concatenating them.</span></span>  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3602">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전에이 메서드를 삭제 합니다. 공백 문자의 내부 목록을 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3602">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims.</span></span> <span data-ttu-id="ad3d8-3603">부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 메서드가 모든 유니코드 공백 문자를 삭제 합니다. (즉, 생성 하는 문자는 <see langword="true" /> 반환 값에 전달 될 때는 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3603">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ad3d8-3604">이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]이상 버전을 수행 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3604">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="ad3d8-3605">또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3605">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ad3d8-3606">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3606">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3607">현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 선행 항목과 후행 항목을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3607">Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3608"><paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 시작 부분과 끝 부분에서 모두 제거된 후 남아 있는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3608">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string.</span></span> <span data-ttu-id="ad3d8-3609"><paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 공백 문자가 대신 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3609">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="ad3d8-3610">현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3610">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3611"><xref:System.String.Trim%2A> 메서드는 현재 문자열에서 선행 및 후행 문자를 모두 제거에 `trimChars` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3611">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ad3d8-3612">각 선행 및 후행 지우기 작업이 중지 중이 아닌 문자가 `trimChars` 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3612">Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="ad3d8-3613">예를 들어, 현재 문자열은 "123abc456xyz789" 및 `trimChars` "9", "1"에서 숫자가 포함 되어는 <xref:System.String.Trim%2A> 메서드 "abc456xyz"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3613">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.Trim%2A> method returns "abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3614">경우는 <xref:System.String.Trim%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3614">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3615">대신, 새 문자열을 모두에서 반환 선행 및 후행 `trimChars` 현재 인스턴스에서 문자가 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3615">Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="ad3d8-3616">현재 문자열 절과 같을 경우 <xref:System.String.Empty> 문자로 구성 된 현재 인스턴스의 모든 문자가 또는 `trimChars` 메서드 반환 배열 <xref:System.String.Empty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3616">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ad3d8-3617">경우 `trimChars` 은 `null` 빈 배열이 면이 메서드를 반환 하는 메서드에에서 발생 하는 선행 또는 후행 문자 제거 또는 `true` 에 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3617">If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method,</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3618">다음 예제에서는 <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드를 공간, 별표 (\*) 및 아포스트로피 (') 문자는 문자열에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3618">The following example uses the <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> method to remove space, asterisk (\*), and apostrophe (') characters from a string.</span></span>  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3619">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전의 경우 삭제 합니다.이 메서드는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 은 <see langword="null" /> 이거나 빈 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3619">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ad3d8-3620">부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]경우 <paramref name="trimChars" /> 은 <see langword="null" /> 또는 빈 배열인 경우 메서드는 모든 유니코드 공백 문자 (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 값을 반환는 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3620">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ad3d8-3621">이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]이상 버전을 수행 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3621">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="ad3d8-3622">또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3622">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ad3d8-3623">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3623">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3624">현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 후행 항목을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3624">Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3625"><paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 끝 부분에서 모두 제거된 후 남아 있는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3625">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string.</span></span> <span data-ttu-id="ad3d8-3626"><paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 유니코드 공백 문자가 대신 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3626">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead.</span></span> <span data-ttu-id="ad3d8-3627">현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3627">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3628"><xref:System.String.TrimEnd%2A> 메서드에 있는 모든 후행 문자가 현재 문자열에서 제거 된 `trimChars` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3628">The <xref:System.String.TrimEnd%2A> method removes from the current string all trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ad3d8-3629">첫 번째 문자에 있지 않은 지우기 작업이 중지 `trimChars` 문자열의 끝에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3629">The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string.</span></span> <span data-ttu-id="ad3d8-3630">예를 들어, 현재 문자열은 "123abc456xyz789" 및 `trimChars` "9", "1"에서 숫자가 포함 되어는 <xref:System.String.TrimEnd%2A> 메서드 "123abc456xyz"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3630">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimEnd%2A> method returns "123abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3631">경우는 <xref:System.String.TrimEnd%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3631">If the <xref:System.String.TrimEnd%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3632">대신, 새 문자열에 있는 모든 후행 문자에 반환 `trimChars` 는 현재 문자열에서 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3632">Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3633">다음 예제에서는 사용 하는 방법을 보여 줍니다.는 <xref:System.String.TrimEnd%28System.Char%5B%5D%29> 메서드 공백 또는 문장 부호는 문자열의 끝에서 지울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3633">The following example demonstrates how you can use the <xref:System.String.TrimEnd%28System.Char%5B%5D%29> method to trim white space or punctuation marks from the end of a string.</span></span>  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3634">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전의 경우 삭제 합니다.이 메서드는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 은 <see langword="null" /> 이거나 빈 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3634">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ad3d8-3635">부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]경우 <paramref name="trimChars" /> 은 <see langword="null" /> 또는 빈 배열인 경우 메서드는 모든 유니코드 공백 문자 (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 값을 반환는 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3635">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ad3d8-3636">이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 이상 버전을 수행 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3636">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="ad3d8-3637">또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3637">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ad3d8-3638">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3638">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ad3d8-3639">현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 선행 항목을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3639">Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ad3d8-3640"><paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 시작 부분에서 모두 제거된 후 남아 있는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3640">The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string.</span></span> <span data-ttu-id="ad3d8-3641"><paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 공백 문자가 대신 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3641">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ad3d8-3642"><xref:System.String.TrimStart%2A> 메서드에 있던 모든 선행 문자가 현재 문자열에서 제거 된 `trimChars` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3642">The <xref:System.String.TrimStart%2A> method removes from the current string all leading characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ad3d8-3643">지우기 작업이 중지 중이 아닌 문자가 `trimChars` 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3643">The trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="ad3d8-3644">예를 들어, 현재 문자열은 "123abc456xyz789" 및 `trimChars` "9", "1"에서 숫자가 포함 되어는 <xref:System.String.TrimStart%2A> 메서드 "abc456xyz789"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3644">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimStart%2A> method returns "abc456xyz789".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ad3d8-3645">경우는 <xref:System.String.TrimStart%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3645">If the <xref:System.String.TrimStart%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ad3d8-3646">대신, 현재 인스턴스 선행 공백 문자를 모두 제거 됩니다는 새 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3646">Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ad3d8-3647">다음 예제에서는 <xref:System.String.TrimStart%2A> 메서드는 소스 코드 줄에서 주석 문자 및 공백을 지울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3647">The following example uses the <xref:System.String.TrimStart%2A> method to trim white space and comment characters from lines of source code.</span></span> <span data-ttu-id="ad3d8-3648">`StripComments` 메서드 호출을 래핑합니다 <xref:System.String.TrimStart%2A> Visual Basic 및 C#에서 슬래시 (/)에서 공백 및 아포스트로피 (')는 주석 문자를 포함 하는 문자 배열을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3648">The `StripComments` method wraps a call to <xref:System.String.TrimStart%2A> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</span></span> <span data-ttu-id="ad3d8-3649"><xref:System.String.TrimStart%2A> 문자열로 주석을 인지 확인할 때 선행 공백을 제거 하려면 메서드도 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3649">The <xref:System.String.TrimStart%2A> method is also called to remove leading white space when evaluating whether a string is a comment.</span></span>  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 <span data-ttu-id="ad3d8-3650">다음 예제에서는 `StripComments` 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3650">The following example then illustrates a call to the `StripComments` method.</span></span>  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="ad3d8-3651">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전의 경우 삭제 합니다.이 메서드는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 은 <see langword="null" /> 이거나 빈 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3651">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ad3d8-3652">부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]경우 <paramref name="trimChars" /> 은 <see langword="null" /> 또는 빈 배열인 경우 메서드는 모든 유니코드 공백 문자 (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 값을 반환는 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3652">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ad3d8-3653">이러한 변경으로 인해는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전 두 문자, 0 너비 공백 (U + 200B) 및 0 너비 비분할 공백 (U + FEFF)를 제거 하는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 이상 버전을 수행 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3653">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="ad3d8-3654">또한는 <see cref="M:System.String.Trim" /> 에서 메서드는 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전을 세 개의 유니코드 공백 문자 트리밍 하지 않습니다: 몽골어 모음 구분 기호 (U + 180E), 좁은 비분할 공백 (U + 202F), 및 중간 수학 공백 (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ad3d8-3654">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>