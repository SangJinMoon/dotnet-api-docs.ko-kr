<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f1e5542ce17228b81ac98e22af0444d4203ab07" />
    <Meta Name="ms.sourcegitcommit" Value="ad09e88f48ca55b181e8d272cfc3742eadc3f939" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/08/2018" />
    <Meta Name="ms.locfileid" Value="35231192" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>배열을 만들고, 조작하고, 검색 및 정렬하여 공용 언어 런타임에서 모든 배열의 기본 클래스 역할을 수행하도록 하는 메서드를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 클래스가 않습니다의 일부가 <xref:System.Collections> 네임 스페이스입니다. 그러나 여전히 이라고 컬렉션에 기반 하므로 <xref:System.Collections.IList> 인터페이스입니다.  
  
 <xref:System.Array> 클래스는 배열을 지 원하는 언어 구현에 대 한 기본 클래스입니다. 그러나 시스템 및 컴파일러에서 명시적으로 파생 될 수 있습니다는 <xref:System.Array> 클래스입니다. 사용자는 언어에서 제공 하는 배열 구문을 사용 해야 합니다.  
  
 요소에는 프로그램 <xref:System.Array>합니다. 길이 <xref:System.Array> 포함할 수 있는 요소의 총 수입니다. 하 한 범위는 <xref:System.Array> 첫 번째 요소의 인덱스입니다. <xref:System.Array> 모든 하한값을 가질 수 있지만 그 값은 기본적으로 0입니다. 인스턴스를 만들 때 다른 하 한을 정의할 수 있습니다는 <xref:System.Array> 클래스 사용 <xref:System.Array.CreateInstance%2A>합니다. 다차원 <xref:System.Array> 각 차원에 대해 서로 다른 범위를 가질 수 있습니다. 배열에는 최대 32 차원 초과 있을 수 있습니다.  
  
 클래스와 달리는 <xref:System.Collections> 네임 스페이스, <xref:System.Array> 용량이 고정 합니다. 용량을 늘리려면 새 만들어야 <xref:System.Array> 필요한 용량으로 개체, 이전에서 요소를 복사 <xref:System.Array> 새 레코드로 개체를 삭제 하면 이전 <xref:System.Array>합니다.  
  
 기본적으로의 최대 크기는 <xref:System.Array> 은 2gb (기가바이트)입니다. 64 비트 환경에서 크기 제한을 설정 하 여 방지할 수 있습니다는 `enabled` 특성에는 [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) 구성 요소를 `true` 런타임 환경에서 합니다. 그러나 배열의 지정 된 차원 (바이트 배열 및 단일 바이트 구조의 배열에 대 한 0X7FFFFFC7)에 0X7FEFFFFF의 최대 인덱스는 총 4 십억 요소로 제한 수 있습니다.  
  
 1 차원 배열 구현는 <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> 및 <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> 제네릭 인터페이스입니다. 구현이 실행 시 배열에 제공 되 고 결과적으로, 제네릭 인터페이스에 대 한 선언 구문에 표시 되지 않습니다는 <xref:System.Array> 클래스입니다. 또한 제네릭 인터페이스의 형식 (명시적 인터페이스 구현)를 캐스팅 하 여만 액세스할 수 있는 인터페이스 멤버에 대 한 참조 항목 없음 있습니다. 이러한 인터페이스 중 하나를 캐스팅할 때 알고 있어야 하 고는 구성원을 추가, 삽입 또는 제거 요소 throw <xref:System.NotSupportedException>합니다.  
  
 <xref:System.Type> 개체 배열 형식 선언에 대 한 정보를 제공합니다. <xref:System.Array> 배열 형식이 같은 개체를 공유 하는 동일한 <xref:System.Type> 개체입니다.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> 및 <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> 예상된 결과에 반환 되지 않을 <xref:System.Array> 때문에 배열 형식으로 캐스팅 된 경우 <xref:System.Array>, 결과 배열이 아닌 개체입니다. 즉, `typeof(System.Array).IsArray` 반환 `false`, 및 `typeof(System.Array).GetElementType` 반환 `null`합니다.  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 동일한 유형 배열 간의 뿐만 아니라 하지만 서로 다른 형식의 표준 배열 간에 요소를 복사 하는 메서드, 형식 캐스팅을 자동으로 처리 합니다.  
  
 일부 메서드와 같은 <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, 및 <xref:System.Array.SetValue%2A>, 대용량 배열을 위한에 매개 변수로 64 비트 정수를 받아들이는 오버 로드를 제공 합니다. <xref:System.Array.LongLength%2A> 및 <xref:System.Array.GetLongLength%2A> 배열의 길이 나타내는 64 비트 정수를 반환 합니다.  
  
 <xref:System.Array> 정렬할 보장 되지 않습니다.  정렬 해야는 <xref:System.Array> 작업을 수행 하기 전에 (같은 <xref:System.Array.BinarySearch%2A>) 해야 하는 <xref:System.Array> 정렬할 합니다.  
  
 사용 하는 <xref:System.Array> 네이티브 코드에 대 한 포인터의 개체는 지원 되지 않으며를 throw 합니다는 <xref:System.NotSupportedException> 여러 가지 방법에 대 한 합니다.  
  
   
  
## Examples  
 다음 코드 예제와 방법을 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 간에 정수 형식의 배열 및 배열 형식의 요소를 복사 <xref:System.Object>합니다.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 다음 코드 예제를 만들고 초기화는 <xref:System.Array> 해당 속성 및 해당 요소를 표시 합니다.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual basic에서)이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.  이 구현에서는 동기화 된 제공 하지 않습니다 (스레드로부터 안전함) 래퍼에 대 한는 <see cref="T:System.Array" />있지만.NET Framework 클래스에 따라 <see cref="T:System.Array" /> 사용 하 여 컬렉션의 동기화 된 버전 제공는 <see cref="P:System.Array.SyncRoot" /> 속성.  컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">읽기 전용 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 래퍼에서 래핑할 1차원 배열(0부터 시작)입니다.</param>
        <summary>지정한 배열의 읽기 전용 래퍼를 반환합니다.</summary>
        <returns>지정한 배열의 읽기 전용 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 래퍼입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열에 대 한 수정을 방지 하려면이 래퍼를 통해서만 배열을 노출 합니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예에서는 읽기 전용 배열을 래핑하 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>합니다.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이진 검색 알고리즘을 사용하여 1차원으로 정렬된 <see cref="T:System.Array" />에서 값을 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원으로 정렬된 <see cref="T:System.Array" />입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <summary>배열의 각 요소 및 지정한 개체에서 구현되는 <see cref="T:System.IComparable" /> 인터페이스를 사용하여 1차원으로 정렬된 배열에서 특정 요소를 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 경우는 <xref:System.Array> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 중 하나 `value` 또는의 모든 요소가 `array` 구현 해야 합니다는 <xref:System.IComparable> 비교에 사용 되는 인터페이스입니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
> [!NOTE]
>  경우`value` 를 구현 하지 않습니다는 <xref:System.IComparable> 인터페이스의 요소 `array` 에 대 한 테스트 되지 않습니다 <xref:System.IComparable> 검색을 시작 하기 전에. 검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <xref:System.IComparable>합니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 예외가 생성 되지 않습니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법을 보여 줍니다 <xref:System.Array.BinarySearch%2A> 의 특정 개체를 찾을 수는 <xref:System.Array>합니다.  
  
> [!NOTE]
>  배열의 해당 요소를 오름차순으로 정렬 만들어집니다. <xref:System.Array.BinarySearch%2A> 메서드를 사용 하려면 배열 오름차순으로 정렬 됩니다.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />의 형식이 <paramref name="array" />의 요소와 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" />가 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않으며 검색 중에 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원으로 정렬된 <see cref="T:System.Array" />입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Collections.IComparer" /> 인터페이스를 사용하여 1차원으로 정렬된 전체 배열에서 값을 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 경우는 <xref:System.Array> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어, 사용할 수는 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.  
  
 경우 `comparer` 않습니다 `null`, 요소의 `array` 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.IComparer> 구현 합니다. 요소 `array` 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 `comparer`, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.  
  
 경우`comparer` 은 `null`, 비교를 수행를 사용 하는 <xref:System.IComparable> 또는 지정 된 값은 요소 자체에서 제공 되는 구현 합니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
> [!NOTE]
>  경우 `comparer` 은 `null` 및 `value` 를 구현 하지 않습니다는 <xref:System.IComparable> 인터페이스의 요소 `array` 에 대 한 테스트 되지 않습니다 <xref:System.IComparable> 검색을 시작 하기 전에. 검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <xref:System.IComparable>합니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 예외가 생성 되지 않습니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="value" />가 <paramref name="array" />의 요소와 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고, <paramref name="value" />가 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않으며 검색 중에 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원으로 정렬된 <see cref="T:System.Array" />입니다.</param>
        <param name="index">검색할 범위의 시작 인덱스입니다.</param>
        <param name="length">검색할 범위의 길이입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <summary>배열의 각 요소 및 지정한 값에서 구현되는 <see cref="T:System.IComparable" /> 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 경우는 <xref:System.Array> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 중 하나 `value` 또는의 모든 요소가 `array` 구현 해야 합니다는 <xref:System.IComparable> 비교에 사용 되는 인터페이스입니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
> [!NOTE]
>  경우 `value` 를 구현 하지 않습니다는 <xref:System.IComparable> 인터페이스의 요소 `array` 에 대 한 테스트 되지 않습니다 <xref:System.IComparable> 검색을 시작 하기 전에. 검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <xref:System.IComparable>합니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 예외가 생성 되지 않습니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="value" />의 형식이 <paramref name="array" />의 요소와 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" />가 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않으며 검색 중에 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원으로 정렬된 <see cref="T:System.Array" />입니다.</param>
        <param name="index">검색할 범위의 시작 인덱스입니다.</param>
        <param name="length">검색할 범위의 길이입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Collections.IComparer" /> 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 경우는 <xref:System.Array> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어, 사용할 수는 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.  
  
 경우 `comparer` 않습니다 `null`, 요소의 `array` 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.IComparer> 구현 합니다. 요소 `array` 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 `comparer`, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.  
  
 경우 `comparer` 은 `null`, 비교를 수행를 사용 하는 <xref:System.IComparable> 또는 지정 된 값은 요소 자체에서 제공 되는 구현 합니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
> [!NOTE]
>  경우 `comparer` 은 `null` 및 `value` 를 구현 하지 않습니다는 <xref:System.IComparable> 인터페이스의 요소 `array` 에 대 한 테스트 되지 않습니다 <xref:System.IComparable> 검색을 시작 하기 전에. 검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <xref:System.IComparable>합니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 사용 하는 경우 예외를 생성 하지 않는 <xref:System.IComparable>합니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="value" />가 <paramref name="array" />의 요소와 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고, <paramref name="value" />가 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않으며 검색 중에 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 정렬된 1차원 <see cref="T:System.Array" />(0부터 시작)입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <summary>
          <see cref="T:System.Array" />의 각 요소 및 지정한 개체에서 구현되는 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 전체 배열에서 특정 요소를 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 경우 `array` 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 `T` 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스는 비교에 사용 됩니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable%601> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 예외가 생성 되지 않습니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable%601> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable%601> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> 제네릭 메서드 오버 로드와 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 제네릭 메서드 오버 로드 합니다. 임의의 순서로 문자열 배열을 만들어집니다.  
  
 배열은 표시 하 고 정렬 하 고 다시 표시 됩니다. 배열을 사용 하기 위해 정렬 해야는 <xref:System.Array.BinarySearch%2A> 메서드.  
  
> [!NOTE]
>  에 대 한 호출에서 <xref:System.Array.Sort%2A> 및 <xref:System.Array.BinarySearch%2A> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다. 배열 및 반환 값은 <xref:System.Array.BinarySearch%2A> 메서드에 전달 되는 `ShowWhere` 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다. 인덱스는 문자열 배열에 없는 경우에 음수 하므로 `ShowWhere` 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 `Xor`Visual Basic의-1) 검색 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 str 연산입니다.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않습니다.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 정렬된 1차원 <see cref="T:System.Array" />(0부터 시작)입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable`1" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Collections.Generic.IComparer`1" /> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 전체 배열에서 값을 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 경우는 <xref:System.Array> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어, 사용할 수는 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.  
  
 경우 `comparer` 않습니다 `null`, 요소의 `array` 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.Generic.IComparer%601> 제네릭 인터페이스를 구현 합니다. 요소 `array` 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 `comparer`, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.  
  
 경우 `comparer` 은 `null`, 비교를 수행를 사용 하는 <xref:System.IComparable%601> 에서 제공 하는 제네릭 인터페이스 구현을 `T`합니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable%601> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
> [!NOTE]
>  경우 `comparer` 은 `null` 및 `value` 를 구현 하지 않습니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 요소의 `array` 에 대 한 테스트 되지 않습니다 <xref:System.IComparable%601> 검색을 시작 하기 전에. 검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <xref:System.IComparable%601>합니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 예외가 생성 되지 않습니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable%601> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable%601> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 제네릭 메서드 오버 로드와 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 제네릭 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 배열은 표시 하 고 정렬 하 고 다시 표시 됩니다. 배열을 사용 하기 위해 정렬 해야는 <xref:System.Array.BinarySearch%2A> 메서드.  
  
> [!NOTE]
>  에 대 한 호출에서 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 및 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다. 배열 및 반환 값은 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 메서드에 전달 되는 `ShowWhere` 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다. 인덱스는 문자열이 n 경우 음수 배열에 하므로 `ShowWhere` 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1) 검색 stri 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 ng 합니다.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="value" />가 <paramref name="array" />의 요소와 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="T" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않습니다.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 정렬된 1차원 <see cref="T:System.Array" />(0부터 시작)입니다.</param>
        <param name="index">검색할 범위의 시작 인덱스입니다.</param>
        <param name="length">검색할 범위의 길이입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <summary>
          <see cref="T:System.Array" />의 각 요소 및 지정한 값에서 구현되는 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 배열에 지정된 된 값이 없는 경우 메서드는 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 `T` 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스는 비교에 사용 됩니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable%601> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 예외가 생성 되지 않습니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable%601> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable%601> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="value" />의 형식이 <paramref name="array" />의 요소와 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않습니다.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 정렬된 1차원 <see cref="T:System.Array" />(0부터 시작)입니다.</param>
        <param name="index">검색할 범위의 시작 인덱스입니다.</param>
        <param name="length">검색할 범위의 길이입니다.</param>
        <param name="value">검색할 개체입니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable`1" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Collections.Generic.IComparer`1" /> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</summary>
        <returns>
          <paramref name="value" />가 있는 경우 지정된 <paramref name="array" />에 있는 지정된 <paramref name="value" />의 인덱스이고, 그렇지 않으면 음수입니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 하나 이상의 요소보다 작은 경우 <paramref name="value" />보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다. <paramref name="value" />가 없고 <paramref name="value" />가 <paramref name="array" />에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다. 이 메서드가 정렬되지 않은 <paramref name="array" />를 사용하여 호출되면 <paramref name="value" />가 <paramref name="array" />에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다. `array` 이 메서드를 호출 하기 전에 정렬 되어야 합니다.  
  
 배열에 지정된 된 값이 없는 경우 메서드는 음의 정수를 반환 합니다. 비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 `Not` Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다. 이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 `value` 배열에 있습니다. 그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 `value`합니다.  
  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어, 사용할 수는 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.  
  
 경우 `comparer` 않습니다 `null`, 요소의 `array` 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.Generic.IComparer%601> 제네릭 인터페이스를 구현 합니다. 요소 `array` 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 `comparer`, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.  
  
 경우 `comparer` 은 `null`, 비교를 수행를 사용 하는 <xref:System.IComparable%601> 형식을 위해 제공 되는 제네릭 인터페이스 구현을 `T`합니다. 요소 `array` 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <xref:System.IComparable%601> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.  
  
 중복 되는 요소가 허용 됩니다. 경우는 <xref:System.Array> 크거나 둘 이상의 요소가 포함 되어 `value`, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.  
  
 `null` 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 `null` 사용 하는 경우 예외를 생성 하지 않는 <xref:System.IComparable%601>합니다.  
  
> [!NOTE]
>  테스트, 모든 요소에 대해 `value` 을 적절 한 전달 <xref:System.IComparable%601> 경우 `value` 은 `null`합니다. 즉,는 <xref:System.IComparable%601> 구현 지정된 된 요소를 비교 하는 방법을 결정 `null`합니다.  
  
 이 메서드는는 O (로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="value" />가 <paramref name="array" />의 요소와 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="T" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않습니다.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">포함된 요소를 지울 배열입니다.</param>
        <param name="index">지울 요소 범위의 시작 인덱스입니다.</param>
        <param name="length">지울 요소의 개수입니다.</param>
        <summary>배열의 각 요소 형식의 기본값으로 요소의 범위를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 배열의 각 요소에에서 요소 형식의 기본값으로 다시 설정합니다. 참조 형식의 요소를 설정 하는 것 (포함 하 여 <xref:System.String> 요소)를 `null`, 다음 표에 표시 된 기본값으로 값 형식의 요소를 가져오거나 설정 합니다.  
  
|형식|값|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|모든 정수 계열 및 부동 소수점 숫자 형식|0 (영)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|다른 값 형식|해당 형식의 필드의 기본값|  
  
 범위의 요소 줄 바꿈을 행 다차원 배열에서 지워집니다.  
  
 이 메서드는만; 요소의 값을 지웁니다. 요소 자체는 삭제 되지 않습니다. 배열 크기가 고정 된 따라서 요소 추가 또는 제거할 수 없습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Array.Clear%2A> 메서드를 1 차원, 2, 차원 및 3 차원 배열에 정수 값을 다시 설정 합니다.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 다음 예제에서는 정의 `TimeZoneTime` 구조에 포함 하는 <xref:System.TimeZoneInfo> 필드와 <xref:System.DateTimeOffset> 필드입니다. 그런 다음 호출 하는 <xref:System.Array.Clear%2A> 의 두 요소 배열에서 요소 중 하나를 지우려면 메서드 `TimeZoneTime` 값입니다. 기본값을 지워진된 요소 값을 설정 하는 메서드는 <xref:System.TimeZoneInfo> 개체 이며, `null`, 및의 기본값은 <xref:System.DateTimeOffset> 개체 이며, <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.  -또는-  <paramref name="index" /> 및 <paramref name="length" /> 합계가 <paramref name="array" />의 크기보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Array" />의 부분 복사본을 만듭니다.</summary>
        <returns>
          <see cref="T:System.Array" />의 부분 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 단순 복사본을는 <xref:System.Array> 의 요소에만 복사는 <xref:System.Array>, 여부은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다. 새 참조 <xref:System.Array> 동일 하 게 지점 개체는 원래에서 참조 <xref:System.Array> 가리킵니다.  
  
 전체 복사본 하는 반면, 한 <xref:System.Array> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.  
  
 복제본은 동일한 <xref:System.Type> 원래 <xref:System.Array>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Array.Length%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 복제본을 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 배열 하 고 단순 복사본의 동작을 보여 줍니다.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">복사할 데이터가 포함된 <see cref="T:System.Array" />입니다.</param>
        <param name="sourceIndex">복사가 시작되는 <c>sourceArray</c>의 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="destinationArray">데이터를 받는 <see cref="T:System.Array" />입니다.</param>
        <param name="destinationIndex">저장이 시작되는 <c>destinationArray</c>의 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="length">복사할 요소의 개수를 나타내는 32비트 정수입니다.</param>
        <summary>
          <see cref="T:System.Array" />의 요소 범위를 지정한 소스 인덱스부터 복사하여 지정된 대상 인덱스부터 시작하는 다른 <see cref="T:System.Array" />에 붙여 넣습니다.  복사가 완료되지 않으면 모든 변경 내용이 취소되도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 및 `destinationArray` 매개 변수에 동일한 차원 수 있어야 합니다.  `sourceArray` 형식은 동일 하거나에서 파생 된는 `destinationArray` 입력; 그렇지 않으면는 <xref:System.ArrayTypeMismatchException> throw 됩니다.  와 달리 <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> 작업을 수행 하기 전에 배열 형식 호환성을 확인 합니다.  
  
 다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다. 예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다. 세 번째 행 (또는 열)의 두 번째 요소부터 복사 하려면 `sourceIndex` 2를 더한 두 번째 행 (또는 열)의 길이 더한 첫 번째 행 (또는 열)의 상한을 이어야 합니다.  
  
 경우 `sourceArray` 및 `destinationArray` 겹치는 경우이 메서드는 동작 처럼의 원래 값 `sourceArray` 하기 전에 임시 위치에 보존 된 `destinationArray` 를 덮어씁니다.  
  
 [C++]  
  
 이 메서드는 표준 C/c + + 함수와 동일 `memmove`이 아니라 `memcpy`합니다.  
  
 참조 형식 또는 값 형식의 배열을 배열의 수 있습니다.  경우 `sourceArray` 및 `destinationArray` 두 참조 형식 배열 파일이 나 두 배열 형식의 <xref:System.Object>, 단순 복사가 수행 됩니다. 단순 복사본을는 <xref:System.Array> 는 새로운 <xref:System.Array> 원본과 같은 요소에 대 한 참조가 포함 된 <xref:System.Array>합니다. 요소는 요소에서 참조 하는 대상은 복사 되지 않습니다. 전체 복사본 하는 반면, 한 <xref:System.Array> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.  
  
 이 메서드는 복사 하는 동안 예외를 throw 하는 경우는 `destinationArray` 변경 되지 않음; 따라서 <xref:System.Array.ConstrainedCopy%2A> 제약이 있는 실행 영역 내에서 사용할 수 (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" />가 <see langword="null" />인 경우  -또는-  <paramref name="destinationArray" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />의 차수가 다릅니다.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 형식은 동일하지 않으며 <paramref name="destinationArray" /> 형식에서 파생되지 않습니다.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" />의 하나 이상의 요소를 <paramref name="destinationArray" />의 형식으로 캐스팅할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />가 <paramref name="sourceArray" />의 첫 번째 차원 하한값보다 작습니다.  -또는-  <paramref name="destinationIndex" />가 <paramref name="destinationArray" />의 첫 번째 차원 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" />가 <paramref name="sourceIndex" />부터 <paramref name="sourceArray" /> 끝까지의 요소 수보다 큽니다.  -또는-  <paramref name="length" />가 <paramref name="destinationIndex" />부터 <paramref name="destinationArray" /> 끝까지의 요소 수보다 큽니다.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">소스 배열 요소의 형식입니다.</typeparam>
        <typeparam name="TOutput">대상 배열 요소의 형식입니다.</typeparam>
        <param name="array">대상 형식으로 변환할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="converter">한 형식에서 다른 형식으로 각 요소를 변환하는 <see cref="T:System.Converter`2" />입니다.</param>
        <summary>한 형식의 배열을 다른 형식의 배열로 변환합니다.</summary>
        <returns>소스 배열에서 변환된 요소를 포함하는 대상 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> 개체를 대상 형식으로 변환 하는 메서드에 대리자입니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Converter%602>, 변환된 된 요소를 새 배열에 저장 됩니다.  
  
 소스 `array` 그대로 유지 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 라는 메서드를 정의 하는 다음 코드 예제에서는 `PointFToPoint` 변환 하는 <xref:System.Drawing.PointF> 구조체는 <xref:System.Drawing.Point> 구조입니다. 배열을 만듭니다 <xref:System.Drawing.PointF> 구조, 만들어집니다는 `Converter<PointF, Point>` 위임 (`Converter(Of PointF, Point)` Visual Basic의)을 나타내는 `PointFToPoint` 메서드를에 대리자를 전달는 <xref:System.Array.ConvertAll%2A> 메서드. <xref:System.Array.ConvertAll%2A> 메서드 전달 하는 입력 목록의 각 요소는 `PointFToPoint` 메서드를 새 목록으로 변환된 된 요소를 배치 <xref:System.Drawing.Point> 구조입니다. 두 목록은 모두 표시 됩니다.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="converter" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>한 <see cref="T:System.Array" />의 요소 범위를 다른 <see cref="T:System.Array" />에 복사하고 필요에 따라 형식 캐스팅 및 boxing을 수행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">복사할 데이터가 포함된 <see cref="T:System.Array" />입니다.</param>
        <param name="destinationArray">데이터를 받는 <see cref="T:System.Array" />입니다.</param>
        <param name="length">복사할 요소의 개수를 나타내는 32비트 정수입니다.</param>
        <summary>
          <see cref="T:System.Array" />의 요소 범위를 첫 번째 요소부터 복사하여 다른 <see cref="T:System.Array" />에 첫 번째 요소부터 붙여넣습니다. 길이가 32비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 및 `destinationArray` 매개 변수에 동일한 차원 수 있어야 합니다. 또한 `destinationArray` 해야 이미 있는 된 차원이 구분 하 고 요소 복사한 데이터를 수용 하기 위해 충분 한 수를가지고 있어야 합니다.  
  
 다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다. 예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다.  
  
 경우 `sourceArray` 및 `destinationArray` 겹치는 경우이 메서드는 동작 처럼의 원래 값 `sourceArray` 하기 전에 임시 위치에 보존 된 `destinationArray` 를 덮어씁니다.  
  
 [C++]  
  
 이 메서드는 표준 C/c + + 함수와 동일 `memmove`이 아니라 `memcpy`합니다.  
  
 참조 형식 또는 값 형식의 배열을 배열의 수 있습니다. 형식 다운 캐스팅을 수행 해야 하는 경우.  
  
-   참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다. 값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.  
  
-   참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <xref:System.Object> 배열에는 <xref:System.Object> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다. 복사 하는 경우는 <xref:System.Object> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <xref:System.InvalidCastException> throw 됩니다.  
  
-   경우 `sourceArray` 및 `destinationArray` 두 참조 형식 배열 파일이 나 두 배열 형식의 <xref:System.Object>, 단순 복사가 수행 됩니다. 단순 복사본을는 <xref:System.Array> 는 새로운 <xref:System.Array> 원본과 같은 요소에 대 한 참조가 포함 된 <xref:System.Array>합니다. 요소는 요소에서 참조 하는 대상은 복사 되지 않습니다. 전체 복사본 하는 반면, 한 <xref:System.Array> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.  
  
 <xref:System.ArrayTypeMismatchException> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다. 형식 호환성은 다음과 같이 정의 됩니다.  
  
-   형식이 자체와 호환 됩니다.  
  
-   값 형식이 호환 <xref:System.Object> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다. 값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다. 연결이 끊긴된 형식이 호환 되지 않습니다.  
  
-   두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다. 확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다. 예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다. 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
-   비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.  
  
-   열거형에 암시적 변환이 포함 <xref:System.Enum> 및 기본 형식입니다.  
  
 하는 경우 모든 요소에 `sourceArray` 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 `destinationArray`, <xref:System.InvalidCastException> throw 됩니다.  
  
 이 메서드가의 상태를 복사 하는 동안 예외가 throw `destinationArray` 정의 되지 않습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" />가 <see langword="null" />인 경우  -또는-  <paramref name="destinationArray" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />의 차수가 다릅니다.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />는 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" />의 하나 이상의 요소를 <paramref name="destinationArray" />의 형식으로 캐스팅할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" />가 <paramref name="sourceArray" />의 요소 수보다 큽니다.  -또는-  <paramref name="length" />가 <paramref name="destinationArray" />의 요소 수보다 큽니다.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">복사할 데이터가 포함된 <see cref="T:System.Array" />입니다.</param>
        <param name="destinationArray">데이터를 받는 <see cref="T:System.Array" />입니다.</param>
        <param name="length">복사할 요소의 개수를 나타내는 64비트 정수입니다. 정수는 0과 <see cref="F:System.Int32.MaxValue" />(포함) 사이여야 합니다.</param>
        <summary>
          <see cref="T:System.Array" />의 요소 범위를 첫 번째 요소부터 복사하여 다른 <see cref="T:System.Array" />에 첫 번째 요소부터 붙여넣습니다. 길이가 64비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 및 `destinationArray` 매개 변수에 동일한 차원 수 있어야 합니다. 또한 `destinationArray` 해야 이미 있는 된 차원이 구분 하 고 요소 복사한 데이터를 수용 하기 위해 충분 한 수를가지고 있어야 합니다.  
  
 다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다. 예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다.  
  
 경우 `sourceArray` 및 `destinationArray` 겹치는 경우이 메서드는 동작 처럼의 원래 값 `sourceArray` 하기 전에 임시 위치에 보존 된 `destinationArray` 를 덮어씁니다.  
  
 [C++]  
  
 이 메서드는 표준 C/c + + 함수와 동일 `memmove`이 아니라 `memcpy`합니다.  
  
 참조 형식 또는 값 형식의 배열을 배열의 수 있습니다. 형식 다운 캐스팅을 수행 해야 하는 경우.  
  
-   참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다. 값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.  
  
-   참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <xref:System.Object> 배열에는 <xref:System.Object> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다. 복사 하는 경우는 <xref:System.Object> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <xref:System.InvalidCastException> throw 됩니다.  
  
-   경우 `sourceArray` 및 `destinationArray` 두 참조 형식 배열 파일이 나 두 배열 형식의 <xref:System.Object>, 단순 복사가 수행 됩니다. 단순 복사본을는 <xref:System.Array> 는 새로운 <xref:System.Array> 원본과 같은 요소에 대 한 참조가 포함 된 <xref:System.Array>합니다. 요소는 요소에서 참조 하는 대상은 복사 되지 않습니다. 전체 복사본 하는 반면, 한 <xref:System.Array> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.  
  
 <xref:System.ArrayTypeMismatchException> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다. 형식 호환성은 다음과 같이 정의 됩니다.  
  
-   형식이 자체와 호환 됩니다.  
  
-   값 형식이 호환 <xref:System.Object> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다. 값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다. 연결이 끊긴된 형식이 호환 되지 않습니다.  
  
-   두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다. 확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다. 예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다. 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
-   비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.  
  
-   열거형에 암시적 변환이 포함 <xref:System.Enum> 및 기본 형식입니다.  
  
 하는 경우 모든 요소에 `sourceArray` 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 `destinationArray`, <xref:System.InvalidCastException> throw 됩니다.  
  
 이 메서드가의 상태를 복사 하는 동안 예외가 throw `destinationArray` 정의 되지 않습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" />가 <see langword="null" />인 경우  -또는-  <paramref name="destinationArray" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />의 차수가 다릅니다.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />는 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" />의 하나 이상의 요소를 <paramref name="destinationArray" />의 형식으로 캐스팅할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" />가 0보다 작거나 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" />가 <paramref name="sourceArray" />의 요소 수보다 큽니다.  -또는-  <paramref name="length" />가 <paramref name="destinationArray" />의 요소 수보다 큽니다.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">복사할 데이터가 포함된 <see cref="T:System.Array" />입니다.</param>
        <param name="sourceIndex">복사가 시작되는 <c>sourceArray</c>의 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="destinationArray">데이터를 받는 <see cref="T:System.Array" />입니다.</param>
        <param name="destinationIndex">저장이 시작되는 <c>destinationArray</c>의 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="length">복사할 요소의 개수를 나타내는 32비트 정수입니다.</param>
        <summary>
          <see cref="T:System.Array" />의 요소 범위를 지정한 소스 인덱스부터 복사하여 지정된 대상 인덱스부터 시작하는 다른 <see cref="T:System.Array" />에 붙여 넣습니다. 길이와 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 및 `destinationArray` 매개 변수에 동일한 차원 수 있어야 합니다. 또한 `destinationArray` 해야 이미 있는 된 차원이 구분 하 고 충분 한 수의 요소에서 시작을 있어야는 `destinationIndex` 복사한 데이터를 수용 하기 위해 위치입니다.  
  
 다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다. 예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다. 세 번째 행 (또는 열)의 두 번째 요소부터 복사 하려면 `sourceIndex` 2를 더한 두 번째 행 (또는 열)의 길이 더한 첫 번째 행 (또는 열)의 상한을 이어야 합니다.  
  
 경우 `sourceArray` 및 `destinationArray` 겹치는 경우이 메서드는 동작 처럼의 원래 값 `sourceArray` 하기 전에 임시 위치에 보존 된 `destinationArray` 를 덮어씁니다.  
  
 [C++]  
  
 이 메서드는 표준 C/c + + 함수와 동일 `memmove`이 아니라 `memcpy`합니다.  
  
 참조 형식 또는 값 형식의 배열을 배열의 수 있습니다. 형식 다운 캐스팅을 수행 해야 하는 경우.  
  
-   참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다. 값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.  
  
-   참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <xref:System.Object> 배열에는 <xref:System.Object> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다. 복사 하는 경우는 <xref:System.Object> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <xref:System.InvalidCastException> throw 됩니다.  
  
-   경우 `sourceArray` 및 `destinationArray` 두 참조 형식 배열 파일이 나 두 배열 형식의 <xref:System.Object>, 단순 복사가 수행 됩니다. 단순 복사본을는 <xref:System.Array> 는 새로운 <xref:System.Array> 원본과 같은 요소에 대 한 참조가 포함 된 <xref:System.Array>합니다. 요소는 요소에서 참조 하는 대상은 복사 되지 않습니다. 전체 복사본 하는 반면, 한 <xref:System.Array> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.  
  
 <xref:System.ArrayTypeMismatchException> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다. 형식 호환성은 다음과 같이 정의 됩니다.  
  
-   형식이 자체와 호환 됩니다.  
  
-   값 형식이 호환 <xref:System.Object> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다. 값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다. 연결이 끊긴된 형식이 호환 되지 않습니다.  
  
-   두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다. 확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다. 예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다. 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
-   비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.  
  
-   열거형에 암시적 변환이 포함 <xref:System.Enum> 및 기본 형식입니다.  
  
 하는 경우 모든 요소에 `sourceArray` 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 `destinationArray`, <xref:System.InvalidCastException> throw 됩니다.  
  
 이 메서드가의 상태를 복사 하는 동안 예외가 throw `destinationArray` 정의 되지 않습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 하나를 복사 하는 방법을 보여 줍니다. <xref:System.Array> 형식의 <xref:System.Object> 다른 <xref:System.Array> 정수 형식의 합니다.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" />가 <see langword="null" />인 경우  -또는-  <paramref name="destinationArray" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />의 차수가 다릅니다.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />는 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" />의 하나 이상의 요소를 <paramref name="destinationArray" />의 형식으로 캐스팅할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />가 <paramref name="sourceArray" />의 첫 번째 차원 하한값보다 작습니다.  -또는-  <paramref name="destinationIndex" />가 <paramref name="destinationArray" />의 첫 번째 차원 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" />가 <paramref name="sourceIndex" />부터 <paramref name="sourceArray" /> 끝까지의 요소 수보다 큽니다.  -또는-  <paramref name="length" />가 <paramref name="destinationIndex" />부터 <paramref name="destinationArray" /> 끝까지의 요소 수보다 큽니다.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">복사할 데이터가 포함된 <see cref="T:System.Array" />입니다.</param>
        <param name="sourceIndex">복사가 시작되는 <c>sourceArray</c>의 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="destinationArray">데이터를 받는 <see cref="T:System.Array" />입니다.</param>
        <param name="destinationIndex">저장이 시작되는 <c>destinationArray</c>의 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="length">복사할 요소의 개수를 나타내는 64비트 정수입니다. 정수는 0과 <see cref="F:System.Int32.MaxValue" />(포함) 사이여야 합니다.</param>
        <summary>
          <see cref="T:System.Array" />의 요소 범위를 지정한 소스 인덱스부터 복사하여 지정된 대상 인덱스부터 시작하는 다른 <see cref="T:System.Array" />에 붙여 넣습니다. 길이와 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 및 `destinationArray` 매개 변수에 동일한 차원 수 있어야 합니다. 또한 `destinationArray` 해야 이미 있는 된 차원이 구분 하 고 충분 한 수의 요소에서 시작을 있어야는 `destinationIndex` 복사한 데이터를 수용 하기 위해 위치입니다.  
  
 다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다. 예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다. 세 번째 행 (또는 열)의 두 번째 요소부터 복사 하려면 `sourceIndex` 2를 더한 두 번째 행 (또는 열)의 길이 더한 첫 번째 행 (또는 열)의 상한을 이어야 합니다.  
  
 경우 `sourceArray` 및 `destinationArray` 겹치는 경우이 메서드는 동작 처럼의 원래 값 `sourceArray` 하기 전에 임시 위치에 보존 된 `destinationArray` 를 덮어씁니다.  
  
 [C++]  
  
 이 메서드는 표준 C/c + + 함수와 동일 `memmove`이 아니라 `memcpy`합니다.  
  
 참조 형식 또는 값 형식의 배열을 배열의 수 있습니다. 형식 다운 캐스팅을 수행 해야 하는 경우.  
  
-   참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다. 값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.  
  
-   참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <xref:System.Object> 배열에는 <xref:System.Object> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다. 복사 하는 경우는 <xref:System.Object> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <xref:System.InvalidCastException> throw 됩니다.  
  
-   경우 `sourceArray` 및 `destinationArray` 두 참조 형식 배열 파일이 나 두 배열 형식의 <xref:System.Object>, 단순 복사가 수행 됩니다. 단순 복사본을는 <xref:System.Array> 는 새로운 <xref:System.Array> 원본과 같은 요소에 대 한 참조가 포함 된 <xref:System.Array>합니다. 요소는 요소에서 참조 하는 대상은 복사 되지 않습니다. 전체 복사본 하는 반면, 한 <xref:System.Array> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.  
  
 <xref:System.ArrayTypeMismatchException> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다. 형식 호환성은 다음과 같이 정의 됩니다.  
  
-   형식이 자체와 호환 됩니다.  
  
-   값 형식이 호환 <xref:System.Object> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다. 값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다. 연결이 끊긴된 형식이 호환 되지 않습니다.  
  
-   두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다. 확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다. 예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다. 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
-   비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.  
  
-   열거형에 암시적 변환이 포함 <xref:System.Enum> 및 기본 형식입니다.  
  
 하는 경우 모든 요소에 `sourceArray` 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 `destinationArray`, <xref:System.InvalidCastException> throw 됩니다.  
  
 이 메서드가의 상태를 복사 하는 동안 예외가 throw `destinationArray` 정의 되지 않습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 하나를 복사 하는 방법을 보여 줍니다. <xref:System.Array> 형식의 <xref:System.Object> 다른 <xref:System.Array> 정수 형식의 합니다.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" />가 <see langword="null" />인 경우  -또는-  <paramref name="destinationArray" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />의 차수가 다릅니다.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" />와 <paramref name="destinationArray" />는 호환되지 않는 형식입니다.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" />의 하나 이상의 요소를 <paramref name="destinationArray" />의 형식으로 캐스팅할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />가 <paramref name="sourceArray" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="destinationIndex" />가 <paramref name="destinationArray" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="length" />가 0보다 작거나 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" />가 <paramref name="sourceIndex" />부터 <paramref name="sourceArray" /> 끝까지의 요소 수보다 큽니다.  -또는-  <paramref name="length" />가 <paramref name="destinationIndex" />부터 <paramref name="destinationArray" /> 끝까지의 요소 수보다 큽니다.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 1차원 배열의 모든 요소를 지정된 1차원 배열에 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">현재 배열에서 복사한 요소의 대상인 1차원 배열입니다.</param>
        <param name="index">복사가 시작되는 <c>array</c>의 인덱스를 나타내는 32비트 정수입니다.</param>
        <summary>현재 1차원 배열의 모든 요소를 지정된 대상 배열 인덱스부터 시작하여 지정된 1차원 배열에 복사합니다. 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 배열 인스턴스의 모든 요소를 복사 하는이 메서드는 `array` 인덱스부터 대상 배열 `index`합니다. `array` 대상 배열 해야 이미 있는 된 차원이 구분 된 및 요소 복사 된 요소에 맞게 충분 한 수 있어야 합니다. 그렇지 않으면 메서드에서 예외가 throw됩니다.  
  
 이 메서드는 지원의 <xref:System.Collections.ICollection?displayProperty=nameWithType> 인터페이스입니다. 구현 하는 경우 <xref:System.Collections.ICollection?displayProperty=nameWithType> 가 사용 하 여 명시적으로 필요한 <xref:System.Array.Copy%2A> 추가 간접 참조를 방지 하려면.  
  
 이 메서드가의 상태를 복사 하는 동안 예외가 throw `array` 정의 되지 않습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Array.Length%2A>합니다. 단순 복사만 수행합니다.  
  
   
  
## Examples  
 다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <xref:System.Array> 다른 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <xref:System.Array> 다른 <xref:System.Array> 생기는 0이 아닌 배열은 합니다. 전체 소스 <xref:System.Array> 복사 대상의 기존 요소를 덮어쓰는 빈 요소를 포함 하 여 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />가 다차원 배열인 경우  -또는-  소스 배열의 요소 개수가 <paramref name="index" />부터 대상 <paramref name="array" /> 끝까지의 사용 가능한 요소 개수보다 큽니다.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">소스 <see cref="T:System.Array" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
        <exception cref="T:System.RankException">소스 배열이 다차원입니다.</exception>
        <exception cref="T:System.InvalidCastException">
          <see cref="T:System.Array" /> 소스에서 하나 이상의 요소를 <paramref name="array" />의 대상 형식으로 캐스팅할 수 없습니다.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">현재 배열에서 복사한 요소의 대상인 1차원 배열입니다.</param>
        <param name="index">복사가 시작되는 <c>array</c>의 인덱스를 나타내는 64비트 정수입니다.</param>
        <summary>현재 1차원 배열의 모든 요소를 지정된 대상 배열 인덱스부터 시작하여 지정된 1차원 배열에 복사합니다. 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 배열 인스턴스의 모든 요소를 복사 하는이 메서드는 `array` 인덱스부터 대상 배열 `index`합니다. `array` 대상 배열 해야 이미 있는 된 차원이 구분 된 및 요소 복사 된 요소에 맞게 충분 한 수 있어야 합니다. 그렇지 않으면 메서드에서 예외가 throw됩니다.  
  
 이 메서드는 지원의 <xref:System.Collections.ICollection?displayProperty=nameWithType> 인터페이스입니다. 구현 하는 경우 <xref:System.Collections.ICollection?displayProperty=nameWithType> 가 사용 하 여 명시적으로 필요한 <xref:System.Array.Copy%2A> 추가 간접 참조를 방지 하려면.  
  
 이 메서드가의 상태를 복사 하는 동안 예외가 throw `array` 정의 되지 않습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Array.Length%2A>합니다. 단순 복사만 수행합니다.  
  
   
  
## Examples  
 다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <xref:System.Array> 다른 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <xref:System.Array> 다른 <xref:System.Array> 생기는 0이 아닌 배열은 합니다. 전체 소스 <xref:System.Array> 복사 대상의 기존 요소를 덮어쓰는 빈 요소를 포함 하 여 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />가 다차원 배열인 경우  -또는-  소스 배열의 요소 개수가 <paramref name="index" />부터 대상 <paramref name="array" /> 끝까지의 사용 가능한 요소 개수보다 큽니다.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">소스 <see cref="T:System.Array" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
        <exception cref="T:System.RankException">소스 <see cref="T:System.Array" />가 다차원입니다.</exception>
        <exception cref="T:System.InvalidCastException">
          <see cref="T:System.Array" /> 소스에서 하나 이상의 요소를 <paramref name="array" />의 대상 형식으로 캐스팅할 수 없습니다.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">만들 <see cref="T:System.Array" />의 <see cref="T:System.Type" />입니다.</param>
        <param name="length">만들 <see cref="T:System.Array" />의 크기입니다.</param>
        <summary>지정한 <see cref="T:System.Type" /> 및 길이를 가진 인덱스가 0부터 시작하는 1차원 <see cref="T:System.Array" />를 만듭니다.</summary>
        <returns>지정한 <see cref="T:System.Type" /> 및 지정한 길이를 가진 인덱스가 0부터 시작하는 새 1차원 <see cref="T:System.Array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 클래스와 달리 <xref:System.Array> 제공는 <xref:System.Array.CreateInstance%2A> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.  
  
 요소 참조 형식으로 초기화 됩니다 `null`합니다. 값 형식 요소를 0으로 초기화 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 만들고 1 차원 초기화 하는 방법을 보여 줍니다 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" />은 유효한 <see cref="T:System.Type" />이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" />은 지원되지 않습니다. 예를 들면 <see cref="T:System.Void" />는 지원되지 않습니다.  -또는-  <paramref name="elementType" />이 개방형 제네릭 형식입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" />가 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">만들 <see cref="T:System.Array" />의 <see cref="T:System.Type" />입니다.</param>
        <param name="lengths">만들 <see cref="T:System.Array" />의 각 차원 크기를 나타내는 32비트 정수 배열입니다.</param>
        <summary>지정한 <see cref="T:System.Type" /> 및 차원 길이를 가진 인덱스가 0부터 시작하는 다차원 <see cref="T:System.Array" />를 만듭니다. 차원 길이가 32비트 정수 배열로 지정되어 있습니다.</summary>
        <returns>지정한 <see cref="T:System.Type" /> 및 각 차원에 대해 지정한 길이를 가진 인덱스가 0부터 시작하는 새 다차원 <see cref="T:System.Array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 클래스와 달리 <xref:System.Array> 제공는 <xref:System.Array.CreateInstance%2A> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.  
  
 에 있는 요소의 수는 `lengths` 새 배열 차원 수와 동일 해야 <xref:System.Array>합니다. 각 요소는 `lengths` 배열 새에서 해당 차원의 길이 지정 해야 <xref:System.Array>합니다.  
  
 요소 참조 형식으로 초기화 됩니다 `null`합니다. 값 형식 요소를 0으로 초기화 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 에 있는 모든 값의 곱 `lengths`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만들고 다차원 초기화 하는 방법을 보여 줍니다. <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" />가 <see langword="null" />인 경우  -또는-  <paramref name="lengths" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" />은 유효한 <see cref="T:System.Type" />이 아닙니다.  -또는-  <paramref name="lengths" /> 배열에 1개 미만의 요소가 포함되어 있습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" />은 지원되지 않습니다. 예를 들면 <see cref="T:System.Void" />는 지원되지 않습니다.  -또는-  <paramref name="elementType" />이 개방형 제네릭 형식입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" />의 값이 0보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">만들 <see cref="T:System.Array" />의 <see cref="T:System.Type" />입니다.</param>
        <param name="lengths">만들 <see cref="T:System.Array" />의 각 차원 크기를 나타내는 64비트 정수 배열입니다. 배열의 각 정수는 0과 <see cref="F:System.Int32.MaxValue" /> 사이여야 합니다.</param>
        <summary>지정한 <see cref="T:System.Type" /> 및 차원 길이를 가진 인덱스가 0부터 시작하는 다차원 <see cref="T:System.Array" />를 만듭니다. 차원 길이가 64비트 정수 배열로 지정되어 있습니다.</summary>
        <returns>지정한 <see cref="T:System.Type" /> 및 각 차원에 대해 지정한 길이를 가진 인덱스가 0부터 시작하는 새 다차원 <see cref="T:System.Array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 클래스와 달리 <xref:System.Array> 제공는 <xref:System.Array.CreateInstance%2A> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.  
  
 에 있는 요소의 수는 `lengths` 새 배열 차원 수와 동일 해야 <xref:System.Array>합니다. 각 요소는 `lengths` 배열 새에서 해당 차원의 길이 지정 해야 <xref:System.Array>합니다.  
  
 요소 참조 형식으로 초기화 됩니다 `null`합니다. 값 형식 요소를 0으로 초기화 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 에 있는 모든 값의 곱 `lengths`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만들고 다차원 초기화 하는 방법을 보여 줍니다. <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" />가 <see langword="null" />인 경우  -또는-  <paramref name="lengths" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" />은 유효한 <see cref="T:System.Type" />이 아닙니다.  -또는-  <paramref name="lengths" /> 배열에 1개 미만의 요소가 포함되어 있습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" />은 지원되지 않습니다. 예를 들면 <see cref="T:System.Void" />는 지원되지 않습니다.  -또는-  <paramref name="elementType" />이 개방형 제네릭 형식입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" />의 값이 0보다 작거나 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">만들 <see cref="T:System.Array" />의 <see cref="T:System.Type" />입니다.</param>
        <param name="length1">만들 <see cref="T:System.Array" />의 첫 번째 차원 크기입니다.</param>
        <param name="length2">만들 <see cref="T:System.Array" />의 두 번째 차원 크기입니다.</param>
        <summary>0부터 시작하는 인덱스를 사용하여 지정된 <see cref="T:System.Type" /> 및 차원 길이의 2차원 <see cref="T:System.Array" />를 만듭니다.</summary>
        <returns>0부터 시작하는 인덱스를 사용하며 각 차원이 지정된 길이로 된 지정된 <see cref="T:System.Type" />의 새로운 2차원 <see cref="T:System.Array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 클래스와 달리 <xref:System.Array> 제공는 <xref:System.Array.CreateInstance%2A> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.  
  
 요소 참조 형식으로 초기화 됩니다 `null`합니다. 값 형식 요소를 0으로 초기화 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 곱 `length1` 및 `length2`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 만들고 차원 초기화 하는 방법을 보여 줍니다 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" />은 유효한 <see cref="T:System.Type" />이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" />은 지원되지 않습니다. 예를 들면 <see cref="T:System.Void" />는 지원되지 않습니다.  -또는-  <paramref name="elementType" />이 개방형 제네릭 형식입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" />가 0보다 작은 경우  -또는-  <paramref name="length2" />가 0보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">만들 <see cref="T:System.Array" />의 <see cref="T:System.Type" />입니다.</param>
        <param name="lengths">만들 <see cref="T:System.Array" />의 각 차원 크기를 포함하는 1차원 배열입니다.</param>
        <param name="lowerBounds">만들 <see cref="T:System.Array" />의 각 차원 하한(시작 인덱스)을 포함하는 1차원 배열입니다.</param>
        <summary>지정한 하한을 가진 지정한 <see cref="T:System.Array" /> 및 차원 길이의 다차원 <see cref="T:System.Type" />를 만듭니다.</summary>
        <returns>각 차원에 대해 지정한 길이 및 하한을 가진 지정한 <see cref="T:System.Array" />의 새 다차원 <see cref="T:System.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 클래스와 달리 <xref:System.Array> 제공는 <xref:System.Array.CreateInstance%2A> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.  
  
 `lengths` 및 `lowerBounds` 배열 요소는 동일한 수 있어야 합니다. 에 있는 요소의 수는 `lengths` 새 배열 차원 수와 동일 해야 <xref:System.Array>합니다.  
  
 각 요소는 `lengths` 배열 새에서 해당 차원의 길이 지정 해야 <xref:System.Array>합니다.  
  
 각 요소는 `lowerBounds` 배열 새에 해당 하는 차원에 대 한 하한값을 지정 해야 <xref:System.Array>합니다. 일반적으로.NET Framework 클래스 라이브러리와 많은 프로그래밍 언어에 0이 아닌 처리 하지 않습니다.  
  
 요소 참조 형식으로 초기화 됩니다 `null`합니다. 값 형식 요소를 0으로 초기화 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 에 있는 모든 값의 곱 `lengths`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만들고 다차원 초기화 하는 방법을 보여 줍니다. <xref:System.Array> 지정 된 하 한을 가진 합니다.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" />가 <see langword="null" />인 경우  -또는-  <paramref name="lengths" />가 <see langword="null" />입니다.  -또는-  <paramref name="lowerBounds" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" />은 유효한 <see cref="T:System.Type" />이 아닙니다.  -또는-  <paramref name="lengths" /> 배열에 1개 미만의 요소가 포함되어 있습니다.  -또는-  <paramref name="lengths" />와 <paramref name="lowerBounds" /> 배열에 있는 요소 수가 다릅니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" />은 지원되지 않습니다. 예를 들면 <see cref="T:System.Void" />는 지원되지 않습니다.  -또는-  <paramref name="elementType" />이 개방형 제네릭 형식입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" />의 값이 0보다 작습니다.  -또는-  <paramref name="lowerBounds" />에 있는 모든 값이 아주 커서 차원의 하한과 길이의 합이 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">만들 <see cref="T:System.Array" />의 <see cref="T:System.Type" />입니다.</param>
        <param name="length1">만들 <see cref="T:System.Array" />의 첫 번째 차원 크기입니다.</param>
        <param name="length2">만들 <see cref="T:System.Array" />의 두 번째 차원 크기입니다.</param>
        <param name="length3">만들 <see cref="T:System.Array" />의 세 번째 차원 크기입니다.</param>
        <summary>지정한 <see cref="T:System.Type" /> 및 차원 길이를 가진 인덱스가 0부터 시작하는 삼차원 <see cref="T:System.Array" />를 만듭니다.</summary>
        <returns>지정한 <see cref="T:System.Type" /> 및 각 차원에 대해 지정한 길이를 가진 인덱스가 0부터 시작하는 새 삼차원 <see cref="T:System.Array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 클래스와 달리 <xref:System.Array> 제공는 <xref:System.Array.CreateInstance%2A> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.  
  
 요소 참조 형식으로 초기화 됩니다 `null`합니다. 값 형식 요소를 0으로 초기화 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 곱 `length1`, `length2`, 및 `length3`합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 생성 하는 삼차원 초기화 하는 방법을 보여 줍니다 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" />은 유효한 <see cref="T:System.Type" />이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" />은 지원되지 않습니다. 예를 들면 <see cref="T:System.Void" />는 지원되지 않습니다.  -또는-  <paramref name="elementType" />이 개방형 제네릭 형식입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" />가 0보다 작은 경우  -또는-  <paramref name="length2" />가 0보다 작습니다.  -또는-  <paramref name="length3" />이 0보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <summary>빈 배열을 반환합니다.</summary>
        <returns>빈 <see cref="T:System.Array" /> 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정한 배열에 지정한 조건자에 정의된 조건과 일치하는 요소가 포함되어 있는지를 확인합니다.</summary>
        <returns>
          <paramref name="array" />에 지정한 조건자에 정의된 조건과 일치하는 하나 이상의 요소가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>, 일치 하는 경우 처리가 중지 됩니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 <xref:System.Predicate%601> 명시적으로 위임 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 예제에 대 한 일치 조건을 지정는 <xref:System.Array.Exists%2A> 메서드 usinglambda 식을 하 여 전 세계는 지정 된 문자로 시작 하는 여부 또는 지정된 된 배열에서 지구를 찾을 수 있는지 여부를 확인 합니다.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 다음 예제에서는 <xref:System.Array.Exists%2A> 메서드 모든 이름이 문자열 배열에서 지정 된 문자로 시작 하는지 여부를 나타냅니다. 이 예제에서는 인스턴스화합니다는 `StringSearcher` 해당 클래스 생성자에 검색할 문자열을 전달 하 여 개체입니다. `StringSearcher.StartsWith` 메서드 시그니처가 동일한는 <xref:System.Predicate%601> 위임 합니다. 경우는 <xref:System.Array.Exists%2A> 메서드가 호출 되 면 반환 될 때까지 배열의 각 멤버는 대리자에 전달 됩니다 `true` 또는 배열의 모든 요소를 반복 합니다.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 대신 수 있습니다도 람다 식을 사용 하는 대리자의 시그니처를 가진 해당 메서드를 명시적으로 정의 합니다. 다음 예제에서는 대체는 `StringSearcher` 클래스 및 해당 `StartsWith` 람다 식 사용 하 여 메서드.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 조건자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <see cref="T:System.Array" />에서 처음으로 검색한 요소를 반환합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째 요소이고, 그렇지 않으면 <paramref name="T" /> 형식의 기본값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 메서드 또는 람다 식을 반환 하는 대리자 `true` 개체에 전달 하는 경우 대리자 또는 람다 식에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>첫 번째 요소부터 마지막 요소까지 합니다.  일치 하는 경우 처리가 중지 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Predicate%601> 대리자는 <xref:System.Array.Find%2A> 배열을 검색할 제네릭 메서드 <xref:System.Drawing.Point> 구조입니다. 대리자가 나타내는 메서드 `ProductGT10`, 반환 `true` X 및 Y 필드 제품 100, 000 보다 큰 경우. <xref:System.Array.Find%2A> 메서드 테스트 조건에 맞는 첫 번째 지점을 반환 하는 배열의 각 요소에 대 한 대리자를 호출 합니다.  
  
> [!NOTE]
>  Visual Basic 및 C# 사용자 대리자를 명시적으로 만들거나 제네릭 메서드의 형식 인수를 지정 하지 않아도 됩니다. 컴파일러에서 제공 하는 메서드 인수 필요한 형식을 결정 합니다.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 필요한 시그니처를 가진 메서드를 명시적으로 정의 하는 대신 인스턴스화하는 <xref:System.Predicate%601> 대리자와 대리자를 전달 하는 <xref:System.Array.Find%2A> 는 람다 식을 사용 하는 일반적인 메서드를 합니다. 다음 예제는 이전 쿼리와 동일으로 람다 식을 사용 하 여는 `match` 인수입니다.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정한 조건자에 정의된 조건과 일치하는 모든 요소를 검색합니다.</summary>
        <returns>지정한 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 모든 요소를 포함하는 <see cref="T:System.Array" />이고, 그렇지 않으면 빈 <see cref="T:System.Array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>, 조건과 일치 하는 요소는 반환된 된 배열에 저장 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 예제에서는 값의 범위는 0에서 1, 000을 가진 50 난수의 배열을 만듭니다. 그런 다음 호출 하는 <xref:System.Array.FindAll%2A> 메서드 값을 반환 하는 해당 범위에서 300를 600으로 람다 식 사용 합니다. 람다 식은 라는 매개 변수를 전달 `x`;  이 나타냅니다에 전달 되는 각 배열 멤버는 <xref:System.Predicate%601>합니다. 또한 로컬 `lBound` 및 `uBound` 변수에 람다 식 내에서 액세스할 수 있습니다.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 다음 코드 예제는 <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, 및 <xref:System.Array.FindAll%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.Find%2A> 제네릭 메서드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` "Amargasaurus" 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindLast%2A> 제네릭 메서드는 배열의 끝부터 뒤로 검색 하는 데 사용 됩니다. 위치 5에서 "Dilophosaurus를" 요소를 찾습니다. <xref:System.Array.FindAll%2A> 제네릭 메서드는 "saurus"로 끝나는 모든 요소가 포함 된 배열을 반환 하는 데 사용 됩니다. 요소가 표시 됩니다.  
  
 코드 예제도 <xref:System.Array.Exists%2A> 및 <xref:System.Array.TrueForAll%2A> 제네릭 메서드.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 조건자에 정의된 조건과 일치하는 요소를 검색하여 <see cref="T:System.Array" /> 또는 그 일부에서 일치하는 요소 중 첫 번째 요소의 0부터 시작하는 인덱스를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <see cref="T:System.Array" />에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 검색은 앞으로 첫 번째 요소부터 마지막 요소입니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <xref:System.Array.FindIndex%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` 위치 1에 있는 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 배열의 위치 2부터 사이 배열의 끝에 검색 하는 데 사용 됩니다. 위치 5에 있는 요소를 찾습니다. 마지막으로 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 위치 2에서 시작 하는 세 가지 요소의 범위를 검색 하는 데 사용 됩니다. "Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정된 인덱스에서 마지막 요소로 확장하는 <see cref="T:System.Array" />의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 까지 검색은 `startIndex` 마지막 요소의 끝입니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 요소 수 `startIndex` 의 끝에 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <xref:System.Array.FindIndex%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` 위치 1에 있는 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 배열의 위치 2부터 사이 배열의 끝에 검색 하는 데 사용 됩니다. 위치 5에 있는 요소를 찾습니다. 마지막으로 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 위치 2에서 시작 하는 세 가지 요소의 범위를 검색 하는 데 사용 됩니다. "Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 지정된 인덱스부터 시작하여 지정된 수의 요소를 포함하는 <see cref="T:System.Array" />의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 까지 검색은 `startIndex` 에서 끝나는 `startIndex` 플러스 `count` 에서 1을 뺀 경우 `count` 가 0 보다 크면 합니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `count`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <xref:System.Array.FindIndex%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` 위치 1에 있는 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 배열의 위치 2부터 사이 배열의 끝에 검색 하는 데 사용 됩니다. 위치 5에 있는 요소를 찾습니다. 마지막으로 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 위치 2에서 시작 하는 세 가지 요소의 범위를 검색 하는 데 사용 됩니다. "Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="count" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" /> 및 <paramref name="count" />가 <paramref name="array" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <see cref="T:System.Array" />에서 마지막으로 검색한 요소를 반환합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소이고, 그렇지 않으면 <paramref name="T" /> 형식의 기본값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 를 개별적으로 전달 되는 <xref:System.Predicate%601>이동, 뒤로 <xref:System.Array>은 지난 요소의 시작 하 고 첫 번째 요소까지 합니다.  일치 하는 경우 처리가 중지 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, 및 <xref:System.Array.FindAll%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.Find%2A> 제네릭 메서드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` "Amargasaurus" 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는`Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindLast%2A> 제네릭 메서드는 배열의 끝부터 뒤로 검색 하는 데 사용 됩니다. 위치 5에서 "Dilophosaurus를" 요소를 찾습니다. <xref:System.Array.FindAll%2A> 제네릭 메서드는 "saurus"로 끝나는 모든 요소가 포함 된 배열을 반환 하는 데 사용 됩니다. 요소가 표시 됩니다.  
  
 코드 예제도 <xref:System.Array.Exists%2A> 및 <xref:System.Array.TrueForAll%2A> 제네릭 메서드.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 조건자에 정의된 조건과 일치하는 요소를 검색하여 <see cref="T:System.Array" /> 또는 그 일부에서 일치하는 요소 중 마지막 요소의 0부터 시작하는 인덱스를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <see cref="T:System.Array" />에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <xref:System.Array.FindLastIndex%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 하면서 각 요소를 차례로 끝에서 배열의 뒤로 이동 하는 메서드 오버 로드는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` 위치 5에 있는 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 배열의 위치 4에서 시작 하 고 뒤로 배열의 시작 부분을 계속 검색 하는 데 사용 됩니다. 위치 1에 있는 요소를 찾습니다. 마지막으로 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 세 요소 4 위치에서 시작 및 작업 (즉, 요소 4, 3 및 2)의 범위를 검색 하는 데 사용 됩니다. "Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 첫 번째 요소에서 지정된 인덱스로 확장하는 <see cref="T:System.Array" />의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 뒤로 검색 됩니다에 `startIndex` 첫 번째 요소의 끝입니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 시작 부분에서 요소 수는 `array` 를 `startIndex`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <xref:System.Array.FindLastIndex%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 하면서 각 요소를 차례로 끝에서 배열의 뒤로 이동 하는 메서드 오버 로드는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` 위치 5에 있는 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 배열의 위치 4에서 시작 하 고 뒤로 배열의 시작 부분을 계속 검색 하는 데 사용 됩니다. 위치 1에 있는 요소를 찾습니다. 마지막으로 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 세 요소 4 위치에서 시작 및 작업 (즉, 요소 4, 3 및 2)의 범위를 검색 하는 데 사용 됩니다. "Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" />입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정된 수의 요소가 들어 있고 지정된 인덱스에서 끝나는 <see cref="T:System.Array" />의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 뒤로 검색 됩니다에 `startIndex` 에서 끝나는 `startIndex` 뺀 `count` + 1, 경우 `count` 가 0 보다 크면 합니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Predicate%601>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `count`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <xref:System.Array.FindLastIndex%2A> 제네릭 메서드. 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다. 코드 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 하면서 각 요소를 차례로 끝에서 배열의 뒤로 이동 하는 메서드 오버 로드는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `true` 위치 5에 있는 요소에 대 한 합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 배열의 위치 4에서 시작 하 고 뒤로 배열의 시작 부분을 계속 검색 하는 데 사용 됩니다. 위치 1에 있는 요소를 찾습니다. 마지막으로 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 메서드 오버 로드는 세 요소 4 위치에서 시작 및 작업 (즉, 요소 4, 3 및 2)의 범위를 검색 하는 데 사용 됩니다. "Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="count" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" /> 및 <paramref name="count" />가 <paramref name="array" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">해당 요소에서 동작이 수행되는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="action">
          <c>array</c>의 각 요소에서 수행할 <see cref="T:System.Action`1" />입니다.</param>
        <summary>지정한 배열의 각 요소에서 지정한 동작을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> 개체에 동작을 수행 하는 메서드에 대리자에 전달 합니다.  요소 `array` 에 개별적으로 전달 되는 <xref:System.Action%601>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다. <xref:System.Array.ForEach%2A> 정수 배열에 각 요소의 제곱을 표시 합니다.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="action" />이 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IEnumerator" />의 <see cref="T:System.Array" />를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" />에 대한 <see cref="T:System.Array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>는 정의되지 않습니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 독점적으로 액세스할 수 있는 권한이 없으므로 컬렉션을 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법을 보여 줍니다 <xref:System.Array.GetEnumerator%2A> 배열 요소를 나열 합니다.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">길이를 지정해야 하는 <see cref="T:System.Array" />의 0부터 시작하는 차원입니다.</param>
        <summary>지정된 차원의 <see cref="T:System.Array" />에 있는 요소의 수를 나타내는 32비트 정수를 가져옵니다.</summary>
        <returns>지정된 차원의 요소 수를 나타내는 32비트 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예로 <xref:System.Array.GetLength%2A> 은 `GetLength(0)`, 첫 번째 차원에 있는 요소 수를 반환 하는 <xref:System.Array>합니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 <xref:System.Array.GetLength%2A> 의 순위에 다른 두 배열의 크기를 표시 합니다.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" />가 0보다 작은 경우  -또는-  <paramref name="dimension" />가 <see cref="P:System.Array.Rank" />보다 크거나 같습니다.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">길이를 지정해야 하는 <see cref="T:System.Array" />의 0부터 시작하는 차원입니다.</param>
        <summary>지정된 차원의 <see cref="T:System.Array" />에 있는 요소의 수를 나타내는 64비트 정수를 가져옵니다.</summary>
        <returns>지정된 차원의 요소 수를 나타내는 64비트 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예로 <xref:System.Array.GetLongLength%2A> 은 `GetLongLength(0)`, 첫 번째 차원에 있는 요소 수를 반환 하는 <xref:System.Array>합니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" />가 0보다 작은 경우  -또는-  <paramref name="dimension" />가 <see cref="P:System.Array.Rank" />보다 크거나 같습니다.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">시작 인덱스를 지정해야 하는 배열의 0부터 시작하는 차원입니다.</param>
        <summary>배열에서 지정된 차원의 첫 번째 요소의 인덱스를 가져옵니다.</summary>
        <returns>배열에서 지정된 차원의 첫 번째 요소의 인덱스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` 배열의 첫 번째 차원의 시작 하는 인덱스를 반환 하 고 `GetLowerBound(Rank - 1)` 배열의 마지막 차원 시작 하는 인덱스를 반환 합니다.  
  
 <xref:System.Array.GetLowerBound%2A> 배열이 비어 있는 경우에 메서드는 배열의 하한값의 인덱스를 나타내는 값을 항상 반환 합니다.  
  
 .NET Framework에서 대부분 배열은 0부터 시작 하는 없지만 (즉,는 <xref:System.Array.GetLowerBound%2A> 메서드는 배열의 각 차원에 대해 0을 반환 합니다.),.NET Framework에서는 0부터 시작 하지 않는 배열을 지원 합니다. 이러한 배열을 만들 수 있습니다는 <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> 메서드, 및 비관리 코드에서 반환 될 수 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드를 1 차원 및 2 차원 배열의 범위를 표시 하 고 배열 요소의 값을 표시 합니다.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" />가 0보다 작은 경우  -또는-  <paramref name="dimension" />가 <see cref="P:System.Array.Rank" />보다 크거나 같습니다.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">상한을 지정해야 하는 배열의 0부터 시작하는 차원입니다.</param>
        <summary>배열에서 지정된 차원의 마지막 요소의 인덱스를 가져옵니다.</summary>
        <returns>배열에 있는 지정된 차원의 마지막 요소의 인덱스이거나 지정된 차원이 비어 있는 경우 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` 배열의 첫 번째 차원에서 마지막 인덱스를 반환 하 고 `GetUpperBound(Rank - 1)` 배열의 마지막 차원 마지막 인덱스를 반환 합니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드를 1 차원 및 2 차원 배열의 범위를 표시 하 고 배열 요소의 값을 표시 합니다.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" />가 0보다 작은 경우  -또는-  <paramref name="dimension" />가 <see cref="P:System.Array.Rank" />보다 크거나 같습니다.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Array" />에 있는 지정한 요소의 값을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져올 <see cref="T:System.Array" /> 요소의 위치를 나타내는 32비트 정수입니다.</param>
        <summary>1차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <returns>1차원 <see cref="T:System.Array" />의 지정한 위치에 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드를 확인할 수 있는지 여부를 값 `index` 범위를 벗어났습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 1차원이 없는 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />가 현재 <see cref="T:System.Array" />의 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">가져올 <see cref="T:System.Array" /> 요소의 위치를 지정하는 인덱스를 나타내는 32비트 정수의 1차원 배열입니다.</param>
        <summary>다차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 32비트 정수 배열로 지정되어 있습니다.</summary>
        <returns>다차원 <see cref="T:System.Array" />의 지정한 위치에서 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소 수가 `indices` 차원 수와 같아야는 <xref:System.Array>합니다. 모든 요소는 `indices` 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <xref:System.Array>합니다.  
  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />의 차수가 <paramref name="indices" />에 있는 요소 수와 다른 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" />의 요소가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">가져올 <see cref="T:System.Array" /> 요소의 위치를 나타내는 64비트 정수입니다.</param>
        <summary>1차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <returns>1차원 <see cref="T:System.Array" />의 지정한 위치에 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드를 확인할 수 있는지 여부를 값 `index` 범위를 벗어났습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 1차원이 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 현재 <see cref="T:System.Array" />의 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">가져올 <see cref="T:System.Array" /> 요소의 위치를 지정하는 인덱스를 나타내는 64비트 정수의 1차원 배열입니다.</param>
        <summary>다차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 64비트 정수 배열로 지정되어 있습니다.</summary>
        <returns>다차원 <see cref="T:System.Array" />의 지정한 위치에서 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소 수가 `indices` 차원 수와 같아야는 <xref:System.Array>합니다. 모든 요소는 `indices` 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <xref:System.Array>합니다.  
  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />의 차수가 <paramref name="indices" />에 있는 요소 수와 다른 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" />의 요소가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">가져올 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="index2">가져올 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <summary>이차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <returns>이차원 <see cref="T:System.Array" />의 지정한 위치에 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 이차원이 없는 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 또는 <paramref name="index2" />가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">가져올 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="index2">가져올 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <summary>이차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <returns>이차원 <see cref="T:System.Array" />의 지정한 위치에 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 이차원이 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 또는 <paramref name="index2" />가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">가져올 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="index2">가져올 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="index3">가져올 <see cref="T:System.Array" /> 요소의 세 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <summary>삼차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <returns>삼차원 <see cref="T:System.Array" />의 지정한 위치에 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 삼차원이 없는 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> 또는 <paramref name="index3" />이 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">가져올 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="index2">가져올 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="index3">가져올 <see cref="T:System.Array" /> 요소의 세 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <summary>삼차원 <see cref="T:System.Array" />의 지정한 위치에서 값을 가져옵니다. 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <returns>삼차원 <see cref="T:System.Array" />의 지정한 위치에 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 삼차원이 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> 또는 <paramref name="index3" />이 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 개체를 검색하여 1차원 배열 또는 배열의 요소 범위에서 처음으로 일치하는 인덱스를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원 배열입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <summary>지정한 개체를 검색하여 1차원 배열에서 처음 검색된 개체의 인덱스를 반환합니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 <paramref name="array" />에서 처음 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 1 차원 arrayfor의 모든 요소를 검색 `value`합니다. 확인 하려면 여부 `value` 에 존재 `array`, 메서드가 각 요소를 호출 하 여 같음 비교를 수행할 `Equals` 일치 하는 항목을 찾을 때까지 메서드. 즉, 요소를 재정의 하는 경우는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드를 재정의 하는 호출 됩니다.  
  
 대부분의 배열은 0은 없으므로이 메서드가 일반적으로 – 1을 반환`value` 를 찾을 수 없습니다. 배열의 하 한에 해당 하는 드문 경우 <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 및 `value` 을 찾을 수 없으면이 메서드가 반환 <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 이 예에서는 호출의 다음 세 가지 오버 로드는 <xref:System.Array.IndexOf%2A> 메서드 문자열 배열에서 문자열로의 인덱스를 찾을 수:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>문자열의 첫 번째 확인 하는 문자열 배열에서 "the"입니다.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>문자열의 첫 번째 확인 하려면 "the" 문자열 배열의 마지막 요소에는 네 번째에 있습니다.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>문자열의 첫 번째 확인 하는 문자열에 "the" 배열에서 마지막으로 성공한 일치는 배열의 끝에 다음 요소에 있습니다.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원 배열입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">검색할 시작 인덱스입니다. 0은 빈 배열에서 유효합니다.</param>
        <summary>1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다. 범위는 지정한 인덱스에서 배열의 끝까지 확장됩니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 <paramref name="startIndex" />에서 마지막 요소로 확장하는 <paramref name="array" />의 요소 범위에서 처음 검색된 값의 인덱스이고, 그러지 않으면 배열의 하한에서 1을 뺀 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 검색 인덱스에 있는 요소에서 1 차원 배열 `startIndex` 부터 마지막 요소입니다. 확인 하려면 여부 `value` 에 존재 `array`, 메서드를 호출 하 여 같음 비교를 수행는 `Equals` 일치 하는 항목을 찾을 때까지 모든 요소의 메서드. 즉, 요소를 재정의 하는 경우는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드를 재정의 하는 호출 됩니다.  
  
 대부분의 배열은 0은 없으므로이 메서드가 일반적으로 – 1을 반환 `value` 를 찾을 수 없습니다. 배열의 하 한에 해당 하는 드문 경우 <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 및 `value` 을 찾을 수 없으면이 메서드가 반환 <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 경우 `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, 메서드가-1을 반환 합니다. 경우 `startIndex` 보다 크면 <xref:System.Array.Length%2A?displayProperty=nameWithType>, 메서드에서 throw 된 <xref:System.ArgumentOutOfRangeException>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 요소 수 `startIndex` 의 끝에 `array`합니다.  
  
   
  
## Examples  
 이 예에서는 호출의 다음 세 가지 오버 로드는 <xref:System.Array.IndexOf%2A> 메서드 문자열 배열에서 문자열로의 인덱스를 찾을 수:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>문자열의 첫 번째 확인 하는 문자열 배열에서 "the"입니다.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>문자열의 첫 번째 확인 하려면 "the" 문자열 배열의 마지막 요소에는 네 번째에 있습니다.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>문자열의 첫 번째 확인 하는 문자열에 "the" 배열에서 마지막으로 성공한 일치는 배열의 끝에 다음 요소에 있습니다.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원 배열입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">검색할 시작 인덱스입니다. 0은 빈 배열에서 유효합니다.</param>
        <param name="count">검색할 요소의 수입니다.</param>
        <summary>1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다. 범위는 지정한 요소 수에 대해 지정한 인덱스에서 확장됩니다.</summary>
        <returns>첫 번째 <paramref name="value" /> 발생의 인덱스가 <paramref name="array" />의 인덱스 범위(<paramref name="startIndex" /> ~ <paramref name="startIndex" /> + <paramref name="count" /> - 1)에 있으면 해당 인덱스이며 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 1 차원 arrayfrom의 요소를 검색 `startIndex` 를 `startIndex` 플러스 `count` 에서 1을 뺀 경우 `count` 가 0 보다 크면 합니다. 확인 하려면 여부 `value` 에 존재 `array`, 메서드를 호출 하 여 같음 비교를 수행는 `Equals` 일치 하는 항목을 찾을 때까지 모든 요소의 메서드. 즉, 요소를 재정의 하는 경우는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드를 재정의 하는 호출 됩니다.  
  
 Becausemost 배열은 있는 하한값 0으로,이 메서드는 일반적으로 경우-1을 반환 `value` 를 찾을 수 없습니다. 배열의 하 한에 해당 하는 드문 경우 <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) 및 `value` 을 찾을 수 없으면이 메서드가 반환 <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 경우 `startindex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, 메서드가-1을 반환 합니다. 경우 `startIndex` 보다 크면 <xref:System.Array.Length%2A?displayProperty=nameWithType>, 메서드에서 throw 된 <xref:System.ArgumentOutOfRangeException>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `count`합니다.  
  
   
  
## Examples  
 이 예에서는 호출의 다음 세 가지 오버 로드는 <xref:System.Array.IndexOf%2A> 메서드 문자열 배열에서 문자열로의 인덱스를 찾을 수:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>문자열의 첫 번째 확인 하는 문자열 배열에서 "the"입니다.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>문자열의 첫 번째 확인 하려면 "the" 문자열 배열의 마지막 요소에는 네 번째에 있습니다.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>문자열의 첫 번째 확인 하는 문자열에 "the" 배열에서 마지막으로 성공한 일치는 배열의 끝에 다음 요소에 있습니다. 값을 확인 하는 `count` 인수를 시작 하는 인덱스에서 배열의 상한을 뺍니다이 고 하나에 추가 합니다.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="count" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" /> 및 <paramref name="count" />가 <paramref name="array" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <summary>지정한 개체를 검색하여 1차원 배열에서 처음 검색된 개체의 인덱스를 반환합니다.</summary>
        <returns>전체 <paramref name="array" />에서 처음 검색된 <paramref name="value" />의 0부터 시작하는 인덱스이고, 검색되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 검색에 대 한 1 차원 배열의 모든 요소 `value`합니다. 확인 하려면 여부 `value` 에 존재 `array`, 메서드를 호출 하 여 같음 비교를 수행는 `T.Equals` 모든 요소에 대 한 메서드. 즉 `T` 재정의 <xref:System.Object.Equals%2A> 메서드를 재정의 하는 호출 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 제네릭 오버 로드를 모두는 <xref:System.Array.IndexOf%2A> 메서드. 문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 메서드 오버 로드는 처음부터 배열 검색 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하 여 배열 및 배열 끝까지 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다. 0은 빈 배열에서 유효합니다.</param>
        <summary>1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다. 범위는 지정한 인덱스에서 배열의 끝까지 확장됩니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 <paramref name="array" />에서 마지막 요소로 확장하는 <paramref name="startIndex" />의 요소 범위에서 처음 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 1 차원 배열에 있는 요소에서 검색 `startIndex` 배열의 끝에 있습니다. 확인 하려면 여부 `value` 에 존재 `array`, 메서드를 호출 하 여 같음 비교를 수행는 `T.Equals` 모든 요소에 대 한 메서드. 즉 `T` 재정의 <xref:System.Object.Equals%2A> 메서드를 재정의 하는 호출 됩니다.  
  
 경우 `startIndex` equals <xref:System.Array.Length%2A>, 메서드가 반환-1.If `startIndex` 보다 크면 <xref:System.Array.Length%2A?displayProperty=nameWithType>, 메서드에서 throw는 <xref:System.ArgumentOutOfRangeException>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 요소 수 `startIndex` 의 끝에 `array`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 제네릭 오버 로드를 모두는 <xref:System.Array.IndexOf%2A> 메서드. 문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 메서드 오버 로드는 처음부터 배열 검색 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하 여 배열 및 배열 끝까지 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다. 0은 빈 배열에서 유효합니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <summary>1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다. 범위는 지정한 요소 수에 대해 지정한 인덱스에서 확장됩니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 <paramref name="array" />부터 시작하여 <paramref name="startIndex" />에 지정된 수의 요소를 포함하는 <paramref name="count" />의 요소 범위에서 처음 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 searchesthe 요소에서 1 차원 배열의 `startIndex` 를 `startIndex` 플러스 `count` 에서 1을 뺀 경우 `count` 가 0 보다 큰 합니다. 확인 하려면 여부 `value` 에 존재 `array`, 메서드를 호출 하 여 같음 비교를 수행는 `T.Equals` 모든 요소에 대 한 메서드. 즉 `T` 재정의 <xref:System.Object.Equals%2A> 메서드를 재정의 하는 호출 됩니다.  
  
 경우 `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, 메서드가-1을 반환 합니다.  경우 `startIndex` 보다 크면 <xref:System.Array.Length%2A?displayProperty=nameWithType>, 메서드에서 throw 된 <xref:System.ArgumentOutOfRangeException>합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 제네릭 오버 로드를 모두는 <xref:System.Array.IndexOf%2A> 메서드. 문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 메서드 오버 로드는 처음부터 배열 검색 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하 여 배열 및 배열 끝까지 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="count" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" /> 및 <paramref name="count" />가 <paramref name="array" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 값 형식의 기본 생성자를 호출하여 값 형식 <see cref="T:System.Array" />의 모든 요소를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 값 형식의 배열을; 지원 되는 컴파일러에 있도록 디자인 되었습니다. 대부분의 사용자에이 메서드를 사용할 필요가 없습니다. 참조 형식에 사용할 수 해야 합니다.  
  
 경우는 <xref:System.Array> 값 유형이 아닙니다 <xref:System.Array> 값 형식에 기본 생성자가 없는 경우 또는 <xref:System.Array> 수정 되지 않습니다.  
  
 값 형식 <xref:System.Array> 한 및 원하는 개수의 차원이 있을 수 있습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Array.Length%2A>합니다.  
  
> [!CAUTION]
>  이 메서드를 사용 하 여; 생성자가 있는 값 형식에 대해서만 그러나 C#에 적용 되는 값 형식 생성자를 갖지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" />의 크기가 고정되어 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>이 속성은 모든 배열에 대해 항상 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 구현 하는 <xref:System.Array.IsFixedSize%2A> 속성에 필요 하기 때문에 <xref:System.Collections.IList?displayProperty=nameWithType> 인터페이스입니다.  
  
 크기가 고정된 된 배열을 배열을 만들 없지만 기존 요소는 수정할 수 있습니다 다음에 추가 하거나 제거할 요소의 수 없습니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" />가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 속성은 모든 배열에 대해 항상 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 구현 하는 <xref:System.Array.IsReadOnly%2A> 속성에 필요 하기 때문에 <xref:System.Collections.IList?displayProperty=nameWithType> 인터페이스입니다. 읽기 전용 배열을 배열의 만든 다음에 추가, 제거 또는 요소를 수정할 수 없습니다.  
  
 읽기 전용 컬렉션에서는 필요한 경우 사용 된 <xref:System.Collections> 구현 하는 클래스는 <xref:System.Collections.IList?displayProperty=nameWithType> 인터페이스입니다.  
  
 캐스팅 하거나를 변환 하는 경우는 <xref:System.Collections.IList> 인터페이스 개체는 <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> 속성에서 반환 `false`합니다. 그러나 캐스팅 하거나를 변환 하는 경우는 <xref:System.Collections.Generic.IList%601> 인터페이스는 `IsReadOnly` 속성에서 반환 `true`합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지를 나타내는 값을 가져옵니다.</summary>
        <value>이 속성은 모든 배열에 대해 항상 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 구현 하는 <xref:System.Array.IsSynchronized%2A> 속성에 필요 하기 때문에 <xref:System.Collections.ICollection?displayProperty=nameWithType> 인터페이스입니다.  
  
 .NET framework 클래스에 따라 <xref:System.Array> 사용 하 여 컬렉션의 동기화 된 버전 제공는 <xref:System.Array.SyncRoot%2A> 속성입니다.  
  
 배열을 사용 하는 클래스를 사용 하 여 동기화 직접 구현할 수도 <xref:System.Array.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야는 `SyncRoot` 컬렉션으로 만들어지므로 컬렉션의 합니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히, 컬렉션을 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 합니다. 일부 구현 <xref:System.Array.SyncRoot%2A> 를 반환할 수 있습니다는 <xref:System.Array> 자체입니다.  
  
 컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 열거 하는 동안 배열을 잠그는 방법을 보여 줍니다는 <xref:System.Array.SyncRoot%2A> 속성입니다.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1차원 <see cref="T:System.Array" /> 또는 <see cref="T:System.Array" /> 일부에서 지정한 값과 마지막으로 일치하는 요소의 인덱스를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <summary>지정한 개체를 검색하여 전체 1차원 <see cref="T:System.Array" /> 내에서 마지막으로 검색된 값의 인덱스를 반환합니다.</summary>
        <returns>검색된 <paramref name="value" />가 있으면 <paramref name="array" /> 전체에서 마지막으로 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 차원 <xref:System.Array> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.  
  
 요소를 사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드. 요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 `Equals` 해당 형식의 구현이 사용 됩니다.  
  
 이 메서드는-1 경우에 일반적으로 반환 대부분 배열은 하한값 0, 이므로 `value` 찾을 수 없습니다. 배열의 하 한에 해당 하는 드문 경우 <xref:System.Int32.MinValue?displayProperty=nameWithType> 및 `value` 발견 되지 않으면이 메서드가 반환 <xref:System.Int32.MaxValue?displayProperty=nameWithType>, 즉 `System.Int32.MinValue - 1`합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
 이 메서드는.NET Framework 버전 2.0에서에서 다음을 사용 합니다.는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 <xref:System.Array> 확인 하려면 여부는 <xref:System.Object> 에 지정 된는 `value` 매개 변수가 있습니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `value` <xref:System.Object> 자체입니다.  
  
 <xref:System.IComparable.CompareTo%2A> 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에서 지정 된 요소 중 마지막 요소의 인덱스를 결정 하는 방법을 보여 줍니다.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">뒤로 검색할 시작 인덱스입니다.</param>
        <summary>지정한 개체를 검색하여 첫 번째 요소에서 지정한 인덱스로 확장하는 1차원 <see cref="T:System.Array" />의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 첫 번째 요소에서 <paramref name="array" />로 확장하는 <paramref name="startIndex" />의 요소 범위에서 마지막으로 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 차원 <xref:System.Array> 뒤로 검색 됩니다에 `startIndex` 첫 번째 요소의 끝입니다.  
  
 요소를 사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드. 요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 `Equals` 해당 형식의 구현이 사용 됩니다.  
  
 이 메서드는-1 경우에 일반적으로 반환 대부분 배열은 하한값 0, 이므로 `value` 찾을 수 없습니다. 배열의 하 한에 해당 하는 드문 경우 <xref:System.Int32.MinValue?displayProperty=nameWithType> 및 `value` 발견 되지 않으면이 메서드가 반환 <xref:System.Int32.MaxValue?displayProperty=nameWithType>, 즉 `System.Int32.MinValue - 1`합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 시작 부분에서 요소 수는 `array` 를 `startIndex`합니다.  
  
 이 메서드는.NET Framework 버전 2.0에서에서 다음을 사용 합니다.는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 <xref:System.Array> 확인 하려면 여부는 <xref:System.Object> 에 지정 된는 `value` 매개 변수가 있습니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `value` <xref:System.Object> 자체입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에서 지정 된 요소 중 마지막 요소의 인덱스를 결정 하는 방법을 보여 줍니다.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">뒤로 검색할 시작 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <summary>지정한 개체를 검색하여 지정한 수의 요소를 포함하고 지정한 인덱스에서 끝나는 1차원 <see cref="T:System.Array" />의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 <paramref name="array" />에서 지정한 수의 요소를 포함하고 <paramref name="count" />에서 끝나는 <paramref name="startIndex" />의 요소 범위에서 마지막으로 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 차원 <xref:System.Array> 뒤로 검색 됩니다에 `startIndex` 에서 끝나는 `startIndex` 뺀 `count` + 1, 경우 `count` 가 0 보다 크면 합니다.  
  
 요소를 사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드. 요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는`Equals` 해당 형식의 구현이 사용 됩니다.  
  
 이 메서드는-1 경우에 일반적으로 반환 대부분 배열은 하한값 0, 이므로 `value` 찾을 수 없습니다. 배열의 하 한에 해당 하는 드문 경우 <xref:System.Int32.MinValue?displayProperty=nameWithType> 및 `value` 발견 되지 않으면이 메서드가 반환 <xref:System.Int32.MaxValue?displayProperty=nameWithType>, 즉 `System.Int32.MinValue - 1`합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `count`합니다.  
  
 이 메서드는.NET Framework 버전 2.0에서에서 다음을 사용 합니다.는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 <xref:System.Array> 확인 하려면 여부는 <xref:System.Object> 에 지정 된는 `value` 매개 변수가 있습니다. .NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `value` <xref:System.Object> 자체입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에서 지정 된 요소 중 마지막 요소의 인덱스를 결정 하는 방법을 보여 줍니다. <xref:System.Array.LastIndexOf%2A> 메서드는 역방향 검색 이므로, `count` 보다 작거나 같음 (`startIndex` 1을 더한 배열의 하한값에서 뺀).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="count" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" /> 및 <paramref name="count" />가 <paramref name="array" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <summary>지정한 개체를 검색하여 전체 <see cref="T:System.Array" />에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 <paramref name="array" /> 전체에서 마지막으로 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.  
  
 요소를 사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드. 요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 `Equals` 해당 형식의 구현이 사용 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제 모두 세 개의 제네릭 오버 로드는 <xref:System.Array.LastIndexOf%2A> 메서드. 문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 메서드 오버 로드에서 마지막으로 전체 배열 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 메서드 오버 로드는 이전 버전과 시작 인덱스 위치 3 배열 및 배열를 통해서는 검색 하는 데 사용 되 고 문자열의 첫 번째 항목을 찾습니다. 마지막으로 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <summary>지정한 개체를 검색하여 첫 번째 요소에서 지정한 인덱스로 확장하는 <see cref="T:System.Array" />의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 첫 번째 요소에서 <paramref name="array" />로 확장하는 <paramref name="startIndex" />의 요소 범위에서 마지막으로 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 뒤로 검색 됩니다에 `startIndex` 첫 번째 요소의 끝입니다.  
  
 요소를 사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드. 요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 `Equals` 해당 형식의 구현이 사용 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 의 시작 부분에서 요소 수는 `array` 를 `startIndex`합니다.  
  
   
  
## Examples  
 다음 코드 예제 모두 세 개의 제네릭 오버 로드는 <xref:System.Array.LastIndexOf%2A> 메서드. 문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 메서드 오버 로드에서 마지막으로 전체 배열 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 메서드 오버 로드는 이전 버전과 시작 인덱스 위치 3 배열 및 배열를 통해서는 검색 하는 데 사용 되 고 문자열의 첫 번째 항목을 찾습니다. 마지막으로 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">검색할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="value">
          <c>array</c>에서 찾을 개체입니다.</param>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <summary>지정한 개체를 검색하여 지정한 수의 요소를 포함하고 지정한 인덱스에서 끝나는 <see cref="T:System.Array" />의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</summary>
        <returns>
          <paramref name="value" />가 있을 경우 <paramref name="array" />에서 지정한 수의 요소를 포함하고 <paramref name="count" />에서 끝나는 <paramref name="startIndex" />의 요소 범위에서 마지막으로 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 뒤로 검색 됩니다에 `startIndex` 에서 끝나는 `startIndex` 뺀 `count` + 1, 경우 `count` 가 0 보다 크면 합니다.  
  
 요소를 사용 하 여 지정 된 값이 비교는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 메서드. 요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 `Equals` 해당 형식의 구현이 사용 됩니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `count`합니다.  
  
   
  
## Examples  
 다음 코드 예제 모두 세 개의 제네릭 오버 로드는 <xref:System.Array.LastIndexOf%2A> 메서드. 문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 메서드 오버 로드에서 마지막으로 전체 배열 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 메서드 오버 로드는 이전 버전과 시작 인덱스 위치 3 배열 및 배열를 통해서는 검색 하는 데 사용 되 고 문자열의 첫 번째 항목을 찾습니다. 마지막으로 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <paramref name="array" />의 유효한 인덱스 범위를 벗어납니다.  -또는-  <paramref name="count" />가 0보다 작습니다.  -또는-  <paramref name="startIndex" /> 및 <paramref name="count" />가 <paramref name="array" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 차원의 <see cref="T:System.Array" />에서 요소의 총수를 가져옵니다.</summary>
        <value>모든 차원에서 요소의 총 수는 <see cref="T:System.Array" />; 배열에 요소가 있는 경우에 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Array.Length%2A> 속성을 배열에서 요소의 총 수를 가져옵니다. 또한 사용 하 여는 <xref:System.Array.GetUpperBound%2A> 메서드 다차원 배열의 각 차원에 있는 요소의 수를 결정 합니다.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">배열이 다차원이고 <see cref="F:System.Int32.MaxValue" /> 요소보다 많이 포함된 경우</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" />의 모든 차원에 있는 요소의 총 수를 나타내는 64비트 정수를 가져옵니다.</summary>
        <value>모든 차원의 <see cref="T:System.Array" />에 있는 요소의 총 수를 나타내는 64비트 정수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" />의 순위(차원 수)를 가져옵니다. 예를 들어, 1차원 배열은 1을 반환하고, 2차원 배열은 2를 반환하는 방식입니다.</summary>
        <value>
          <see cref="T:System.Array" />의 순위(차원의 수)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 Visual Basic 코드  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 및 C# 코드  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 로 3 차원 배열을 만들기는 <xref:System.Array.Rank%2A> 속성 값이 3 인 합니다.  
  
 가변된 배열 (배열의 배열)는 1 차원 배열입니다. 값을 해당 <xref:System.Array.Rank%2A> 속성은 1입니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에서는 1 차원 배열, 2 차원 배열 및 가변된 배열을 초기화 하 고 검색 된 <xref:System.Array.Rank%2A> 각 속성입니다.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">크기를 조정할 1차원 배열(0부터 시작)이거나 지정한 크기로 새 배열을 만들 경우 <see langword="null" />입니다.</param>
        <param name="newSize">새 배열의 크기입니다.</param>
        <summary>1차원 배열의 요소 수를 지정된 새로운 크기로 변경합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 지정한 크기로 새 배열을 할당 하 고, 새 레코드로 이전 배열에서 요소를 복사, 한 다음 새 항목으로 이전 배열을 대체 합니다. `array` 1 차원 배열 이어야 합니다.  
  
 경우 `array` 은 `null`,이 메서드는 지정 된 크기로 새 배열을 만듭니다.  
  
 경우 `newSize` 보다 크면는 <xref:System.Array.Length%2A> 이전 배열의 새 배열을 할당 되 고 요소를 모두 새로운 이전 배열에서 복사 됩니다.  경우 `newSize` 는 보다 작은 <xref:System.Array.Length%2A> 이전 배열의 새 배열을 할당 하 고 요소가 복사 되 고 이전 배열에서 새로운 새 채워질 때까지 이전 배열에 있는 요소의 나머지는 무시 됩니다.  경우 `newSize` 같은지는 <xref:System.Array.Length%2A> 이전 배열의이 메서드는 없습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `newSize`합니다.  
  
 <xref:System.Array.Resize%2A> 메서드는 1 차원 배열 크기를 조정 합니다. <xref:System.Array> 클래스는 다차원 배열 크기 조정에 대 한 메서드는 포함 되지 않습니다. 이 수행 하려면 사용자 고유의 코드를 제공 하거나 타사 라이브러리의 특수 한 용도의 메서드를 호출 해야 합니다. 다음 코드에서는의 배열 크기를 조정 하는 방법에 대 한 구현 *n* 차원.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 다음 예제에서는 크기 조정 배열에 미치는 영향  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" />가 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1차원 <see cref="T:System.Array" /> 또는 <see cref="T:System.Array" />의 일부에 있는 요소의 순서를 역순으로 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">순서를 바꿀 1차원 <see cref="T:System.Array" />입니다.</param>
        <summary>1차원 <see cref="T:System.Array" /> 전체에 있는 요소의 시퀀스를 역순으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소에이 메서드를 호출한 후 `myArray[i]`여기서 `i` 는 배열에서 인덱스를 이동, `myArray[j]`여기서 `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
 다음 예제와 같이 <xref:System.Array.Reverse%2A> 가변된 배열이 되돌리려면 메서드를 사용할 수 있습니다. 현재 문화권의 달력에서 현재 연도의 각 달에 하나의 요소가 표시 된 가변된 배열을 초기화합니다. 각 요소는 해당 월의 일 수 만큼의 요소와 배열이 포함 됩니다. 이 예제에서는 배열, 호출의 내용을 표시는 <xref:System.Array.Reverse%2A> 메서드 및 역방향 배열의 내용 표시 합니다.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제에 있는 값의 정렬 순서 반대로 바꾸는 방법을 보여 줍니다.는 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">순서를 바꿀 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="index">순서를 바꿀 섹션의 시작 인덱스입니다.</param>
        <param name="length">순서를 바꿀 섹션에 있는 요소 수입니다.</param>
        <summary>1차원 <see cref="T:System.Array" />의 요소 범위에 있는 요소의 시퀀스를 역순으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소에이 메서드를 호출한 후 `myArray[i]`여기서 `i` 는 배열에서 인덱스를 이동, `myArray[j]`여기서 `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`합니다.  
  
 <xref:System.Array.Reverse%2A> 가변된 배열이 되돌리려면 메서드를 사용할 수 있습니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제에 있는 요소의 범위에 있는 값의 정렬 순서 반대로 바꾸는 방법을 보여 줍니다.는 <xref:System.Array>합니다.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Array" />의 지정한 요소를 지정한 값으로 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="index">설정할 <see cref="T:System.Array" /> 요소의 위치를 나타내는 32비트 정수입니다.</param>
        <summary>값을 1차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드를 확인할 수 있는지 여부를 값 `index` 범위를 벗어났습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 1차원이 없는 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />가 현재 <see cref="T:System.Array" />의 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="indices">설정할 요소의 위치를 지정하는 인덱스를 나타내는 32비트 정수의 1차원 배열입니다.</param>
        <summary>값을 다차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 32비트 정수 배열로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소 수가 `indices` 차원 수와 같아야는 <xref:System.Array>합니다. 모든 요소는 `indices` 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <xref:System.Array>합니다.  
  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드에 있는 값의 어느 것인지 확인 수는 `indices` 배열 범위를 벗어났습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />의 차수가 <paramref name="indices" />에 있는 요소 수와 다른 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" />의 요소가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="index">설정할 <see cref="T:System.Array" /> 요소의 위치를 나타내는 64비트 정수입니다.</param>
        <summary>값을 1차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드를 확인할 수 있는지 여부를 값 `index` 범위를 벗어났습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 1차원이 없는 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 현재 <see cref="T:System.Array" />의 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="indices">설정할 요소의 위치를 지정하는 인덱스를 나타내는 64비트 정수의 1차원 배열입니다.</param>
        <summary>값을 다차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 64비트 정수 배열로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소 수가 `indices` 차원 수와 같아야는 <xref:System.Array>합니다. 모든 요소는 `indices` 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <xref:System.Array>합니다.  
  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드에 있는 값의 어느 것인지 확인 수는 `indices` 배열 범위를 벗어났습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />의 차수가 <paramref name="indices" />에 있는 요소 수와 다른 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" />의 요소가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="index1">설정할 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="index2">설정할 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <summary>값을 이차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 이차원이 없는 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 또는 <paramref name="index2" />가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="index1">설정할 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="index2">설정할 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <summary>값을 이차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 이차원이 없는 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 또는 <paramref name="index2" />가 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="index1">설정할 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="index2">설정할 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <param name="index3">설정할 <see cref="T:System.Array" /> 요소의 세 번째 차원 인덱스를 나타내는 32비트 정수입니다.</param>
        <summary>값을 삼차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 32비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 삼차원이 없는 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> 또는 <paramref name="index3" />이 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">지정한 요소의 새 값입니다.</param>
        <param name="index1">설정할 <see cref="T:System.Array" /> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="index2">설정할 <see cref="T:System.Array" /> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <param name="index3">설정할 <see cref="T:System.Array" /> 요소의 세 번째 차원 인덱스를 나타내는 64비트 정수입니다.</param>
        <summary>값을 삼차원 <see cref="T:System.Array" />에 있는 지정한 위치의 요소로 설정합니다. 인덱스가 64비트 정수로 지정되어 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 및 <xref:System.Array.GetUpperBound%2A> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.  
  
 변환에 대 한 자세한 내용은 참조 <xref:System.Convert>합니다.  
  
 이 메서드는 o (1) 작업.  
  
> [!NOTE]
>  경우 <xref:System.Array.SetValue%2A> 할당 하는 데 사용 되 `null` 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다. 요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 삼차원이 없는 경우</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" />를 <see cref="T:System.Array" />의 요소 형식으로 캐스팅할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> 또는 <paramref name="index3" />이 현재 <see cref="T:System.Array" />의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1차원 배열의 요소를 정렬합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />입니다.</param>
        <summary>
          <see cref="T:System.Array" />에 있는 각 요소의 <see cref="T:System.IComparable" /> 구현을 사용하여 1차원 <see cref="T:System.Array" /> 전체의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소 `array` 구현 해야 합니다는 <xref:System.IComparable> 인터페이스를 다른 모든 요소와 비교할 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 값을 정렬 하는 방법을 보여 줍니다는 <xref:System.Array> 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다. 현재는 결과 <xref:System.Globalization.CultureInfo>합니다.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" />의 각 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />입니다.  -또는-  <see langword="null" />은 <c>키</c><see cref="T:System.Array" />만 정렬합니다.</param>
        <summary>각 키의 <see cref="T:System.Array" /> 구현을 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 1차원 <see cref="T:System.IComparable" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 각 키에는 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable> 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `keys`합니다.  
  
   
  
## Examples  
 다음 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다. 정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다. 현재는 결과 <xref:System.Globalization.CultureInfo>합니다.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" />가 다차원 배열인 경우  -또는-  <paramref name="items" /><see cref="T:System.Array" />가 다차원 배열입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 긴 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">정렬할 1차원 배열입니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" />를 사용하여 1차원 <see cref="T:System.Collections.IComparer" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 은 `null`의 각 요소 `array` 구현 해야 합니다는 <xref:System.IComparable> 인터페이스를 다른 모든 요소와 비교할 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
 .NET Framework에 포함 되어 미리 정의 된 <xref:System.Collections.IComparer> 다음 표에 나열 된 구현입니다.  
  
|구현|설명|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|형식의 두 개체를 비교 `T` 형식의 기본 정렬 순서를 사용 하 여 합니다.|  
  
 자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <xref:System.Collections.IComparer> 구현에는 `comparer` 매개 변수입니다. 이 예제는이 정의 하 여 수행 된 `ReverseComparer` 클래스에 대 한 기본 정렬 순서를 반대로 하 형식 인스턴스의 대/소문자 구분 문자열 비교를 수행 하 고 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 비교자를 사용 하 여 문자열 arrayby의 값을 정렬 합니다. 또한 사용자 지정을 정의 <xref:System.Collections.IComparer> 라는 구현 `ReverseComparer` 대/소문자 구분 문자열 비교를 수행 하는 동안 개체의 기본 정렬 순서를 반대로 하 합니다. 출력은 현재 문화권에 따라 달라질 수 있습니다는 참고 사항  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" />의 각 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />입니다.  -또는-  <see langword="null" />은 <c>키</c><see cref="T:System.Array" />만 정렬합니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" />를 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 1차원 <see cref="T:System.Collections.IComparer" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 경우 `comparer` 은 `null`, 각 키에서 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable> 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 .NET Framework에 포함 되어 미리 정의 된 <xref:System.Collections.IComparer> 다음 표에 나열 된 구현입니다.  
  
|구현|설명|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|형식의 두 개체를 비교 `T` 형식의 기본 정렬 순서를 사용 하 여 합니다.|  
  
 자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <xref:System.Collections.IComparer> 구현에는 `comparer` 매개 변수입니다. 이 예제는이 정의 하 여 수행 된 <xref:System.Collections.IComparer> 기본 정렬 순서를 바꾸는 및 대/소문자 구분 문자열 비교를 수행 하는 구현 합니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `keys`합니다.  
  
   
  
## Examples  
 다음 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다. 정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다. 현재는 결과 <xref:System.Globalization.CultureInfo>합니다.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" />가 다차원 배열인 경우  -또는-  <paramref name="items" /><see cref="T:System.Array" />가 다차원 배열입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 긴 경우  -또는-  <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="keys" /><see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 가능한 INCLUDE[net_v45](~/includes/net-v45-md.md)] 하는 정렬 작업 해당 previouslythrew <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <summary>
          <see cref="T:System.Array" />에 있는 각 요소의 <see cref="T:System.IComparable" /> 구현을 사용하여 1차원 <see cref="T:System.Array" />이 요소 범위에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소에 있는 요소의 지정된 된 범위 내 `array` 구현 해야 합니다는 <xref:System.IComparable> 인터페이스를 다른 모든 요소와 비교할 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 값을 정렬 하는 방법을 보여 줍니다는 <xref:System.Array> 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다. 현재는 결과 <xref:System.Globalization.CultureInfo>합니다.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" />의 각 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />입니다.  -또는-  <see langword="null" />은 <c>키</c><see cref="T:System.Array" />만 정렬합니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <summary>각 키의 <see cref="T:System.Array" /> 구현을 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 1차원 <see cref="T:System.IComparable" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 각 키에 있는 요소의 지정 된 범위에서의 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable> 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다. 정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다. 현재는 결과 <xref:System.Globalization.CultureInfo>합니다.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" />가 다차원 배열인 경우  -또는-  <paramref name="items" /><see cref="T:System.Array" />가 다차원 배열입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="keys" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 긴 경우  -또는-  <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="keys" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="items" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" />를 사용하여 1차원 <see cref="T:System.Collections.IComparer" />의 요소 범위에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 은 `null`, 각 요소에 있는 요소의 지정된 된 범위 내 `array` 구현 해야 합니다는 <xref:System.IComparable> 다른 모든 요소와 비교할 수 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 .NET Framework에 포함 되어 미리 정의 된 <xref:System.Collections.IComparer> 다음 표에 나열 된 구현입니다.  
  
|구현|설명|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|형식의 두 개체를 비교 `T` 형식의 기본 정렬 순서를 사용 하 여 합니다.|  
  
 자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <xref:System.Collections.IComparer> 구현에는 `comparer` 매개 변수입니다. 이 예제는이 정의 하 여 수행 된 `ReverseComparer` 클래스에 대 한 기본 정렬 순서를 반대로 하 형식 인스턴스의 대/소문자 구분 문자열 비교를 수행 하 고 합니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 값을 정렬 하는 방법을 보여 줍니다는 <xref:System.Array> 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다. 현재는 결과 <xref:System.Globalization.CultureInfo>합니다.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />입니다.</param>
        <param name="items">
          <c>keys</c>
          <see cref="T:System.Array" />의 각 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />입니다.  -또는-  <see langword="null" />은 <c>키</c><see cref="T:System.Array" />만 정렬합니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  -또는-  각 요소의 <see cref="T:System.IComparable" /> 구현을 사용할 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" />를 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 1차원 <see cref="T:System.Collections.IComparer" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 경우 `comparer` 은 `null`, 각 키에 있는 요소의 지정 된 범위에서는 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable> 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 .NET Framework에 포함 되어 미리 정의 된 <xref:System.Collections.IComparer> 다음 표에 나열 된 구현입니다.  
  
|구현|설명|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|형식의 두 개체를 비교 `T` 형식의 기본 정렬 순서를 사용 하 여 합니다.|  
  
 자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <xref:System.Collections.IComparer> 구현에는 `comparer` 매개 변수입니다. 이 예제는이 사용자 지정을 정의 하 여 수행 <xref:System.Collections.IComparer> 기본 정렬 순서를 바꾸는 및 대/소문자 구분 문자열 비교를 수행 하는 구현 합니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다. 정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다. 현재는 결과 <xref:System.Globalization.CultureInfo>합니다.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" />가 다차원 배열인 경우  -또는-  <paramref name="items" /><see cref="T:System.Array" />가 다차원 배열입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="keys" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 하한이 <paramref name="items" />의 하한과 일치하지 않는 경우  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 큽니다.  -또는-  <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="keys" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="items" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="keys" /><see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <summary>
          <see cref="T:System.Array" />에 있는 각 요소의 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 구현을 사용하여 전체 <see cref="T:System.Array" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소 `array` 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> 제네릭 메서드 오버 로드와 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 제네릭 메서드 오버 로드 합니다. 임의의 순서로 문자열 배열을 만들어집니다.  
  
 배열은 표시 하 고 정렬 하 고 다시 표시 됩니다.  
  
> [!NOTE]
>  에 대 한 호출에서 <xref:System.Array.Sort%2A> 및 <xref:System.Array.BinarySearch%2A> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다. 배열 및 반환 값은 <xref:System.Array.BinarySearch%2A> 메서드에 전달 되는 `ShowWhere` 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다. 인덱스는 문자열이 n 경우 음수 배열에 하므로 `ShowWhere` 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1) 검색 stri 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 ng 합니다.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 제네릭 인터페이스 구현이거나 각 요소의 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 구현을 사용할 경우 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" /> 제네릭 인터페이스를 사용하여 <see cref="T:System.Collections.Generic.IComparer`1" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 은 `null`의 각 요소 `array` 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 제네릭 메서드 오버 로드와 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 제네릭 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 배열은 표시 하 고 정렬 하 고 다시 표시 됩니다. 배열을 사용 하기 위해 정렬 해야는 <xref:System.Array.BinarySearch%2A> 메서드.  
  
> [!NOTE]
>  에 대 한 호출에서 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 및 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다. 배열 및 반환 값은 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 메서드에 전달 되는 `ShowWhere` 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다. 인덱스는 문자열이 n 경우 음수 배열에 하므로 `ShowWhere` 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1) 검색 stri 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 ng 합니다.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="comparison">요소를 비교할 때 사용할 <see cref="T:System.Comparison`1" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" />을 사용하여 <see cref="T:System.Comparison`1" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교 메서드를 정의 `CompareDinosByLength`합니다. 이 방법은 다음과 같습니다: 테스트는 comparandsare 먼저`null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열이 큰 것으로 간주 됩니다. 셋째, 길이 값이 같으면 일반 문자열 비교 ´ ù.  
  
 문자열의 배열 만들어지고 특정 순서 없이에서 4 개의 문자열 채워집니다. 목록에는 빈 문자열과 null 참조가 포함 됩니다. 사용 하 여 정렬 목록이 표시 되는 <xref:System.Comparison%601> 나타내는 제네릭 대리자는 `CompareDinosByLength` 메서드를 다시 표시 합니다.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="comparison" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparison" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparison" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <summary>
          <see cref="T:System.Array" />에 있는 각 요소의 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 구현을 사용하여 <see cref="T:System.Array" />의 요소 범위에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소에 있는 요소의 지정된 된 범위 내 `array` 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 제네릭 메서드 오버 로드와 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 배열 범위를 정렬 하는 것에 대 한 제네릭 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 코드 예제에서는 만들고 세 육 식 동물 (정확 하 게 티라) 3 초 식으로 구성 된 공룡 이름의 배열을 표시 합니다. <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 제네릭 메서드 오버 로드 하는 데 다음 표시 되는 배열의 마지막 세 요소를 정렬 합니다. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 제네릭 메서드 오버 로드를 사용 `ReverseCompare` 마지막 세 요소를 반대 순서로 정렬 합니다. 완전히 바뀐된 공룡의 다시 표시 됩니다.  
  
> [!NOTE]
>  에 대 한 호출에서 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 및 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">정렬할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 제네릭 인터페이스 구현이거나 각 요소의 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 구현을 사용할 경우 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" /> 제네릭 인터페이스를 사용하여 <see cref="T:System.Collections.Generic.IComparer`1" />의 요소 범위에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 은 `null`, 각 요소에 있는 요소의 지정된 된 범위 내 `array` 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 `array`합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 제네릭 메서드 오버 로드와 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 배열 범위를 정렬 하는 것에 대 한 제네릭 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 코드 예제에서는 만들고 세 육 식 동물 (정확 하 게 티라) 3 초 식으로 구성 된 공룡 이름의 배열을 표시 합니다. <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 제네릭 메서드 오버 로드 하는 데 다음 표시 되는 배열의 마지막 세 요소를 정렬 합니다. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 제네릭 메서드 오버 로드를 사용 `ReverseCompare` 마지막 세 요소를 반대 순서로 정렬 합니다. 완전히 바뀐된 공룡의 다시 표시 됩니다.  
  
> [!NOTE]
>  에 대 한 호출에서 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 및 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="array" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">키 배열 요소의 형식입니다.</typeparam>
        <typeparam name="TValue">항목 배열 요소의 형식입니다.</typeparam>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="items">
          <c>keys</c>의 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)이거나 <c>keys</c>만 정렬할 경우 <see langword="null" />입니다.</param>
        <summary>각 키의 <see cref="T:System.Array" /> 제네릭 인터페이스 구현을 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 <see cref="T:System.IComparable`1" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 각 키에는 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, 및 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다. 다음 배열 정렬 이며 여러 번 표시 됩니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 오버 로드와의 인스턴스 `ReverseCompare` 쌍을 이루는 배열의 정렬 순서를 반대로 하는 데 사용 됩니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 두 배열의 마지막 세 요소를 정렬 하려면 오버 로드를 사용 합니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 오버 로드는 두 배열의 마지막 세 요소를 반대 순서로 정렬할 하는 데 사용 됩니다.  
  
> [!NOTE]
>  Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 하한이 <paramref name="items" />의 하한과 일치하지 않는 경우  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 큽니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">키 배열 요소의 형식입니다.</typeparam>
        <typeparam name="TValue">항목 배열 요소의 형식입니다.</typeparam>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="items">
          <c>keys</c>의 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)이거나 <c>keys</c>만 정렬할 경우 <see langword="null" />입니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 제네릭 인터페이스 구현이거나 각 요소의 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 구현을 사용할 경우 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" /> 제네릭 인터페이스를 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 <see cref="T:System.Collections.Generic.IComparer`1" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 경우 `comparer` 은 `null`, 각 키에서 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, 및 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다. 다음 배열 정렬 이며 여러 번 표시 됩니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 오버 로드와의 인스턴스 `ReverseCompare` 정렬 순서를 반대로 하는 데 사용 됩니다 쌍으로 연결 된 배열입니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 두 배열의 마지막 세 요소를 정렬 하려면 오버 로드를 사용 합니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 오버 로드는 두 배열의 마지막 세 요소를 반대 순서로 정렬할 하는 데 사용 됩니다.  
  
> [!NOTE]
>  Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 하한이 <paramref name="items" />의 하한과 일치하지 않는 경우  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 큽니다.  -또는-  <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="keys" /><see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">키 배열 요소의 형식입니다.</typeparam>
        <typeparam name="TValue">항목 배열 요소의 형식입니다.</typeparam>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="items">
          <c>keys</c>의 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)이거나 <c>keys</c>만 정렬할 경우 <see langword="null" />입니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <summary>각 키에서 구현하는 <see cref="T:System.Array" /> 제네릭 인터페이스를 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 <see cref="T:System.IComparable`1" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 에 있는 요소의 지정 된 범위 내에서 각 키의 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, 및 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드를 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다. 다음 배열 정렬 이며 여러 번 표시 됩니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 오버 로드와의 인스턴스 `ReverseCompare` 쌍을 이루는 배열의 정렬 순서를 반대로 하는 데 사용 됩니다.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > 오버 로드 하는 데 두 배열의 마지막 세 요소를 정렬 합니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 오버 로드는 두 배열의 마지막 세 요소를 반대 순서로 정렬할 하는 데 사용 됩니다.  
  
> [!NOTE]
>  Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="keys" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 하한이 <paramref name="items" />의 하한과 일치하지 않는 경우  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 큽니다.  -또는-  <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="keys" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="items" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">키 배열 요소의 형식입니다.</typeparam>
        <typeparam name="TValue">항목 배열 요소의 형식입니다.</typeparam>
        <param name="keys">정렬할 키를 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="items">
          <c>keys</c>의 키에 해당하는 항목을 포함하는 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)이거나 <c>keys</c>만 정렬할 경우 <see langword="null" />입니다.</param>
        <param name="index">정렬할 범위의 시작 인덱스입니다.</param>
        <param name="length">정렬할 범위에 있는 요소 수입니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 제네릭 인터페이스 구현이거나 각 요소의 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 구현을 사용할 경우 <see langword="null" />입니다.</param>
        <summary>지정한 <see cref="T:System.Array" /> 제네릭 인터페이스를 사용하여 첫 번째 <see cref="T:System.Array" />에 있는 키를 기반으로 하는 한 쌍의 <see cref="T:System.Collections.Generic.IComparer`1" /> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키에는 `keys` <xref:System.Array> 해당 항목에는 `items` <xref:System.Array>합니다. 키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 `items` <xref:System.Array> 마찬가지로 위치가 변경 합니다. 따라서는 `items` <xref:System.Array> 에 해당 하는 키의 배열에 따라 정렬 된 `keys` <xref:System.Array>합니다.  
  
 경우 `comparer` 은 `null`, 각 키에 있는 요소의 지정 된 범위에서는 `keys` <xref:System.Array> 구현 해야 합니다는 <xref:System.IComparable%601> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.  
  
 키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다. 정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <xref:System.ArgumentException>합니다.  
  
 정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.  
  
 이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.  
  
-   사용 하 여 파티션 크기를 16 개 요소 경우는 [삽입 정렬](https://en.wikipedia.org/wiki/Insertion_sort) 알고리즘입니다.  
  
-   파티션 수가 2를 초과 하는 경우 * 로그<sup>N</sup>여기서 *N* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 사용는 [Quicksort](https://en.wikipedia.org/wiki/Quicksort) 알고리즘입니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (`n` 로그 `n`) 작업, 여기서 `n` 은 `length`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, 및 [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드 합니다.  
  
 코드 예제에서는 문자열에 대 한 대체 비교자 정의 `ReverseCompare`를 구현 하는 `IComparer<string>`(`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자를 호출 하 여는 <xref:System.String.CompareTo%28System.String%29> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.  
  
 코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다. 다음 배열 정렬 이며 여러 번 표시 됩니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 오버 로드와의 인스턴스 `ReverseCompare` 쌍을 이루는 배열의 정렬 순서를 반대로 하는 데 사용 됩니다.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 두 배열의 마지막 세 요소를 정렬 하려면 오버 로드를 사용 합니다.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 오버 로드를 사용 하는 마지막 세 정렬 하려면 요소가 모두 반대 순서로 배열입니다.  
  
> [!NOTE]
>  Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다. 사용 하는 경우는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <paramref name="keys" />의 하한값보다 작습니다.  -또는-  <paramref name="length" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 하한이 <paramref name="items" />의 하한과 일치하지 않는 경우  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="keys" />의 길이가 <paramref name="items" />의 길이보다 큽니다.  -또는-  <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="keys" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="items" />가 <see langword="null" />이 아니고 <paramref name="index" /> 및 <paramref name="length" />가 <paramref name="items" /><see cref="T:System.Array" />의 올바른 범위를 지정하지 않습니다.  -또는-  <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 <paramref name="keys" /><see cref="T:System.Array" />의 요소 중 하나 이상이 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스를 구현하지 않는 경우</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다. Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <see cref="T:System.IndexOutOfRangeException" /> 예외를 throw 하 고는 <see cref="T:System.ArgumentException" /> 호출자에 게는 예외입니다. 부터는 [! 이전에 정렬 작업에서 발생 했습니다 수 있기 INCLUDE[net_v45](~/includes/net-v45-md.md)] <see cref="T:System.ArgumentException" /> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다. 대부분의 경우 16 개 요소 배열에 적용 됩니다.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Array" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 구현 하는 <xref:System.Collections.ICollection?displayProperty=nameWithType> 인터페이스입니다.  
  
 .NET framework 클래스에 따라 <xref:System.Array> 사용 하 여 컬렉션의 동기화 된 버전 제공는 <xref:System.Array.SyncRoot%2A> 속성입니다.  
  
 배열을 사용 하는 클래스를 사용 하 여 동기화 직접 구현할 수도 <xref:System.Array.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야는 `SyncRoot` 컬렉션으로 만들어지므로 컬렉션의 합니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히, 컬렉션을 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 합니다. 일부 구현 <xref:System.Array.SyncRoot%2A> 를 반환할 수 있습니다는 <xref:System.Array> 자체입니다.  
  
 컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 열거 하는 동안 배열을 잠그는 방법을 보여 줍니다는 <xref:System.Array.SyncRoot%2A> 속성입니다.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" />에 포함된 요소 수를 가져옵니다.</summary>
        <value>컬렉션에 포함된 요소 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.ICollection> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">개체가 <see cref="T:System.Collections.IList" />에 추가됩니다.</param>
        <summary>이 메서드를 호출하면 <see cref="T:System.NotSupportedException" /> 예외가 항상 throw됩니다.</summary>
        <returns>배열에 값을 추가하는 것은 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> 구현 컬렉션에 멤버를 추가 합니다. 그러나 배열 크기는 고정된 되어 때문에 (의 <xref:System.Array.IsFixedSize%2A> 속성은 항상 반환 `true`),이 메서드는 항상 throw 한 <xref:System.NotSupportedException> 예외입니다.  
  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" />가 고정 크기입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IList" />에서 항목을 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">현재 목록에서 찾을 개체입니다. 찾을 요소는 참조 형식에 대해 <see langword="null" />이 될 수 있습니다.</param>
        <summary>
          <see cref="T:System.Collections.IList" />에 요소가 있는지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="value" />에 있으면 <see cref="T:System.Collections.IList" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">현재 목록에서 찾을 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.IList" />에서 특정 항목의 인덱스를 결정합니다.</summary>
        <returns>목록에 값이 있으면 해당 값의 인덱스이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <c>값</c>을 삽입할 인덱스입니다.</param>
        <param name="value">삽입할 개체입니다.</param>
        <summary>항목을 <see cref="T:System.Collections.IList" />의 지정된 인덱스에 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <see cref="T:System.Collections.IList" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" />이 읽기 전용인 경우  -또는-  <see cref="T:System.Collections.IList" />의 크기가 고정되어 있습니다.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" />가 <see cref="T:System.Collections.IList" />에서 null 참조인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져오거나 설정할 요소의 인덱스입니다.</param>
        <summary>지정한 인덱스에 있는 요소를 가져오거나 설정합니다.</summary>
        <value>지정한 인덱스의 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작은 경우  -또는-  <paramref name="index" />가 <see cref="P:System.Collections.ICollection.Count" />보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentException">현재 <see cref="T:System.Array" />에 1차원이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.IList" />에서 제거할 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.IList" />에서 맨 처음 발견되는 특정 개체를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" />이 읽기 전용인 경우  -또는-  <see cref="T:System.Collections.IList" />의 크기가 고정되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">제거할 요소의 인덱스입니다.</param>
        <summary>지정한 인덱스에서 <see cref="T:System.Collections.IList" /> 항목을 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IList> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">인덱스는 <see cref="T:System.Collections.IList" />의 유효한 인덱스가 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" />이 읽기 전용인 경우  -또는-  <see cref="T:System.Collections.IList" />의 크기가 고정되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">현재 인스턴스와 비교할 개체입니다.</param>
        <param name="comparer">현재 개체와 <c>other</c>를 비교하는 개체입니다.</param>
        <summary>정렬 순서에서 현재 컬렉션 개체의 위치가 다른 개체보다 앞인지, 뒤인지 또는 동일한지를 확인합니다.</summary>
        <returns>다음 표와 같이 현재 컬렉션 개체와 다른 개체 사이의 관계를 나타내는 정수입니다.  
  
 <list type="table"><listheader><term> 반환 값  </term><description> 설명  </description></listheader><item><term> -1 </term><description> 현재 인스턴스가 <paramref name="other" /> 앞에 옵니다.  </description></item><item><term> 0  </term><description> 현재 인스턴스와 <paramref name="other" />가 같습니다.  </description></item><item><term> 1  </term><description> 현재 인스턴스가 <paramref name="other" /> 뒤에 옵니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IStructuralComparable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">현재 인스턴스와 비교할 개체입니다.</param>
        <param name="comparer">현재 인스턴스와 <c>other</c>이 같은지를 확인하는 개체입니다.</param>
        <summary>개체가 현재 인스턴스와 같은지를 확인합니다.</summary>
        <returns>두 개체가 같으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IStructuralEquatable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">현재 개체의 해시 코드를 계산하는 개체입니다.</param>
        <summary>현재 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>현재 인스턴스에 대한 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Array> 인스턴스가 <xref:System.Collections.IStructuralEquatable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">배열 요소의 형식입니다.</typeparam>
        <param name="array">조건에 대해 확인할 1차원 <see cref="T:System.Array" />(인덱스는 0부터 시작)입니다.</param>
        <param name="match">요소에 대해 확인할 조건을 정의하는 조건자입니다.</param>
        <summary>배열의 모든 요소가 지정한 조건자에 정의된 조건과 일치하는지를 확인합니다.</summary>
        <returns>
          <paramref name="array" />의 모든 요소가 지정한 조건자에 정의된 조건과 일치하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 배열에 요소가 없으면 반환 값은 <see langword="true" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자`true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  요소 `array` 를 개별적으로 전달 되는 <xref:System.Predicate%601>, 대리자는 반환 될 때 처리가 중지 됩니다 `false` 모든 요소에 대 한 합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 는 <xref:System.Array.Length%2A> 의 `array`합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 배열의 각 요소에에서의 마지막 문자가 숫자 인지 확인 합니다. 두 개의 문자열 배열을 만듭니다. 첫 번째 arrayincludes 모두 알파벳 문자로 끝나는 문자열 및 숫자 문자로 끝나는 문자열. 두 번째 배열 숫자 문자로 끝나는 문자열만 구성 됩니다. 이 예제에서는 또한 정의 `EndWithANumber` 서명과 일치 하는 메서드는 <xref:System.Predicate%601> 위임 합니다. 각 배열에 전달 된 <xref:System.Array.TrueForAll%2A> 메서드를 나타내는 대리자과 함께 `EndsWithANumber` 메서드.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 다음 예제는은 첫 번째 제외 하는 문자열 배열에 전달 된 <xref:System.Array.TrueForAll%2A> 메서드는 특정 배열 요소 숫자의 문자열 표현으로 끝나는지 여부를 확인 하는 람다 식과 함께 합니다.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 두 경우 모두는 <xref:System.Array.TrueForAll%2A> 메서드 반환 `false` 숫자에 종료 하지 않는 첫 번째 배열 요소를 발견 되는 즉시 합니다. 그렇지 않으면 반환 `true` 배열의 모든 요소를 반복 하면 됩니다.  
  
> [!NOTE]
>  만들 필요가 없다는 두 예와 같이, C# 및 Visual Basic의 경우에 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우  -또는-  <paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>