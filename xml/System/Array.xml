<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Array.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b335c7a4c2bf211f02463ddce0008b2f15f2e6b0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b335c7a4c2bf211f02463ddce0008b2f15f2e6b0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</source>
          <target state="translated">배열을 만들고, 조작하고, 검색 및 정렬하여 공용 언어 런타임에서 모든 배열의 기본 클래스 역할을 수행하도록 하는 메서드를 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is not part of the <ph id="ph2">&lt;xref:System.Collections&gt;</ph> namespaces.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 클래스가 않습니다의 일부가 <ph id="ph2">&lt;xref:System.Collections&gt;</ph> 네임 스페이스입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, it is still considered a collection because it is based on the <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">그러나 여전히 이라고 컬렉션에 기반 하므로 <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is the base class for language implementations that support arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 클래스는 배열을 지 원하는 언어 구현에 대 한 기본 클래스입니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">그러나 시스템 및 컴파일러에서 명시적으로 파생 될 수 있습니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Users should employ the array constructs provided by the language.</source>
          <target state="translated">사용자는 언어에서 제공 하는 배열 구문을 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An element is a value in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">요소에는 프로그램 <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The length of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the total number of elements it can contain.</source>
          <target state="translated">길이 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 포함할 수 있는 요소의 총 수입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The lower bound of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the index of its first element.</source>
          <target state="translated">하 한 범위는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 첫 번째 요소의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound, but it has a lower bound of zero by default.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 모든 하한값을 가질 수 있지만 그 값은 기본적으로 0입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>A different lower bound can be defined when creating an instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class using <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>.A multidimensional <ph id="ph3">&lt;xref:System.Array&gt;</ph> can have different bounds for each dimension.</source>
          <target state="translated">인스턴스를 만들 때 다른 하 한을 정의할 수 있습니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 클래스 사용 <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>합니다. 다차원 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 각 차원에 대해 서로 다른 범위를 가질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An array can have a maximum of 32 dimensions.</source>
          <target state="translated">배열에는 최대 32 차원 초과 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Unlike the classes in the <ph id="ph1">&lt;xref:System.Collections&gt;</ph> namespaces, <ph id="ph2">&lt;xref:System.Array&gt;</ph> has a fixed capacity.</source>
          <target state="translated">클래스와 달리는 <ph id="ph1">&lt;xref:System.Collections&gt;</ph> 네임 스페이스, <ph id="ph2">&lt;xref:System.Array&gt;</ph> 용량이 고정 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To increase the capacity, you must create a new <ph id="ph1">&lt;xref:System.Array&gt;</ph> object with the required capacity, copy the elements from the old <ph id="ph2">&lt;xref:System.Array&gt;</ph> object to the new one, and delete the old <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">용량을 늘리려면 새 만들어야 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 필요한 용량으로 개체, 이전에서 요소를 복사 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 새 레코드로 개체를 삭제 하면 이전 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>By default, the maximum size of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is 2 gigabytes (GB).</source>
          <target state="translated">기본적으로의 최대 크기는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 은 2gb (기가바이트)입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In a 64-bit environment, you can avoid the size restriction by setting the <ph id="ph1">`enabled`</ph> attribute of the <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
          <target state="translated">64 비트 환경에서 크기 제한을 설정 하 여 방지할 수 있습니다는 <ph id="ph1">`enabled`</ph> 특성에는 <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> 구성 요소를 <ph id="ph2">`true`</ph> 런타임 환경에서 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</source>
          <target state="translated">그러나 배열의 지정 된 차원 (바이트 배열 및 단일 바이트 구조의 배열에 대 한 0X7FFFFFC7)에 0X7FEFFFFF의 최대 인덱스는 총 4 십억 요소로 제한 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Single-dimensional arrays implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> generic interfaces.</source>
          <target state="translated">1 차원 배열 구현는 <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">구현이 실행 시 배열에 제공 되 고 결과적으로, 제네릭 인터페이스에 대 한 선언 구문에 표시 되지 않습니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</source>
          <target state="translated">또한 제네릭 인터페이스의 형식 (명시적 인터페이스 구현)를 캐스팅 하 여만 액세스할 수 있는 인터페이스 멤버에 대 한 참조 항목 없음 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">이러한 인터페이스 중 하나를 캐스팅할 때 알고 있어야 하 고는 구성원을 추가, 삽입 또는 제거 요소 throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects provide information about array type declarations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> 개체 배열 형식 선언에 대 한 정보를 제공합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> objects with the same array type share the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 배열 형식이 같은 개체를 공유 하는 동일한 <ph id="ph2">&lt;xref:System.Type&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> might not return the expected results with <ph id="ph3">&lt;xref:System.Array&gt;</ph> because if an array is cast to the type <ph id="ph4">&lt;xref:System.Array&gt;</ph>, the result is an object, not an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> 예상된 결과에 반환 되지 않을 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 때문에 배열 형식으로 캐스팅 된 경우 <ph id="ph4">&lt;xref:System.Array&gt;</ph>, 결과 배열이 아닌 개체입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>That is, <ph id="ph1">`typeof(System.Array).IsArray`</ph> returns <ph id="ph2">`false`</ph>, and <ph id="ph3">`typeof(System.Array).GetElementType`</ph> returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">즉, <ph id="ph1">`typeof(System.Array).IsArray`</ph> 반환 <ph id="ph2">`false`</ph>, 및 <ph id="ph3">`typeof(System.Array).GetElementType`</ph> 반환 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> 동일한 유형 배열 간의 뿐만 아니라 하지만 서로 다른 형식의 표준 배열 간에 요소를 복사 하는 메서드, 형식 캐스팅을 자동으로 처리 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Some methods, such as <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</source>
          <target state="translated">일부 메서드와 같은 <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, 및 <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, 대용량 배열을 위한에 매개 변수로 64 비트 정수를 받아들이는 오버 로드를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> return 64-bit integers indicating the length of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> 배열의 길이 나타내는 64 비트 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 정렬할 보장 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Array&gt;</ph> prior to performing operations (such as <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to be sorted.</source>
          <target state="translated">정렬 해야는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 작업을 수행 하기 전에 (같은 <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) 해야 하는 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 정렬할 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Using an <ph id="ph1">&lt;xref:System.Array&gt;</ph> object of pointers in native code is not supported and will throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> for several methods.</source>
          <target state="translated">사용 하는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 네이티브 코드에 대 한 포인터의 개체는 지원 되지 않으며를 throw 합니다는 <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> 여러 가지 방법에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example shows how <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> copies elements between an array of type integer and an array of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">다음 코드 예제와 방법을 <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> 간에 정수 형식의 배열 및 배열 형식의 요소를 복사 <ph id="ph2">&lt;xref:System.Object&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example creates and initializes an <ph id="ph1">&lt;xref:System.Array&gt;</ph> and displays its properties and its elements.</source>
          <target state="translated">다음 코드 예제를 만들고 초기화는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 해당 속성 및 해당 요소를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">공용 정적 (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> Visual basic에서)이 형식의 멤버는 스레드로부터 안전 합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">인터페이스 멤버는 스레드로부터 안전하지 않습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>This implementation does not provide a synchronized (thread safe) wrapper for an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; however, .NET Framework classes based on <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> property.</source>
          <target state="translated">이 구현에서는 동기화 된 제공 하지 않습니다 (스레드로부터 안전함) 래퍼에 대 한는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>있지만.NET Framework 클래스에 따라 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> 사용 하 여 컬렉션의 동기화 된 버전 제공는 <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> 속성.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The one-dimensional, zero-based array to wrap in a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper.</source>
          <target state="translated">읽기 전용 <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> 래퍼에서 래핑할 1차원 배열(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>Returns a read-only wrapper for the specified array.</source>
          <target state="translated">지정한 배열의 읽기 전용 래퍼를 반환합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper for the specified array.</source>
          <target state="translated">지정한 배열의 읽기 전용 <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> 래퍼입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>To prevent any modifications to the array, expose the array only through this wrapper.</source>
          <target state="translated">배열에 대 한 수정을 방지 하려면이 래퍼를 통해서만 배열을 노출 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The following example wraps an array in a read-only <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</source>
          <target state="translated">다음 예에서는 읽기 전용 배열을 래핑하 <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches a one-dimensional sorted <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> for a value, using a binary search algorithm.</source>
          <target state="translated">이진 검색 알고리즘을 사용하여 1차원으로 정렬된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 값을 검색합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원으로 정렬된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified object.</source>
          <target state="translated">배열의 각 요소 및 지정한 개체에서 구현되는 <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 사용하여 1차원으로 정렬된 배열에서 특정 요소를 검색합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">중 하나 <ph id="ph1">`value`</ph> 또는의 모든 요소가 <ph id="ph2">`array`</ph> 구현 해야 합니다는 <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> 비교에 사용 되는 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If<ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">경우<ph id="ph1">`value`</ph> 를 구현 하지 않습니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 인터페이스의 요소 <ph id="ph3">`array`</ph> 에 대 한 테스트 되지 않습니다 <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> 검색을 시작 하기 전에.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 예외가 생성 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> to locate a specific object in an <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제를 사용 하는 방법을 보여 줍니다 <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> 의 특정 개체를 찾을 수는 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The array is created with its elements in ascending sort order.</source>
          <target state="translated">배열의 해당 요소를 오름차순으로 정렬 만들어집니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method requires the array to be sorted in ascending order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> 메서드를 사용 하려면 배열 오름차순으로 정렬 됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 형식이 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 요소와 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않으며 검색 중에 <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원으로 정렬된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 인터페이스를 사용하여 1차원으로 정렬된 전체 배열에서 값을 검색합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">비교자는 요소를 비교 하는 방법을 사용자 지정 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">예를 들어, 사용할 수는 <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 않습니다 <ph id="ph2">`null`</ph>, 요소의 <ph id="ph3">`array`</ph> 사용 하 여 지정된 된 값과 비교할 <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> 구현 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 <ph id="ph2">`comparer`</ph>, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If<ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">경우<ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 비교를 수행를 사용 하는 <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> 또는 지정 된 값은 요소 자체에서 제공 되는 구현 합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph> 및 <ph id="ph3">`value`</ph> 를 구현 하지 않습니다는 <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> 인터페이스의 요소 <ph id="ph5">`array`</ph> 에 대 한 테스트 되지 않습니다 <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> 검색을 시작 하기 전에.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 예외가 생성 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph4">&lt;paramref name="array" /&gt;</ph>의 요소와 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고, <ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않으며 검색 중에 <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원으로 정렬된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The starting index of the range to search.</source>
          <target state="translated">검색할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The length of the range to search.</source>
          <target state="translated">검색할 범위의 길이입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified value.</source>
          <target state="translated">배열의 각 요소 및 지정한 값에서 구현되는 <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">중 하나 <ph id="ph1">`value`</ph> 또는의 모든 요소가 <ph id="ph2">`array`</ph> 구현 해야 합니다는 <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> 비교에 사용 되는 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">경우 <ph id="ph1">`value`</ph> 를 구현 하지 않습니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 인터페이스의 요소 <ph id="ph3">`array`</ph> 에 대 한 테스트 되지 않습니다 <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> 검색을 시작 하기 전에.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 예외가 생성 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 형식이 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 요소와 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않으며 검색 중에 <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원으로 정렬된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The starting index of the range to search.</source>
          <target state="translated">검색할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">검색할 범위의 길이입니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스는 하나는 배열의 상한 보다 크지 많은 경우 보다 더 큰 요소가 없는 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">비교자는 요소를 비교 하는 방법을 사용자 지정 합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">예를 들어, 사용할 수는 <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 않습니다 <ph id="ph2">`null`</ph>, 요소의 <ph id="ph3">`array`</ph> 사용 하 여 지정된 된 값과 비교할 <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> 구현 합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 <ph id="ph2">`comparer`</ph>, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 비교를 수행를 사용 하는 <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> 또는 지정 된 값은 요소 자체에서 제공 되는 구현 합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph> 및 <ph id="ph3">`value`</ph> 를 구현 하지 않습니다는 <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> 인터페이스의 요소 <ph id="ph5">`array`</ph> 에 대 한 테스트 되지 않습니다 <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> 검색을 시작 하기 전에.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 사용 하는 경우 예외를 생성 하지 않는 <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph4">&lt;paramref name="array" /&gt;</ph>의 요소와 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고, <ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않으며 검색 중에 <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 요소가 발견되었습니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 정렬된 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 각 요소 및 지정한 개체에서 구현되는 <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 전체 배열에서 특정 요소를 검색합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">`array`</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">경우 <ph id="ph1">`array`</ph> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> 구현 해야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스는 비교에 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 예외가 생성 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> 제네릭 메서드 오버 로드와 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">임의의 순서로 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">배열은 표시 하 고 정렬 하 고 다시 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">배열을 사용 하기 위해 정렬 해야는 <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">배열 및 반환 값은 <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> 메서드에 전달 되는 <ph id="ph2">`ShowWhere`</ph> 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index is negative if the string is not in the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph>-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">인덱스는 문자열 배열에 없는 경우에 음수 하므로 <ph id="ph1">`ShowWhere`</ph> 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 <ph id="ph2">`Xor`</ph>Visual Basic의-1) 검색 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 str 연산입니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않습니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 정렬된 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 전체 배열에서 값을 검색합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">비교자는 요소를 비교 하는 방법을 사용자 지정 합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">예를 들어, 사용할 수는 <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 않습니다 <ph id="ph2">`null`</ph>, 요소의 <ph id="ph3">`array`</ph> 사용 하 여 지정된 된 값과 비교할 <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> 제네릭 인터페이스를 구현 합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 <ph id="ph2">`comparer`</ph>, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided by <ph id="ph4">`T`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 비교를 수행를 사용 하는 <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> 에서 제공 하는 제네릭 인터페이스 구현을 <ph id="ph4">`T`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> before the search begins.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph> 및 <ph id="ph3">`value`</ph> 를 구현 하지 않습니다는 <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 요소의 <ph id="ph5">`array`</ph> 에 대 한 테스트 되지 않습니다 <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> 검색을 시작 하기 전에.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated">검색 구현 하지 않는 요소가 발견 하는 경우 예외가 throw 됩니다 <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 예외가 생성 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">다음 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 제네릭 메서드 오버 로드와 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">배열은 표시 하 고 정렬 하 고 다시 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">배열을 사용 하기 위해 정렬 해야는 <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">배열 및 반환 값은 <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 메서드에 전달 되는 <ph id="ph2">`ShowWhere`</ph> 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">인덱스는 문자열이 n 경우 음수 배열에 하므로 <ph id="ph1">`ShowWhere`</ph> 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 <ph id="ph2">`Xor`</ph> Visual Basic의-1) 검색 stri 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 ng 합니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph4">&lt;paramref name="array" /&gt;</ph>의 요소와 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="T" /&gt;</ph>가 <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않습니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 정렬된 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The starting index of the range to search.</source>
          <target state="translated">검색할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The length of the range to search.</source>
          <target state="translated">검색할 범위의 길이입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified value.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 각 요소 및 지정한 값에서 구현되는 <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">배열에 지정된 된 값이 없는 경우 메서드는 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> 구현 해야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스는 비교에 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 예외가 생성 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 형식이 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 요소와 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않습니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 정렬된 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to search.</source>
          <target state="translated">검색할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The length of the range to search.</source>
          <target state="translated">검색할 범위의 길이입니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 제네릭 인터페이스를 사용하여 1차원으로 정렬된 배열의 요소 범위에서 값을 검색합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 있는 경우 지정된 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 있는 지정된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 인덱스이고, 그렇지 않으면 음수입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 하나 이상의 요소보다 작은 경우 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>보다 큰 첫째 요소 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 없고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있는 모든 요소보다 큰 경우 마지막 요소에 1을 더한 인덱스의 비트 보수인 음수가 반환됩니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 정렬되지 않은 <ph id="ph1">&lt;paramref name="array" /&gt;</ph>를 사용하여 호출되면 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>에 있더라도 반환 값이 올바르지 않고 음수가 반환될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">이 메서드는 음수 인덱스를 포함 하는 검색 배열을 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 이 메서드를 호출 하기 전에 정렬 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">배열에 지정된 된 값이 없는 경우 메서드는 음의 정수를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">비트 보수 연산자를 적용할 수 있습니다 (~ C#에서는 <ph id="ph1">`Not`</ph> Visual basic에서) 하는 인덱스를 생성할 음수 결과를 합니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">이 인덱스 배열 크기와 같은지는 요소가 없습니다 보다 큰 <ph id="ph1">`value`</ph> 배열에 있습니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">그렇지 않으면 첫 번째 요소 보다 큰 인덱스를은 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">비교자는 요소를 비교 하는 방법을 사용자 지정 합니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">예를 들어, 사용할 수는 <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> 으로 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 않습니다 <ph id="ph2">`null`</ph>, 요소의 <ph id="ph3">`array`</ph> 사용 하 여 지정된 된 값과 비교할 <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> 제네릭 인터페이스를 구현 합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 값으로 정의 된 정렬 순서에 따라 증가 하도록 정렬 되어 있어야 <ph id="ph2">`comparer`</ph>, 그렇지 않으면 결과가 올바르지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided for type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 비교를 수행를 사용 하는 <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> 형식을 위해 제공 되는 제네릭 인터페이스 구현을 <ph id="ph4">`T`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 정의 된 정렬 순서에 따라 값이 증가 이미 정렬 되어야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 구현을 제공 합니다; 그렇지 않으면 결과 잘못 되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">중복 되는 요소가 허용 됩니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 크거나 둘 이상의 요소가 포함 되어 <ph id="ph2">`value`</ph>, 메서드, 각 항목 중 하나에 것 뿐 아니라 첫 번째 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> 항상 다른 참조 형식과;와 비교할 수 있습니다. 와 비교할 따라서 <ph id="ph2">`null`</ph> 사용 하는 경우 예외를 생성 하지 않는 <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">테스트, 모든 요소에 대해 <ph id="ph1">`value`</ph> 을 적절 한 전달 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 경우 <ph id="ph3">`value`</ph> 은 <ph id="ph4">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">즉,는 <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> 구현 지정된 된 요소를 비교 하는 방법을 결정 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는는 O (로그 <ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph4">&lt;paramref name="array" /&gt;</ph>의 요소와 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="T" /&gt;</ph>가 <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않습니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The array whose elements need to be cleared.</source>
          <target state="translated">포함된 요소를 지울 배열입니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range of elements to clear.</source>
          <target state="translated">지울 요소 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The number of elements to clear.</source>
          <target state="translated">지울 요소의 개수입니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Sets a range of elements in an array to the default value of each element type.</source>
          <target state="translated">배열의 각 요소 형식의 기본값으로 요소의 범위를 설정합니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method resets each element in an array to the element type's default value.</source>
          <target state="translated">이 메서드는 배열의 각 요소에에서 요소 형식의 기본값으로 다시 설정합니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It sets elements of reference types (including <ph id="ph1">&lt;xref:System.String&gt;</ph> elements) to <ph id="ph2">`null`</ph>, and sets elements of value types to the default values shown in the following table.</source>
          <target state="translated">참조 형식의 요소를 설정 하는 것 (포함 하 여 <ph id="ph1">&lt;xref:System.String&gt;</ph> 요소)를 <ph id="ph2">`null`</ph>, 다음 표에 표시 된 기본값으로 값 형식의 요소를 가져오거나 설정 합니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Type</source>
          <target state="translated">형식</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>All integral and floating point numeric types</source>
          <target state="translated">모든 정수 계열 및 부동 소수점 숫자 형식</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>0 (zero)</source>
          <target state="translated">0 (영)</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Other value types</source>
          <target state="translated">다른 값 형식</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Default value of the type's fields</source>
          <target state="translated">해당 형식의 필드의 기본값</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The range of cleared elements wrap from row to row in a multi-dimensional array.</source>
          <target state="translated">범위의 요소 줄 바꿈을 행 다차원 배열에서 지워집니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method only clears the values of the elements; it does not delete the elements themselves.</source>
          <target state="translated">이 메서드는만; 요소의 값을 지웁니다. 요소 자체는 삭제 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>An array has a fixed size; therefore, elements cannot be added or removed.</source>
          <target state="translated">배열 크기가 고정 된 따라서 요소 추가 또는 제거할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> 메서드를 1 차원, 2, 차원 및 3 차원 배열에 정수 값을 다시 설정 합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example defines a <ph id="ph1">`TimeZoneTime`</ph> structure that includes a <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> field and a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> field.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`TimeZoneTime`</ph> 구조에 포함 하는 <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> 필드와 <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> 필드입니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to clear one element in a two-element array of <ph id="ph2">`TimeZoneTime`</ph> values.</source>
          <target state="translated">그런 다음 호출 하는 <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> 의 두 요소 배열에서 요소 중 하나를 지우려면 메서드 <ph id="ph2">`TimeZoneTime`</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The method sets the value of the cleared element to the default value of a <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> object, which is <ph id="ph2">`null`</ph>, and the default value of a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> object, which is <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본값을 지워진된 요소 값을 설정 하는 메서드는 <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> 개체 이며, <ph id="ph2">`null`</ph>, 및의 기본값은 <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> 개체 이며, <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the size of <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 합계가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 크기보다 큽니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 부분 복사본을 만듭니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 부분 복사본입니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies only the elements of the <ph id="ph2">&lt;xref:System.Array&gt;</ph>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">단순 복사본을는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 의 요소에만 복사는 <ph id="ph2">&lt;xref:System.Array&gt;</ph>, 여부은 참조 형식 또는 값 형식 참조에서 참조 하는 개체를 복사 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The references in the new <ph id="ph1">&lt;xref:System.Array&gt;</ph> point to the same objects that the references in the original <ph id="ph2">&lt;xref:System.Array&gt;</ph> point to.</source>
          <target state="translated">새 참조 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 동일 하 게 지점 개체는 원래에서 참조 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 가리킵니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">전체 복사본 하는 반면, 한 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The clone is of the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> as the original <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">복제본은 동일한 <ph id="ph1">&lt;xref:System.Type&gt;</ph> 원래 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The following code example clones a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> array and demonstrates the behavior of a shallow copy.</source>
          <target state="translated">다음 코드 예제에서는 복제본을 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> 배열 하 고 단순 복사본의 동작을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">복사할 데이터가 포함된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">복사가 시작되는 <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">데이터를 받는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">저장이 시작되는 <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">복사할 요소의 개수를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위를 지정한 소스 인덱스부터 복사하여 지정된 대상 인덱스부터 시작하는 다른 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 붙여 넣습니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Guarantees that all changes are undone if the copy does not succeed completely.</source>
          <target state="translated">복사가 완료되지 않으면 모든 변경 내용이 취소되도록 합니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 매개 변수에 동일한 차원 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> type must be the same as or derived from the <ph id="ph2">`destinationArray`</ph> type; otherwise, an <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> 형식은 동일 하거나에서 파생 된는 <ph id="ph2">`destinationArray`</ph> 입력; 그렇지 않으면는 <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> verifies the compatibility of the array types before performing any operation.</source>
          <target state="translated">와 달리 <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> 작업을 수행 하기 전에 배열 형식 호환성을 확인 합니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">세 번째 행 (또는 열)의 두 번째 요소부터 복사 하려면 <ph id="ph1">`sourceIndex`</ph> 2를 더한 두 번째 행 (또는 열)의 길이 더한 첫 번째 행 (또는 열)의 상한을 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 겹치는 경우이 메서드는 동작 처럼의 원래 값 <ph id="ph3">`sourceArray`</ph> 하기 전에 임시 위치에 보존 된 <ph id="ph4">`destinationArray`</ph> 를 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">이 메서드는 표준 C/c + + 함수와 동일 <ph id="ph1">`memmove`</ph>이 아니라 <ph id="ph2">`memcpy`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열을 배열의 수 있습니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 두 참조 형식 배열 파일이 나 두 배열 형식의 <ph id="ph3">&lt;xref:System.Object&gt;</ph>, 단순 복사가 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">단순 복사본을는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 는 새로운 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 원본과 같은 요소에 대 한 참조가 포함 된 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">요소는 요소에서 참조 하는 대상은 복사 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">전체 복사본 하는 반면, 한 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the <ph id="ph1">`destinationArray`</ph> remains unchanged; therefore, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> can be used within a constrained execution region (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</source>
          <target state="translated">이 메서드는 복사 하는 동안 예외를 throw 하는 경우는 <ph id="ph1">`destinationArray`</ph> 변경 되지 않음; 따라서 <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> 제약이 있는 실행 영역 내에서 사용할 수 (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 차수가 다릅니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> type is neither the same as nor derived from the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> 형식은 동일하지 않으며 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> 형식에서 파생되지 않습니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>의 하나 이상의 요소를 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 형식으로 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>의 첫 번째 차원 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 첫 번째 차원 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph>부터 <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph> 끝까지의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph>부터 <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph> 끝까지의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the source array.</source>
          <target state="translated">소스 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the target array.</source>
          <target state="translated">대상 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to convert to a target type.</source>
          <target state="translated">대상 형식으로 변환할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> that converts each element from one type to another type.</source>
          <target state="translated">한 형식에서 다른 형식으로 각 요소를 변환하는 <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Converts an array of one type to an array of another type.</source>
          <target state="translated">한 형식의 배열을 다른 형식의 배열로 변환합니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>An array of the target type containing the converted elements from the source array.</source>
          <target state="translated">소스 배열에서 변환된 요소를 포함하는 대상 형식의 배열입니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> 개체를 대상 형식으로 변환 하는 메서드에 대리자입니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, and the converted elements are saved in the new array.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, 변환된 된 요소를 새 배열에 저장 됩니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The source <ph id="ph1">`array`</ph> remains unchanged.</source>
          <target state="translated">소스 <ph id="ph1">`array`</ph> 그대로 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The following code example defines a method named <ph id="ph1">`PointFToPoint`</ph> that converts a <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structure to a <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structure.</source>
          <target state="translated">라는 메서드를 정의 하는 다음 코드 예제에서는 <ph id="ph1">`PointFToPoint`</ph> 변환 하는 <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> 구조체는 <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> 구조입니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The example then creates an array of <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> structures, creates a <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegate (<ph id="ph3">`Converter(Of PointF, Point)`</ph> in Visual Basic) to represent the <ph id="ph4">`PointFToPoint`</ph> method, and passes the delegate to the <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method.</source>
          <target state="translated">배열을 만듭니다 <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> 구조, 만들어집니다는 <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> 위임 (<ph id="ph3">`Converter(Of PointF, Point)`</ph> Visual Basic의)을 나타내는 <ph id="ph4">`PointFToPoint`</ph> 메서드를에 대리자를 전달는 <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method passes each element of the input list to the <ph id="ph2">`PointFToPoint`</ph> method and puts the converted elements into a new list of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> 메서드 전달 하는 입력 목록의 각 요소는 <ph id="ph2">`PointFToPoint`</ph> 메서드를 새 목록으로 변환된 된 요소를 배치 <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> 구조입니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Both lists are displayed.</source>
          <target state="translated">두 목록은 모두 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="converter" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies a range of elements in one <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and performs type casting and boxing as required.</source>
          <target state="translated">한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위를 다른 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 복사하고 필요에 따라 형식 캐스팅 및 boxing을 수행합니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">복사할 데이터가 포함된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">데이터를 받는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">복사할 요소의 개수를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위를 첫 번째 요소부터 복사하여 다른 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 첫 번째 요소부터 붙여넣습니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The length is specified as a 32-bit integer.</source>
          <target state="translated">길이가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 매개 변수에 동일한 차원 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">또한 <ph id="ph1">`destinationArray`</ph> 해야 이미 있는 된 차원이 구분 하 고 요소 복사한 데이터를 수용 하기 위해 충분 한 수를가지고 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 겹치는 경우이 메서드는 동작 처럼의 원래 값 <ph id="ph3">`sourceArray`</ph> 하기 전에 임시 위치에 보존 된 <ph id="ph4">`destinationArray`</ph> 를 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">이 메서드는 표준 C/c + + 함수와 동일 <ph id="ph1">`memmove`</ph>이 아니라 <ph id="ph2">`memcpy`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열을 배열의 수 있습니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">형식 다운 캐스팅을 수행 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 두 참조 형식 배열 파일이 나 두 배열 형식의 <ph id="ph3">&lt;xref:System.Object&gt;</ph>, 단순 복사가 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">단순 복사본을는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 는 새로운 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 원본과 같은 요소에 대 한 참조가 포함 된 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">요소는 요소에서 참조 하는 대상은 복사 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">전체 복사본 하는 반면, 한 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">형식 호환성은 다음과 같이 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">형식이 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">값 형식이 호환 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">연결이 끊긴된 형식이 호환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">열거형에 암시적 변환이 포함 <ph id="ph1">&lt;xref:System.Enum&gt;</ph> 및 기본 형식입니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">하는 경우 모든 요소에 <ph id="ph1">`sourceArray`</ph> 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">이 메서드가의 상태를 복사 하는 동안 예외가 throw <ph id="ph1">`destinationArray`</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 차수가 다릅니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>는 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>의 하나 이상의 요소를 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 형식으로 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">복사할 데이터가 포함된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">데이터를 받는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">복사할 요소의 개수를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">정수는 0과 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>(포함) 사이여야 합니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위를 첫 번째 요소부터 복사하여 다른 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 첫 번째 요소부터 붙여넣습니다.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The length is specified as a 64-bit integer.</source>
          <target state="translated">길이가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 매개 변수에 동일한 차원 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">또한 <ph id="ph1">`destinationArray`</ph> 해야 이미 있는 된 차원이 구분 하 고 요소 복사한 데이터를 수용 하기 위해 충분 한 수를가지고 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 겹치는 경우이 메서드는 동작 처럼의 원래 값 <ph id="ph3">`sourceArray`</ph> 하기 전에 임시 위치에 보존 된 <ph id="ph4">`destinationArray`</ph> 를 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">이 메서드는 표준 C/c + + 함수와 동일 <ph id="ph1">`memmove`</ph>이 아니라 <ph id="ph2">`memcpy`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열을 배열의 수 있습니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">형식 다운 캐스팅을 수행 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 두 참조 형식 배열 파일이 나 두 배열 형식의 <ph id="ph3">&lt;xref:System.Object&gt;</ph>, 단순 복사가 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">단순 복사본을는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 는 새로운 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 원본과 같은 요소에 대 한 참조가 포함 된 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">요소는 요소에서 참조 하는 대상은 복사 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">전체 복사본 하는 반면, 한 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">형식 호환성은 다음과 같이 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">형식이 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">값 형식이 호환 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">연결이 끊긴된 형식이 호환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">열거형에 암시적 변환이 포함 <ph id="ph1">&lt;xref:System.Enum&gt;</ph> 및 기본 형식입니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">하는 경우 모든 요소에 <ph id="ph1">`sourceArray`</ph> 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">이 메서드가의 상태를 복사 하는 동안 예외가 throw <ph id="ph1">`destinationArray`</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 차수가 다릅니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>는 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>의 하나 이상의 요소를 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 형식으로 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작거나 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큽니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">복사할 데이터가 포함된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">복사가 시작되는 <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">데이터를 받는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">저장이 시작되는 <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">복사할 요소의 개수를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위를 지정한 소스 인덱스부터 복사하여 지정된 대상 인덱스부터 시작하는 다른 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 붙여 넣습니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The length and the indexes are specified as 32-bit integers.</source>
          <target state="translated">길이와 인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 매개 변수에 동일한 차원 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">또한 <ph id="ph1">`destinationArray`</ph> 해야 이미 있는 된 차원이 구분 하 고 충분 한 수의 요소에서 시작을 있어야는 <ph id="ph2">`destinationIndex`</ph> 복사한 데이터를 수용 하기 위해 위치입니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">세 번째 행 (또는 열)의 두 번째 요소부터 복사 하려면 <ph id="ph1">`sourceIndex`</ph> 2를 더한 두 번째 행 (또는 열)의 길이 더한 첫 번째 행 (또는 열)의 상한을 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 겹치는 경우이 메서드는 동작 처럼의 원래 값 <ph id="ph3">`sourceArray`</ph> 하기 전에 임시 위치에 보존 된 <ph id="ph4">`destinationArray`</ph> 를 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">이 메서드는 표준 C/c + + 함수와 동일 <ph id="ph1">`memmove`</ph>이 아니라 <ph id="ph2">`memcpy`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열을 배열의 수 있습니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">형식 다운 캐스팅을 수행 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 두 참조 형식 배열 파일이 나 두 배열 형식의 <ph id="ph3">&lt;xref:System.Object&gt;</ph>, 단순 복사가 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">단순 복사본을는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 는 새로운 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 원본과 같은 요소에 대 한 참조가 포함 된 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">요소는 요소에서 참조 하는 대상은 복사 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">전체 복사본 하는 반면, 한 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">형식 호환성은 다음과 같이 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">형식이 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">값 형식이 호환 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">연결이 끊긴된 형식이 호환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">열거형에 암시적 변환이 포함 <ph id="ph1">&lt;xref:System.Enum&gt;</ph> 및 기본 형식입니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">하는 경우 모든 요소에 <ph id="ph1">`sourceArray`</ph> 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">이 메서드가의 상태를 복사 하는 동안 예외가 throw <ph id="ph1">`destinationArray`</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">다음 코드 예제에서는 하나를 복사 하는 방법을 보여 줍니다. <ph id="ph1">&lt;xref:System.Array&gt;</ph> 형식의 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 다른 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 정수 형식의 합니다.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 차수가 다릅니다.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>는 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>의 하나 이상의 요소를 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 형식으로 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>의 첫 번째 차원 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 첫 번째 차원 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph>부터 <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph> 끝까지의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph>부터 <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph> 끝까지의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">복사할 데이터가 포함된 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">복사가 시작되는 <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">데이터를 받는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">저장이 시작되는 <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">복사할 요소의 개수를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">정수는 0과 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>(포함) 사이여야 합니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위를 지정한 소스 인덱스부터 복사하여 지정된 대상 인덱스부터 시작하는 다른 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 붙여 넣습니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The length and the indexes are specified as 64-bit integers.</source>
          <target state="translated">길이와 인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 매개 변수에 동일한 차원 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">또한 <ph id="ph1">`destinationArray`</ph> 해야 이미 있는 된 차원이 구분 하 고 충분 한 수의 요소에서 시작을 있어야는 <ph id="ph2">`destinationIndex`</ph> 복사한 데이터를 수용 하기 위해 위치입니다.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">다차원 배열 간에 복사 하는 경우 긴 1 차원 배열 처럼 동작 하며 행 (또는 열)은 개념상 놓여집니다 종단 간 합니다.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">예를 들어 첫 번째 행 (또는 열)의 모든 4 개 요소와 두 번째 행 (또는 열)의 처음 두 요소 배열에 3 개의 행 (또는 열) 네 가지 요소로 된, 각 복사 6 개 요소 배열의 시작 부분에서 복사는 합니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">세 번째 행 (또는 열)의 두 번째 요소부터 복사 하려면 <ph id="ph1">`sourceIndex`</ph> 2를 더한 두 번째 행 (또는 열)의 길이 더한 첫 번째 행 (또는 열)의 상한을 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 겹치는 경우이 메서드는 동작 처럼의 원래 값 <ph id="ph3">`sourceArray`</ph> 하기 전에 임시 위치에 보존 된 <ph id="ph4">`destinationArray`</ph> 를 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">이 메서드는 표준 C/c + + 함수와 동일 <ph id="ph1">`memmove`</ph>이 아니라 <ph id="ph2">`memcpy`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열을 배열의 수 있습니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">형식 다운 캐스팅을 수행 해야 하는 경우.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">참조 형식 배열에서 값 형식의 배열에 복사할 경우 각 요소는 unboxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">값 형식의 배열에서 참조 형식 배열에 복사할 경우 각 요소는 boxed 하 고 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">참조 형식 또는 값 형식의 배열에서 복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 각 값 또는 참조를 저장 하기 위해 만든 이며 다음 복사 합니다.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">복사 하는 경우는 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 배열에는 참조 형식 또는 값 형식의 배열 및 할당 가능 하지는 <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">경우 <ph id="ph1">`sourceArray`</ph> 및 <ph id="ph2">`destinationArray`</ph> 두 참조 형식 배열 파일이 나 두 배열 형식의 <ph id="ph3">&lt;xref:System.Object&gt;</ph>, 단순 복사가 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">단순 복사본을는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 는 새로운 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 원본과 같은 요소에 대 한 참조가 포함 된 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">요소는 요소에서 참조 하는 대상은 복사 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">전체 복사본 하는 반면, 한 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 요소와 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목을 복사 합니다.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 배열은 호환 되지 않는 형식의 경우에 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">형식 호환성은 다음과 같이 정의 됩니다.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">형식이 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">값 형식이 호환 <ph id="ph1">&lt;xref:System.Object&gt;</ph> 및 해당 값 형식에서 구현 된 인터페이스 형식을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">값 형식은 해당 인터페이스를 직접 구현 하는 경우에 인터페이스에 연결 된 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">연결이 끊긴된 형식이 호환 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">두 개의 내장 (미리 정의 된) 값 유형은 대상 형식으로 원본 유형에 서 복사 확대 변환 하는 경우에 호환입니다.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">확대 변환 되지 축소 변환 정보 손실 될 수 있지만 내용은 손실 됩니다.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">예를 들어 32 비트 부호 있는 정수를 64 비트 부호 있는 정수로 변환 확대 변환 이며 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 축소 변환 합니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">비 내장 (사용자 정의 됨) 값 형식 자체와 호환 됩니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">열거형에 암시적 변환이 포함 <ph id="ph1">&lt;xref:System.Enum&gt;</ph> 및 기본 형식입니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">하는 경우 모든 요소에 <ph id="ph1">`sourceArray`</ph> 다운 캐스트 (예를 들어 파생된 클래스를 기본 클래스 또는 개체에 대 한 인터페이스) 필요 하나 이상의 요소에 해당 유형으로 캐스팅할 수 없습니다 및 <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">이 메서드가의 상태를 복사 하는 동안 예외가 throw <ph id="ph1">`destinationArray`</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">다음 코드 예제에서는 하나를 복사 하는 방법을 보여 줍니다. <ph id="ph1">&lt;xref:System.Array&gt;</ph> 형식의 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 다른 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 정수 형식의 합니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 차수가 다릅니다.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>는 호환되지 않는 형식입니다.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>의 하나 이상의 요소를 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 형식으로 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작거나 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큽니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph>부터 <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph> 끝까지의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph>부터 <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph> 끝까지의 요소 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</source>
          <target state="translated">현재 1차원 배열의 모든 요소를 지정된 1차원 배열에 복사합니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">현재 배열에서 복사한 요소의 대상인 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>A 32-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">복사가 시작되는 <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">현재 1차원 배열의 모든 요소를 지정된 대상 배열 인덱스부터 시작하여 지정된 1차원 배열에 복사합니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">현재 배열 인스턴스의 모든 요소를 복사 하는이 메서드는 <ph id="ph1">`array`</ph> 인덱스부터 대상 배열 <ph id="ph2">`index`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 대상 배열 해야 이미 있는 된 차원이 구분 된 및 요소 복사 된 요소에 맞게 충분 한 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">그렇지 않으면 메서드에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">이 메서드는 지원의 <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">구현 하는 경우 <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> 가 사용 하 여 명시적으로 필요한 <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> 추가 간접 참조를 방지 하려면.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">이 메서드가의 상태를 복사 하는 동안 예외가 throw <ph id="ph1">`array`</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>합니다. 단순 복사만 수행합니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 다른 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 다른 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 생기는 0이 아닌 배열은 합니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">전체 소스 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 복사 대상의 기존 요소를 덮어쓰는 빈 요소를 포함 하 여 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">소스 배열의 요소 개수가 <ph id="ph1">&lt;paramref name="index" /&gt;</ph>부터 대상 <ph id="ph2">&lt;paramref name="array" /&gt;</ph> 끝까지의 사용 가능한 요소 개수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">소스 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 형식을 대상 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 형식으로 자동 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The source array is multidimensional.</source>
          <target state="translated">소스 배열이 다차원입니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 소스에서 하나 이상의 요소를 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 대상 형식으로 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">현재 배열에서 복사한 요소의 대상인 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>A 64-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">복사가 시작되는 <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>의 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">현재 1차원 배열의 모든 요소를 지정된 대상 배열 인덱스부터 시작하여 지정된 1차원 배열에 복사합니다.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">현재 배열 인스턴스의 모든 요소를 복사 하는이 메서드는 <ph id="ph1">`array`</ph> 인덱스부터 대상 배열 <ph id="ph2">`index`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 대상 배열 해야 이미 있는 된 차원이 구분 된 및 요소 복사 된 요소에 맞게 충분 한 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">그렇지 않으면 메서드에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">이 메서드는 지원의 <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">구현 하는 경우 <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> 가 사용 하 여 명시적으로 필요한 <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> 추가 간접 참조를 방지 하려면.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">이 메서드가의 상태를 복사 하는 동안 예외가 throw <ph id="ph1">`array`</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>합니다. 단순 복사만 수행합니다.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 다른 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">다음 코드 예제를 복사 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 다른 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 생기는 0이 아닌 배열은 합니다.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">전체 소스 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 복사 대상의 기존 요소를 덮어쓰는 빈 요소를 포함 하 여 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">소스 배열의 요소 개수가 <ph id="ph1">&lt;paramref name="index" /&gt;</ph>부터 대상 <ph id="ph2">&lt;paramref name="array" /&gt;</ph> 끝까지의 사용 가능한 요소 개수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">소스 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 형식을 대상 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 형식으로 자동 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">소스 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원입니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 소스에서 하나 이상의 요소를 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 대상 형식으로 캐스팅할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The size of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 크기입니다.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Creates a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and length, with zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 길이를 가진 인덱스가 0부터 시작하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>A new one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length, using zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 지정한 길이를 가진 인덱스가 0부터 시작하는 새 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">대부분의 클래스와 달리 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 제공는 <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">요소 참조 형식으로 초기화 됩니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">값 형식 요소를 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The following code example shows how to create and initialize a one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제를 만들고 1 차원 초기화 하는 방법을 보여 줍니다 <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>이 아닙니다.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">예를 들면 <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>이 개방형 제네릭 형식인 경우.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>An array of 32-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 각 차원 크기를 나타내는 32비트 정수 배열입니다.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 차원 길이를 가진 인덱스가 0부터 시작하는 다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The dimension lengths are specified in an array of 32-bit integers.</source>
          <target state="translated">차원 길이가 32비트 정수 배열로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 각 차원에 대해 지정한 길이를 가진 인덱스가 0부터 시작하는 새 다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">대부분의 클래스와 달리 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 제공는 <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">에 있는 요소의 수는 <ph id="ph1">`lengths`</ph> 새 배열 차원 수와 동일 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 요소는 <ph id="ph1">`lengths`</ph> 배열 새에서 해당 차원의 길이 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">요소 참조 형식으로 초기화 됩니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">값 형식 요소를 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 에 있는 모든 값의 곱 <ph id="ph3">`lengths`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제에서는 만들고 다차원 초기화 하는 방법을 보여 줍니다. <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>이 아닙니다.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> 배열에 1개 미만의 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">예를 들면 <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 개방형 제네릭 형식입니다.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>의 값이 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>An array of 64-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 각 차원 크기를 나타내는 64비트 정수 배열입니다.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each integer in the array must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">배열의 각 정수는 0과 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 사이여야 합니다.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 차원 길이를 가진 인덱스가 0부터 시작하는 다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The dimension lengths are specified in an array of 64-bit integers.</source>
          <target state="translated">차원 길이가 64비트 정수 배열로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 각 차원에 대해 지정한 길이를 가진 인덱스가 0부터 시작하는 새 다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">대부분의 클래스와 달리 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 제공는 <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">에 있는 요소의 수는 <ph id="ph1">`lengths`</ph> 새 배열 차원 수와 동일 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 요소는 <ph id="ph1">`lengths`</ph> 배열 새에서 해당 차원의 길이 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">요소 참조 형식으로 초기화 됩니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">값 형식 요소를 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 에 있는 모든 값의 곱 <ph id="ph3">`lengths`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제에서는 만들고 다차원 초기화 하는 방법을 보여 줍니다. <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>이 아닙니다.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> 배열에 1개 미만의 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">예를 들면 <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>이 개방형 제네릭 형식인 경우.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>의 값이 0보다 작거나 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큽니다.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 첫 번째 차원 크기입니다.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 두 번째 차원 크기입니다.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Creates a two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">0부터 시작하는 인덱스를 사용하여 지정된 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 차원 길이의 2차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>A new two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">0부터 시작하는 인덱스를 사용하며 각 차원이 지정된 길이로 된 지정된 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>의 새로운 2차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">대부분의 클래스와 달리 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 제공는 <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">요소 참조 형식으로 초기화 됩니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">값 형식 요소를 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph> and <ph id="ph4">`length2`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 곱 <ph id="ph3">`length1`</ph> 및 <ph id="ph4">`length2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a two-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제를 만들고 차원 초기화 하는 방법을 보여 줍니다 <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>이 아닙니다.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">예를 들면 <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>이 개방형 제네릭 형식인 경우.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 각 차원 크기를 포함하는 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the lower bound (starting index) of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 각 차원 하한(시작 인덱스)을 포함하는 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with the specified lower bounds.</source>
          <target state="translated">지정한 하한을 가진 지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 및 차원 길이의 다차원 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length and lower bound for each dimension.</source>
          <target state="translated">각 차원에 대해 지정한 길이 및 하한을 가진 지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 새 다차원 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">대부분의 클래스와 달리 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 제공는 <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">`lengths`</ph> and <ph id="ph2">`lowerBounds`</ph> arrays must have the same number of elements.</source>
          <target state="translated"><ph id="ph1">`lengths`</ph> 및 <ph id="ph2">`lowerBounds`</ph> 배열 요소는 동일한 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">에 있는 요소의 수는 <ph id="ph1">`lengths`</ph> 새 배열 차원 수와 동일 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 요소는 <ph id="ph1">`lengths`</ph> 배열 새에서 해당 차원의 길이 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lowerBounds`</ph> array must specify the lower bound of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 요소는 <ph id="ph1">`lowerBounds`</ph> 배열 새에 해당 하는 차원에 대 한 하한값을 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</source>
          <target state="translated">일반적으로.NET Framework 클래스 라이브러리와 많은 프로그래밍 언어에 0이 아닌 처리 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">요소 참조 형식으로 초기화 됩니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">값 형식 요소를 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 에 있는 모든 값의 곱 <ph id="ph3">`lengths`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> with specified lower bounds.</source>
          <target state="translated">다음 코드 예제에서는 만들고 다차원 초기화 하는 방법을 보여 줍니다. <ph id="ph1">&lt;xref:System.Array&gt;</ph> 지정 된 하 한을 가진 합니다.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>이 아닙니다.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> 배열에 1개 미만의 요소가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> and <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> arrays do not contain the same number of elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> 배열에 들어 있는 요소 수가 다른 경우</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">예를 들면 <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 개방형 제네릭 형식입니다.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>의 값이 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is very large, such that the sum of a dimension's lower bound and length is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph>에 있는 모든 값이 아주 커서 차원의 하한과 길이의 합이 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 첫 번째 차원 크기입니다.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 두 번째 차원 크기입니다.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the third dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">만들 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 세 번째 차원 크기입니다.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Creates a three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 차원 길이를 가진 인덱스가 0부터 시작하는 삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>A new three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">지정한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 및 각 차원에 대해 지정한 길이를 가진 인덱스가 0부터 시작하는 새 삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">대부분의 클래스와 달리 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 제공는 <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> 메서드 런타임에 바인딩된 액세스를 허용 하는 공용 생성자를 대신 합니다.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">요소 참조 형식으로 초기화 됩니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">값 형식 요소를 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, and <ph id="ph5">`length3`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 곱 <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, 및 <ph id="ph5">`length3`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a three-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제에는 생성 하는 삼차원 초기화 하는 방법을 보여 줍니다 <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 유효한 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>이 아닙니다.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>은 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">예를 들면 <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph>는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph>이 개방형 제네릭 형식인 경우.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length3" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Empty``1">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty array.</source>
          <target state="translated">빈 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">빈 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 반환합니다.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">지정한 배열에 지정한 조건자에 정의된 조건과 일치하는 요소가 포함되어 있는지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="array" /&gt;</ph> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="array" /&gt;</ph>에 지정한 조건자에 정의된 조건과 일치하는 하나 이상의 요소가 포함되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when a match is found.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, 일치 하는 경우 처리가 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 명시적으로 위임 합니다.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example specifies the match conditions for the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</source>
          <target state="translated">다음 예제에 대 한 일치 조건을 지정는 <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> 메서드 usinglambda 식을 하 여 전 세계는 지정 된 문자로 시작 하는 여부 또는 지정된 된 배열에서 지구를 찾을 수 있는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method to indicate whether any names in a string array begin with a specified character.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> 메서드 모든 이름이 문자열 배열에서 지정 된 문자로 시작 하는지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The example instantiates a <ph id="ph1">`StringSearcher`</ph> object by passing the string to search for to its class constructor.</source>
          <target state="translated">이 예제에서는 인스턴스화합니다는 <ph id="ph1">`StringSearcher`</ph> 해당 클래스 생성자에 검색할 문자열을 전달 하 여 개체입니다.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">`StringSearcher.StartsWith`</ph> method has same signature as the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">`StringSearcher.StartsWith`</ph> 메서드 시그니처가 동일한는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>When the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method is called, each member of the array is passed to the delegate until it returns <ph id="ph2">`true`</ph> or iterates all the elements in the array.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> 메서드가 호출 되 면 반환 될 때까지 배열의 각 멤버는 대리자에 전달 됩니다 <ph id="ph2">`true`</ph> 또는 배열의 모든 요소를 반복 합니다.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</source>
          <target state="translated">대신 수 있습니다도 람다 식을 사용 하는 대리자의 시그니처를 가진 해당 메서드를 명시적으로 정의 합니다.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example replaces the <ph id="ph1">`StringSearcher`</ph> class and its <ph id="ph2">`StartsWith`</ph> method with a lambda expression.</source>
          <target state="translated">다음 예제에서는 대체는 <ph id="ph1">`StringSearcher`</ph> 클래스 및 해당 <ph id="ph2">`StartsWith`</ph> 람다 식 사용 하 여 메서드.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 조건자입니다.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 처음으로 검색한 요소를 반환합니다.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째 요소이고, 그렇지 않으면 <ph id="ph1">&lt;paramref name="T" /&gt;</ph> 형식의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method or a lambda expression that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate or lambda expression.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 메서드 또는 람다 식을 반환 하는 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자 또는 람다 식에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, starting with the first element and ending with the last element.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>첫 번째 요소부터 마지막 요소까지 합니다.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">일치 하는 경우 처리가 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate with the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> generic method to search an array of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 대리자는 <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> 배열을 검색할 제네릭 메서드 <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> 구조입니다.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The method the delegate represents, <ph id="ph1">`ProductGT10`</ph>, returns <ph id="ph2">`true`</ph> if the product of the X and Y fields is greater than 100,000.</source>
          <target state="translated">대리자가 나타내는 메서드 <ph id="ph1">`ProductGT10`</ph>, 반환 <ph id="ph2">`true`</ph> X 및 Y 필드 제품 100, 000 보다 큰 경우.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> method calls the delegate for each element of the array, returning the first point that meets the test condition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> 메서드 테스트 조건에 맞는 첫 번째 지점을 반환 하는 배열의 각 요소에 대 한 대리자를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</source>
          <target state="translated">Visual Basic 및 C# 사용자 대리자를 명시적으로 만들거나 제네릭 메서드의 형식 인수를 지정 하지 않아도 됩니다.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The compilers determine the necessary types from the method arguments you supply.</source>
          <target state="translated">컴파일러에서 제공 하는 메서드 인수 필요한 형식을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Rather than explicitly defining a method with the necessary signature, instantiating a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate, and passing the delegate to the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> method, it is customary to use a lambda expression.</source>
          <target state="translated">필요한 시그니처를 가진 메서드를 명시적으로 정의 하는 대신 인스턴스화하는 <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 대리자와 대리자를 전달 하는 <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> 는 람다 식을 사용 하는 일반적인 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example is identical to the previous one, except that it uses a lambda expression as the <ph id="ph1">`match`</ph> argument.</source>
          <target state="translated">다음 예제는 이전 쿼리와 동일으로 람다 식을 사용 하 여는 <ph id="ph1">`match`</ph> 인수입니다.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">지정한 조건자에 정의된 조건과 일치하는 모든 요소를 검색합니다.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정한 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 모든 요소를 포함하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>이고, 그렇지 않으면 빈 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and the elements that match the conditions are saved in the returned array.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, 조건과 일치 하는 요소는 반환된 된 배열에 저장 됩니다.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</source>
          <target state="translated">다음 예제에서는 값의 범위는 0에서 1, 000을 가진 50 난수의 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> method with a lambda expression that returns the values that range from 300 to 600.</source>
          <target state="translated">그런 다음 호출 하는 <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> 메서드 값을 반환 하는 해당 범위에서 300를 600으로 람다 식 사용 합니다.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Note that the lambda expression is passed a parameter named <ph id="ph1">`x`</ph>;  this represents the individual array member that is passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">람다 식은 라는 매개 변수를 전달 <ph id="ph1">`x`</ph>;  이 나타냅니다에 전달 되는 각 배열 멤버는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Also note that the local <ph id="ph1">`lBound`</ph> and <ph id="ph2">`uBound`</ph> variables are accessible within the lambda expression.</source>
          <target state="translated">또한 로컬 <ph id="ph1">`lBound`</ph> 및 <ph id="ph2">`uBound`</ph> 변수에 람다 식 내에서 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> 제네릭 메서드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> "Amargasaurus" 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> 제네릭 메서드는 배열의 끝부터 뒤로 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">위치 5에서 "Dilophosaurus를" 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> 제네릭 메서드는 "saurus"로 끝나는 모든 요소가 포함 된 배열을 반환 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">요소가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">코드 예제도 <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">지정한 조건자에 정의된 조건과 일치하는 요소를 검색하여 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 또는 그 일부에서 일치하는 요소 중 첫 번째 요소의 0부터 시작하는 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 검색은 앞으로 첫 번째 요소부터 마지막 요소입니다.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> 위치 1에 있는 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 배열의 위치 2부터 사이 배열의 끝에 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">위치 5에 있는 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 위치 2에서 시작 하는 세 가지 요소의 범위를 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">"Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정된 인덱스에서 마지막 요소로 확장하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 까지 검색은 <ph id="ph2">`startIndex`</ph> 마지막 요소의 끝입니다.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 요소 수 <ph id="ph3">`startIndex`</ph> 의 끝에 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> 위치 1에 있는 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 배열의 위치 2부터 사이 배열의 끝에 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">위치 5에 있는 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 위치 2에서 시작 하는 세 가지 요소의 범위를 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">"Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">검색할 섹션에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 지정된 인덱스부터 시작하여 지정된 수의 요소를 포함하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 까지 검색은 <ph id="ph2">`startIndex`</ph> 에서 끝나는 <ph id="ph3">`startIndex`</ph> 플러스 <ph id="ph4">`count`</ph> 에서 1을 뺀 경우 <ph id="ph5">`count`</ph> 가 0 보다 크면 합니다.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> 위치 1에 있는 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 배열의 위치 2부터 사이 배열의 끝에 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">위치 5에 있는 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 위치 2에서 시작 하는 세 가지 요소의 범위를 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">"Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 섹션을 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 마지막으로 검색한 요소를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소이고, 그렇지 않으면 <ph id="ph1">&lt;paramref name="T" /&gt;</ph> 형식의 기본값입니다.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, moving backward in the <ph id="ph3">&lt;xref:System.Array&gt;</ph>, starting with the last element and ending with the first element.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 를 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>이동, 뒤로 <ph id="ph3">&lt;xref:System.Array&gt;</ph>은 지난 요소의 시작 하 고 첫 번째 요소까지 합니다.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">일치 하는 경우 처리가 중지 됩니다.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> 제네릭 메서드를 차례로 각 요소를 전달 하는 처음부터 배열을 트래버스하는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> "Amargasaurus" 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는<ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> 제네릭 메서드는 배열의 끝부터 뒤로 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">위치 5에서 "Dilophosaurus를" 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> 제네릭 메서드는 "saurus"로 끝나는 모든 요소가 포함 된 배열을 반환 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">요소가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">코드 예제도 <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">지정한 조건자에 정의된 조건과 일치하는 요소를 검색하여 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 또는 그 일부에서 일치하는 요소 중 마지막 요소의 0부터 시작하는 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 하면서 각 요소를 차례로 끝에서 배열의 뒤로 이동 하는 메서드 오버 로드는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> 위치 5에 있는 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 배열의 위치 4에서 시작 하 고 뒤로 배열의 시작 부분을 계속 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">위치 1에 있는 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 세 요소 4 위치에서 시작 및 작업 (즉, 요소 4, 3 및 2)의 범위를 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">"Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">역방향 검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 첫 번째 요소에서 지정된 인덱스로 확장하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 검색 됩니다에 <ph id="ph2">`startIndex`</ph> 첫 번째 요소의 끝입니다.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 시작 부분에서 요소 수는 <ph id="ph3">`array`</ph> 를 <ph id="ph4">`startIndex`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 하면서 각 요소를 차례로 끝에서 배열의 뒤로 이동 하는 메서드 오버 로드는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> 위치 5에 있는 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 배열의 위치 4에서 시작 하 고 뒤로 배열의 시작 부분을 계속 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">위치 1에 있는 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 세 요소 4 위치에서 시작 및 작업 (즉, 요소 4, 3 및 2)의 범위를 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">"Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">역방향 검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">검색할 섹션에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">검색할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정된 수의 요소가 들어 있고 지정된 인덱스에서 끝나는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 검색 됩니다에 <ph id="ph2">`startIndex`</ph> 에서 끝나는 <ph id="ph3">`startIndex`</ph> 뺀 <ph id="ph4">`count`</ph> + 1, 경우 <ph id="ph5">`count`</ph> 가 0 보다 크면 합니다.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자 <ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">다음 코드 예제에서는 세 개의 오버 로드를 모두 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> 제네릭 메서드.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 포함 된 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">코드 예제에서는 명명 된 검색 조건자 메서드도 정의 <ph id="ph1">`EndsWithSaurus`</ph>문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 하면서 각 요소를 차례로 끝에서 배열의 뒤로 이동 하는 메서드 오버 로드는 <ph id="ph2">`EndsWithSaurus`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">검색을 중지 하는 경우는 <ph id="ph1">`EndsWithSaurus`</ph> 메서드 반환 <ph id="ph2">`true`</ph> 위치 5에 있는 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">C# 및 Visual Basic에서 필요 없는 만들려는 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 배열의 위치 4에서 시작 하 고 뒤로 배열의 시작 부분을 계속 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">위치 1에 있는 요소를 찾습니다.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> 메서드 오버 로드는 세 요소 4 위치에서 시작 및 작업 (즉, 요소 4, 3 및 2)의 범위를 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">"Saurus"로 끝나는 해당 범위에 이름이 없으면 공룡 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 섹션을 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> on whose elements the action is to be performed.</source>
          <target state="translated">해당 요소에서 동작이 수행되는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> to perform on each element of <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>의 각 요소에서 수행할 <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>Performs the specified action on each element of the specified array.</source>
          <target state="translated">지정한 배열의 각 요소에서 지정한 동작을 수행합니다.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Action%601&gt;</ph> 개체에 동작을 수행 하는 메서드에 대리자에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 에 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> to display the squares of each element in an integer array.</source>
          <target state="translated">다음 예제에서는 사용 하는 방법을 보여 줍니다. <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> 정수 배열에 각 요소의 제곱을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="action" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph>의 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph>에 대한 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`for each`</ph> c + +에서는 <ph id="ph3">`For Each`</ph> Visual basic에서)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">그러므로 열거자를 직접 조작하는 대신 <ph id="ph1">`foreach`</ph>를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 실행하면 열거자가 이 위치로 복원됩니다.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">이 위치에서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>는 정의되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">따라서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>의 값을 읽기 전에 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>에서는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>이 호출될 때까지 동일한 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 다음 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환할 수도 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">마지막으로 호출 하는 경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 컬렉션의 첫째 요소에 다시 설정하려면 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 호출한 뒤 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>를 호출해야 합니다.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 독점적으로 액세스할 수 있는 권한이 없으므로 컬렉션을 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> to list the elements of an array.</source>
          <target state="translated">다음 코드 예제를 사용 하는 방법을 보여 줍니다 <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> 배열 요소를 나열 합니다.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">길이를 지정해야 하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 0부터 시작하는 차원입니다.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정된 차원의 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 요소의 수를 나타내는 32비트 정수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A 32-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">지정된 차원의 요소 수를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> is <ph id="ph2">`GetLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">예로 <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> 은 <ph id="ph2">`GetLength(0)`</ph>, 첫 번째 차원에 있는 요소 수를 반환 하는 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> to display the dimensions of two arrays with different ranks.</source>
          <target state="translated">다음 예제를 사용 하는 방법을 보여 줍니다 <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> 의 순위에 다른 두 배열의 크기를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>보다 크거나 같은 경우</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">길이를 지정해야 하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 0부터 시작하는 차원입니다.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정된 차원의 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 요소의 수를 나타내는 64비트 정수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A 64-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">지정된 차원의 요소 수를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> is <ph id="ph2">`GetLongLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">예로 <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> 은 <ph id="ph2">`GetLongLength(0)`</ph>, 첫 번째 차원에 있는 요소 수를 반환 하는 <ph id="ph3">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>보다 크거나 같은 경우</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>A zero-based dimension of the array whose starting index needs to be determined.</source>
          <target state="translated">시작 인덱스를 지정해야 하는 배열의 0부터 시작하는 차원입니다.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Gets the index of the first element of the specified dimension in the array.</source>
          <target state="translated">배열에서 지정된 차원의 첫 번째 요소의 인덱스를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The index of the first element of the specified dimension in the array.</source>
          <target state="translated">배열에서 지정된 차원의 첫 번째 요소의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">`GetLowerBound(0)`</ph> returns the starting index of the first dimension of the array, and <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> returns the starting index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetLowerBound(0)`</ph> 배열의 첫 번째 차원의 시작 하는 인덱스를 반환 하 고 <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> 배열의 마지막 차원 시작 하는 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 배열이 비어 있는 경우에 메서드는 배열의 하한값의 인덱스를 나타내는 값을 항상 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Note that, although most arrays in the .NET Framework are zero-based (that is, the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</source>
          <target state="translated">.NET Framework에서 대부분 배열은 0부터 시작 하는 없지만 (즉,는 <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 메서드는 배열의 각 차원에 대해 0을 반환 합니다.),.NET Framework에서는 0부터 시작 하지 않는 배열을 지원 합니다.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Such arrays can be created with the <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> method, and can also be returned from unmanaged code.</source>
          <target state="translated">이러한 배열을 만들 수 있습니다는 <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> 메서드, 및 비관리 코드에서 반환 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드를 1 차원 및 2 차원 배열의 범위를 표시 하 고 배열 요소의 값을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>보다 크거나 같은 경우</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>A zero-based dimension of the array whose upper bound needs to be determined.</source>
          <target state="translated">상한을 지정해야 하는 배열의 0부터 시작하는 차원입니다.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>Gets the index of the last element of the specified dimension in the array.</source>
          <target state="translated">배열에서 지정된 차원의 마지막 요소의 인덱스를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</source>
          <target state="translated">배열에 있는 지정된 차원의 마지막 요소의 인덱스이거나 지정된 차원이 비어 있는 경우 -1입니다.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">`GetUpperBound(0)`</ph> returns the last index in the first dimension of the array, and <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> returns the last index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetUpperBound(0)`</ph> 배열의 첫 번째 차원에서 마지막 인덱스를 반환 하 고 <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> 배열의 마지막 차원 마지막 인덱스를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드를 1 차원 및 2 차원 배열의 범위를 표시 하 고 배열 요소의 값을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph>가 <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>보다 크거나 같은 경우</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Gets the value of the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 요소의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 위치를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드를 확인할 수 있는지 여부를 값 <ph id="ph3">`index`</ph> 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 1차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 위치를 지정하는 인덱스를 나타내는 32비트 정수의 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">인덱스가 32비트 정수 배열로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">요소 수가 <ph id="ph1">`indices`</ph> 차원 수와 같아야는 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">모든 요소는 <ph id="ph1">`indices`</ph> 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 차수가 <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>에 있는 요소 수와 다른 경우</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>의 요소가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 위치를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드를 확인할 수 있는지 여부를 값 <ph id="ph3">`index`</ph> 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 1차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 위치를 지정하는 인덱스를 나타내는 64비트 정수의 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">인덱스가 64비트 정수 배열로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">요소 수가 <ph id="ph1">`indices`</ph> 차원 수와 같아야는 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">모든 요소는 <ph id="ph1">`indices`</ph> 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 차수가 <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>에 있는 요소 수와 다른 경우</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>의 요소가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">이차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">이차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 이차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="index2" /&gt;</ph>가 현재 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">이차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">이차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 이차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="index2" /&gt;</ph>가 현재 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 세 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 삼차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="index3" /&gt;</ph>이 현재 <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">가져올 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 세 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에서 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 위치에 있는 값입니다.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 삼차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="index3" /&gt;</ph>이 현재 <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</source>
          <target state="translated">지정한 개체를 검색하여 1차원 배열 또는 배열의 요소 범위에서 처음으로 일치하는 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">검색할 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">지정한 개체를 검색하여 1차원 배열에서 처음 검색된 개체의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에서 처음 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method searches all the elements of a one-dimensional arrayfor <ph id="ph1">`value`</ph>.</source>
          <target state="translated">이 메서드는 1 차원 arrayfor의 모든 요소를 검색 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling each element's <ph id="ph3">`Equals`</ph> method until it finds a match.</source>
          <target state="translated">확인 하려면 여부 <ph id="ph1">`value`</ph> 에 존재 <ph id="ph2">`array`</ph>, 메서드가 각 요소를 호출 하 여 같음 비교를 수행할 <ph id="ph3">`Equals`</ph> 일치 하는 항목을 찾을 때까지 메서드.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">즉, 요소를 재정의 하는 경우는 <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> 메서드를 재정의 하는 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if<ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">대부분의 배열은 0은 없으므로이 메서드가 일반적으로 – 1을 반환<ph id="ph1">`value`</ph> 를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">배열의 하 한에 해당 하는 드문 경우 <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) 및 <ph id="ph2">`value`</ph> 을 찾을 수 없으면이 메서드가 반환 <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">이 예에서는 호출의 다음 세 가지 오버 로드는 <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> 메서드 문자열 배열에서 문자열로의 인덱스를 찾을 수:</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>문자열의 첫 번째 확인 하는 문자열 배열에서 "the"입니다.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>문자열의 첫 번째 확인 하려면 "the" 문자열 배열의 마지막 요소에는 네 번째에 있습니다.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>문자열의 첫 번째 확인 하는 문자열에 "the" 배열에서 마지막으로 성공한 일치는 배열의 끝에 다음 요소에 있습니다.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">검색할 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">검색할 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0은 빈 배열에서 유효합니다.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">범위는 지정한 인덱스에서 배열의 끝까지 확장됩니다.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found, within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>에서 마지막 요소로 확장하는 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 요소 범위에서 처음 검색된 값의 인덱스이고, 그러지 않으면 배열의 하한에서 1을 뺀 값입니다.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method searches a one-dimensional array from the element at index <ph id="ph1">`startIndex`</ph> to the last element.</source>
          <target state="translated">이 메서드 검색 인덱스에 있는 요소에서 1 차원 배열 <ph id="ph1">`startIndex`</ph> 부터 마지막 요소입니다.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">확인 하려면 여부 <ph id="ph1">`value`</ph> 에 존재 <ph id="ph2">`array`</ph>, 메서드를 호출 하 여 같음 비교를 수행는 <ph id="ph3">`Equals`</ph> 일치 하는 항목을 찾을 때까지 모든 요소의 메서드.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">즉, 요소를 재정의 하는 경우는 <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> 메서드를 재정의 하는 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">대부분의 배열은 0은 없으므로이 메서드가 일반적으로 – 1을 반환 <ph id="ph1">`value`</ph> 를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">배열의 하 한에 해당 하는 드문 경우 <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) 및 <ph id="ph2">`value`</ph> 을 찾을 수 없으면이 메서드가 반환 <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>,the method returns -1.</source>
          <target state="translated">경우 <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, 메서드가-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`startIndex`</ph> 보다 크면 <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, 메서드에서 throw 된 <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 요소 수 <ph id="ph3">`startIndex`</ph> 의 끝에 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">이 예에서는 호출의 다음 세 가지 오버 로드는 <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> 메서드 문자열 배열에서 문자열로의 인덱스를 찾을 수:</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>문자열의 첫 번째 확인 하는 문자열 배열에서 "the"입니다.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>문자열의 첫 번째 확인 하려면 "the" 문자열 배열의 마지막 요소에는 네 번째에 있습니다.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>문자열의 첫 번째 확인 하는 문자열에 "the" 배열에서 마지막으로 성공한 일치는 배열의 끝에 다음 요소에 있습니다.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">검색할 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">검색할 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0은 빈 배열에서 유효합니다.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements to search.</source>
          <target state="translated">검색할 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</source>
          <target state="translated">1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">범위는 지정한 요소 수에 대해 지정한 인덱스에서 확장됩니다.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found in the <ph id="ph2">&lt;paramref name="array" /&gt;</ph> from index <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">첫 번째 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 발생의 인덱스가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 인덱스 범위(<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> ~ <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1)에 있으면 해당 인덱스이며 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method searches the elements of a one-dimensional arrayfrom <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">이 메서드는 1 차원 arrayfrom의 요소를 검색 <ph id="ph1">`startIndex`</ph> 를 <ph id="ph2">`startIndex`</ph> 플러스 <ph id="ph3">`count`</ph> 에서 1을 뺀 경우 <ph id="ph4">`count`</ph> 가 0 보다 크면 합니다.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">확인 하려면 여부 <ph id="ph1">`value`</ph> 에 존재 <ph id="ph2">`array`</ph>, 메서드를 호출 하 여 같음 비교를 수행는 <ph id="ph3">`Equals`</ph> 일치 하는 항목을 찾을 때까지 모든 요소의 메서드.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">즉, 요소를 재정의 하는 경우는 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드를 재정의 하는 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Becausemost arrays have a lower bound of zero, this method generally returns –1 when <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Becausemost 배열은 있는 하한값 0으로,이 메서드는 일반적으로 경우-1을 반환 <ph id="ph1">`value`</ph> 를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">배열의 하 한에 해당 하는 드문 경우 <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) 및 <ph id="ph2">`value`</ph> 을 찾을 수 없으면이 메서드가 반환 <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startindex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">경우 <ph id="ph1">`startindex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, 메서드가-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`startIndex`</ph> 보다 크면 <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, 메서드에서 throw 된 <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">이 예에서는 호출의 다음 세 가지 오버 로드는 <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> 메서드 문자열 배열에서 문자열로의 인덱스를 찾을 수:</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>문자열의 첫 번째 확인 하는 문자열 배열에서 "the"입니다.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>문자열의 첫 번째 확인 하려면 "the" 문자열 배열의 마지막 요소에는 네 번째에 있습니다.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>문자열의 첫 번째 확인 하는 문자열에 "the" 배열에서 마지막으로 성공한 일치는 배열의 끝에 다음 요소에 있습니다.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine the value of the <ph id="ph1">`count`</ph> argument, it subtracts the upper bound of the array from the starting index and adds one.</source>
          <target state="translated">값을 확인 하는 <ph id="ph1">`count`</ph> 인수를 시작 하는 인덱스에서 배열의 상한을 뺍니다이 고 하나에 추가 합니다.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 섹션을 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">지정한 개체를 검색하여 1차원 배열에서 처음 검색된 개체의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">전체 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에서 처음 검색된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 0부터 시작하는 인덱스이고, 검색되지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method searches all the elements of a one-dimensional array for <ph id="ph1">`value`</ph>.</source>
          <target state="translated">이 메서드 검색에 대 한 1 차원 배열의 모든 요소 <ph id="ph1">`value`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">확인 하려면 여부 <ph id="ph1">`value`</ph> 에 존재 <ph id="ph2">`array`</ph>, 메서드를 호출 하 여 같음 비교를 수행는 <ph id="ph3">`T.Equals`</ph> 모든 요소에 대 한 메서드.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">즉 <ph id="ph1">`T`</ph> 재정의 <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> 메서드를 재정의 하는 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 세 개의 제네릭 오버 로드를 모두는 <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 메서드 오버 로드는 처음부터 배열 검색 하 고 문자열의 첫 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 인덱스 위치 3 시작 하 여 배열 및 배열 끝까지 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0은 빈 배열에서 유효합니다.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">범위는 지정한 인덱스에서 배열의 끝까지 확장됩니다.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에서 마지막 요소로 확장하는 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>의 요소 범위에서 처음 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method searches a one-dimensional array from the element at <ph id="ph1">`startIndex`</ph> to the end of the array.</source>
          <target state="translated">이 메서드는 1 차원 배열에 있는 요소에서 검색 <ph id="ph1">`startIndex`</ph> 배열의 끝에 있습니다.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">확인 하려면 여부 <ph id="ph1">`value`</ph> 에 존재 <ph id="ph2">`array`</ph>, 메서드를 호출 하 여 같음 비교를 수행는 <ph id="ph3">`T.Equals`</ph> 모든 요소에 대 한 메서드.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">즉 <ph id="ph1">`T`</ph> 재정의 <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> 메서드를 재정의 하는 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>,the method returns -1.If <ph id="ph3">`startIndex`</ph> is greater than <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>, 메서드가 반환-1.If <ph id="ph3">`startIndex`</ph> 보다 크면 <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, 메서드에서 throw는 <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 요소 수 <ph id="ph3">`startIndex`</ph> 의 끝에 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 세 개의 제네릭 오버 로드를 모두는 <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 메서드 오버 로드는 처음부터 배열 검색 하 고 문자열의 첫 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 인덱스 위치 3 시작 하 여 배열 및 배열 끝까지 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">검색할 1차원(인덱스는 0부터 시작) 배열입니다.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0은 빈 배열에서 유효합니다.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">검색할 섹션에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">1차원 배열의 요소 범위에서 지정한 개체를 검색하여 처음으로 일치하는 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">범위는 지정한 요소 수에 대해 지정한 인덱스에서 확장됩니다.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains the number of elements specified in <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>부터 시작하여 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>에 지정된 수의 요소를 포함하는 <ph id="ph4">&lt;paramref name="count" /&gt;</ph>의 요소 범위에서 처음 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method searchesthe elements of a one-dimensional array from <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">이 메서드 searchesthe 요소에서 1 차원 배열의 <ph id="ph1">`startIndex`</ph> 를 <ph id="ph2">`startIndex`</ph> 플러스 <ph id="ph3">`count`</ph> 에서 1을 뺀 경우 <ph id="ph4">`count`</ph> 가 0 보다 큰 합니다.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">확인 하려면 여부 <ph id="ph1">`value`</ph> 에 존재 <ph id="ph2">`array`</ph>, 메서드를 호출 하 여 같음 비교를 수행는 <ph id="ph3">`T.Equals`</ph> 모든 요소에 대 한 메서드.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">즉 <ph id="ph1">`T`</ph> 재정의 <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> 메서드를 재정의 하는 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">경우 <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, 메서드가-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`startIndex`</ph> 보다 크면 <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, 메서드에서 throw 된 <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 세 개의 제네릭 오버 로드를 모두는 <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 메서드 오버 로드는 처음부터 배열 검색 하 고 문자열의 첫 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 인덱스 위치 3 시작 하 여 배열 및 배열 끝까지 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 섹션을 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Array.Initialize">
          <source>Initializes every element of the value-type <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> by calling the default constructor of the value type.</source>
          <target state="translated">해당 값 형식의 기본 생성자를 호출하여 값 형식 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 모든 요소를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is designed to help compilers support value-type arrays; most users do not need this method.</source>
          <target state="translated">이 메서드는 값 형식의 배열을; 지원 되는 컴파일러에 있도록 디자인 되었습니다. 대부분의 사용자에이 메서드를 사용할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>It must not be used on reference-type arrays.</source>
          <target state="translated">참조 형식에 사용할 수 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not a value-type <ph id="ph2">&lt;xref:System.Array&gt;</ph> or if the value type does not have a default constructor, the <ph id="ph3">&lt;xref:System.Array&gt;</ph> is not modified.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 값 유형이 아닙니다 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 값 형식에 기본 생성자가 없는 경우 또는 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 수정 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>The value-type <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound and any number of dimensions.</source>
          <target state="translated">값 형식 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 한 및 원하는 개수의 차원이 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</source>
          <target state="translated">이 메서드를 사용 하 여; 생성자가 있는 값 형식에 대해서만 그러나 C#에 적용 되는 값 형식 생성자를 갖지 않습니다.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="P:System.Array.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 크기가 고정되어 있는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>This property is always <ph id="ph1">&lt;see langword="true" /&gt;</ph> for all arrays.</source>
          <target state="translated">이 속성은 모든 배열에 대해 항상 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 구현 하는 <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> 속성에 필요 하기 때문에 <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</source>
          <target state="translated">크기가 고정된 된 배열을 배열을 만들 없지만 기존 요소는 수정할 수 있습니다 다음에 추가 하거나 제거할 요소의 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="P:System.Array.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">이 속성은 모든 배열에 대해 항상 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 구현 하는 <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> 속성에 필요 하기 때문에 <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</source>
          <target state="translated">읽기 전용 배열을 배열의 만든 다음에 추가, 제거 또는 요소를 수정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you require a read-only collection, use a <ph id="ph1">&lt;xref:System.Collections&gt;</ph> class that implements the <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">읽기 전용 컬렉션에서는 필요한 경우 사용 된 <ph id="ph1">&lt;xref:System.Collections&gt;</ph> 구현 하는 클래스는 <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you cast or convert an array to an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface object, the <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">캐스팅 하거나를 변환 하는 경우는 <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스 개체는 <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> 속성에서 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>However, if you cast or convert an array to a <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interface, the <ph id="ph2">`IsReadOnly`</ph> property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">그러나 캐스팅 하거나를 변환 하는 경우는 <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> 인터페이스는 <ph id="ph2">`IsReadOnly`</ph> 속성에서 반환 <ph id="ph3">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="P:System.Array.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">이 속성은 모든 배열에 대해 항상 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 구현 하는 <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> 속성에 필요 하기 때문에 <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">.NET framework 클래스에 따라 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 사용 하 여 컬렉션의 동기화 된 버전 제공는 <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">배열을 사용 하는 클래스를 사용 하 여 동기화 직접 구현할 수도 <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">동기화 하는 코드에서 작업을 수행 해야는 <ph id="ph1">`SyncRoot`</ph> 컬렉션으로 만들어지므로 컬렉션의 합니다.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">특히, 컬렉션을 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">일부 구현 <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 를 반환할 수 있습니다는 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 자체입니다.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">다음 코드 예제에 사용 하 여 열거 하는 동안 배열을 잠그는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Returns the index of the last occurrence of a value in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> 일부에서 지정한 값과 마지막으로 일치하는 요소의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정한 개체를 검색하여 전체 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 내에서 마지막으로 검색된 값의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">검색된 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있으면 <ph id="ph2">&lt;paramref name="array" /&gt;</ph> 전체에서 마지막으로 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">1 차원 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">요소를 사용 하 여 지정 된 값이 비교는 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 <ph id="ph1">`Equals`</ph> 해당 형식의 구현이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">이 메서드는-1 경우에 일반적으로 반환 대부분 배열은 하한값 0, 이므로 <ph id="ph1">`value`</ph> 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">배열의 하 한에 해당 하는 드문 경우 <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">`value`</ph> 발견 되지 않으면이 메서드가 반환 <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, 즉 <ph id="ph4">`System.Int32.MinValue - 1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">이 메서드는.NET Framework 버전 2.0에서에서 다음을 사용 합니다.는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 확인 하려면 여부는 <ph id="ph4">&lt;xref:System.Object&gt;</ph> 에 지정 된는 <ph id="ph5">`value`</ph> 매개 변수가 있습니다.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> 자체입니다.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph2">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 메서드는 <ph id="ph2">`item`</ph> 컬렉션의 개체에 대 한 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">다음 코드 예제에서는 배열에서 지정 된 요소 중 마지막 요소의 인덱스를 결정 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">뒤로 검색할 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">지정한 개체를 검색하여 첫 번째 요소에서 지정한 인덱스로 확장하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 첫 번째 요소에서 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>로 확장하는 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">1 차원 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 검색 됩니다에 <ph id="ph2">`startIndex`</ph> 첫 번째 요소의 끝입니다.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">요소를 사용 하 여 지정 된 값이 비교는 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 <ph id="ph1">`Equals`</ph> 해당 형식의 구현이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">이 메서드는-1 경우에 일반적으로 반환 대부분 배열은 하한값 0, 이므로 <ph id="ph1">`value`</ph> 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">배열의 하 한에 해당 하는 드문 경우 <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">`value`</ph> 발견 되지 않으면이 메서드가 반환 <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, 즉 <ph id="ph4">`System.Int32.MinValue - 1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 시작 부분에서 요소 수는 <ph id="ph3">`array`</ph> 를 <ph id="ph4">`startIndex`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">이 메서드는.NET Framework 버전 2.0에서에서 다음을 사용 합니다.는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 확인 하려면 여부는 <ph id="ph4">&lt;xref:System.Object&gt;</ph> 에 지정 된는 <ph id="ph5">`value`</ph> 매개 변수가 있습니다.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> 자체입니다.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">다음 코드 예제에서는 배열에서 지정 된 요소 중 마지막 요소의 인덱스를 결정 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">뒤로 검색할 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">검색할 섹션에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">지정한 개체를 검색하여 지정한 수의 요소를 포함하고 지정한 인덱스에서 끝나는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에서 지정한 수의 요소를 포함하고 <ph id="ph3">&lt;paramref name="count" /&gt;</ph>에서 끝나는 <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 값의 인덱스이고, 그렇지 않으면 배열의 하한에서 1을 뺀 값입니다.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">1 차원 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 검색 됩니다에 <ph id="ph2">`startIndex`</ph> 에서 끝나는 <ph id="ph3">`startIndex`</ph> 뺀 <ph id="ph4">`count`</ph> + 1, 경우 <ph id="ph5">`count`</ph> 가 0 보다 크면 합니다.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">요소를 사용 하 여 지정 된 값이 비교는 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the<ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는<ph id="ph1">`Equals`</ph> 해당 형식의 구현이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">이 메서드는-1 경우에 일반적으로 반환 대부분 배열은 하한값 0, 이므로 <ph id="ph1">`value`</ph> 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">배열의 하 한에 해당 하는 드문 경우 <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">`value`</ph> 발견 되지 않으면이 메서드가 반환 <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, 즉 <ph id="ph4">`System.Int32.MinValue - 1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">이 메서드는.NET Framework 버전 2.0에서에서 다음을 사용 합니다.는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">&lt;xref:System.Array&gt;</ph> 확인 하려면 여부는 <ph id="ph4">&lt;xref:System.Object&gt;</ph> 에 지정 된는 <ph id="ph5">`value`</ph> 매개 변수가 있습니다.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">.NET Framework의 이전 버전에서는이 확인 작업을 수행를 사용 하 여는 <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> 의 메서드는 <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> 자체입니다.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">다음 코드 예제에서는 배열에서 지정 된 요소 중 마지막 요소의 인덱스를 결정 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to (<ph id="ph3">`startIndex`</ph> minus the lower bound of the array plus 1).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> 메서드는 역방향 검색 이므로, <ph id="ph2">`count`</ph> 보다 작거나 같음 (<ph id="ph3">`startIndex`</ph> 1을 더한 배열의 하한값에서 뺀).</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 섹션을 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">지정한 개체를 검색하여 전체 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 <ph id="ph2">&lt;paramref name="array" /&gt;</ph> 전체에서 마지막으로 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">요소를 사용 하 여 지정 된 값이 비교는 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 <ph id="ph1">`Equals`</ph> 해당 형식의 구현이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제 모두 세 개의 제네릭 오버 로드는 <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 메서드 오버 로드에서 마지막으로 전체 배열 검색 하 고 문자열의 두 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 이전 버전과 시작 인덱스 위치 3 배열 및 배열를 통해서는 검색 하는 데 사용 되 고 문자열의 첫 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">역방향 검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">지정한 개체를 검색하여 첫 번째 요소에서 지정한 인덱스로 확장하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 첫 번째 요소에서 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>로 확장하는 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 검색 됩니다에 <ph id="ph2">`startIndex`</ph> 첫 번째 요소의 끝입니다.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">요소를 사용 하 여 지정 된 값이 비교는 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 <ph id="ph1">`Equals`</ph> 해당 형식의 구현이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 의 시작 부분에서 요소 수는 <ph id="ph3">`array`</ph> 를 <ph id="ph4">`startIndex`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제 모두 세 개의 제네릭 오버 로드는 <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 메서드 오버 로드에서 마지막으로 전체 배열 검색 하 고 문자열의 두 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 이전 버전과 시작 인덱스 위치 3 배열 및 배열를 통해서는 검색 하는 데 사용 되 고 문자열의 첫 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">검색할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">역방향 검색의 0부터 시작하는 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">검색할 섹션에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">지정한 개체를 검색하여 지정한 수의 요소를 포함하고 지정한 인덱스에서 끝나는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 요소의 인덱스를 반환합니다.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 있을 경우 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>에서 지정한 수의 요소를 포함하고 <ph id="ph3">&lt;paramref name="count" /&gt;</ph>에서 끝나는 <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>의 요소 범위에서 마지막으로 검색된 값의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 뒤로 검색 됩니다에 <ph id="ph2">`startIndex`</ph> 에서 끝나는 <ph id="ph3">`startIndex`</ph> 뺀 <ph id="ph4">`count`</ph> + 1, 경우 <ph id="ph5">`count`</ph> 가 0 보다 크면 합니다.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">요소를 사용 하 여 지정 된 값이 비교는 <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">요소 형식이 비 내장 (사용자 정의 됨) 형식이 면는 <ph id="ph1">`Equals`</ph> 해당 형식의 구현이 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제 모두 세 개의 제네릭 오버 로드는 <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">문자열의 배열 인덱스 위치 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 만들어집니다.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 메서드 오버 로드에서 마지막으로 전체 배열 검색 하 고 문자열의 두 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 이전 버전과 시작 인덱스 위치 3 배열 및 배열를 통해서는 검색 하는 데 사용 되 고 문자열의 첫 번째 항목을 찾습니다.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">마지막으로 <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 유효한 인덱스 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 섹션을 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>Gets the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">모든 차원의 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에서 요소의 총수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zero if there are no elements in the array.</source>
          <target state="translated">모든 차원에서 요소의 총 수는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; 배열에 요소가 있는 경우에 0입니다.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The following example uses the                                 <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property to get the total number of elements in an array.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> 속성을 배열에서 요소의 총 수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>It also uses the                                 <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> method to determine the number of elements in each dimension of a multidimensional array.</source>
          <target state="translated">또한 사용 하 여는 <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 다차원 배열의 각 차원에 있는 요소의 수를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>The array is multidimensional and contains more than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> elements.</source>
          <target state="translated">배열이 다차원이고 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 요소보다 많이 포함된 경우</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="P:System.Array.LongLength">
          <source>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 모든 차원에 있는 요소의 총 수를 나타내는 64비트 정수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>A 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">모든 차원의 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 요소의 총 수를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>Gets the rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 순위(차원 수)를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</source>
          <target state="translated">예를 들어, 1차원 배열은 1을 반환하고, 2차원 배열은 2를 반환하는 방식입니다.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 순위(차원의 수)입니다.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>For example, the Visual Basic code</source>
          <target state="translated">예를 들어 Visual Basic 코드</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>and the C# code</source>
          <target state="translated">및 C# 코드</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>create an array of three dimensions with a <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property whose value is 3.</source>
          <target state="translated">로 3 차원 배열을 만들기는 <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> 속성 값이 3 인 합니다.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>A jagged array (an array of arrays) is a one-dimensional array; the value of its <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property is 1.</source>
          <target state="translated">가변된 배열 (배열의 배열)는 1 차원 배열입니다. 값을 해당 <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> 속성은 1입니다.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property of each.</source>
          <target state="translated">다음 예제에서는 1 차원 배열, 2 차원 배열 및 가변된 배열을 초기화 하 고 검색 된 <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> 각 속성입니다.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The one-dimensional, zero-based array to resize, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to create a new array with the specified size.</source>
          <target state="translated">크기를 조정할 1차원 배열(0부터 시작)이거나 지정한 크기로 새 배열을 만들 경우 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The size of the new array.</source>
          <target state="translated">새 배열의 크기입니다.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>Changes the number of elements of a one-dimensional array to the specified new size.</source>
          <target state="translated">1차원 배열의 요소 수를 지정된 새로운 크기로 변경합니다.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</source>
          <target state="translated">이 메서드 지정한 크기로 새 배열을 할당 하 고, 새 레코드로 이전 배열에서 요소를 복사, 한 다음 새 항목으로 이전 배열을 대체 합니다.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">`array`</ph> must be a one-dimensional array.</source>
          <target state="translated"><ph id="ph1">`array`</ph> 1 차원 배열 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`array`</ph> is <ph id="ph2">`null`</ph>, this method creates a new array with the specified size.</source>
          <target state="translated">경우 <ph id="ph1">`array`</ph> 은 <ph id="ph2">`null`</ph>,이 메서드는 지정 된 크기로 새 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is greater than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</source>
          <target state="translated">경우 <ph id="ph1">`newSize`</ph> 보다 크면는 <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> 이전 배열의 새 배열을 할당 되 고 요소를 모두 새로운 이전 배열에서 복사 됩니다.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is less than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</source>
          <target state="translated">경우 <ph id="ph1">`newSize`</ph> 는 보다 작은 <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> 이전 배열의 새 배열을 할당 하 고 요소가 복사 되 고 이전 배열에서 새로운 새 채워질 때까지 이전 배열에 있는 요소의 나머지는 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is equal to the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, this method does nothing.</source>
          <target state="translated">경우 <ph id="ph1">`newSize`</ph> 같은지는 <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> 이전 배열의이 메서드는 없습니다.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`newSize`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`newSize`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> method resizes a one-dimensional array only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> 메서드는 1 차원 배열 크기를 조정 합니다.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class does not include a method for resizing multi-dimensional arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 클래스는 다차원 배열 크기 조정에 대 한 메서드는 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>To do this, you must either provide your own code or call a special-purpose method in a third-party library.</source>
          <target state="translated">이 수행 하려면 사용자 고유의 코드를 제공 하거나 타사 라이브러리의 특수 한 용도의 메서드를 호출 해야 합니다.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following code illustrates one possible implementation for a method that resizes an array of <bpt id="p1">*</bpt>n<ept id="p1">*</ept> dimensions.</source>
          <target state="translated">다음 코드에서는의 배열 크기를 조정 하는 방법에 대 한 구현 <bpt id="p1">*</bpt>n<ept id="p1">*</ept> 차원.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following example shows how resizing affects the array.</source>
          <target state="translated">다음 예제에서는 크기 조정 배열에 미치는 영향</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Reverses the order of the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 일부에 있는 요소의 순서를 역순으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">순서를 바꿀 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>Reverses the sequence of the elements in the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 전체에 있는 요소의 시퀀스를 역순으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">요소에이 메서드를 호출한 후 <ph id="ph1">`myArray[i]`</ph>여기서 <ph id="ph2">`i`</ph> 는 배열에서 인덱스를 이동, <ph id="ph3">`myArray[j]`</ph>여기서 <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>As the following example shows, the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">다음 예제와 같이 <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> 가변된 배열이 되돌리려면 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</source>
          <target state="translated">현재 문화권의 달력에서 현재 연도의 각 달에 하나의 요소가 표시 된 가변된 배열을 초기화합니다.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>Each element contains an array with as many elements as that month has days.</source>
          <target state="translated">각 요소는 해당 월의 일 수 만큼의 요소와 배열이 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The example displays the contents of the array, calls the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method, and then displays the contents of the reversed array.</source>
          <target state="translated">이 예제에서는 배열, 호출의 내용을 표시는 <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> 메서드 및 역방향 배열의 내용 표시 합니다.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The following code example shows how to reverse the sort of the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제에 있는 값의 정렬 순서 반대로 바꾸는 방법을 보여 줍니다.는 <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">순서를 바꿀 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the section to reverse.</source>
          <target state="translated">순서를 바꿀 섹션의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the section to reverse.</source>
          <target state="translated">순서를 바꿀 섹션에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>Reverses the sequence of the elements in a range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에 있는 요소의 시퀀스를 역순으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">요소에이 메서드를 호출한 후 <ph id="ph1">`myArray[i]`</ph>여기서 <ph id="ph2">`i`</ph> 는 배열에서 인덱스를 이동, <ph id="ph3">`myArray[j]`</ph>여기서 <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> 가변된 배열이 되돌리려면 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">다음 코드 예제에 있는 요소의 범위에 있는 값의 정렬 순서 반대로 바꾸는 방법을 보여 줍니다.는 <ph id="ph1">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sets the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to the specified value.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 지정한 요소를 지정한 값으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 위치를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드를 확인할 수 있는지 여부를 값 <ph id="ph3">`index`</ph> 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 1차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">설정할 요소의 위치를 지정하는 인덱스를 나타내는 32비트 정수의 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">인덱스가 32비트 정수 배열로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">요소 수가 <ph id="ph1">`indices`</ph> 차원 수와 같아야는 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">모든 요소는 <ph id="ph1">`indices`</ph> 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드에 있는 값의 어느 것인지 확인 수는 <ph id="ph3">`indices`</ph> 배열 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 차수가 <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>에 있는 요소 수와 다른 경우</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>의 요소가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 위치를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드를 확인할 수 있는지 여부를 값 <ph id="ph3">`index`</ph> 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 1차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">설정할 요소의 위치를 지정하는 인덱스를 나타내는 64비트 정수의 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 다차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">인덱스가 64비트 정수 배열로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">요소 수가 <ph id="ph1">`indices`</ph> 차원 수와 같아야는 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">모든 요소는 <ph id="ph1">`indices`</ph> 는 다차원 배열 원하는 요소의 위치를 전체적으로 지정 해야 <ph id="ph2">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드에 있는 값의 어느 것인지 확인 수는 <ph id="ph3">`indices`</ph> 배열 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>의 차수가 <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>에 있는 요소 수와 다른 경우</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph>의 요소가 현재 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 이차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 이차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="index2" /&gt;</ph>가 현재 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 이차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 이차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="index2" /&gt;</ph>가 현재 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 세 번째 차원 인덱스를 나타내는 32비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">인덱스가 32비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 삼차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="index3" /&gt;</ph>이 현재 <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">지정한 요소의 새 값입니다.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 첫 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 두 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">설정할 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 요소의 세 번째 차원 인덱스를 나타내는 64비트 정수입니다.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">값을 삼차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 지정한 위치의 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">인덱스가 64비트 정수로 지정되어 있습니다.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> 메서드 범위를 벗어난 인덱스 중 하나 인지 여부를 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">변환에 대 한 자세한 내용은 참조 <ph id="ph1">&lt;xref:System.Convert&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> 할당 하는 데 사용 되 <ph id="ph2">`null`</ph> 값 형식의 배열 요소에는 요소의 모든 필드가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">요소의 값은 null 참조가 아니며 null 참조를 검색 하 여 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">다음 코드 예제에는 설정 하 고 1 차원 또는 다차원 배열에 특정 값을 가져오는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 삼차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>를 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 형식으로 캐스팅할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="index3" /&gt;</ph>이 현재 <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 해당 차원에 대한 올바른 인덱스 범위 밖에 있는 경우</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sorts the elements in a one-dimensional array.</source>
          <target state="translated">1차원 배열의 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>Sorts the elements in an entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용하여 1차원 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> 전체의 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">각 요소 <ph id="ph1">`array`</ph> 구현 해야 합니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 인터페이스를 다른 모든 요소와 비교할 <ph id="ph3">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an<bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는<bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">다음 코드 예제에서는 값을 정렬 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">현재는 결과 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 각 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>만을 정렬하려면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">각 키의 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 구현을 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 1차원 <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`keys`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">다음 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">현재는 결과 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The one-dimensional array to sort.</source>
          <target state="translated">정렬할 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 구현입니다.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Sorts the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 사용하여 1차원 <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>의 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>의 각 요소 <ph id="ph3">`array`</ph> 구현 해야 합니다는 <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> 인터페이스를 다른 모든 요소와 비교할 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework에 포함 되어 미리 정의 된 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 다음 표에 나열 된 구현입니다.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">구현</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">형식의 두 개체를 비교 <ph id="ph1">`T`</ph> 형식의 기본 정렬 순서를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 구현에는 <ph id="ph2">`comparer`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">이 예제는이 정의 하 여 수행 된 <ph id="ph1">`ReverseComparer`</ph> 클래스에 대 한 기본 정렬 순서를 반대로 하 형식 인스턴스의 대/소문자 구분 문자열 비교를 수행 하 고 합니다.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The following example sorts the values in a string arrayby using the default comparer.</source>
          <target state="translated">다음 예제에서는 기본 비교자를 사용 하 여 문자열 arrayby의 값을 정렬 합니다.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>It also defines a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation named <ph id="ph2">`ReverseComparer`</ph> that reverses an object's default sort order while performing a case-insensitive string comparison.</source>
          <target state="translated">또한 사용자 지정을 정의 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 라는 구현 <ph id="ph2">`ReverseComparer`</ph> 대/소문자 구분 문자열 비교를 수행 하는 동안 개체의 기본 정렬 순서를 반대로 하 합니다.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Note that the output might vary depending on the current culture.</source>
          <target state="translated">출력은 현재 문화권에 따라 달라질 수 있습니다는 참고 사항</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 각 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>만을 정렬하려면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 1차원 <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 각 키에서 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework에 포함 되어 미리 정의 된 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 다음 표에 나열 된 구현입니다.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">구현</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">형식의 두 개체를 비교 <ph id="ph1">`T`</ph> 형식의 기본 정렬 순서를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 구현에는 <ph id="ph2">`comparer`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The example does this by defining an <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">이 예제는이 정의 하 여 수행 된 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 기본 정렬 순서를 바꾸는 및 대/소문자 구분 문자열 비교를 수행 하는 구현 합니다.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`keys`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">다음 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">현재는 결과 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수 있는 정렬 작업 해당 previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용하여 1차원 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>이 요소 범위에 있는 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">각 요소에 있는 요소의 지정된 된 범위 내 <ph id="ph1">`array`</ph> 구현 해야 합니다는 <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> 인터페이스를 다른 모든 요소와 비교할 <ph id="ph3">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">다음 코드 예제에서는 값을 정렬 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">현재는 결과 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 각 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>만을 정렬하려면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">각 키의 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 구현을 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 1차원 <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">각 키에 있는 요소의 지정 된 범위에서의 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">다음 코드 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">현재는 결과 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph4">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>에서 올바른 범위를 지정하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 사용하여 1차원 <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>의 요소 범위에 있는 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 각 요소에 있는 요소의 지정된 된 범위 내 <ph id="ph3">`array`</ph> 구현 해야 합니다는 <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> 다른 모든 요소와 비교할 수 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework에 포함 되어 미리 정의 된 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 다음 표에 나열 된 구현입니다.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">구현</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">형식의 두 개체를 비교 <ph id="ph1">`T`</ph> 형식의 기본 정렬 순서를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 구현에는 <ph id="ph2">`comparer`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">이 예제는이 정의 하 여 수행 된 <ph id="ph1">`ReverseComparer`</ph> 클래스에 대 한 기본 정렬 순서를 반대로 하 형식 인스턴스의 대/소문자 구분 문자열 비교를 수행 하 고 합니다.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">다음 코드 예제에서는 값을 정렬 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">현재는 결과 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 각 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>만을 정렬하려면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 구현입니다.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated">각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> 구현을 사용할 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>를 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 1차원 <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 각 키에 있는 요소의 지정 된 범위에서는 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework에 포함 되어 미리 정의 된 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 다음 표에 나열 된 구현입니다.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">구현</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">두 개체를 비교 합니다. 하지만 문자열의 대/소문자 구분 비교를 수행 합니다.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">현재 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">고정 문화권의 정렬 규칙을 사용 하 여 두 개체를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">형식의 두 개체를 비교 <ph id="ph1">`T`</ph> 형식의 기본 정렬 순서를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">자신만의 인스턴스를 제공 하 여 사용자 지정 비교를 지원할 수도 있습니다 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 구현에는 <ph id="ph2">`comparer`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">이 예제는이 사용자 지정을 정의 하 여 수행 <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> 기본 정렬 순서를 바꾸는 및 대/소문자 구분 문자열 비교를 수행 하는 구현 합니다.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">다음 코드 예제에서는 키를 포함 하는 첫 번째 배열 하 고 두 번째 배열 값이 들어 있는 두 개의 관련 된 배열을 정렬 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">정렬 작업을 마쳤으면 기본 비교 연산자 및 정렬 순서를 반대로 하는 사용자 지정 비교자를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">현재는 결과 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>가 다차원 배열인 경우</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 하한이 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 하한과 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph4">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>에서 올바른 범위를 지정하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>Sorts the elements in an entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스 구현을 사용하여 전체 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>의 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">각 요소 <ph id="ph1">`array`</ph> 구현 해야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 <ph id="ph3">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> 제네릭 메서드 오버 로드와 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">임의의 순서로 문자열 배열을 만들어집니다.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">배열은 표시 하 고 정렬 하 고 다시 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">배열 및 반환 값은 <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> 메서드에 전달 되는 <ph id="ph2">`ShowWhere`</ph> 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">인덱스는 문자열이 n 경우 음수 배열에 하므로 <ph id="ph1">`ShowWhere`</ph> 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 <ph id="ph2">`Xor`</ph> Visual Basic의-1) 검색 stri 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 ng 합니다.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-base <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">요소를 비교할 때 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 제네릭 인터페이스 구현이거나 각 요소의 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스 구현을 사용할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 제네릭 인터페이스를 사용하여 <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>의 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>의 각 요소 <ph id="ph3">`array`</ph> 구현 해야 합니다는 <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 제네릭 메서드 오버 로드와 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">배열은 표시 하 고 정렬 하 고 다시 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">배열을 사용 하기 위해 정렬 해야는 <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 하나에 없는 배열과 하나는, 제네릭 메서드 오버 로드는 다음 두 개의 문자열을 검색 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">배열 및 반환 값은 <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 메서드에 전달 되는 <ph id="ph2">`ShowWhere`</ph> 문자열이 발견 되 고 그렇지 않은 경우 요소 검색 문자열은 사이 해당 배열에 있는 경우 인덱스 값을 표시 하는 제네릭 메서드를 합니다.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">인덱스는 문자열이 n 경우 음수 배열에 하므로 <ph id="ph1">`ShowWhere`</ph> 메서드를 사용 하며 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 <ph id="ph2">`Xor`</ph> Visual Basic의-1) 검색 stri 보다 큰 목록에서 첫 번째 요소의 인덱스를 가져옵니다 ng 합니다.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> to use when comparing elements.</source>
          <target state="translated">요소를 비교할 때 사용할 <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>을 사용하여 <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>의 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method uses introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The code example defines an alternative comparison method for strings, named <ph id="ph1">`CompareDinosByLength`</ph>.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교 메서드를 정의 <ph id="ph1">`CompareDinosByLength`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method works as follows: First, the comparandsare tested for<ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">이 방법은 다음과 같습니다: 테스트는 comparandsare 먼저<ph id="ph1">`null`</ph>, null 참조는 null이 아닌 미만으로 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">둘째, 문자열 길이 비교 하 고 더 긴 문자열이 큰 것으로 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">셋째, 길이 값이 같으면 일반 문자열 비교 ´ ù.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>A array of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">문자열의 배열 만들어지고 특정 순서 없이에서 4 개의 문자열 채워집니다.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list also includes an empty string and a null reference.</source>
          <target state="translated">목록에는 빈 문자열과 null 참조가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list is displayed, sorted using a <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> generic delegate representing the <ph id="ph2">`CompareDinosByLength`</ph> method, and displayed again.</source>
          <target state="translated">사용 하 여 정렬 목록이 표시 되는 <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> 나타내는 제네릭 대리자는 <ph id="ph2">`CompareDinosByLength`</ph> 메서드를 다시 표시 합니다.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 각 요소의 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스 구현을 사용하여 <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 범위에 있는 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">각 요소에 있는 요소의 지정된 된 범위 내 <ph id="ph1">`array`</ph> 구현 해야 합니다는 <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 <ph id="ph3">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 제네릭 메서드 오버 로드와 <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 배열 범위를 정렬 하는 것에 대 한 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">코드 예제에서는 만들고 세 육 식 동물 (정확 하 게 티라) 3 초 식으로 구성 된 공룡 이름의 배열을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 제네릭 메서드 오버 로드 하는 데 다음 표시 되는 배열의 마지막 세 요소를 정렬 합니다.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 제네릭 메서드 오버 로드를 사용 <ph id="ph2">`ReverseCompare`</ph> 마지막 세 요소를 반대 순서로 정렬 합니다.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">완전히 바뀐된 공룡의 다시 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">정렬할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">요소를 비교할 때 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 제네릭 인터페이스 구현이거나 각 요소의 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스 구현을 사용할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 제네릭 인터페이스를 사용하여 <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>의 요소 범위에 있는 요소를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 각 요소에 있는 요소의 지정된 된 범위 내 <ph id="ph3">`array`</ph> 구현 해야 합니다는 <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 요소와 비교할 수 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 제네릭 메서드 오버 로드와 <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 배열 범위를 정렬 하는 것에 대 한 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">코드 예제에서는 만들고 세 육 식 동물 (정확 하 게 티라) 3 초 식으로 구성 된 공룡 이름의 배열을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 제네릭 메서드 오버 로드 하는 데 다음 표시 되는 배열의 마지막 세 요소를 정렬 합니다.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 제네릭 메서드 오버 로드를 사용 <ph id="ph2">`ReverseCompare`</ph> 마지막 세 요소를 반대 순서로 정렬 합니다.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">완전히 바뀐된 공룡의 다시 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Visual Basic, C# 및 c + + 첫 번째 인수의 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 하는 제네릭이 다른 보이지 않습니다.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the key array.</source>
          <target state="translated">키 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the items array.</source>
          <target state="translated">항목 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>의 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)이거나 <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>만 정렬할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">각 키의 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 제네릭 인터페이스 구현을 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, 및 <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">다음 배열 정렬 이며 여러 번 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 오버 로드와의 인스턴스 <ph id="ph2">`ReverseCompare`</ph> 쌍을 이루는 배열의 정렬 순서를 반대로 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 두 배열의 마지막 세 요소를 정렬 하려면 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 오버 로드는 두 배열의 마지막 세 요소를 반대 순서로 정렬할 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 하한이 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 하한과 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">키 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">항목 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>의 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)이거나 <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>만 정렬할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">요소를 비교할 때 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 제네릭 인터페이스 구현이거나 각 요소의 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스 구현을 사용할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 제네릭 인터페이스를 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 각 키에서 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 는 <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph5">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, 및 <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">다음 배열 정렬 이며 여러 번 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload and an instance of <ph id="ph3">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; 오버 로드와의 인스턴스 <ph id="ph3">`ReverseCompare`</ph> 정렬 순서를 반대로 하는 데 사용 됩니다 쌍으로 연결 된 배열입니다.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 두 배열의 마지막 세 요소를 정렬 하려면 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 오버 로드는 두 배열의 마지막 세 요소를 반대 순서로 정렬할 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 하한이 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 하한과 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the key array.</source>
          <target state="translated">키 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the items array.</source>
          <target state="translated">항목 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>의 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)이거나 <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>만 정렬할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">각 키에서 구현하는 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 제네릭 인터페이스를 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">에 있는 요소의 지정 된 범위 내에서 각 키의 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt;, 및 <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드를 합니다.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">다음 배열 정렬 이며 여러 번 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 오버 로드와의 인스턴스 <ph id="ph2">`ReverseCompare`</ph> 쌍을 이루는 배열의 정렬 순서를 반대로 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt; overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt; 오버 로드 하는 데 두 배열의 마지막 세 요소를 정렬 합니다.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 오버 로드는 두 배열의 마지막 세 요소를 반대 순서로 정렬할 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 하한이 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 하한과 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph4">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>에서 올바른 범위를 지정하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">키 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">항목 배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">정렬할 키를 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>의 키에 해당하는 항목을 포함하는 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)이거나 <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>만 정렬할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">정렬할 범위의 시작 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">정렬할 범위에 있는 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">요소를 비교할 때 사용할 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 제네릭 인터페이스 구현이거나 각 요소의 <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스 구현을 사용할 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">지정한 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> 제네릭 인터페이스를 사용하여 첫 번째 <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>에 있는 키를 기반으로 하는 한 쌍의 <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> 개체(키를 포함하는 개체와 해당 항목을 포함하는 개체)의 요소 범위를 정렬합니다.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">각 키에는 <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 해당 항목에는 <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">키를 정렬 하는 동안 해당 항목의 위치가 변경 되는 경우는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 마찬가지로 위치가 변경 합니다.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">따라서는 <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> 에 해당 하는 키의 배열에 따라 정렬 된 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">경우 <ph id="ph1">`comparer`</ph> 은 <ph id="ph2">`null`</ph>, 각 키에 있는 요소의 지정 된 범위에서는 <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> 구현 해야 합니다는 <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> 제네릭 인터페이스를 다른 모든 키와 비교할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">키 보다 더 많은 항목이 있지만 키가 없는 해당 항목은 정렬 되지 정렬할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">정렬할 수 없습니다. 항목; 보다 더 많은 키가 있는 경우 이렇게 하면이를 throw 한 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">정렬 성공적으로 완료 되지 않은 경우 결과가 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">이 메서드는 다음과 같이 맞추어 내면적인 정렬 (introsort) 알고리즘을 사용합니다.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">사용 하 여 파티션 크기를 16 개 요소 경우는 <bpt id="p1">[</bpt>삽입 정렬<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">파티션 수가 2를 초과 하는 경우 * 로그<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>여기서 <bpt id="p2">*</bpt>N<ept id="p2">*</ept> 는 범위 입력 배열을 사용 하 여 한 <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">그렇지 않으면 사용는 <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> 알고리즘입니다.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">최악의 경우 Heapsort 및 Quicksort 알고리즘을 사용 하 여 정렬 된 배열에 대해이 메서드는는 O (<ph id="ph1">`n`</ph> 로그 <ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">`length`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, 및 [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; 쌍을 키와 값을 나타내는 배열 정렬에 대 한 제네릭 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">코드 예제에서는 문자열에 대 한 대체 비교자 정의 <ph id="ph1">`ReverseCompare`</ph>를 구현 하는 <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> Visual Basic의 <ph id="ph4">`IComparer&lt;String^&gt;`</ph> Visual c + +에서) 제네릭 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">비교자를 호출 하 여는 <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> 메서드를 문자열 높음-낮음 낮은-높은 대신 순서로 정렬 되도록 비교 대상의 순서를 반대로 합니다.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">코드 예제에서는 만들고 공룡 이름 (키)의 배열 및 각 공룡 미터 (값)의 최대 길이 나타내는 정수 배열을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">다음 배열 정렬 이며 여러 번 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> 두 배열에서 첫 번째 배열 공룡 이름의 순서로 정렬 하려면 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> 오버 로드와의 인스턴스 <ph id="ph2">`ReverseCompare`</ph> 쌍을 이루는 배열의 정렬 순서를 반대로 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> 두 배열의 마지막 세 요소를 정렬 하려면 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; 오버 로드를 사용 하는 마지막 세 정렬 하려면 요소가 모두 반대 순서로 배열입니다.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Visual Basic, C# 및 c + +의 처음 두 개의 인수 형식에서 제네릭 형식 매개 변수의 형식을 유추 하기 때문에 제네릭 메서드를 호출 제네릭이 아닌 대응에 대 한 호출에서 다르게 표시 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Microsoft intermediate language MSIL ()을 검사 하려면 확인할 수 있습니다는 제네릭 메서드의 호출 되 고 있습니다.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>의 하한값보다 작습니다.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 하한이 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 하한과 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph>의 길이가 <ph id="ph4">&lt;paramref name="items" /&gt;</ph>의 길이보다 긴 경우</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 올바른 범위를 지정하지 않습니다.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이 아니고 <ph id="ph3">&lt;paramref name="index" /&gt;</ph> 및 <ph id="ph4">&lt;paramref name="length" /&gt;</ph>가 <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>에서 올바른 범위를 지정하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>의 구현으로 인해 정렬 중에 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">예를 들어 항목을 자기 자신과 비교할 때 <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>에서 0을 반환하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이고 <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>의 요소 중 하나 이상이 <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> 제네릭 인터페이스를 구현하지 않는 경우</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 및 이전 버전에는 Quicksort 알고리즘만을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort 식별 하면 정렬 작업이 throw 하는 일부 상황에서 잘못 된 비교자는 <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> 예외를 throw 하 고는 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 호출자에 게는 예외입니다.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, 수를 이전에 정렬 작업에서 발생 했습니다 <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> 삽입 정렬 및 heapsort 알고리즘 잘못 된 비교자를 감지 하지 않으면, 예외를 throw 하지 것입니다.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">대부분의 경우 16 개 요소 배열에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" uid="P:System.Array.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This property implements the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">이 속성을 구현 하는 <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">.NET framework 클래스에 따라 <ph id="ph1">&lt;xref:System.Array&gt;</ph> 사용 하 여 컬렉션의 동기화 된 버전 제공는 <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">배열을 사용 하는 클래스를 사용 하 여 동기화 직접 구현할 수도 <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">동기화 하는 코드에서 작업을 수행 해야는 <ph id="ph1">`SyncRoot`</ph> 컬렉션으로 만들어지므로 컬렉션의 합니다.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">특히, 컬렉션을 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">일부 구현 <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 를 반환할 수 있습니다는 <ph id="ph2">&lt;xref:System.Array&gt;</ph> 자체입니다.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">컬렉션을 열거 하는 스레드로부터 안전한 프로시저가 아닙니다 기본적으로 합니다.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">다음 코드 예제에 사용 하 여 열거 하는 동안 배열을 잠그는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 포함된 요소 수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>The number of elements contained in the collection.</source>
          <target state="translated">컬렉션에 포함된 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The object to be added to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">개체가 <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>에 추가됩니다.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Calling this method always throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> exception.</source>
          <target state="translated">이 메서드를 호출하면 <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> 예외가 항상 throw됩니다.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Adding a value to an array is not supported.</source>
          <target state="translated">배열에 값을 추가하는 것은 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>No value is returned.</source>
          <target state="translated">값이 반환되지 않습니다.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Ordinarily, an <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implementation adds a member to a collection.</source>
          <target state="translated">일반적으로 <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> 구현 컬렉션에 멤버를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>However, because arrays have a fixed size (the <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property always returns <ph id="ph2">`true`</ph>), this method always throws a <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">그러나 배열 크기는 고정된 되어 때문에 (의 <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> 속성은 항상 반환 <ph id="ph2">`true`</ph>),이 메서드는 항상 throw 한 <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>가 고정 크기입니다.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>Removes all items from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>에서 항목을 모두 제거합니다.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">현재 목록에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The element to locate can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">찾을 요소는 참조 형식에 대해 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>에 요소가 있는지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>에 있으면 <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">현재 목록에서 찾을 개체입니다.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>에서 특정 항목의 인덱스를 결정합니다.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The index of value if found in the list; otherwise, -1.</source>
          <target state="translated">목록에 값이 있으면 해당 값의 인덱스이고, 그렇지 않으면 -1입니다.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>값<ept id="p1">&lt;/c&gt;</ept>을 삽입할 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The object to insert.</source>
          <target state="translated">삽입할 개체입니다.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>Inserts an item to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> at the specified index.</source>
          <target state="translated">항목을 <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>의 지정된 인덱스에 삽입합니다.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is not a valid index in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>의 유효한 인덱스가 아닌 경우</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>가 고정 크기입니다.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is null reference in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>에서 null 참조인 경우</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The index of the element to get or set.</source>
          <target state="translated">가져오거나 설정할 요소의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">지정한 인덱스에 있는 요소를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">지정한 인덱스의 요소입니다.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph>가 <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>보다 크거나 같은 경우</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>에 1차원이 없는 경우</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The object to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>에서 제거할 개체입니다.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>에서 맨 처음 발견되는 특정 개체를 제거합니다.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>가 고정 크기입니다.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The index of the element to remove.</source>
          <target state="translated">제거할 요소의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>Removes the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> item at the specified index.</source>
          <target state="translated">지정한 인덱스에서 <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> 항목을 제거합니다.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>index is not a valid index in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">인덱스는 <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>의 유효한 인덱스가 아닙니다.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>가 고정 크기입니다.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">현재 인스턴스와 비교할 개체입니다.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An object that compares the current object and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">현재 개체와 <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>를 비교하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</source>
          <target state="translated">정렬 순서에서 현재 컬렉션 개체의 위치가 다른 개체보다 앞인지, 뒤인지 또는 동일한지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An integer that indicates the relationship of the current collection object to other, as shown in the following table.</source>
          <target state="translated">다음 표와 같이 현재 컬렉션 개체와 다른 개체 사이의 관계를 나타내는 정수입니다.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 반환 값</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 설명</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance precedes <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 현재 인스턴스가 <ph id="ph3">&lt;paramref name="other" /&gt;</ph> 앞에 옵니다.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 현재 인스턴스와 <ph id="ph3">&lt;paramref name="other" /&gt;</ph>이 같습니다.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance follows <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 현재 인스턴스가 <ph id="ph3">&lt;paramref name="other" /&gt;</ph> 뒤에 옵니다.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">현재 인스턴스와 비교할 개체입니다.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>An object that determines whether the current instance and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> are equal.</source>
          <target state="translated">현재 인스턴스와 <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>이 같은지를 확인하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>Determines whether an object is equal to the current instance.</source>
          <target state="translated">개체가 현재 인스턴스와 같은지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the two objects are equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">두 개체가 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그러지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>An object that computes the hash code of the current object.</source>
          <target state="translated">현재 개체의 해시 코드를 계산하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>Returns a hash code for the current instance.</source>
          <target state="translated">현재 인스턴스의 해시 코드를 반환합니다.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>The hash code for the current instance.</source>
          <target state="translated">현재 인스턴스에 대한 해시 코드입니다.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">이 멤버는 명시적 인터페이스 멤버 구현이며,</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> 인스턴스가 <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">배열 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to check against the conditions.</source>
          <target state="translated">조건에 대해 확인할 1차원 <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>(인덱스는 0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions to check against the elements.</source>
          <target state="translated">요소에 대해 확인할 조건을 정의하는 조건자입니다.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Determines whether every element in the array matches the conditions defined by the specified predicate.</source>
          <target state="translated">배열의 모든 요소가 지정한 조건자에 정의된 조건과 일치하는지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if every element in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 모든 요소가 지정한 조건자에 정의된 조건과 일치하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>If there are no elements in the array, the return value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">배열에 요소가 없으면 반환 값은 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns<ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> 반환 하는 메서드에 대리자<ph id="ph2">`true`</ph> 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
          <target state="translated">요소 <ph id="ph1">`array`</ph> 를 개별적으로 전달 되는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, 대리자는 반환 될 때 처리가 중지 됩니다 <ph id="ph3">`false`</ph> 모든 요소에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 는 <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> 의 <ph id="ph4">`array`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example determines whether the last character of each element in a string array is a number.</source>
          <target state="translated">다음 예제에서는 문자열 배열의 각 요소에에서의 마지막 문자가 숫자 인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>It creates two string arrays.</source>
          <target state="translated">두 개의 문자열 배열을 만듭니다.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</source>
          <target state="translated">첫 번째 arrayincludes 모두 알파벳 문자로 끝나는 문자열 및 숫자 문자로 끝나는 문자열. 두 번째 배열 숫자 문자로 끝나는 문자열만 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example also defines an <ph id="ph1">`EndWithANumber`</ph> method whose signature matches the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">이 예제에서는 또한 정의 <ph id="ph1">`EndWithANumber`</ph> 서명과 일치 하는 메서드는 <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example passes each array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with a delegate that represents the <ph id="ph2">`EndsWithANumber`</ph> method.</source>
          <target state="translated">각 배열에 전달 된 <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> 메서드를 나타내는 대리자과 함께 <ph id="ph2">`EndsWithANumber`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example is similar to the first, except that it passes the string array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</source>
          <target state="translated">다음 예제는은 첫 번째 제외 하는 문자열 배열에 전달 된 <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> 메서드는 특정 배열 요소 숫자의 문자열 표현으로 끝나는지 여부를 확인 하는 람다 식과 함께 합니다.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> as soon as it encounters the first array element that does not end in a number.</source>
          <target state="translated">두 경우 모두는 <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> 메서드 반환 <ph id="ph2">`false`</ph> 숫자에 종료 하지 않는 첫 번째 배열 요소를 발견 되는 즉시 합니다.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Otherwise, it returns <ph id="ph1">`true`</ph> after iterating all the elements in the array.</source>
          <target state="translated">그렇지 않으면 반환 <ph id="ph1">`true`</ph> 배열의 모든 요소를 반복 하면 됩니다.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>As both examples show, in C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">만들 필요가 없다는 두 예와 같이, C# 및 Visual Basic의 경우에 <ph id="ph1">`Predicate&lt;string&gt;`</ph> 위임 (<ph id="ph2">`Predicate(Of String)`</ph> Visual basic에서) 명시적으로 합니다.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>