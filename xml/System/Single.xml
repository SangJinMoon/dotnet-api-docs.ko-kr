<Type Name="Single" FullName="System.Single">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="77e71ab8535b5bfefd6030c3226091df1a03daa3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429417" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>단정밀도 부동 소수점 숫자를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single> 값 형식은 음수 3.402823 e 38에서 양수 또는 음수 0, 뿐만 아니라 양수 3.402823 e 38 까지의 값을 가진 단 정밀도 32 비트 숫자를 나타냅니다 <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>, 및 not-a-number (<xref:System.Single.NaN>). 값 (예: 행 또는 은하계 사이의 거리) 매우 큰 수 또는 매우 작은 (예: 킬로그램에 물질의 분자 질량)과 종종 정확 하지 않습니다 (예: 다른 태양계 지구 까지의 거리 값을 나타내는 것은 ). <xref:System.Single> 종류는 IEC 60559: 1989 (IEEE 754) 이진 부동 소수점 연산에 대 한 표준 준수 합니다.  
  
 이 항목은 다음 섹션으로 구성되어 있습니다.  
  
-   [부동 소수점 표현 및 정밀도](#Precision)  
  
-   [같음에 대 한 테스트](#Equality)  
  
-   [부동 소수점 값 및 예외](#Exceptions)  
  
-   [형식 변환 및 단일 구조](#Conversion)  
  
-   [부동 소수점 기능](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> 인스턴스 값을 문자열 표현으로 변환 하 고 숫자의 문자열 표현을이 형식의 인스턴스로 변환이 형식의 인스턴스를 비교 하는 메서드를 제공 합니다. 형식 사양 코드로 값 형식의 문자열 표현을 제어 하는 방법에 대 한 정보를 참조 하십시오. [형식 지정](~/docs/standard/base-types/formatting-types.md), [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md), 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>부동 소수점 표현 및 정밀도  
 <xref:System.Single> 데이터 형식은 다음 표에 나와 있는 것 처럼 32 비트 이진 형식으로 단 정밀도 부동 소수점 값을 저장 합니다.  
  
|파트|비트|  
|----------|----------|  
|Significand 또는 수|0-22|  
|지 수|23-30|  
|기호 (0 = 1 양수, 음수 =)|31|  
  
 소수 일부 소수 값을 정확 하 게 표현할 수 없는 경우와 마찬가지로 (1/3 등 또는 <xref:System.Math.PI?displayProperty=nameWithType>), 이진 분수가 일부 소수 자릿수 값을 나타낼 수 없습니다. 예를 들어 2/10, 소수 부분으로.2 요소로 정확 하 게 표시 되는 패턴 "1100" 반복으로 무한대로와 이진 소수로.0011111001001100으로 표시 됩니다. 이 경우 부동 소수점 값 표시 되는 숫자의 정확 하지 않은 표현을 제공 합니다. 정밀도 부족을 증가 종종 원래 부동 소수점 값에 추가적인 수치 연산을 수행 합니다. 예를 들어.3으로 10을 곱한 결과 비교 하며 9 번.3에.3을 추가, 나타납니다 추가 하는 경우는 보다 덜 정확한 결과 생성 곱하기 보다 더 많은 작업을 8 개를 포함 하기 때문에 있습니다. 이 불일치가 두를 표시 하는 경우에 명백한는 <xref:System.Single> "R"을 사용 하 여 값 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md)이며 필요한 경우에서 지 원하는 정밀도 9 자리를 모두 표시 하는 경우는 <xref:System.Single> 유형입니다.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 일부 숫자는 소수 이진 값과 동일 하 게 표현할 수 없는 때문에 대략적인 실수 부동 소수점 숫자에 수 있습니다.  
  
 모든 부동 소수점 숫자가 제한 된 수의 유효 자릿수 부동 소수점 값을 근사치 숫자는 실수를 계산 하는 방식을 정확 하 게 결정 합니다. A <xref:System.Single> 값에 최대 7 자리의 정밀도 최대 9 자리 내부적으로 유지 합니다. 즉, 부동 소수점 연산에는 정밀도 부동 소수점 값을 변경 하려면 별로 수 있습니다. 다음 예제에서는 큰 단 정밀도 부동 소수점 값을 정의 하 고 다음의 제품에 추가 <xref:System.Single.Epsilon?displayProperty=nameWithType> 및를 하나 quadrillion 합니다. 그러나 제품 원래 부동 소수점 값을 수정 하려면 너무 작습니다. 가장 덜 중요 한 자리는 1/1000, 제품의 최대 유효 자릿수는 1 하는 반면<sup>-312</sup>합니다.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 제한 된 정밀도 부동 소수점 숫자의 몇 가지 결과가 발생 합니다.  
  
-   최소 유효 자릿수가 다르기 때문에 특정 전체 자릿수에 대 한 동일 하 게 나타나는 두 부동 소수점 숫자가 같은지 비교 하지 수도 있습니다. 다음 예제에서는 일련의 숫자를 더한 및 고 합계가 예상 되는 전체와 비교 됩니다. 두 값이 동일한 경우에 대 한 호출을 표시 하지만 `Equals` 메서드는 없다는 것을 나타냅니다.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     형식 항목을 변경 하는 경우는 <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> 에서 문을 `{0}` 및 `{1}` 를 `{0:R}` 및 `{1:R}` 두 유효 자릿수가 모두 표시 하려면 <xref:System.Single> 값이 명확한 경우 두 값이 서로 같지 않은지 때문에 추가 작업 중 전체 자릿수의 손실입니다. 이 경우 호출 하 여 문제를 해결할 수 있습니다는 <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> 반올림 하는 메서드는 <xref:System.Single> 비교를 수행 하기 전에 원하는 정밀도 값입니다.  
  
-   부동 소수점 숫자를 사용 하는 수치 또는 비교 연산을 하지 산출할 수 동일한 결과 10 진수를 사용 하는 경우 이진 부동 소수점 숫자는 10 진수과 같지 않을 때문에입니다. .3으로 10을 곱한 및.3에.3 9 번 추가의 결과 표시 하 여이 화면 하는 이전 예입니다.  
  
     사용 하 여 소수 자릿수 값이 포함 된 숫자 연산에는 정확도 중요 한 경우는 <xref:System.Decimal> 형식 대신는 <xref:System.Single> 유형입니다. 때의 범위를 벗어난 정수 값으로 숫자 연산에는 정확도 <xref:System.Int64> 또는 <xref:System.UInt64> 사용 하 여 형식을 반드시는 <xref:System.Numerics.BigInteger> 형식입니다.  
  
-   부동 소수점 숫자가 포함 된 경우 왕복 하지 않는 값 않을 수 있습니다. 작업은 원래 부동 소수점 숫자를 다른 형식으로 변환 하 고 역 작업이 변환에서 변환 된 형식을 부동 소수점 숫자에 다시 최종 부동 소수점 숫자가 같은지를 원래 값을 왕복 하는 데 라고 부동 소수점 수입니다. 하나 이상의 최하위 유효 자릿수가 손실 되거나 변환에서 변경 때문에 대 한 왕복은 실패할 수 있습니다. 다음 예제에서는 세 가지 <xref:System.Single> 값을 문자열로 변환 되 고 파일에 저장 합니다. 볼 수 있듯이 출력 값이 동일한 것으로 표시 하지만, 복원 된 값의 원래 값과 같지 않습니다.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     이 경우 값 성공적으로 라운드트립 사용 하 여 수 "G9" [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 의 전체 자릿수를 유지 하기 위해 <xref:System.Single> 다음 예제와 같이 값입니다.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> 값 보다 적은 정밀도 <xref:System.Double> 값입니다. A <xref:System.Single> 겉보기 해당 하는 변환 된 값 <xref:System.Double> 종종과 같지 않습니다는 <xref:System.Double> 정밀도의 차이 때문에 값입니다. 다음 예제에서는 동일한 나누기 작업의 결과에 할당 됩니다는 <xref:System.Double> 값 및 <xref:System.Single> 값입니다. 이후에 <xref:System.Single> 값으로 캐스팅 되는 <xref:System.Double>, 두 값의 비교는 같지 않은 것을 보여 줍니다.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     이 문제를 방지를 사용 하 여는 <xref:System.Double> 데이터 형식 자리에 <xref:System.Single> 데이터 형식이 나 사용 하 여는 <xref:System.Math.Round%2A> 메서드 두 값이 같은 정밀도 갖도록 합니다.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>같음에 대 한 테스트  
 같은, 두 개의 <xref:System.Single> 값 동일한 값을 나타내야 합니다. 그러나 값을 정밀도에서 차이점이 있기 때문에 또는 하나 또는 두 값에 따라 정밀도 손실 때문에 종종 동일한 것으로 예상 되는 부동 소수점 값으로 판명 최하위 유효 자릿수의 차이로 인해 동일 하지 않은 것입니다. 결과적으로,에 대 한 호출이 <xref:System.Single.Equals%2A> 대 한 호출이 나 두 값이 같은지를 확인 하는 <xref:System.Single.CompareTo%2A> 메서드 두 관계를 확인 하려면 <xref:System.Single> 값, 종종 하면 예기치 않은 결과가 합니다. 이 다음 예제에서 분명 하 게 한 두 개의 분명히과 같아야 <xref:System.Single> 값이 첫 번째 값 이지만 두 번째 값에는 9의 전체 자릿수는 7 자리에 있기 때문에 같지 않은 것으로 판명 됩니다.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 계산 된 값을 서로 다른 코드 경로 따르는 및 다양 한 방법에서 종종 조작 되는 같지 않은 것으로 증명 합니다. 다음 예제에서는 하나의 <xref:System.Single> 값을 제곱 하 고 원래 값을 복원 하기 위해 제곱근 계산 되는 다음 합니다. 두 번째 <xref:System.Single> 3.51으로 곱하고 원래 값으로 복원 3.51 나눈 결과의 제곱근 전에 제곱 됩니다. 가 두 값을 동일한 것으로 표시 되지만에 대 한 호출에서 <xref:System.Single.Equals%28System.Single%29> 메서드는 같지 않은 것을 나타냅니다. "G9" 표준 형식 문자열을 사용 하 여 각각의 모든 유효 자릿수가 표시 하는 결과 문자열을 반환 <xref:System.Single> 값 두 번째 값.0000000000001 임을 보여 줍니다. 첫 번째 보다 작아야 합니다.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 정밀도의 손실 비교의 결과 영향을 줄 가능성이 높은 경우에 호출 하는 대신 다음 기술을 사용할 수 있습니다는 <xref:System.Single.Equals%2A> 또는 <xref:System.Single.CompareTo%2A> 메서드:  
  
-   호출의 <xref:System.Math.Round%2A?displayProperty=nameWithType> 값이 모두 같은 정밀도 갖도록 하는 메서드입니다. 다음 예제에서는 두 개의 소수 값이 같으면 되도록이 방법을 사용 하도록 이전 예제를 수정 합니다.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     정밀도의 문제는 여전히 중간점 값의 반올림에 적용 되는 참고 합니다. 자세한 내용은 <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> 메서드를 참조하세요.  
  
-   일치 대신 대략적인 같음을 테스트 합니다. 이러한 기술을 사용 하거나 절대를 정의 하는 두 값 다를 수 있지만 여전히는 양 같아야 또는 더 작은 값 보다 큰 값에서 벗어날 수 있는 상대 크기를 정의 합니다.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> 두 개의 사이의 거리를 측정 하는 절대로 사용 되기도 <xref:System.Single> 같은지 테스트할 때 값입니다.  그러나 <xref:System.Single.Epsilon?displayProperty=nameWithType> , 추가 하거나에서 뺀 수 있는 가능한 가장 작은 값을 측정 한 <xref:System.Single> 값이 0 인 합니다. 대부분 양수 및 음수 <xref:System.Single> 값, 값 <xref:System.Single.Epsilon?displayProperty=nameWithType> 감지 너무 작습니다. 따라서 값 0을 제외 하 고 권장 하지는 않습니다 같음에 대 한 테스트에 사용 합니다.  
  
     다음 예제에서는 후자의 방법을 사용할 경우 사용 하 여 정의 `IsApproximatelyEqual` 두 값 간의 상대적 차이 테스트 하는 메서드. 결과에 대 한 호출 또한 대조는 `IsApproximatelyEqual` 메서드 및 <xref:System.Single.Equals%28System.Single%29> 메서드.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>부동 소수점 값 및 예외  
 부동 소수점 값을 사용 하 여 작업에서 오버플로 또는 0으로 나누기와 같은 잘못 된 작업의 경우에 예외를 throw 하는 정수 계열 형식 작업과 달리 예외를 throw 하지 않습니다.  대신, 이러한 경우 부동 소수점 연산의 결과 0, 양의 무한대, 음의 무한대 또는 (nan 숫자가) not-a-number:  
  
-   부동 소수점 연산의 결과 대상 형식에 너무 작은 경우의 결과 0입니다. 다음 예제와 같이 두 매우 작은 부동 소수점 숫자가 곱할 경우 발생할 수 있습니다.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   부동 소수점 연산의 결과의 크기가 대상 형식의 범위를 초과한 경우 작업의 결과 <xref:System.Single.PositiveInfinity> 또는 <xref:System.Single.NegativeInfinity>결과의 부호에 따라 합니다. 오버플로 하는 작업의 결과 <xref:System.Single.MaxValue?displayProperty=nameWithType> 은 <xref:System.Single.PositiveInfinity>, 및를 오버플로 하는 작업의 결과 <xref:System.Single.MinValue?displayProperty=nameWithType> 은 <xref:System.Single.NegativeInfinity>다음 예제와 같이 합니다.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> 또한 양의 피제수와 0으로 나누기에서 발생 하 고 <xref:System.Single.NegativeInfinity> 음수 피제수와 0으로 나누기에서 결과입니다.  
  
-   부동 소수점 연산이 유효 하지 않을 경우 작업의 결과 <xref:System.Single.NaN>합니다. 예를 들어 <xref:System.Single.NaN> 다음과 같은 작업에서 발생 합니다.  
  
    -   0 피제수와 0으로 나누었습니다. 참고에서 결과가 0으로 나누기의 경우 다른 <xref:System.Single.PositiveInfinity> 또는 <xref:System.Single.NegativeInfinity>합니다.  
  
    -   부동 소수점 작업을 입력이 잘못 되었습니다. 음수 값의 제곱근을 반환 찾으려고 시도 하는 예를 들어 <xref:System.Single.NaN>합니다.  
  
    -   값이 인수가 지정 된 모든 작업 <xref:System.Single.NaN?displayProperty=nameWithType>합니다.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>형식 변환 및 단일 구조  
 <xref:System.Single> 컴파일러에 의해 변환이 구현 하는 대신; 구조 모든 명시적 또는 암시적 변환 연산자를 정의 하지 않습니다.  
  
 다음 표에서 가능한 변환은 값이 다른 기본 숫자 형식에의 한 <xref:System.Single> 값을 주며 변환을 확대 또는 축소 되는 여부 및 여부 결과 <xref:System.Single> 보다 적은 정밀도 있을 수 있습니다는 원래 값입니다.  
  
|B*에서 A*로의 변환이|확대/축소|정밀도의 손실 될 수|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|아니요|  
|<xref:System.Decimal>|Widening<br /><br /> C#는 캐스트 연산자를 참고 합니다.|예. <xref:System.Decimal> 29 10 진수 자리의 정밀도 지원합니다. <xref:System.Single> 9를 지원 합니다.|  
|<xref:System.Double>|축소; 범위를 벗어난 값으로 변환할지 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.|예. <xref:System.Double> 정밀도의 열일곱 자릿수로 지원 <xref:System.Single> 9를 지원 합니다.|  
|<xref:System.Int16>|Widening|아니요|  
|<xref:System.Int32>|Widening|예. <xref:System.Int32> 정밀도의 10 진수 자릿수를 지원 <xref:System.Single> 9를 지원 합니다.|  
|<xref:System.Int64>|Widening|예. <xref:System.Int64> 정밀도의 19 10 진수를 지원합니다. <xref:System.Single> 9를 지원 합니다.|  
|<xref:System.SByte>|Widening|아니요|  
|<xref:System.UInt16>|Widening|아니요|  
|<xref:System.UInt32>|Widening|예. <xref:System.UInt32> 정밀도의 10 진수 자릿수를 지원 <xref:System.Single> 9를 지원 합니다.|  
|<xref:System.UInt64>|Widening|예. <xref:System.Int64> 정밀도의 20 10 진수를 지원합니다. <xref:System.Single> 9를 지원 합니다.|  
  
 다음 예제에서는 다른 기본 숫자 형식의 최소값 또는 최대값 값 변환는 <xref:System.Single> 값입니다.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 또한는 <xref:System.Double> 값 <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 를 변환할 <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>각각.  
  
 일부 숫자 형식의 값 변환은 <xref:System.Single> 값 정밀도 손실 될 수 있습니다. 변환할 때 정밀도의 손실 될 수 예제와 같이 <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, 및 <xref:System.UInt64> 값을 <xref:System.Single> 값입니다.  
  
 변환은 <xref:System.Single> 값을 한 <xref:System.Double> 확대 변환 합니다. 변환 하는 경우 전체 자릿수 손실이 발생할 수 있습니다는 <xref:System.Double> 형식에 대 한 정확한 표현이 없는 <xref:System.Single> 값입니다.  
  
 변환은 <xref:System.Single> 이외의 모든 기본 숫자 데이터 형식의 값에 값을 <xref:System.Double> 는 축소 변환 하 고 캐스트 연산자 (C#에서) 또는 변환 메서드 (Visual Basic)에서는 필요 합니다. 대상 유형으로 정의 된 대상 데이터 형식의 범위 밖에 있는 값 `MinValue` 및 `MaxValue` 속성을 다음 표에 나와 있는 것 처럼 동작 합니다.  
  
|대상 형식|결과|  
|-----------------|------------|  
|다른 정수 계열 형식|<xref:System.OverflowException> checked 컨텍스트에서 변환이 발생 하는 경우는 예외입니다.<br /><br /> Unchecked 컨텍스트에서 (C#에서 기본값) 변환을 수행 하는 경우 변환 작업은 성공 하지만 값 오버플로가 발생 합니다.|  
|<xref:System.Decimal>|<xref:System.OverflowException> 예외|  
  
 또한 <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> throw는 <xref:System.OverflowException> 컨텍스트 있지만 unchecked 컨텍스트에서 정수로 변환 하는 경우 이러한 값 오버플로 정수로 변환 합니다. 변환에 대 한 <xref:System.Decimal>, 항상 throw 한 <xref:System.OverflowException>합니다. 변환에 대 한 <xref:System.Double>를 변환 <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>각각.  
  
 정밀도의 손실을 변환 하 여 발생할 수는 <xref:System.Single> 값을 다른 숫자 형식입니다. 정수 계열이 아닌 변환의 경우 <xref:System.Single> 값을 예제의 출력에서 볼 수 있듯이 소수 부분이 손실 되는 경우는 <xref:System.Single> 값 반올림 됩니다 (예: Visual Basic) 또는 (예: C#) 잘립니다. 변환에 대 한 <xref:System.Decimal> 값의 <xref:System.Single> 값이 정확한 표시 대상 데이터 형식에 없을 수도 있습니다.  
  
 다음 예제에서는 다양 한 변환 <xref:System.Single> 값을 다른 여러 가지 숫자 형식입니다. (기본값) Visual basic에서 및 C#에서 확인 된 컨텍스트에서 발생 하는 변환을 (때문에 [체크](~/docs/csharp/language-reference/keywords/checked.md) 키워드)입니다. 예제의 출력에서 선택 된 변환에 대 한 결과 보여 줍니다. unchecked 컨텍스트. 사용 하 여 컴파일하면 Visual Basic에서는 unchecked 컨텍스트에서 변환을 수행할 수 있습니다는 `/removeintchecks+` 컴파일러 스위치와 C# 주석으로 처리 하 여는 `checked` 문.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 숫자 형식의 변환 작업에 대 한 자세한 내용은 참조 하십시오. [.NET Framework의 형식 변환](~/docs/standard/base-types/type-conversion.md) 및 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md)합니다.  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>부동 소수점 기능  
 <xref:System.Single> 구조와 관련 된 형식을 다음과 같은 범주의 작업을 수행 하는 메서드를 제공 합니다.  
  
-   **값의 비교**합니다. 호출할 수 있습니다는 <xref:System.Single.Equals%2A> 두 지 여부를 결정 하는 메서드 <xref:System.Single> 값이 같으면 또는 <xref:System.Single.CompareTo%2A> 메서드를 두 값 간에 관계를 결정 합니다.  
  
     <xref:System.Single> 구조는 또한 비교 연산자의 전체 집합을 지원 합니다. 예를 들어 같음 또는 같지 않음, 테스트 또는 하나의 값이 다른 값 보다 크거나 여부 확인 수 있습니다. 피연산자 중 하나가 한 <xref:System.Double>, <xref:System.Single> 값으로 변환 됩니다는 <xref:System.Double> 비교를 수행 하기 전에. 피연산자 중 하나는 정수 계열 형식을 이면 변환할는 <xref:System.Single> 비교를 수행 하기 전에. 하지만 이러한 확대 변환, 전체 자릿수 손실을 프로세서별 수 있습니다.  
  
    > [!WARNING]
    >  전체 자릿수의 차이 때문에 두 개의 <xref:System.Single> 동일한 것으로 예상 하는 값 수 판명 같지 않은 것을 비교 결과 영향을 주는 합니다. 참조는 [같음 테스트](#Equality) 두 개를 비교 하는 방법에 대 한 자세한 내용은 섹션 <xref:System.Single> 값입니다.  
  
     호출할 수도 있습니다는 <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, 및 <xref:System.Single.IsNegativeInfinity%2A> 를 이러한 특수 값에 대 한 테스트 합니다.  
  
-   **수학 연산을**합니다. 더하기, 빼기, 곱하기 및 나누기 등의 일반적인 산술 연산이 아니라 언어 컴파일러 및 공용 중간 언어 (CIL) 지침으로 구현 됩니다 <xref:System.Single> 메서드. 수치 연산이 다른 피연산자가는 <xref:System.Double>, <xref:System.Single> 변환할는 <xref:System.Double> 이기도 작업과 작업의 결과 수행 하기 전에 <xref:System.Double> 값입니다. 경우 다른 피연산자는 정수 계열 형식으로 변환 됩니다는 <xref:System.Single> 이기도 작업과 작업의 결과 수행 하기 전에 <xref:System.Single> 값입니다.  
  
     호출 하 여 다른 수치 연산을 수행할 수 있습니다 `static` (`Shared` Visual basic에서)의 메서드는 <xref:System.Math?displayProperty=nameWithType> 클래스입니다. 연산에 대해 일반적으로 사용 되는 추가 방법 여기에 (같은 <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, 및 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), 기 하 도형 (와 같은 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 및 <xref:System.Math.Sin%2A?displayProperty=nameWithType>), 및 미적분 법 (같은 <xref:System.Math.Log%2A?displayProperty=nameWithType>).  모든 경우에는 <xref:System.Single> 값으로 변환 됩니다는 <xref:System.Double>합니다.  
  
     개별 비트를 조작할 수도 있습니다는 <xref:System.Single> 값입니다. <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> 메서드는 바이트 배열에 해당 비트 패턴을 반환 합니다.  해당 바이트 배열을 전달 하 여는 <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> 메서드를 유지할 수 있습니다도 <xref:System.Single> 값 비트 패턴의 32 비트 정수에에서의 합니다.  
  
-   **반올림**합니다. 반올림는 대개 기술로 부동 소수점 표현 및 정밀도 문제로 인해 발생 하는 값 사이의 차이의 영향을 줄이기 위한 합니다. 반올림할 수는 <xref:System.Single> 호출 하 여 값의 <xref:System.Math.Round%2A?displayProperty=nameWithType> 메서드. 하지만는 <xref:System.Single> 값으로 변환 됩니다는 <xref:System.Double> 는 메서드를 호출 하 고 변환 정밀도 손실 될 수 있습니다.  
  
-   **서식 지정**합니다. 변환할 수 있습니다는 <xref:System.Single> 값을 호출 하 여 해당 문자열 표현에서 <xref:System.Single.ToString%2A> 메서드 또는 사용 하 여는 [합성 서식 지정](~/docs/standard/base-types/composite-formatting.md) 기능입니다. 형식 문자열에서 부동 소수점 값의 문자열 표현을 제어 하는 방법에 대 한 정보에 대 한 참조는 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md) 항목입니다.  
  
-   **문자열 구문 분석**합니다. 부동 소수점 값으로의 문자열 표현을 변환할 수 있습니다는 <xref:System.Single> 호출 하 여 값의 <xref:System.Single.Parse%2A> 또는 <xref:System.Single.TryParse%2A> 메서드. 구문 분석이 실패 하는 경우는 <xref:System.Single.Parse%2A> 메서드 예외를 throw 하는 반면는 <xref:System.Single.TryParse%2A> 메서드 반환 `false`합니다.  
  
-   **형식 변환**합니다. <xref:System.Single> 구조에 대 한 명시적 인터페이스 구현을 제공는 <xref:System.IConvertible> 인터페이스에는 두 개의 표준.NET Framework 데이터 형식 간의 변환만 지원 합니다. 언어 컴파일러 때에 다른 모든 표준 숫자 형식 변환 제외 하 고에 대 한 값의 암시적 변환이 지원 <xref:System.Double> 를 <xref:System.Single> 값입니다. 모든 표준 숫자 형식 이외의 다른 값으로 변환은 <xref:System.Double> 에 <xref:System.Single> 확대 변환이 캐스팅 연산자나 변환 메서드를 사용 하는 필요 하지 않습니다.  
  
     그러나 32 비트 및 64 비트 정수 값의 변환에는 정밀도 손실이 될 수 있습니다. 다음 표에서 32 비트, 64 비트에 대 한 전체 자릿수의 차이가 및 <xref:System.Double> 유형:  
  
    |형식|최대 소수 자릿수 (소수 자릿수)|내부 소수 자릿수 (소수 자릿수)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> 및 <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> 및 <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|10|  
  
     정밀도의 문제에 영향을 가장 많이 <xref:System.Single> 변환 된 값 <xref:System.Double> 값입니다. 다음 예제에서는 동일한 나누기 연산에 의해 발생 하는 두 개의 값 서로 다름을으로 변환 하는 단 정밀도 부동 소수점 값 이므로 값 중 하나는 <xref:System.Double>합니다.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 유형의 모든 멤버는 스레드로부터 안전 합니다. 멤버 인스턴스 상태를 수정 하려면 표시 되는 실제로 새 값으로 초기화 하는 새 인스턴스를 반환 합니다. 으로 다른 종류와이 형식의 인스턴스를 포함 하는 공유 변수를 읽고 쓰는 보호 해야 스레드로부터 안전을 보장 하려면 잠금에 의해.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스를 지정된 개체나 다른 <see cref="T:System.Single" /> 인스턴스와 비교하고 이 인스턴스의 값이 지정된 개체나 다른 <see cref="T:System.Single" /> 인스턴스의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">비교할 개체 또는 <see langword="null" />입니다.</param>
        <summary>이 인스턴스를 지정된 개체와 비교하고 이 인스턴스의 값이 지정된 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>이 인스턴스와 <paramref name="value" />의 상대 값을 나타내는 부호 있는 숫자입니다.  
  
 <list type="table"><listheader><term> 반환 값  </term><description> 설명  </description></listheader><item><term> 0보다 작음  </term><description> 이 인스턴스는 <paramref name="value" />보다 작습니다.  -또는-  이 인스턴스가 숫자(<see cref="F:System.Single.NaN" />)가 아니고 <paramref name="value" />가 숫자입니다.  </description></item><item><term> 0  </term><description> 이 인스턴스가 <paramref name="value" />과 같습니다.  -또는-  이 인스턴스 및 값이 모두 숫자(<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> 또는 <see cref="F:System.Single.NegativeInfinity" />가 아닙니다.  </description></item><item><term> 0보다 큼  </term><description> 이 인스턴스는 <paramref name="value" />보다 큽니다.  -또는-  이 인스턴스가 번호이고 <paramref name="value" />가 숫자(<see cref="F:System.Single.NaN" />)이 아닙니다.  -또는-  <paramref name="value" />가 <see langword="null" />입니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 매개 변수 여야 `null` 또는 인스턴스의 <xref:System.Single>, 그러지 않으면 예외가 throw 됩니다. 모든 인스턴스 <xref:System.Single>, 해당 값에 관계 없이 보다 큰 것으로 간주 됩니다 `null`합니다.  
  
 값은 같은 동일 해야 합니다. 특히 부동 소수점 값이 여러 수학 연산을에 종속 하는 경우에 정밀도 떨어질 수 및 최소 유효 자릿수가 제외 하 고 거의 동일 하 게 해당 값에 대 한 일반적입니다. 반환 값이로 인해는 <xref:System.Single.CompareTo%2A> 메서드 때때로 놀라운 보일 수 있습니다. 예를 들어 동일한 값으로 나누기 뒤 특정 값을 곱하는 식은 원래 값을 생성 해야 하지만 다음 예제에서는 계산 된 값으로 밝혀졌습니다 원래 값 보다 커야 합니다. "R"을 사용 하 여 두 값의 모든 유효 자릿수가 표시 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 의 최하위 유효 자릿수가의 원래 값에서 계산 된 값이 다른 것을 나타냅니다. 이러한 비교를 처리 하는 방법에 대 한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Single.Equals%28System.Single%29> 메서드.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 이 메서드는 지원 하도록 구현 된 <xref:System.IComparable> 인터페이스입니다. 없지만 <xref:System.Single.NaN> 간에 동일한 것으로 간주 되지 않으며 <xref:System.Single.NaN> (심지어 자체)는 <xref:System.IComparable> 인터페이스에서는 `A.CompareTo(A)` 0을 반환 합니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 개의 특정 숫자 비교.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.CompareTo%2A> 메서드.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />가 <see cref="T:System.Single" />가 아닌 경우</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">비교할 단정밀도 부동 소수점 숫자입니다.</param>
        <summary>이 인스턴스를 지정된 단정밀도 부동 소수점 숫자와 비교하고 이 인스턴스의 값이 지정된 단정밀도 부동 소수점 숫자 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>이 인스턴스와 <paramref name="value" />의 상대 값을 나타내는 부호 있는 숫자입니다.  
  
 <list type="table"><listheader><term> 반환 값  </term><description> 설명  </description></listheader><item><term> 0보다 작음  </term><description> 이 인스턴스는 <paramref name="value" />보다 작습니다.  -또는-  이 인스턴스가 숫자(<see cref="F:System.Single.NaN" />)가 아니고 <paramref name="value" />가 숫자입니다.  </description></item><item><term> 0  </term><description> 이 인스턴스가 <paramref name="value" />과 같습니다.  -또는-  이 인스턴스와 <paramref name="value" /> 모두 숫자(<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> 또는 <see cref="F:System.Single.NegativeInfinity" />가 아닙니다.  </description></item><item><term> 0보다 큼  </term><description> 이 인스턴스는 <paramref name="value" />보다 큽니다.  -또는-  이 인스턴스가 번호이고 <paramref name="value" />가 숫자(<see cref="F:System.Single.NaN" />)가 아닙니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 같은 동일 해야 합니다. 것이 일반적를 정밀도 손실 하 고 값이 여러 수학 연산을에 종속 하는 경우에 특히 최하위 유효 자릿수를 제외 하 고 거의 동일한 될 부동 소수점 값입니다. 반환 값이로 인해는 <xref:System.Single.CompareTo%2A> 메서드 때때로 보일 수 있지만 놀라운 합니다. 예를 들어 동일한 값으로 나누기 뒤 모든 값을 곱하는 식은 원래 값을 생성 해야 합니다. 그러나 다음 예제에서는 계산 된 값으로 밝혀졌습니다 원래 값 보다 커야 합니다. "R"을 사용 하 여 두 값의 모든 유효 자릿수가 표시 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 의 최하위 유효 자릿수가의 원래 값에서 계산 된 값이 다른 것을 나타냅니다. 이러한 비교를 처리 하는 방법에 대 한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Single.Equals%28System.Single%29> 메서드.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 이 메서드를 구현 하는 <xref:System.IComparable%601?displayProperty=nameWithType> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> 메서드 변환할 필요가 없기 때문에 `value` 매개 변수를 개체로 합니다.  
  
 하지만 해당 값이 개체 <xref:System.Single.NaN> 값이 다른 개체에 같지 않은 경우 <xref:System.Single.NaN> (심지어 자체)는 <xref:System.IComparable%601> 인터페이스에서는 `A.CompareTo(A)` 0을 반환 합니다.  
  
## <a name="widening-conversions"></a>확대 변환  
 프로그래밍 언어에 따라 코딩할 수는 <xref:System.Single.CompareTo%2A> 메서드 매개 변수 형식이 비트 수가 적은 보다 인스턴스 형식입니다. 일부 프로그래밍 언어 매개 변수를 나타내는 형식으로 비트 수는 인스턴스와 암시적 확대 변환을 수행 하기 때문에 이것이 가능 합니다.  
  
 예를 들어 인스턴스 형식이 <xref:System.Single> 매개 변수 형식이 고 <xref:System.Int32>합니다. Microsoft C# 컴파일러는 매개 변수의 값을 나타내는 명령을 생성 한 <xref:System.Single> 개체를 생성 합니다는 <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> 확대 표현의 매개 변수 및 인스턴스 값을 비교 하는 메서드.  
  
 해당 컴파일러에서 숫자 형식을 암시적으로 확대 변환을 수행 하는지 확인 하려면 해당 프로그래밍 언어의 설명서를 참조 하십시오. 자세한 내용은 참조는 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md) 항목입니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 개의 특정 숫자 비교.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 및 제네릭이 아닌 버전을 보여 줍니다.는 <xref:System.Single.CompareTo%2A> 여러 값 및 참조 형식에 대 한 메서드.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>0보다 큰 양의 최소 <see cref="T:System.Single" /> 값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.Single.Epsilon> 속성은 가장 작은 양수를 반영 <xref:System.Single> 값은 숫자 연산 또는 비교에서 중요 하 때의 값은 <xref:System.Single> 인스턴스는 0입니다. 예를 들어 다음 코드와 0 및 <xref:System.Single.Epsilon> 반면 같지 않은 값으로 간주 됩니다의 절반 및 값 <xref:System.Single.Epsilon> 동일한 것으로 간주 됩니다.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 보다 정확 하 게 단 정밀도 부동 소수점 형식 부호, 수 23 비트로 또는, significand와 8 비트 지 수 구성 됩니다. 다음 예제와 같이 0에-126의 지 수 및 0의가 수 있습니다. <xref:System.Single.Epsilon> -126의 지 수에 1의가 수 있습니다. 즉 <xref:System.Single.Epsilon?displayProperty=nameWithType> 가 가장 작은 양수가 <xref:System.Single> 값의 최소값을 나타내고에 대 한 가능한 가장 작은 증가값으로 0 보다 큰는 <xref:System.Single> 인 지 수는-126 합니다.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 그러나는 <xref:System.Single.Epsilon> 속성은 일반 측정 한 값의 전체 자릿수 없습니다는 <xref:System.Single> ; 입력에 적용 됩니다 <xref:System.Single> 인스턴스 값이 0입니다.  
  
> [!NOTE]
>  값은 <xref:System.Single.Epsilon> 속성 부동 소수점 연산에서 반올림 상대 오차의 상한을 나타내는 컴퓨터 엡실론 동일 하지 않습니다.  
  
 이 상수의 값은 1.4 e-45입니다.  
  
 두 명백히 같은 부동 소수점 숫자가 수 것으로 간주 최소 유효 자릿수가에 차이가 있으므로 합니다. 예를 들어 C# 식 `(float)1/3 == (float)0.33333`, 같은지 비교 하지 왼쪽에서 나누기 연산을 반면 상수 오른쪽에는 지정 된 자릿수로 최대 전체 자릿수에 있기 때문에 있습니다. 보다 큰 값을 사용 해야 하는지 여부를 두 개의 부동 소수점 숫자 취급 될 수 있습니다를 결정 하는 사용자 지정 알고리즘을 만드는 경우는 <xref:System.Single.Epsilon> 소수점의 두 값의 차이 값을 설정 하는 상수 같은 것으로 간주 합니다. (일반적으로 해당 차이 값은 이러한 <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>플랫폼 참고 사항  
 ARM 시스템에서의 값은 <xref:System.Single.Epsilon> 상수 0과 같으며 이므로 너무 작아 검색할 수 있습니다. 1.175494351E 해당 하는 대체 epsilon 값을 정의할 수 있습니다-38 대신 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Single" />의 두 인스턴스가 같은 값을 표시하는지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 개체입니다.</param>
        <summary>이 인스턴스가 지정된 개체와 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="obj" />의 인스턴스이고 이 인스턴스의 값과 같으면 <see cref="T:System.Single" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.Equals%2A> 값 나타날 수 있는 두 값의 정밀도 차이 때문에 주의 해야 메서드를 사용 해야 합니다. 다음 예제에서는 <xref:System.Single> .3333 값 및 <xref:System.Single> 분할 하 여 반환 된 1을 3 같지 않습니다.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 동일한 지 비교 하는 대신 두 값 사이의 차이 허용 가능한 오차를 정의 하는 방법을 권장 (예:. 01%의 값 중 하나). 절대 값의 두 값 사이의 차이 보다 작거나 동일한 경우 차이점은 전체 자릿수의 차이가 있기 때문에 발생할 가능성이 며 따라서 값 않습니다를 동일한 것입니다. 다음 예제에서는이 방법을 사용 하 여 33333과 1/3, 두 개의 비교 <xref:System.Single> 이전 코드 예제에서는 동일 하지 않은 것으로 확인 하는 값입니다.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 이 경우 값이 같으면 합니다.  
  
> [!NOTE]
>  때문에 <xref:System.Single.Epsilon> 최소 식을 정의 합니다. 해당 범위는 0에 가까운 양수 값의 차이 보다 커야 <xref:System.Single.Epsilon>합니다. 일반적으로 여러 번 보다 크면 <xref:System.Single.Epsilon>합니다.  
  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 개의 특정 숫자 비교.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.Equals%2A> 메서드.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>컴파일러 오버 로드 확인의 두 동작에는 명백한 차이 고려 될 수 있습니다 <see cref="M:System.Single.Equals(System.Object)" /> 메서드 오버 로드 합니다. 경우 간에 암시적 변환이 <paramref name="obj" /> 인수 및 <see cref="T:System.Single" /> 정의 및 인수 인수로 형식화 되지 않습니다는 <see cref="T:System.Object" />, 컴파일러는 암시적 변환 및 호출 수행할 수 있습니다는 <see cref="M:System.Single.Equals(System.Single)" /> 메서드. 호출 그렇지 않은 경우는 <see cref="M:System.Single.Equals(System.Object)" /> 메서드는 항상 반환 <see langword="false" /> 경우 해당 <paramref name="obj" /> 인수가 <see cref="T:System.Single" /> 값입니다. 다음 예제에서는 두 개의 메서드 오버 로드 간의 동작 차이 보여 줍니다. 제외한 모든 기본 숫자 형식의 경우 <see cref="T:System.Double" /> Visual Basic을 제외한 <see cref="T:System.Decimal" /> 및 <see cref="T:System.Double" /> C#에서는 첫 번째 비교 반환 <see langword="true" /> 컴파일러가 확대 변환 및 호출에 자동으로 수행 하기 때문에 <see cref="M:System.Single.Equals(System.Single)" /> 메서드를 두 번째 비교를 반환 하는 반면 <see langword="false" /> 컴파일러를 호출 하기 때문에 <see cref="M:System.Single.Equals(System.Object)" /> 메서드.  [! code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 개체입니다.</param>
        <summary>이 인스턴스의 값과 지정된 <see cref="T:System.Single" /> 개체의 값이 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see langword="true" />가 이 인스턴스와 같으면 <paramref name="obj" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 구현 하는 <xref:System.IEquatable%601?displayProperty=nameWithType> 인터페이스를 하 고 수행 보다 조금 더 나은 <xref:System.Single.Equals%2A> 변환할 필요가 없기 때문에 `obj` 매개 변수를 개체로 합니다.  
  
## <a name="widening-conversions"></a>확대 변환  
 프로그래밍 언어에 따라 수도 코드에는 <xref:System.Single.Equals%2A> 메서드 매개 변수 형식이 비트 수가 적은 보다 인스턴스 형식입니다. 일부 프로그래밍 언어 매개 변수를 나타내는 형식으로 비트 수는 인스턴스와 암시적 확대 변환을 수행 하기 때문에 이것이 가능 합니다.  
  
 예를 들어 인스턴스 형식이 <xref:System.Single> 매개 변수 형식이 고 <xref:System.Int32>합니다. Microsoft C# 컴파일러는 매개 변수의 값을 나타내는 명령을 생성 한 <xref:System.Single> 개체를 생성 합니다는 <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> 확대 표현의 매개 변수 및 인스턴스 값을 비교 하는 메서드.  
  
 해당 컴파일러에서 숫자 형식을 암시적으로 확대 변환을 수행 하는지 확인 하려면 해당 프로그래밍 언어의 설명서를 참조 하십시오. 자세한 내용은 참조는 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md) 항목입니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 <xref:System.Single.Equals%2A> 없기 때문에 값 같은 정밀도 두 값의 차이 때문에 주의 해야 메서드를 사용 해야 합니다. 다음 예제에서는 <xref:System.Single> .3333 값 및 <xref:System.Single> 분할 하 여 반환 된 1을 3 같지 않습니다.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 같음 허용 가능한 두 값 사이의 차이 오차를 정의 하는 것에 대 한 비교와 관련 된 문제를 방지 하는 하나의 비교 방법 (같은. 01%의 값 중 하나). 절대 값의 두 값 사이의 차이 보다 작거나 동일한 경우 차이점은 전체 자릿수의 차이가 수 및 값은 동일한 것으로 가능성이 따라서 합니다. 다음 예제에서는이 방법을 사용 하 여은 두 33333과 1/3 비교 <xref:System.Single> 이전 코드 예제에서는 동일 하지 않은 것으로 확인 하는 값입니다.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 이 경우 값이 같으면 합니다.  
  
> [!NOTE]
>  때문에 <xref:System.Single.Epsilon> 최소 식을 정의 합니다. 해당 범위는 0에 가까운 양수 값의 차이 보다 커야 <xref:System.Single.Epsilon>합니다. 일반적으로 여러 번 보다 크면 <xref:System.Single.Epsilon>합니다. 이 인해 사용 하지 않으면 권장 <xref:System.Double.Epsilon> 비교할 때 <xref:System.Double> 같음에 대 한 값입니다.  
  
 동일한 지 비교와 관련 된 문제를 방지 하는 두 번째 기술은 일부 절대 값으로 두 개의 부동 소수점 숫자의 차이 비교 하는 작업이 포함 됩니다. 차이 절대 값 보다 작은 경우 숫자는 동일 합니다. 큰 경우 숫자가 같지 않습니다. 이 작업을 수행 하는 한 가지 방법은 임의로 절대 값을 선택 하는 것입니다. 그러나이 문제가 차이의 허용 가능한 오차의 규모에 따라 다르기 때문에 <xref:System.Single> 값입니다. 두 번째 방법은의 부동 소수점 형식 디자인 기능 활용: 두 부동 소수점 값의 정수 표현의가 수 구성 요소 간 차이 구분 하는 가능한 부동 소수점 값의 수를 나타내는 두 개의 값입니다. 예를 들어 0.0 사이의 차이 및 <xref:System.Single.Epsilon> 있으므로 1 <xref:System.Single.Epsilon> 는 표현 가능한 가장 작은 값으로 작업할 때는 <xref:System.Single> 값이 0 인 합니다. 다음 예제에서는이 방법을 사용 하 여은 두 33333과 1/3을 비교 <xref:System.Double> 있는 값이 이전 코드 예제와는 <xref:System.Single.Equals%28System.Single%29> 를 동일 하지 않은 메서드를 찾을 수 있습니다. 이 예에서는 사용 하는 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> 및 <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> 단 정밀도 부동 소수점 값을 정수 표현으로 변환 하는 메서드.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 숫자의 비교는.NET Framework의 버전에 따라 다른 결과 생성할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>컴파일러 오버 로드 확인의 두 동작에는 명백한 차이 고려 될 수 있습니다 <see cref="M:System.Single.Equals(System.Object)" /> 메서드 오버 로드 합니다. 경우 간에 암시적 변환이 <paramref name="obj" /> 인수 및 <see cref="T:System.Single" /> 정의 및 인수 인수로 형식화 되지 않습니다는 <see cref="T:System.Object" />, 컴파일러는 암시적 변환 및 호출 수행할 수 있습니다는 <see cref="M:System.Single.Equals(System.Single)" /> 메서드. 호출 그렇지 않은 경우는 <see cref="M:System.Single.Equals(System.Object)" /> 메서드는 항상 반환 <see langword="false" /> 경우 해당 <paramref name="obj" /> 인수가 <see cref="T:System.Single" /> 값입니다. 다음 예제에서는 두 개의 메서드 오버 로드 간의 동작 차이 보여 줍니다. 제외한 모든 기본 숫자 형식의 경우 <see cref="T:System.Double" /> Visual Basic을 제외한 <see cref="T:System.Decimal" /> 및 <see cref="T:System.Double" /> C#에서는 첫 번째 비교 반환 <see langword="true" /> 컴파일러가 확대 변환 및 호출에 자동으로 수행 하기 때문에 <see cref="M:System.Single.Equals(System.Single)" /> 메서드를 두 번째 비교를 반환 하는 반면 <see langword="false" /> 컴파일러를 호출 하기 때문에 <see cref="M:System.Single.Equals(System.Object)" /> 메서드.  [! code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.TypeCode" /> 값 형식에 대한 <see cref="T:System.Single" />를 반환합니다.</summary>
        <returns>열거형 상수인 <see cref="F:System.TypeCode.Single" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">단정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 음의 무한대로 계산되는지 양의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="f" />가 <see cref="F:System.Single.PositiveInfinity" /> 또는 <see cref="F:System.Single.NegativeInfinity" />로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Single.PositiveInfinity> 또는 <xref:System.Single.NegativeInfinity> 오버플로 조건을 신호를 보내 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.IsInfinity%2A> 메서드.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">단정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 값이 숫자가 아닌지(<see cref="F:System.Single.NaN" />) 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="f" />이(가) Not-a-Number(<see cref="F:System.Single.NaN" />)로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Single.NaN> 신호를 보내 해당 연산의 결과가 정의 되지 않습니다. 예를 들어 0.0으로 0.0 구분으로 인해 <xref:System.Single.NaN>합니다.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> 반환 `false` 경우는 <xref:System.Single> 값 <xref:System.Single.PositiveInfinity> 또는 <xref:System.Single.NegativeInfinity>합니다. 이러한 값을 테스트 하려면는 <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, 및 <xref:System.Single.IsNegativeInfinity%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.IsNaN%2A> 메서드.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">단정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 음의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="f" />가 <see cref="F:System.Single.NegativeInfinity" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Single.NegativeInfinity> 오버플로 조건을 신호를 보내 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.IsNegativeInfinity%2A> 메서드.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">단정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 양의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="f" />가 <see cref="F:System.Single.PositiveInfinity" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Single.PositiveInfinity> 오버플로 조건을 신호를 보내 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.IsPositiveInfinity%2A> 메서드.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>
          <see cref="T:System.Single" />의 최대값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 양의 3.40282347 e + 38입니다.  
  
 초과 하는 작업의 결과 <xref:System.Single.MaxValue?displayProperty=nameWithType> 은 <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>합니다. 다음 예에서 <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 결과가 초과 하면 더하기, 곱하기 및 지 수 연산에서 결과 <xref:System.Single.MaxValue?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.MaxValue> 상수입니다.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>
          <see cref="T:System.Single" />의 가능한 최소값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 음수 3.402823 e 38입니다.  
  
 작업의 결과 보다 작은 <xref:System.Single.MinValue?displayProperty=nameWithType> 은 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>합니다. 다음 예에서 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 결과가 빼기 및 곱하기 작업에서 결과 보다 작은 <xref:System.Single.MinValue?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.MinValue> 상수입니다.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Not-a-Number(<see langword="NaN" />)를 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 또는 연산자 반환 <xref:System.Single.NaN> 때 연산의 결과가 정의 되지 않습니다. 예를 들어 0으로 나눈 결과 <xref:System.Single.NaN>다음 예제와 같이 합니다. (하지만 분모가 0이 아닌 숫자를 0을 반환 하거나 <xref:System.Single.PositiveInfinity> 또는 <xref:System.Single.NegativeInfinity>제수의 부호에 따라.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 메서드 호출 또한는 <xref:System.Single.NaN> 값 또는 작업에는 <xref:System.Single.NaN> 반환 값 <xref:System.Single.NaN>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 사용 하 여는 <xref:System.Single.IsNaN%2A> 메서드 값을 숫자 인지 확인할 수 있습니다. 일반적으로 <xref:System.Single> 비교 연산자를 사용할 수 없습니다 <xref:System.Single.NaN?displayProperty=nameWithType> 다른 <xref:System.Single> 있지만 값 비교 방법 (같은 <xref:System.Single.Equals%2A> 및 <xref:System.Single.CompareTo%2A>) 수 있습니다. 다음 예제에서는 간의 동작 차이 보여 줍니다. <xref:System.Single> 비교 연산자와 메서드.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 다음 예제는 <xref:System.Single.NaN> 상수입니다.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>음의 무한대를 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 음수 0으로 나눈 결과입니다.  
  
 작업의 결과이 상수가 반환은 보다 작은 <xref:System.Single.MinValue>합니다.  
  
 사용 하 여 <xref:System.Single.IsNegativeInfinity%2A> 하는 값이 음의 무한대로 계산 되는지 확인 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.NegativeInfinity> 상수입니다.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Single" /> 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />과 <paramref name="right" />가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Equality%2A> 메서드 정의 대 한 같음 연산자 <xref:System.Single> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Single" /> 값이 지정된 다른 <see cref="T:System.Single" /> 값보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThan%2A> 큼의 작업을 정의 하는 방법-에 대 한 연산자 보다 <xref:System.Single> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Single" /> 값이 지정된 다른 <see cref="T:System.Single" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />가 <paramref name="right" />보다 크거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThanOrEqual%2A> 메서드 정의 대 한 또는 같음 연산자의 연산을 <xref:System.Single> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Single" /> 값이 같지 않은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Inequality%2A> 메서드 정의 대 한 같지 않음 연산자 <xref:System.Single> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Single" /> 값이 지정된 다른 <see cref="T:System.Single" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThan%2A> 메서드 작음 연산을 정의-에 대 한 연산자 보다 <xref:System.Single> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Single" /> 값이 지정된 다른 <see cref="T:System.Single" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThanOrEqual%2A> 작거나 같음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Single> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <summary>숫자의 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 단정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 형식의 문자열:  
  
 [*ws*][*sign*] [*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][e[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 부호 기호 또는 양수 부호 기호. 유효한 기호 문자에서 결정 됩니다는 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 선행 기호만 사용할 수 있습니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 실행 *정수 계열 자릿수* 그룹 구분 기호로 분할할 수 있습니다. 예를 들어, 일부 문화권 쉼표 (,) 개의 그룹을 구분 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.|  
|*,*|Culture 별 1000 단위 구분 기호입니다.|  
|*.*|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 `s` 매개 변수를 조합 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. 즉, 공백과 천 단위 구분 기호는 사용할 수 있지만 통화 기호를 없는 합니다. 요소를 명시적으로 정의 하려면 (통화 기호, 1000 단위와 같은 구분 기호 및 공백)에 나타날 수 있는 `s`를 사용 하 여는 <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 메서드 오버 로드 합니다.  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 따라 초기화 된 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>을 참조하세요. 특정 문화권의 서식 지정 정보를 사용 하 여 문자열의 구문을 분석을 사용 하 여는 <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> 또는 <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드.  
  
 일반적으로 전달 하는 경우는 <xref:System.Single.Parse%2A> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Single.ToString%2A> 메서드, 원래 <xref:System.Single> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다.  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Single.Parse%28System.String%29> 문자열의 배열을를 값으로 변환 하려면 <xref:System.Single> 값입니다.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />가 <see cref="F:System.Single.MinValue" />보다 작거나 <see cref="F:System.Single.MaxValue" />보다 큰 숫자를 나타내는 경우</exception>
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style">
          <c>s</c>에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />입니다.</param>
        <summary>지정된 스타일로 된 숫자의 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 단정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` 스타일 요소를 정의 하는 매개 변수 (공백, 1000 단위와 같은 구분 기호 및 통화 기호)에 허용 되는 `s` 구문 분석 작업이 성공 하려면에 대 한 매개 변수입니다. 비트 플래그의 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>합니다. 값에 따라 `style`, 형태를 취할 수 있습니다.  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
 *ws*  
 일련의 공백 문자입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.  
  
 $  
 Culture 별 통화 기호입니다. 문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 현재 문화권의 통화 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.  
  
 *sign*  
 음수 부호 기호 (-) 또는 더하기 기호 (+) 기호입니다. 부호의 시작 부분에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그입니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.  
  
 *integral-digits*  
 일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.  
  
 ,  
 Culture 관련 그룹 구분 기호입니다. 현재 문화권의 그룹 구분 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그  
  
 .  
 Culture 별 소수점 기호입니다. 에 현재 문화권의 소수점 기호가 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.  
  
 *fractional-digits*  
 일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다. 소수 자릿수에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.  
  
 E  
 "E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `value` 경우 매개 변수 지 수 표기법으로 숫자를 나타낼 수 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그입니다.  
  
 *exponential-digits*  
 일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.  
  
 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버 있을 수 있지만 입력된 문자열에서 제공 되어야 할 필요는 없습니다 있는 요소를 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 있을 수 있는 요소에 영향을 `s`합니다.  
  
|NumberStyles 값|에 허용 되는 요소 `s` 숫자 이외에|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*정수 계열 자릿수* 요소만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (*.*) 및 *소수 자릿수가* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자 지 수 표기법을 나타냅니다. 단독으로이 플래그는 폼의 값을 지원 *자리*E*자릿수*추가; 양수 또는 음수 부호 및 소수점 기호 등의 요소를 사용 하 여 문자열을 구문 분석 하는 데 필요한 플래그입니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*ws* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*ws* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*기호* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*기호* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*기호* 숫자 값이 들어 괄호 안에 형식 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1000 단위 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `s` 16 진수 또는 숫자를 지 수 표기법으로 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 부분이 나 끝 부분에 요소 `s`, *기호* 맨 앞에 `s`, 소수점 (.) 기호입니다. `s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 1000 단위 구분 기호 (,) 및 소수점 (.) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `s` 16 진수를 나타낼 수 없습니다.|  
  
 몇 가지 예 `s` 는 "100", "-123456789", "123.45 e + 6", "+" 500, "5e2", "3.1416", "600.", "-. 123" 및 "-Infinity" 합니다.  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 따라 초기화 된 개체입니다. 구문 분석 작업에 대 한 서식 지정 정보를 가져올 사용 되는 문화권을 지정 하려면 호출는 <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 오버 로드 합니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Single.Parse%2A> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Single.ToString%2A> 메서드, 원래 <xref:System.Single> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다.  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 의 문자열 표현을 구문 분석할 메서드의 <xref:System.Single> 값입니다. 이 예제에서는 EN-US 문화권에 대 한 서식 지정 정보를 사용합니다.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />는 유효한 형식의 숫자가 아닙니다.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />는 <see cref="F:System.Single.MinValue" />보다 작거나 <see cref="F:System.Single.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  -또는-  <paramref name="style" />이 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값을 포함합니다.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="provider">
          <c>s</c>에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 형식의 숫자에 대한 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 단정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 여러 가지 방법으로 서식을 지정할 수 있는 텍스트 변환 데 일반적으로 <xref:System.Single> 값입니다. 예를 들어 숫자 값으로 HTML 텍스트 상자에 사용자가 입력 한 텍스트 변환에 사용할 수 있습니다.  
  
 `s` 매개 변수를 조합 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. `s` 매개 변수가 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 로 지정 된 문화권에 대 한 `provider`, 또는 형식의 문자열을 포함할 수 있습니다.  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "자리" 라는 용어를 포함 하는 요소는 일련의 0에서 9 사이의 숫자 문자로 구성 됩니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 부호 기호 (-) 또는 더하기 기호 (+) 기호입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 실행 *정수 계열 자릿수* 그룹 구분 기호로 분할할 수 있습니다. 예를 들어, 일부 문화권 쉼표 (,) 개의 그룹을 구분 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.|  
|.|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 숫자 형식에 대 한 자세한 내용은 참조는 [형식 지정](~/docs/standard/base-types/formatting-types.md) 항목입니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다. 때는 <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드가 호출 되 면 호출는 `provider` 매개 변수의 <xref:System.IFormatProvider.GetFormat%2A> 메서드 전달는 <xref:System.Type> 을 나타내는 개체는 <xref:System.Globalization.NumberFormatInfo> 형식입니다. <xref:System.IFormatProvider.GetFormat%2A> 다음 메서드는 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 정보를 제공 하는 `s` 매개 변수입니다. 세 가지 방법으로 사용 하 여 `provider` 매개 변수를 구문 분석 작업에 사용자 지정 서식 지정 정보를 제공 합니다.  
  
-   전달할 수는 <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 culture에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.  
  
-   실제 전달할 수 있습니다 <xref:System.Globalization.NumberFormatInfo> 숫자 서식 지정 정보를 제공 하는 개체입니다. (구현 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)  
  
-   구현 하는 사용자 지정 개체를 전달할 수 있습니다 <xref:System.IFormatProvider>합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 경우 `provider` 은 `null` 또는 <xref:System.Globalization.NumberFormatInfo> 를 가져올 수 없으며 서식 지정 정보는 현재 시스템 문화권이 사용 됩니다.  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
 몇 가지 예 `s` 는 "100", "-123456789", "123.45 e + 6", "+" 500, "5e2", "3.1416", "600.", "-. 123" 및 "-Infinity" 합니다.  
  
   
  
## Examples  
 다음 예제에서는 단추 클릭 Web form의 이벤트 처리기입니다. 반환 된 배열을 사용 하 여는 <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> 속성을 사용자의 로캘을 결정 합니다. 그런 다음는 <xref:System.Globalization.CultureInfo> 해당 로캘에 해당 하는 개체입니다. <xref:System.Globalization.NumberFormatInfo> 하에 속하는 개체는 <xref:System.Globalization.CultureInfo> 에 다음 전달 된 개체는 <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드는 사용자 입력을 <xref:System.Single> 값입니다.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />가 <see cref="F:System.Single.MinValue" />보다 작거나 <see cref="F:System.Single.MaxValue" />보다 큰 숫자를 나타내는 경우</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style">
          <c>s</c>에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />입니다.</param>
        <param name="provider">
          <c>s</c>에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 스타일 및 문화권별 형식으로 된 숫자의 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 단정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` 스타일 요소를 정의 하는 매개 변수 (공백, 1000 단위와 같은 구분 기호 및 통화 기호)에 허용 되는 `s` 구문 분석 작업이 성공 하려면에 대 한 매개 변수입니다. 비트 플래그의 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` 매개 변수에 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 로 지정 된 문화권에 대 한 `provider`합니다. 값에 따라 `style`, 형태를 취할 수 있습니다.  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([및])는 선택적 요소에 구성 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|$|Culture 별 통화 기호입니다. 문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 현재 문화권의 통화 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.|  
|*sign*|음수 부호 기호 (-) 또는 더하기 기호 (+) 기호입니다. 부호의 시작 부분에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그입니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.|  
|,|Culture 관련 그룹 구분 기호입니다. 현재 문화권의 그룹 구분 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그|  
|.|Culture 별 소수점 기호입니다. 에 현재 문화권의 소수점 기호가 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다. 소수 자릿수에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `s` 경우 매개 변수 지 수 표기법으로 숫자를 나타낼 수 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버 있을 수 있지만 입력된 문자열에서 제공 되어야 할 필요는 없습니다 있는 요소를 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 있을 수 있는 요소에 영향을 `s`합니다.  
  
|NumberStyles 값|에 허용 되는 요소 `s` 숫자 이외에|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*정수 계열 자릿수* 요소만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (*.*) 및 *소수 자릿수가* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자 지 수 표기법을 나타냅니다. 단독으로이 플래그는 폼의 값을 지원 *자리*E*자릿수*추가; 양수 또는 음수 부호 및 소수점 기호 등의 요소를 사용 하 여 문자열을 구문 분석 하는 데 필요한 플래그입니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*ws* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*ws* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*기호* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*기호* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*기호* 숫자 값이 들어 괄호 안에 형식 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1000 단위 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `s` 16 진수 또는 숫자를 지 수 표기법으로 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 부분이 나 끝 부분에 요소 `s`, *기호* 맨 앞에 `s`, 소수점 (.) 기호입니다. `s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 1000 단위 구분 기호 (,) 및 소수점 (.) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `s` 16 진수를 나타낼 수 없습니다.|  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 의 형식에 대 한 문화권별 정보를 제공 하는 개체 `value`합니다. 일반적으로 `provider` 다음 중 하나가 될 수 있습니다.  
  
-   A <xref:System.Globalization.CultureInfo> 숫자 형식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 숫자 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다. (구현 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)  
  
-   구현 하는 사용자 지정 개체 <xref:System.IFormatProvider> 사용 하 여는 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 인스턴스화하고 반환 하는 메서드는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 경우 `provider` 은 `null`, <xref:System.Globalization.NumberFormatInfo> 개체가 현재 문화권이 사용 됩니다.  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 의 문자열 표현을 구문 분석할 메서드의 <xref:System.Single> 값입니다. 배열의 각 문자열은 EN-US, NL-NL 및 사용자 지정 문화권의 서식 지정 규칙을 사용 하 여 구문 분석 합니다. 사용자 지정 문화권 밑줄 ("_") 및 해당 그룹 크기를 2로 해당 그룹 구분 기호를 정의합니다.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />가 숫자 값을 나타내지 않는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  -또는-  <paramref name="style" />이 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값입니다.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />는 <see cref="F:System.Single.MinValue" />보다 작거나 <see cref="F:System.Single.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>양의 무한대를 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 양의 숫자를 0으로 나눈 결과입니다.  
  
 이 상수는 작업의 결과 보다 크면 반환 됩니다 <xref:System.Single.MaxValue>합니다.  
  
 사용 하 여 <xref:System.Single.IsPositiveInfinity%2A> 값이 양의 무한대로 계산 되는지 확인 하려면.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Single.PositiveInfinity> 상수입니다.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 인스턴스의 값이 0이 아니면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Byte" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 변환은 지원되지 않습니다. 이 메서드를 사용하려고 하면 <see cref="T:System.InvalidCastException" />이 throw됩니다.</summary>
        <returns>이 변환은 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">모든 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 변환은 지원되지 않습니다. 이 메서드를 사용하려고 하면 <see cref="T:System.InvalidCastException" />이 throw됩니다.</summary>
        <returns>이 변환은 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">모든 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Decimal" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Double" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Int16" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Int32" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Int64" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.SByte" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>변경되지 않은 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">이 <see cref="T:System.Single" /> 값을 변환할 대상 형식입니다.</param>
        <param name="provider">반환된 값의 형식에 대한 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <paramref name="type" />으로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 `static` (`Shared` Visual basic에서) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.UInt16" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.UInt32" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.UInt64" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Single> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString> 메서드 형식을 <xref:System.Single> 에서 값을 기본값 ("G" 또는 일반)는 현재 문화권의 형식입니다. 다른 형식이 나 문화권을 지정 하려는 경우 사용의 다른 오버 로드는 <xref:System.Single.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|특정 문화권|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|특정 형식|기본 (현재) 문화권|<xref:System.Single.ToString%28System.String%29>|  
|특정 형식|특정 문화권|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 형식의 문자열:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "자리" 라는 용어를 포함 하는 요소는 일련의 0에서 9 사이의 숫자 문자로 구성 됩니다. 다음 표에서 각 요소를 보여 줍니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*sign*|음수 부호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자는 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|'.'|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자의 소수 부분을 지정 하는 숫자입니다.|  
|' e'|소문자 'e' 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|*exponential-digits*|일련의 지 수를 지정 하는 숫자입니다.|  
  
 반환 값의 예로 "100", "-123456789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" 및 "-Infinity"입니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 메서드의 숫자의 문자열 표현을 표시를 <xref:System.Single> 값입니다.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 다음 코드 예제에서는 <xref:System.Single.Parse%28System.String%29> 메서드와 함께 <xref:System.Single.ToString> 메서드.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 형식 정보를 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스의 값을 <paramref name="provider" />에 지정된 내용에 따라 나타낸 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.IFormatProvider%29> 메서드 형식을 <xref:System.Single> 에서 값을 기본값 ("G" 또는 일반) 지정된 된 문화권의 형식입니다. 다른 형식이 나 현재 문화권을 지정 하려는 경우 사용의 다른 오버 로드는 <xref:System.Single.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재) 문화권|<xref:System.Single.ToString>|  
|특정 형식|기본 (현재) 문화권|<xref:System.Single.ToString%28System.String%29>|  
|특정 형식|특정 문화권|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 형식의 문자열:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). 포함 하는 용어 "숫자" 요소는 일련의 0에서 9 사이의 숫자 문자로 구성 됩니다. 다음 표에서 각 요소를 나열합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|sign|음수 부호 또는 양수 부호 기호입니다.|  
|integral-digits|일련의 숫자는 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|'.'|Culture 별 소수점 기호입니다.|  
|소수 자릿수입니다.|일련의 숫자의 소수 부분을 지정 하는 숫자입니다.|  
|' e'|소문자 'e' 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|자리 지 수|일련의 지 수를 지정 하는 숫자입니다.|  
  
 반환 값의 예로 "100", "-123456789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" 및 "-Infinity"입니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. 일반적으로 `provider` 는 <xref:System.Globalization.CultureInfo> 개체 또는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. `provider` 매개 변수에서 서식 지정에 사용 되는 문화권별 정보를 제공 합니다. 경우 `provider` 은 `null`를 사용 하 여 반환 값의 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 데이터입니다.  
  
 변환 하는 <xref:System.Single> 값을 지정 된 문화권 및 호출 하는 특정 형식 문자열을 사용 하 여 해당 문자열 표현에서 <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 문자열 표현을 표시 <xref:System.Single> 사용 하 여 값 <xref:System.Globalization.CultureInfo> 서로 다른 문화권을 나타내는 개체입니다.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">숫자 서식 문자열입니다.</param>
        <summary>지정된 형식을 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스의 값을 <paramref name="format" />에 지정된 내용에 따라 나타낸 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%29> 메서드 형식을 <xref:System.Single> 현재 문화권의 규칙을 사용 하 여 지정 된 형식에서 값입니다. 기본값 ("G" 또는 일반)을 사용 하려는 경우 다른 문화권이 지정, 다른 오버 로드를 사용 하거나 형식는 <xref:System.Single.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재) 문화권|<xref:System.Single.ToString>|  
|기본 ("G") 형식|특정 문화권|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|특정 형식|특정 문화권|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는로 지정 된 현재 인스턴스의 값의 문자열 표현을 `format`합니다.  
  
 `format` 매개 변수는 D 및 X를 제외한 모든 유효한 표준 숫자 서식 지정자 및 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 형식이 `null` 이거나 빈 문자열이 면 반환 값 ("G")는 일반 숫자 형식 지정자와 함께 지정 됩니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 기본적으로 반환 값만 포함 7 자리의 전체 자릿수 최대 9 자리 내부적으로 유지 합니다. 이 인스턴스의 값이 7 자리 보다 큰 경우 <xref:System.Single.ToString%28System.String%29> 반환 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 또는 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 를 초과 합니다. 정교한 정밀도 필요로 하는 경우 지정 `format` 는 항상 반환 9 자리의 전체 자릿수 또는 "R", "G9" 형식 지정 반환 하는 7 자리 숫자를 해당 정밀도 또는 9 자리 표현할 수만 나타낼 수 있는 경우 최대 전체 자릿수입니다.  
  
   
  
## Examples  
 다음 예제에서는 숫자 값을 정의 찾아서을 통화 값으로 "C" 표준 숫자 서식 문자열을 사용 하 여과 세 개의 소수 자릿수 숫자 값으로 "N" 표준 숫자 형식 문자열을 사용 하 여입니다. 결과 문자열은 EN-US 문화권의 규칙을 사용 하 여 형식이 지정 됩니다. 숫자 형식 문자열에 대 한 자세한 내용은 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 다음 예제에서는 여러 <xref:System.Single> 각 지원 되는 표준 숫자 서식 지정자와 두 개의 사용자 지정 숫자 형식 문자열을 함께 사용 하 여 값입니다. 패딩 하는 방법을 보여 줍니다 이러한 사용자 지정 형식 문자열 중 하나는 <xref:System.Single> 값 앞에 오는 0입니다. 숫자 값을 문자열로 변환,이 예제에서는 EN-US 문화권의 형식 규칙을 사용 합니다.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">숫자 서식 문자열입니다.</param>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 형식 및 문화권별 형식 정보를 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>
          <paramref name="format" /> 및 <paramref name="provider" />로 지정된 이 인스턴스 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드 형식을 <xref:System.Single> 지정된 된 문화권의 지정 된 형식에서 값입니다. 다른 오버 로드를 사용 하 여 기본 형식 또는 문화권 설정을 사용 하려는 경우는 <xref:System.Single.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재) 문화권|<xref:System.Single.ToString>|  
|기본 ("G") 형식|특정 문화권|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|특정 형식|기본 (현재) 문화권|<xref:System.Single.ToString%28System.String%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는로 지정 된 현재 인스턴스의 값의 문자열 표현을 `format`합니다.  
  
 `format` 매개 변수는 D 및 X를 제외한 모든 유효한 표준 숫자 서식 지정자 및 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 경우 `format` 은 `null` 이거나 빈 문자열을이 인스턴스에 대 한 반환 값 ("G")는 일반 숫자 형식 지정자와 함께 지정 됩니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. 일반적으로 `provider` 는 <xref:System.Globalization.CultureInfo> 개체 또는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. `provider` 매개 변수에서 서식 지정에 사용 되는 문화권별 정보를 제공 합니다. 경우 `provider` 은 `null`, 반환 값으로 지정 됩니다는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.  
  
 기본적으로 반환 값만 포함 7 자리의 전체 자릿수 최대 9 자리 내부적으로 유지 합니다. 이 인스턴스의 값이 7 자리 보다 큰 경우 <xref:System.Single.ToString%2A> 반환 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 또는 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 를 초과 합니다. 정교한 정밀도 필요로 하는 경우 지정 `format` 는 항상 반환 9 자리의 전체 자릿수 또는 "R", "G9" 형식 지정 반환 하는 7 자리 숫자를 해당 정밀도 또는 9 자리 표현할 수만 나타낼 수 있는 경우 최대 전체 자릿수입니다.  
  
   
  
## Examples  
 다음 예제에서는 표시 된 <xref:System.Single> 각 지원 되는 표준 숫자 서식 지정자를 사용 하 여 다양 한 문화권에 대 한 값입니다.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자를 나타내는 문자열입니다.</param>
        <param name="result">이 메서드는 변환이 성공한 경우 <c>s</c>에 포함된 숫자 값이나 기호에 해당하는 단정밀도 부동 소수점 숫자를 반환하며 변환이 실패한 경우 0을 반환합니다. <c>s</c> 매개 변수가 <see langword="null" /> 또는 <see cref="F:System.String.Empty" />이거나 올바른 형식의 숫자가 아니거나, <see cref="F:System.Single.MinValue" />보다 작거나 <see cref="F:System.Single.MaxValue" />보다 큰 숫자를 나타내는 경우 변환이 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다. 원래 <c>result</c>에 제공된 모든 값을 덮어쓰게 됩니다.</param>
        <summary>숫자의 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 성공적으로 변환되었으면 <paramref name="s" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 다른이 오버 로드는 <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> 메서드 구문 분석 된 숫자 값을 반환 하는 대신 구문 분석 작업이 성공 했는지를 나타내는 부울 값을 반환 합니다. 테스트 하기 위해 예외 처리를 사용할 필요가 <xref:System.FormatException> 에 `s` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 `s` 매개 변수에 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (문자열 비교는 대/소문자 구분) 또는 형식의 문자열:  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 부호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|*,*|Culture 관련 그룹 구분 기호입니다.|  
|*.*|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다.|  
|*E*|대 / 소문자 구분 문자 'e' 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|*exponential-digits*|일련의 숫자 0에서 하는 9 사이의 지 수를 지정 합니다.|  
  
 `s` 매개 변수를 조합 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. 즉, 공백과 천 단위 구분 기호는 사용할 수 있지만 통화 기호를 없는 합니다. 요소를 명시적으로 정의 하려면 (통화 기호, 1000 단위와 같은 구분 기호 및 공백)에 나타날 수 있는 `s`를 사용 하 여는 <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> 메서드 오버 로드 합니다.  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 따라 초기화 된 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>을 참조하세요. 구문 분석 하려면 문화권 지정 다른 서식 지정 정보를 사용 하 여, 사용 된 <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> 메서드 오버 로드 합니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Single.TryParse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 메서드, 원래 <xref:System.Single> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다.  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> 숫자 값의 문자열 표현을 상호 변환 하는 메서드 <xref:System.Single> 값입니다. 해당 EN-US가 현재 문화권이 가정 합니다.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자를 나타내는 문자열입니다.</param>
        <param name="style">
          <c>s</c>에 사용할 수 있는 형식을 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />입니다.</param>
        <param name="provider">
          <c>s</c>에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <param name="result">이 메서드는 변환이 성공한 경우 <c>s</c>에 포함된 숫자 값이나 기호에 해당하는 단정밀도 부동 소수점 숫자를 반환하며 변환이 실패한 경우 0을 반환합니다. <c>s</c> 매개 변수가 <see langword="null" /> 또는 <see cref="F:System.String.Empty" />이거나, <c>스타일</c>과 규격 형식이 아니거나, <see cref="F:System.Single.MinValue" />보다 작거나 <see cref="F:System.Single.MaxValue" />보다 큰 숫자를 나타내거나, <c>스타일</c>이 <see cref="T:System.Globalization.NumberStyles" /> 열거형 상수의 유효한 조합이 아닌 경우 변환이 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다. 원래 <c>result</c>에 제공된 모든 값을 덮어쓰게 됩니다.</param>
        <summary>지정된 스타일 및 문화권별 형식으로 된 숫자의 문자열 표현을 해당하는 단정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 성공적으로 변환되었으면 <paramref name="s" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 다른이 오버 로드는 <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드 구문 분석 된 숫자 값을 반환 하는 대신 구문 분석 작업이 성공 했는지를 나타내는 부울 값을 반환 합니다. 테스트 하기 위해 예외 처리를 사용할 필요가 <xref:System.FormatException> 에 `s` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 `style` 매개 변수를 허용 되는 형식을 정의 `s` 구문 분석 작업이 성공 하려면에 대 한 매개 변수입니다. 비트 플래그의 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s` 매개 변수에 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> 하 여 지정 된 문화권에 대 한 `provider`합니다. 값에 따라 또한 `style`, `s` 매개 변수는 다음과 같은 요소가 포함 될 수 있습니다.  
  
 [ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 플래그입니다. 끝에 나 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|*$*|Culture 별 통화 기호입니다. 위치는 문자열에 의해 정의 됩니다는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 또는 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 의 속성은 <xref:System.Globalization.NumberFormatInfo> 에서 반환 된 개체는 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 의 메서드는 `provider` 매개 변수입니다. 통화 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.|  
|*sign*|가 선택적 부호입니다. 부호의 시작 부분에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그입니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|*,*|Culture 별 1000 단위 구분 기호입니다. 현재 문화권의 천 단위 구분 기호에 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다.|  
|*.*|Culture 별 소수점 기호입니다. 에 현재 문화권의 소수점 기호가 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다. 소수 자릿수에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*e*|E 또는 E 문자 임을 나타내는 `s` 지 수 표기법을 사용 하 여 숫자를 표시할 수 있습니다. `s` 매개 변수 스타일을 포함 하는 경우 지 수 표기법으로 숫자를 나타낼 수는 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버 요소는 입력된 문자열에 필요 하지 않을 수도 있는 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 있을 수 있는 요소에 영향을 `s`합니다.  
  
|NumberStyles 값|S에서 숫자 허용 되는 요소|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*정수 계열 자릿수* 요소만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* 및 *소수 자릿수가* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다. 이 플래그를 단독으로 폼의 값을 지원 *정수 계열 숫자*E*자리 지 수*추가; 등의 요소와 지 수 표기법에서 문자열을 구문 분석 하는 데 필요한 플래그 양수 또는 음수 기호 및 소수점 기호입니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*ws* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*ws* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*기호* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*기호* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*기호* 숫자 값이 들어 괄호 안에 형식 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*,* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|* $ * 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모두. `s` 매개 변수를 16 진수 숫자 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 부분이 나 끝 부분에 요소 `s`, *기호* 맨 앞에 `s`, 및 *합니다.* 기호입니다. `s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 1000 단위 구분 기호 (*,),* 및 소수점 (*.*) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 스타일 제외 하 고 `s` 16 진수를 나타낼 수 없습니다.|  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다. 때는 <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> 메서드가 호출 되 면 호출는 `provider` 매개 변수의 <xref:System.IFormatProvider.GetFormat%2A> 메서드 전달는 <xref:System.Type> 을 나타내는 개체는 <xref:System.Globalization.NumberFormatInfo> 형식입니다. <xref:System.IFormatProvider.GetFormat%2A> 다음 메서드는 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 정보를 제공 하는 `s` 매개 변수입니다. 세 가지 방법으로 사용 하 여 `provider` 매개 변수를 구문 분석 작업에 사용자 지정 서식 지정 정보를 제공 합니다.  
  
-   전달할 수는 <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 culture에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.  
  
-   실제 전달할 수 있습니다 <xref:System.Globalization.NumberFormatInfo> 숫자 서식 지정 정보를 제공 하는 개체입니다. (구현 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)  
  
-   구현 하는 사용자 지정 개체를 전달할 수 있습니다 <xref:System.IFormatProvider>합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 경우 `provider` 은 `null`의 서식을 `s` 에 따라 해석 됩니다는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> 특정 스타일 및 특정 문화권의 규칙을 사용 하 여 서식이 지정 된 숫자의 문자열 표현을 구문 분석 하는 메서드.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  -또는-  <paramref name="style" />이 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값입니다.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>