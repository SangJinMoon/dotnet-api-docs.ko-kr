<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Delegate.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53f0536eac77f3171e3a7eeb74486cfcf863ec3d8.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3f0536eac77f3171e3a7eeb74486cfcf863ec3d8</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</source>
          <target state="translated">대리자는 정적 메서드 또는 클래스 인스턴스 및 해당 클래스의 인스턴스 메서드를 참조하는 데이터 구조입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is the base class for delegate types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate&gt;</ph> 클래스는 대리자 형식에 대 한 기본 클래스입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class or from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class.</source>
          <target state="translated">그러나 시스템 및 컴파일러에서 명시적으로 파생 될 수 있습니다는 <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> 클래스 또는 <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>It is also not permissible to derive a new type from a delegate type.</source>
          <target state="translated">이기도 하지 대리자 형식에서 새 유형을 파생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is not considered a delegate type; it is a class used to derive delegate types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate&gt;</ph> 클래스는 대리자 형식으로 간주 되지 않으면 대리자 형식을 파생 하는 데 사용 되는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Most languages implement a <ph id="ph1">`delegate`</ph> keyword, and compilers for those languages are able to derive from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class; therefore, users should use the <ph id="ph3">`delegate`</ph> keyword provided by the language.</source>
          <target state="translated">구현 하는 대부분의 언어는 <ph id="ph1">`delegate`</ph> 키워드 및 해당 언어 컴파일러에서 파생 시킬 수 있습니다는 <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> 클래스; 따라서 사용자가 사용 해야는 <ph id="ph3">`delegate`</ph> 언어에서 제공 하는 키워드입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides an <ph id="ph1">`Invoke`</ph> method for each delegate type, with the same signature as the delegate.</source>
          <target state="translated">공용 언어 런타임에서 제공는 <ph id="ph1">`Invoke`</ph> 대리자와 동일한 서명 사용 하 여 각 대리자 형식에 대 한 메서드.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</source>
          <target state="translated">이 경우 컴파일러 자동으로 호출 하기 때문에 C#, Visual Basic 또는 Visual c + +에서이 메서드를 명시적으로 호출할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`Invoke`</ph> method is useful in <bpt id="p1">[</bpt>reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> when you want to find the signature of the delegate type.</source>
          <target state="translated"><ph id="ph1">`Invoke`</ph> 메서드는에 유용 <bpt id="p1">[</bpt>리플렉션<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> 대리자 형식 시그니처를 찾으려는 경우.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides each delegate type with <ph id="ph1">`BeginInvoke`</ph> and <ph id="ph2">`EndInvoke`</ph> methods, to enable asynchronous invocation of the delegate.</source>
          <target state="translated">공용 언어 런타임에서 제공 각 대리자 형식에 <ph id="ph1">`BeginInvoke`</ph> 및 <ph id="ph2">`EndInvoke`</ph> 메서드는 대리자의 비동기 호출을 사용 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information about these methods, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">이러한 메서드에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>대<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</source>
          <target state="translated">대리자 형식의 선언에는 하나 이상의 메서드 서명을 지정 하는 계약을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate is an instance of a delegate type that has references to:</source>
          <target state="translated">대리자는에 대 한 참조가 대리자 형식의 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type and a target object assignable to that type.</source>
          <target state="translated">형식과 해당 형식에 지정할 수 하나의 대상 개체의 인스턴스 메서드.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type, with the hidden <ph id="ph1">`this`</ph> parameter exposed in the formal parameter list.</source>
          <target state="translated">숨겨진 된 형식의 인스턴스 메서드인 <ph id="ph1">`this`</ph> 매개 변수 형식 매개 변수 목록에 표시 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be an open instance delegate.</source>
          <target state="translated">대리자는 열려 있는 인스턴스 대리자를 라고 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method.</source>
          <target state="translated">정적 메서드입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method and a target object assignable to the first parameter of the method.</source>
          <target state="translated">정적 메서드 및 대상 개체는 메서드의 첫 번째 매개 변수를 할당할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be closed over its first argument.</source>
          <target state="translated">대리자는 첫 번째 인수에 대해 닫혀 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information on delegate binding, see the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">대리자 바인딩에 대 한 자세한 내용은 참조는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는 메서드의 서명을 대리자 형식에 지정 된 시그니처를 정확 하 게 일치 하는 경우에 대리자는 메서드를 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</source>
          <target state="translated">따라서 앞의 목록에 첫 번째 및 세 번째 항목이 지원 됩니다 하 고 첫 번째 글머리 기호 형식이 정확히 일치 하는 값 필요로 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</source>
          <target state="translated">대리자는 메서드의 진입점에 대 한 참조와 정의 된 형식에 할당할 수 있는 형식의 대상 이라는 개체에 대 한 참조를 저장 대리자에서 첫 번째 인수 (가장 일반적인 경우)에 대해 닫혀 인스턴스 메서드를 나타내는 경우는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an open instance method, it stores a reference to the method's entry point.</source>
          <target state="translated">대리자는 열려 있는 인스턴스 메서드를 나타내는 경우 메서드의 진입점에 대 한 참조를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate signature must include the hidden <ph id="ph1">`this`</ph> parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</source>
          <target state="translated">대리자 시그니처는 숨겨진 포함 해야 <ph id="ph1">`this`</ph> 매개 변수는 정식 매개 변수 목록의 경우 대리자에는 대상 개체에 대 한 참조 및 대리자를 호출 하는 경우 대상 개체를 제공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method, the delegate stores a reference to the method's entry point.</source>
          <target state="translated">대리자는 정적 메서드를 나타내는 대리자 메서드 진입점에 대 한 참조를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</source>
          <target state="translated">대리자에서 첫 번째 인수에 대해 닫혀 있는 정적 메서드를 나타내는 대리자 메서드의 진입점에 대 한 참조와 메서드의 첫 번째 인수의 형식에 지정할 수 하나의 대상 개체에 대 한 참조를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate is invoked, the first argument of the static method receives the target object.</source>
          <target state="translated">대리자가 호출 됩니다는 정적 메서드의 첫 번째 인수는 대상 개체를 받습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</source>
          <target state="translated">대리자의 호출 목록에서 목록의 각 요소에 호출 대리자가 나타내는 방법 중 하나에 정확 하 게 대리자의 정렬된 된 집합은 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An invocation list can contain duplicate methods.</source>
          <target state="translated">호출 목록에 중복 메서드 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>During an invocation, methods are invoked in the order in which they appear in the invocation list.</source>
          <target state="translated">메서드는 호출 하는 동안 호출 목록에 나타나는 순서 대로 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</source>
          <target state="translated">대리자는 호출 목록의 모든 메서드를 호출 하려고 합니다. 중복 된 각 시간에 대해 호출 목록에 표시 되 면 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are immutable; once created, the invocation list of a delegate does not change.</source>
          <target state="translated">대리자는 변경할 수 없습니다. 를 만든 후에 대리자의 호출 목록 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</source>
          <target state="translated">대리자 참조 됩니다 멀티 캐스트 또는 결합할 대리자는 하나 이상의 메서드를 호출할 수 하 고 결합 하는 연산에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Combining operations, such as <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, do not alter existing delegates.</source>
          <target state="translated">와 같은 작업을 결합 <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, 기존 대리자를 변경 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or <ph id="ph1">`null`</ph>.</source>
          <target state="translated">이러한 작업이 변경 되지 않은 대리자 작업의 결과 포함 하는 새 대리자를 반환 하는 대신, 또는 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns <ph id="ph1">`null`</ph> when the result of the operation is a delegate that does not reference at least one method.</source>
          <target state="translated">결합 작업을 반환 <ph id="ph1">`null`</ph> 때 작업의 결과 하나 이상의 메서드를 참조 하지 않는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns an unchanged delegate when the requested operation has no effect.</source>
          <target state="translated">결합 작업 요청 된 작업의 영향을 주지 않습니다는 변경 되지 않은 대리자를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Managed languages use the <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> methods to implement delegate operations.</source>
          <target state="translated">언어 사용 하 여 관리 되는 <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> 메서드 대리자 작업을 구현 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Examples include the <ph id="ph1">`AddHandler`</ph> and <ph id="ph2">`RemoveHandler`</ph> statements in Visual Basic and the += and -= operators on delegate types in C#.</source>
          <target state="translated">예로 <ph id="ph1">`AddHandler`</ph> 및 <ph id="ph2">`RemoveHandler`</ph> Visual Basic의 선언문 및 + = 및-= 연산자에 대리자 C#의 형식입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, generic delegate types can have variant type parameters.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, 제네릭 대리자 형식에서 variant 형식 매개 변수를 가질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</source>
          <target state="translated">반공 변 형식 매개 변수는 대리자의 매개 변수 형식으로 사용할 수 및 반환 형식으로 공변 형식 매개 변수를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>.</source>
          <target state="translated">이 기능을 사용 하면 제네릭 대리자에 설명 된 대로 해당 형식 인수는 참조 형식, 상속 관계에 있는 경우 할당 호환 되도록 동일한 제네릭 형식 정의에서 생성 된 형식을 <bpt id="p1">[</bpt>공 분산 및 반 공변성<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">할당 호환 되는 제네릭 대리자 차이 때문에 없는 함께 사용할 수 있는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">결합할 수 있으려면 형식이 정확히 일치 해야 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">예를 들어 라는 클래스 <ph id="ph1">`Derived`</ph> 라는 클래스에서 파생 된 <ph id="ph2">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> Visual basic에서) 형식의 변수에 할당할 수 <ph id="ph3">`Action&lt;Derived&gt;`</ph>, 하지만 두 대리자 형식이 정확히 일치 하지 않기 때문에 함께 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</source>
          <target state="translated">호출 된 메서드가 예외를 throw 하는 경우 메서드가 실행이 중지 되며, 예외는 대리자의 호출자로 다시 전달 됩니다 및 나머지 메서드는 호출 목록의 호출 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Catching the exception in the caller does not alter this behavior.</source>
          <target state="translated">호출자에 예외를 catch 하는 경우에이 동작을 변경 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</source>
          <target state="translated">반환 값을 포함 하는 대리자에 의해 호출 된 메서드 서명의 경우 대리자 호출 목록에 있는 마지막 요소의 반환 값을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</source>
          <target state="translated">서명을 참조로 전달 되는 매개 변수를 포함 하는 경우 매개 변수의 최종 값 순서 대로 실행 및 매개 변수의 값을 업데이트 하는 호출 목록의 모든 메서드의 결과입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The closest equivalent of a delegate in C or C++ is a function pointer.</source>
          <target state="translated">C 또는 c + +에서 대리자를 해당 하는 가장 가까운 함수 포인터입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate can represent a static method or an instance method.</source>
          <target state="translated">대리자는 정적 메서드 또는 인스턴스 메서드를 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</source>
          <target state="translated">대리자가 인스턴스 메서드를 나타내는 대리자 메서드 진입점에 대 한 참조를 뿐만 아니라 클래스 인스턴스에 대 한 참조를 저장 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Unlike function pointers, delegates are object oriented and type safe.</source>
          <target state="translated">함수 포인터와 달리 대리자는 개체 지향적 및 형식이 안전 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The following example shows how to define a delegate named <ph id="ph1">`myMethodDelegate`</ph>.</source>
          <target state="translated">다음 예제에서는 라는 대리자를 정의 하는 방법을 보여 줍니다. <ph id="ph1">`myMethodDelegate`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instances of this delegate are created for an instance method and a static method of the nested <ph id="ph1">`mySampleClass`</ph> class.</source>
          <target state="translated">인스턴스 메서드와 정적 메서드는 중첩 된에 대 한이 대리자의 인스턴스를 만들 <ph id="ph1">`mySampleClass`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate for the instance method requires an instance of <ph id="ph1">`mySampleClass`</ph>.</source>
          <target state="translated">인스턴스 메서드의 대리자의 인스턴스가 필요 <ph id="ph1">`mySampleClass`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`mySampleClass`</ph> instance is saved in a variable named <ph id="ph2">`mySC`</ph>.</source>
          <target state="translated"><ph id="ph1">`mySampleClass`</ph> 이라는 변수에 인스턴스는 저장 되지만 <ph id="ph2">`mySC`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Initializes a new delegate.</source>
          <target state="translated">새 대리자를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The class instance on which the delegate invokes <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">대리자가 <bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 호출하는 클래스 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The name of the instance method that the delegate represents.</source>
          <target state="translated">대리자가 나타내는 인스턴스 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Initializes a delegate that invokes the specified instance method on the specified class instance.</source>
          <target state="translated">지정된 클래스 인스턴스에서 지정된 인스턴스 메서드를 호출하는 대리자를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>To create a delegate by specifying the name of an instance method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name and a target object.</source>
          <target state="translated">오버 로드를 사용 하 여 인스턴스 메서드 이름을 지정 하 여 대리자를 만들려는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드 이름 및 대상 개체를 지정 하는 메서드.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> method overload creates a delegate for an instance method with a specified name.</source>
          <target state="translated">예를 들어는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> 메서드 오버 로드는 지정 된 이름의 인스턴스 메서드의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor creates delegates for instance methods only.</source>
          <target state="translated">이 생성자만 메서드에 대리자를 예를 들어 만듭니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>There was an error binding to the target method.</source>
          <target state="translated">대상 메서드에 바인딩할 때 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that defines <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 정의하는 클래스를 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The name of the static method that the delegate represents.</source>
          <target state="translated">대리자가 나타내는 정적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Initializes a delegate that invokes the specified static method from the specified class.</source>
          <target state="translated">지정된 클래스에서 지정된 정적 메서드를 호출하는 대리자를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>To create a delegate by specifying the name of a static method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name but does not specify a target object.</source>
          <target state="translated">오버 로드를 사용 하 여 정적 메서드 이름을 지정 하 여 대리자를 만들려는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드 메서드 이름을 지정 하는 대상 개체를 지정 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> method overload creates a static delegate for a method with a specified name.</source>
          <target state="translated">예를 들어는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> 메서드 오버 로드는 지정된 된 이름을 가진 메서드에 대 한 정적 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor creates delegates for static methods only.</source>
          <target state="translated">이 생성자만 정적 메서드에 대 한 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> represents an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>이 개방형 제네릭 형식을 나타내는 경우</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>Creates a shallow copy of the delegate.</source>
          <target state="translated">대리자의 부분 복사본을 만듭니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>A shallow copy of the delegate.</source>
          <target state="translated">대리자의 부분 복사본입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>The clone has the same <ph id="ph1">&lt;xref:System.Type&gt;</ph>, target, method, and invocation list as the original delegate.</source>
          <target state="translated">복사본은 동일한 <ph id="ph1">&lt;xref:System.Type&gt;</ph>, 원래 대리자로 대상, 방법 및 호출 목록입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</source>
          <target state="translated">단순 복사본을 원래 개체와 동일한 형식의 새 인스턴스를 만들고 원래 개체의 비정적 필드를 복사 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">필드 값 형식이 필드의 비트 단위로 복사가 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</source>
          <target state="translated">필드 참조 형식인 경우 참조를 복사할 수 있지만 참조 된 개체는 필요는 없습니다. 따라서 원본 개체에 대 한 참조와 복제에 대 한 참조는 동일한 개체를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</source>
          <target state="translated">이와 반대로 개체의 전체 복사본을 개체의 필드에서 직접 또는 간접적으로 참조 하는 모든 항목을 복제 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegates.</source>
          <target state="translated">지정된 결합할 수 있는 멀티캐스트 대리자의 호출 목록을 연결합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The array of delegates to combine.</source>
          <target state="translated">결합할 대리자의 배열입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Concatenates the invocation lists of an array of delegates.</source>
          <target state="translated">대리자 배열의 호출 목록을 연결합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> 배열의 대리자 호출 목록을 연결하는 호출 목록이 있는 새 대리자입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, if <ph id="ph4">&lt;paramref name="delegates" /&gt;</ph> contains zero elements, or if every entry in <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="delegates" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>이거나 <ph id="ph4">&lt;paramref name="delegates" /&gt;</ph>에 요소가 없거나 <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph>의 모든 항목이 <ph id="ph6">&lt;see langword="null" /&gt;</ph>인 경우 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>If the <ph id="ph1">`delegates`</ph> array contains entries that are <ph id="ph2">`null`</ph>, those entries are ignored.</source>
          <target state="translated">경우는 <ph id="ph1">`delegates`</ph> 배열에 있는 항목 <ph id="ph2">`null`</ph>, 이러한 항목은 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">호출 목록에 중복 된 항목이; 포함 될 수 있습니다. 즉, 같은 개체에 대해 동일한 메서드를 참조 하는 항목입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">할당 호환 되는 제네릭 대리자 차이 때문에 없는 함께 사용할 수 있는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">결합할 수 있으려면 형식이 정확히 일치 해야 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">예를 들어 라는 클래스 <ph id="ph1">`Derived`</ph> 라는 클래스에서 파생 된 <ph id="ph2">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> Visual basic에서) 형식의 변수에 할당할 수 있습니다 <ph id="ph3">`Action&lt;Derived&gt;`</ph>에 설명 되어 있듯이 <bpt id="p1">[</bpt>공 분산과 반공 분산<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, 하지만 두 대리자 형식이 않기 때문에 함께 사용할 수 없습니다 정확히 일치 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> 때마다 이벤트를 다중 메서드 호출이 발생 하는 이벤트 처리기를 만드는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Not all the non-null entries in <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> are instances of the same delegate type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegates" /&gt;</ph>의 null이 아닌 모든 항목이 동일한 대리자 형식의 인스턴스인 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes first.</source>
          <target state="translated">해당 호출 목록이 처음에 나오는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes last.</source>
          <target state="translated">해당 호출 목록이 마지막에 나오는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Concatenates the invocation lists of two delegates.</source>
          <target state="translated">두 대리자의 호출 목록을 연결합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list that concatenates the invocation lists of <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> in that order.</source>
          <target state="translated">호출 목록 <ph id="ph1">&lt;paramref name="a" /&gt;</ph>와 <ph id="ph2">&lt;paramref name="b" /&gt;</ph>를 순서대로 연결하는 호출 목록을 가진 새 대리자입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="a" /&gt;</ph> if <ph id="ph2">&lt;paramref name="b" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, returns <ph id="ph4">&lt;paramref name="b" /&gt;</ph> if <ph id="ph5">&lt;paramref name="a" /&gt;</ph> is a null reference, and returns a null reference if both <ph id="ph6">&lt;paramref name="a" /&gt;</ph> and <ph id="ph7">&lt;paramref name="b" /&gt;</ph> are null references.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="b" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>이면 <ph id="ph1">&lt;paramref name="a" /&gt;</ph>를 반환하고, <ph id="ph5">&lt;paramref name="a" /&gt;</ph>가 null 참조이면 <ph id="ph4">&lt;paramref name="b" /&gt;</ph>를 반환하며, <ph id="ph6">&lt;paramref name="a" /&gt;</ph>와 <ph id="ph7">&lt;paramref name="b" /&gt;</ph>가 모두 null 참조이면 null 참조를 반환합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">호출 목록에 중복 된 항목이; 포함 될 수 있습니다. 즉, 같은 개체에 대해 동일한 메서드를 참조 하는 항목입니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">할당 호환 되는 제네릭 대리자 차이 때문에 없는 함께 사용할 수 있는 것은 아닙니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">결합할 수 있으려면 형식이 정확히 일치 해야 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">예를 들어 라는 클래스 <ph id="ph1">`Derived`</ph> 라는 클래스에서 파생 된 <ph id="ph2">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> Visual basic에서) 형식의 변수에 할당할 수 있습니다 <ph id="ph3">`Action&lt;Derived&gt;`</ph>에 설명 되어 있듯이 <bpt id="p1">[</bpt>공 분산과 반공 분산<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, 하지만 두 대리자 형식이 않기 때문에 함께 사용할 수 없습니다 정확히 일치 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> 때마다 이벤트를 다중 메서드 호출이 발생 하는 이벤트 처리기를 만드는 데 유용 합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="a" /&gt;</ph> and <ph id="ph5">&lt;paramref name="b" /&gt;</ph> are not instances of the same delegate type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="a" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="b" /&gt;</ph> 모두 <ph id="ph3">&lt;see langword="null" /&gt;</ph>이 아니며, <ph id="ph4">&lt;paramref name="a" /&gt;</ph> 및 <ph id="ph5">&lt;paramref name="b" /&gt;</ph>가 동일한 대리자 형식의 인스턴스가 아닙니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</source>
          <target state="translated">현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록의 끝에 덧붙일 호출 목록을 가진 결합할 수 있는 멀티캐스트 대리자입니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</source>
          <target state="translated">지정된 결합할 수 있는 멀티캐스트 대리자와 현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록을 연결합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <ph id="ph1">&lt;paramref name="d" /&gt;</ph>, or the current multicast (combinable) delegate if <ph id="ph2">&lt;paramref name="d" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록과 <ph id="ph1">&lt;paramref name="d" /&gt;</ph>의 호출 목록을 연결하는 호출 목록을 가진 새로운 결합할 수 있는 멀티캐스트 대리자이거나, <ph id="ph2">&lt;paramref name="d" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우 현재 결합할 수 있는 멀티캐스트 대리자입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>This method applies only if the current delegate is multicast (combinable).</source>
          <target state="translated">이 메서드는 현재 대리자가 멀티 캐스트 하는 경우에 적용 됩니다. 결합할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The current implementation simply throws a <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>.</source>
          <target state="translated">현재 구현에서는 단순히 throw 한 <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">호출 목록에 중복 된 항목이; 포함 될 수 있습니다. 즉, 같은 개체에 대해 동일한 메서드를 참조 하는 항목입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Always thrown.</source>
          <target state="translated">항상 throw됩니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Creates a delegate of the specified type.</source>
          <target state="translated">지정된 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Only static methods are supported in the .NET Framework version 1.0 and 1.1.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는 정적 메서드만 지원됩니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type to represent the specified static method.</source>
          <target state="translated">지정된 정적 메서드를 나타내기 위해서 지정된 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">지정된 정적 메서드를 나타내기 위한 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는이 메서드 오버 로드만 정적 메서드에 대 한 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</source>
          <target state="translated">.NET framework 버전 2.0의 경우이 메서드 오버 로드도 만들 수 열려 있는 인스턴스 메서드 대리자; 즉, 명시적으로 숨겨진된 첫 번째 인수를 제공 하는 대리자 인스턴스 메서드.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</source>
          <target state="translated">대 한 자세한 내용은 참조는 보다 일반적인 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> 메서드 오버 로드를 위한 인스턴스 또는 정적 메서드를 대리자에 개방형 또는 폐쇄형의 모든 조합을 만들 하 고 필요에 따라 첫 번째 인수를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">이 메서드 오버 로드 때 사용할지 대리자의 첫 번째 인수에 대해 닫혀 있지 않으면 이므로 좀 더 빠른 경우.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">`true`</ph> 에 대 한 <ph id="ph3">`throwOnBindFailure`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">호환 가능한 매개 변수 형식 및 반환 형식</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">.NET Framework 버전 2.0에서에서 매개 변수 형식 및이 메서드 오버 로드를 사용 하 여 만든 대리자의 반환 형식 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식이 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</source>
          <target state="translated">.NET framework 버전 1.0 및 1.1에서는 형식이 정확히 일치 해야 바인딩 동작을 완화를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">예를 들어, 사용 하 여 대리자 형식의 매개 변수 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 의 반환 형식이 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <ph id="ph3">&lt;xref:System.Object&gt;</ph> 형식의 반환 값 및 <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This section contains two code examples.</source>
          <target state="translated">이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">첫 번째 예제에서는이 메서드 오버 로드를 만들 수 있는 대리자의 두 종류: 인스턴스 메서드를 통해 열고 정적 메서드에 대해 엽니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는이 오버 로드를 사용 하 여 대리자를 만들 수는 두 가지 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">두 개의 오버 로드가 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 지정 하는 메서드는 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 첫 번째 인수가 아닌; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">이 코드 예제에서는 두 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">이 예제에서는 클래스를 선언 <ph id="ph1">`C`</ph> 정적 메서드가 있는 <ph id="ph2">`M2`</ph> 및 인스턴스 메서드 <ph id="ph3">`M1`</ph>, 두 대리자 형식이: <ph id="ph4">`D1`</ph> 의 인스턴스를 사용 <ph id="ph5">`C`</ph> 및 문자열, 및 <ph id="ph6">`D2`</ph> 문자열을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">라는 두 번째 클래스 <ph id="ph1">`Example`</ph> 는 대리자를 만드는 코드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D1`</ph>를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 <ph id="ph2">`M1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D2`</ph>, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 <ph id="ph2">`M2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예제 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">기본 클래스를 정의 하는 코드 예제에서는 <ph id="ph1">`Base`</ph> 라는 클래스 및 <ph id="ph2">`Derived`</ph> 에서 파생 된 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">파생된 클래스에는 <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> Visual basic에서) 라는 메서드 <ph id="ph3">`MyMethod`</ph> 형식의 매개 변수가 둘 <ph id="ph4">`Base`</ph> 의 반환 형식이 <ph id="ph5">`Derived`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">코드 예제에서는 또한 라는 대리자를 정의 <ph id="ph1">`Example`</ph> 형식의 매개 변수 <ph id="ph2">`Derived`</ph> 의 반환 형식이 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">코드 예제에서는 대리자 라는 <ph id="ph1">`Example`</ph> 메서드를 나타내는 데 사용할 수 있습니다 <ph id="ph2">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">때문에 대리자에 메서드를 바인딩할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">대리자의 매개 변수 형식 (<ph id="ph1">`Derived`</ph>)의 매개 변수 형식 보다 제한적인 <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>)는 항상 안전 하 게 대리자의 인수를 전달, <ph id="ph4">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">반환 형식을 <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) 대리자의 매개 변수 형식 보다 제한적인 (<ph id="ph3">`Base`</ph>), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">코드 예제에서는 출력이 없습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a static method, and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 정적 메서드가 아니고 .NET Framework 버전이 1.0 또는 1.1인 경우</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>를 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The object to which the delegate is bound, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to treat <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> as <ph id="ph2">&lt;see langword="static" /&gt;</ph> (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">대리자가 바인드되는 개체이거나, <bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 <ph id="ph2">&lt;see langword="static" /&gt;</ph>(Visual Basic의 경우 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph>)으로 처리하는 경우 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</source>
          <target state="translated">지정한 첫 번째 인수를 사용하여 지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type that represents the specified static or instance method.</source>
          <target state="translated">지정된 정적 또는 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">이 메서드 오버 로드를 호출 하는 것은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드를 지정 하 고 <ph id="ph2">`true`</ph> 에 대 한 <ph id="ph3">`throwOnBindFailure`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>These two overloads provide the most flexible way to create delegates.</source>
          <target state="translated">이러한 두 오버 로드에는 대리자를 만드는 가장 유연한 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</source>
          <target state="translated">인스턴스 메서드 또는 정적 대 한 대리자를 만들고 필요에 따라 첫 번째 인수를 지정 하려면 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">첫 번째 인수를 제공 하지 않을 경우 사용 하 여는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> 성능 향상을 위해 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">대리자 형식 및 메서드의 호환 반환 형식이 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">반환 형식, 즉 <ph id="ph1">`method`</ph> 의 반환 형식에 할당할 수 있어야 <ph id="ph2">`type`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 는에 전달 된 제공 <ph id="ph2">`method`</ph> 될 때마다 대리자가 호출 됩니다. <ph id="ph3">`firstArgument`</ph> 대리자를 바인딩할 수를 라고 대리자는 첫 번째 인수에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">경우 <ph id="ph1">`method`</ph> 은 <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> Visual basic에서)에서는 대리자를 호출할 때 제공 된 목록이 경우 첫 번째; 제외한 모든 매개 변수를 포함 하는 인수 <ph id="ph4">`method`</ph> 는 인스턴스 메서드이므로 다음 <ph id="ph5">`firstArgument`</ph> 숨겨진된 인스턴스에 전달 됩니다 매개 변수 (나타내는 <ph id="ph6">`this`</ph> C# 또는 <ph id="ph7">`Me`</ph> Visual basic에서).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 제공 되의 첫 번째 매개 변수 <ph id="ph2">`method`</ph> 참조 형식 이어야 하 고 <ph id="ph3">`firstArgument`</ph> 해당 형식과 호환 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">경우 <ph id="ph1">`method`</ph> 은 <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> Visual basic에서)의 첫 번째 매개 변수는 형식 및 <ph id="ph4">&lt;xref:System.Object&gt;</ph> 또는 <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, 다음 <ph id="ph6">`firstArgument`</ph> 값 형식일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">이 경우 <ph id="ph1">`firstArgument`</ph> 자동으로 boxed 형식이 있습니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">가 C# 또는 Visual Basic 함수에서 호출 됩니다. 대로 다른 모든 인수에 대 한 자동 boxing 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 가 null 참조 및 <ph id="ph2">`method`</ph> 는 인스턴스 메서드이므로 결과 서명이 대리자 형식에 따라 달라 집니다 <ph id="ph3">`type`</ph> 및의 <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">하는 경우의 서명을 <ph id="ph1">`type`</ph> 의 숨겨진된 첫 번째 매개 변수를 명시적으로 포함 <ph id="ph2">`method`</ph>, 열려 있는 인스턴스 메서드를 나타내는 대리자는 간주 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">인수 목록에 첫 번째 인수의 숨겨진된 인스턴스 매개 변수에 전달 되는 대리자를 호출 하는 경우 <ph id="ph1">`method`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">하는 경우의 서명을 <ph id="ph1">`method`</ph> 및 <ph id="ph2">`type`</ph> 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">대리자를 호출 하 여 인스턴스 메서드는 특히 유용한 작업이 되지 않는 null 인스턴스에서 호출 방법과 비슷합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 가 null 참조 및 <ph id="ph2">`method`</ph> 은 정적, 결과에 따라 달라 집니다의 대리자 형식 시그니처 <ph id="ph3">`type`</ph> 및의 <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">경우의 서명을 <ph id="ph1">`method`</ph> 및 <ph id="ph2">`type`</ph> 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 열려 있는 정적 메서드를 나타내기 위해 간주 합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">이것이 정적 메서드에 대 한 가장 일반적인 경우입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">사용 하 여 약간 더 나은 성능을 얻을 수는 경우에 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">하는 경우의 서명을 <ph id="ph1">`type`</ph> 의 두 번째 매개 변수로 시작 <ph id="ph2">`method`</ph> 힙이고 다른 매개 변수 형식은 호환 되는 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">첫 번째 매개 변수는 null 참조가 전달 되는 대리자를 호출 하는 경우 <ph id="ph1">`method`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">호환 가능한 매개 변수 형식 및 반환 형식</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식을와 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는 형식이 정확히 일치 해야 합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">예를 들어, 사용 하 여 대리자 형식의 매개 변수 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 의 반환 형식이 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <ph id="ph3">&lt;xref:System.Object&gt;</ph> 형식의 반환 값 및 <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">메서드를 결정 하는 대리자 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">이 오버 로드에서 제공 하는 유연성 생각 하는 다른 유용한 방법은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 지정된 된 대리자 메서드 서명 및 메서드 종류 (정적 인스턴스)의 4 가지 다른 조합을 나타낼 수 있다는 것입니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">대리자 형식 고려 <ph id="ph1">`D`</ph> 형식의 인수를 하나 이상 사용 <ph id="ph2">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">다음 메서드를 설명 <ph id="ph1">`D`</ph> 모든 경우에에서 일치 해야 하므로 반환 형식을 무시 하 고 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 형식 인수가 하나만 있는 인스턴스 메서드를 나타낼 수 <ph id="ph2">`C`</ph>인스턴스 메서드가 속한 종류에 관계 없이 합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 되 <ph id="ph2">`firstArgument`</ph> 형식의 인스턴스인 <ph id="ph3">`method`</ph> 속한 결과로 생성 된 대리자는 해당 인스턴스에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(다르거나 일반적으로, <ph id="ph1">`D`</ph> 경우 null 참조에 대해 닫을 수도 있습니다 <ph id="ph2">`firstArgument`</ph> 가 null 참조입니다.)</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 인스턴스 메서드를 나타낼 수 <ph id="ph2">`C`</ph> 는 인수가 없는 합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 <ph id="ph2">`firstArgument`</ph> 가 null 참조입니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">결과로 생성 된 대리자는 열려 있는 인스턴스 메서드를 나타내며의 인스턴스 <ph id="ph1">`C`</ph> 를 호출할 때마다 제공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 형식의 인수 하나를 사용 하는 정적 메서드를 나타낼 수 <ph id="ph2">`C`</ph>, 메서드가 모든 형식에 속할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 <ph id="ph2">`firstArgument`</ph> 가 null 참조입니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">열려 있는 정적 메서드 및 인스턴스의 결과 대리자가 나타내는 <ph id="ph1">`C`</ph> 를 호출할 때마다 제공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 입력에 속하는 정적 메서드를 나타낼 수 <ph id="ph2">`F`</ph> 형식의 인수가 두 개 및 <ph id="ph3">`F`</ph> 유형과 <ph id="ph4">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 <ph id="ph2">`firstArgument`</ph> 의 인스턴스가 <ph id="ph3">`F`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">결과로 생성 된 대리자의 해당 인스턴스에 대해 닫혀 하는 정적 메서드를 나타내는 <ph id="ph1">`F`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">경우에서에 유의 여기서 <ph id="ph1">`F`</ph> 및 <ph id="ph2">`C`</ph> 같은 종류, 정적 메서드는 해당 형식의 두 인수입니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(이 경우 <ph id="ph1">`D`</ph> 경우 null 참조에 대해 닫혀 <ph id="ph2">`firstArgument`</ph> 가 null 참조입니다.)</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This section contains three code examples.</source>
          <target state="translated">이 섹션에는 세 가지 코드 예제가 있습니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">첫 번째 예제에서는 만들 수 있는 대리자의 네 가지 종류: 정적 메서드를 통해 열린 인스턴스 메서드를 통해 열린 인스턴스 메서드를 통해 닫히고 정적 메서드에 대해 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">세 번째 코드 예제는 단일 대리자 형식을 정의 하 고 대리자 형식의 모든 메서드에 나타낼 수를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에는이 오버 로드를 사용 하 여 대리자를 만들 수 4 가지 방법을 보여 줍니다.는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">두 개의 오버 로드가 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드를 지정 하는 <ph id="ph2">`firstArgument`</ph> 및 <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">이 코드 예제에서는 두 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">이 예제에서는 클래스를 선언 <ph id="ph1">`C`</ph> 정적 메서드가 있는 <ph id="ph2">`M2`</ph> 및 인스턴스 메서드 <ph id="ph3">`M1`</ph>, 대리자 형식이 세: <ph id="ph4">`D1`</ph> 의 인스턴스를 사용 <ph id="ph5">`C`</ph> 및 문자열을 <ph id="ph6">`D2`</ph> 에서는 문자열 및 <ph id="ph7">`D3`</ph>인수가 없는 합니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">라는 두 번째 클래스 <ph id="ph1">`Example`</ph> 는 대리자를 만드는 코드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D2`</ph>의 인스턴스에 대해 닫힘 <ph id="ph2">`C`</ph>, 인스턴스 메서드에 대해 만든 <ph id="ph3">`M1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">바인딩된 인스턴스를 보여 주는을 다른 문자열과 대리자는 <ph id="ph1">`C`</ph> 항상 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D1`</ph>를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 <ph id="ph2">`M1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D2`</ph>, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 <ph id="ph2">`M2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">형식의 대리자 마지막으로, <ph id="ph1">`D3`</ph>, 문자열에 대해 닫혀, 정적 메서드에 대해 만든 <ph id="ph2">`M2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">메서드는 바인딩된 문자열을 사용 한다는 것을 나타내기 위해 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예제 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">사용 하 여이 코드 예제는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">다른 사용 오버 <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 비슷합니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">기본 클래스를 정의 하는 코드 예제에서는 <ph id="ph1">`Base`</ph> 라는 클래스 및 <ph id="ph2">`Derived`</ph> 에서 파생 된 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">파생된 클래스에는 <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> Visual basic에서) 라는 메서드 <ph id="ph3">`MyMethod`</ph> 형식의 매개 변수가 둘 <ph id="ph4">`Base`</ph> 의 반환 형식이 <ph id="ph5">`Derived`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">코드 예제에서는 또한 라는 대리자를 정의 <ph id="ph1">`Example`</ph> 형식의 매개 변수 <ph id="ph2">`Derived`</ph> 의 반환 형식이 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">코드 예제에서는 대리자 라는 <ph id="ph1">`Example`</ph> 메서드를 나타내는 데 사용할 수 있습니다 <ph id="ph2">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">때문에 대리자에 메서드를 바인딩할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">대리자의 매개 변수 형식 (<ph id="ph1">`Derived`</ph>)의 매개 변수 형식 보다 제한적인 <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>)는 항상 안전 하 게 대리자의 인수를 전달, <ph id="ph4">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">반환 형식을 <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) 대리자의 매개 변수 형식 보다 제한적인 (<ph id="ph3">`Base`</ph>), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">코드 예제에서는 출력이 없습니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예제 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example shows all the methods a single delegate type can represent, using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method to create the delegates.</source>
          <target state="translated">다음 코드 예제에서는 모든 메서드를 사용 하는 단일 대리자 형식을 나타낼 수는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드는 대리자를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">두 개의 오버 로드가 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드를 지정 하는 <ph id="ph2">`firstArgument`</ph> 및 <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">이 코드 예제에서는 두 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">코드 예제에서는 두 개의 클래스를 정의 <ph id="ph1">`C`</ph> 및 <ph id="ph2">`F`</ph>, 및 대리자 형식은 <ph id="ph3">`D`</ph> 형식의 인수를 하나 이상 사용 <ph id="ph4">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">클래스는 동일한 정적 메서드와 인스턴스 메서드 <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, 및 <ph id="ph3">`M4`</ph>, 클래스 및 <ph id="ph4">`C`</ph> 인스턴스 메서드도 <ph id="ph5">`M2`</ph> 는 인수가 없는 합니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">이라는 세 번째 클래스 <ph id="ph1">`Example`</ph> 는 대리자를 만드는 코드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">대리자는 메서드를 만드는 예를 들어 <ph id="ph1">`M1`</ph> 형식의 <ph id="ph2">`C`</ph> 유형과 <ph id="ph3">`F`</ph>; 각는 각 형식의 인스턴스에 대해 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">메서드 <ph id="ph1">`M1`</ph> 형식의 <ph id="ph2">`C`</ph> 표시는 <ph id="ph3">`ID`</ph> 바인딩된 인스턴스 속성 및 인수입니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">메서드에 대 한 대리자는 <ph id="ph1">`M2`</ph> 형식의 <ph id="ph2">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">이 열려 있는 인스턴스 대리자를 대리자의 인수에는 인스턴스 메서드 숨겨진된 첫 번째 인수를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method has no other arguments.</source>
          <target state="translated">메서드는 다른 인수가 없습니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is called as if it were a static method.</source>
          <target state="translated">마치는 정적 메서드 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">대리자가 정적 메서드에 대해 <ph id="ph1">`M3`</ph> 형식의 <ph id="ph2">`C`</ph> 유형과 <ph id="ph3">`F`</ph>; 이러한 대리자는 정적 대리자입니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">마지막으로 대리자는 정적 메서드에 대해 생성 됩니다 <ph id="ph1">`M4`</ph> 형식의 <ph id="ph2">`C`</ph> 유형과 <ph id="ph3">`F`</ph>각 메서드에 첫 번째 인수로 선언 형식이 고 형식의 인스턴스 제공 되므로를 해당 인수에 대해 대리자 닫혔는지 .</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">메서드 <ph id="ph1">`M4`</ph> 형식의 <ph id="ph2">`C`</ph> 표시는 <ph id="ph3">`ID`</ph> 바인딩된 인스턴스 속성 및 인수입니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>를 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>가 호출되는 클래스 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 인스턴스 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">이 방법은 대리자 예를 들어만 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드 수를 지정 하 <ph id="ph2">`false`</ph> 에 대 한 <ph id="ph3">`ignoreCase`</ph> 및 <ph id="ph4">`true`</ph> 에 대 한 <ph id="ph5">`throwOnBindFailure`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>는 인스턴스 메서드가 아닙니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated">예를 들어 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>는 찾을 수 없기 때문에 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 바인딩할 수 없습니다. 예외가 발생하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 예외가 발생하지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</source>
          <target state="translated">바인딩 실패 시 지정한 동작을 기반으로 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">지정된 정적 메서드를 나타내기 위한 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</source>
          <target state="translated">이 메서드 오버 로드 열려 있는 정적 메서드 대리자를 만들 수 있습니다 및 인스턴스 메서드가 대리자를 열고-즉, 대리자의 숨겨진된 첫 번째 인수를 노출 하는 인스턴스 메서드.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</source>
          <target state="translated">대 한 자세한 내용은 참조는 보다 일반적인 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> 정적 메서드 또는 메서드 오버 로드를 예를 들어 모든 조합의 개방형 또는 폐쇄형 대리자를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">이 메서드 오버 로드 때 사용할지 대리자의 첫 번째 인수에 대해 닫혀 있지 않으면 이므로 좀 더 빠른 경우.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">호환 가능한 매개 변수 형식 및 반환 형식</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식을와 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는 형식이 정확히 일치 해야 합니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">예를 들어, 사용 하 여 대리자 형식의 매개 변수 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 의 반환 형식이 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <ph id="ph3">&lt;xref:System.Object&gt;</ph> 형식의 반환 값 및 <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains two code examples.</source>
          <target state="translated">이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">첫 번째 예제에서는이 메서드 오버 로드를 만들 수 있는 대리자의 두 종류: 인스턴스 메서드를 통해 열고 정적 메서드에 대해 엽니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에서는이 오버 로드를 사용 하 여 대리자를 만들 수는 두 가지 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">두 개의 오버 로드가 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 지정 하는 메서드는 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 첫 번째 인수가 아닌; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">이 코드 예제에서는 두 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">이 예제에서는 클래스를 선언 <ph id="ph1">`C`</ph> 정적 메서드가 있는 <ph id="ph2">`M2`</ph> 및 인스턴스 메서드 <ph id="ph3">`M1`</ph>, 두 대리자 형식이: <ph id="ph4">`D1`</ph> 의 인스턴스를 사용 <ph id="ph5">`C`</ph> 및 문자열, 및 <ph id="ph6">`D2`</ph> 문자열을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">라는 두 번째 클래스 <ph id="ph1">`Example`</ph> 는 대리자를 만드는 코드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D1`</ph>를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 <ph id="ph2">`M1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D2`</ph>, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 <ph id="ph2">`M2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예제 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">사용 하 여이 코드 예제는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">다른 사용 오버 <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 비슷합니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">기본 클래스를 정의 하는 코드 예제에서는 <ph id="ph1">`Base`</ph> 라는 클래스 및 <ph id="ph2">`Derived`</ph> 에서 파생 된 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">파생된 클래스에는 <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> Visual basic에서) 라는 메서드 <ph id="ph3">`MyMethod`</ph> 형식의 매개 변수가 둘 <ph id="ph4">`Base`</ph> 의 반환 형식이 <ph id="ph5">`Derived`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">코드 예제에서는 또한 라는 대리자를 정의 <ph id="ph1">`Example`</ph> 형식의 매개 변수 <ph id="ph2">`Derived`</ph> 의 반환 형식이 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">코드 예제에서는 대리자 라는 <ph id="ph1">`Example`</ph> 메서드를 나타내는 데 사용할 수 있습니다 <ph id="ph2">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">때문에 대리자에 메서드를 바인딩할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">대리자의 매개 변수 형식 (<ph id="ph1">`Derived`</ph>)의 매개 변수 형식 보다 제한적인 <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>)는 항상 안전 하 게 대리자의 인수를 전달, <ph id="ph4">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">반환 형식을 <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) 대리자의 매개 변수 형식 보다 제한적인 (<ph id="ph3">`Base`</ph>), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">코드 예제에서는 출력이 없습니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>를 바인딩할 수 없으므로 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 구현하는 클래스를 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 정적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">이 메서드는 정적 메서드만 대 한 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드 수를 지정 하 <ph id="ph2">`false`</ph> 에 대 한 <ph id="ph3">`ignoreCase`</ph> 및 <ph id="ph4">`true`</ph> 에 대 한 <ph id="ph5">`throwOnBindFailure`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>이 개방형 제네릭 형식인 경우.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">즉, 해당 <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 속성이 <ph id="ph2">&lt;see langword="true" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="static" /&gt;</ph> 메서드(Visual Basic의 경우 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> 메서드)가 아닌 경우</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">예를 들어 찾을 수 없고 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>이기 때문에 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>를 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of delegate to create.</source>
          <target state="translated">만들 디자이너 형식을 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that is the first argument of the method the delegate represents.</source>
          <target state="translated">대리자가 나타내는 메서드의 첫 번째 인수인 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For instance methods, it must be compatible with the instance type.</source>
          <target state="translated">인스턴스 메서드의 경우 인스턴스 형식과 호환되어야 합니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 바인딩할 수 없습니다. 예외가 발생하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 예외가 발생하지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</source>
          <target state="translated">지정한 첫 번째 인수와 바인딩 실패 시 지정한 동작을 기반으로 지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static or instance method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="false" /&gt;</ph> and the delegate cannot be bound to <ph id="ph4">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자이거나, <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph>가 <ph id="ph3">&lt;see langword="false" /&gt;</ph>이고 대리자를 <ph id="ph4">&lt;paramref name="method" /&gt;</ph>에 바인딩할 수 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload and the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</source>
          <target state="translated">이 메서드 오버 로드와 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> 메서드 오버 로드를 항상 바인딩 실패 시 throw, 대리자를 만들 수 있는 가장 유연한 방법을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>You can use them to create delegates for either static or instance methods, with or without a first argument.</source>
          <target state="translated">만들 대리자에 대 한 정적 또는 인스턴스 메서드로 첫 번째 인수를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">첫 번째 인수를 제공 하지 않을 경우 사용 하 여는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> 성능 향상을 위해 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">대리자 형식 및 메서드의 호환 반환 형식이 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">반환 형식, 즉 <ph id="ph1">`method`</ph> 의 반환 형식에 할당할 수 있어야 <ph id="ph2">`type`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 는에 전달 된 제공 <ph id="ph2">`method`</ph> 될 때마다 대리자가 호출 됩니다. <ph id="ph3">`firstArgument`</ph> 대리자를 바인딩할 수를 라고 대리자는 첫 번째 인수에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">경우 <ph id="ph1">`method`</ph> 은 <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> Visual basic에서)에서는 대리자를 호출할 때 제공 된 목록이 경우 첫 번째; 제외한 모든 매개 변수를 포함 하는 인수 <ph id="ph4">`method`</ph> 는 인스턴스 메서드이므로 다음 <ph id="ph5">`firstArgument`</ph> 숨겨진된 인스턴스에 전달 됩니다 매개 변수 (나타내는 <ph id="ph6">`this`</ph> C# 또는 <ph id="ph7">`Me`</ph> Visual basic에서).</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 제공 되의 첫 번째 매개 변수 <ph id="ph2">`method`</ph> 참조 형식 이어야 하 고 <ph id="ph3">`firstArgument`</ph> 해당 형식과 호환 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">경우 <ph id="ph1">`method`</ph> 은 <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> Visual basic에서)의 첫 번째 매개 변수는 형식 및 <ph id="ph4">&lt;xref:System.Object&gt;</ph> 또는 <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, 다음 <ph id="ph6">`firstArgument`</ph> 값 형식일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">이 경우 <ph id="ph1">`firstArgument`</ph> 자동으로 boxed 형식이 있습니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">가 C# 또는 Visual Basic 함수에서 호출 됩니다. 대로 다른 모든 인수에 대 한 자동 boxing 발생 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 가 null 참조 및 <ph id="ph2">`method`</ph> 는 인스턴스 메서드이므로 결과 서명이 대리자 형식에 따라 달라 집니다 <ph id="ph3">`type`</ph> 및의 <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">하는 경우의 서명을 <ph id="ph1">`type`</ph> 의 숨겨진된 첫 번째 매개 변수를 명시적으로 포함 <ph id="ph2">`method`</ph>, 열려 있는 인스턴스 메서드를 나타내는 대리자는 간주 합니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">인수 목록에 첫 번째 인수의 숨겨진된 인스턴스 매개 변수에 전달 되는 대리자를 호출 하는 경우 <ph id="ph1">`method`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">하는 경우의 서명을 <ph id="ph1">`method`</ph> 및 <ph id="ph2">`type`</ph> 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">대리자를 호출 하 여 인스턴스 메서드는 특히 유용한 작업이 되지 않는 null 인스턴스에서 호출 방법과 비슷합니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">경우 <ph id="ph1">`firstArgument`</ph> 가 null 참조 및 <ph id="ph2">`method`</ph> 은 정적, 결과에 따라 달라 집니다의 대리자 형식 시그니처 <ph id="ph3">`type`</ph> 및의 <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">경우의 서명을 <ph id="ph1">`method`</ph> 및 <ph id="ph2">`type`</ph> 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 열려 있는 정적 메서드를 나타내기 위해 간주 합니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">이것이 정적 메서드에 대 한 가장 일반적인 경우입니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">사용 하 여 약간 더 나은 성능을 얻을 수는 경우에 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">하는 경우의 서명을 <ph id="ph1">`type`</ph> 의 두 번째 매개 변수로 시작 <ph id="ph2">`method`</ph> 힙이고 다른 매개 변수 형식은 호환 되는 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">첫 번째 매개 변수는 null 참조가 전달 되는 대리자를 호출 하는 경우 <ph id="ph1">`method`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">호환 가능한 매개 변수 형식 및 반환 형식</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식을와 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1 the types must match exactly.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서에서 형식이 정확히 일치 해야 합니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">예를 들어, 사용 하 여 대리자 형식의 매개 변수 <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> 의 반환 형식이 <ph id="ph2">&lt;xref:System.Object&gt;</ph> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <ph id="ph3">&lt;xref:System.Object&gt;</ph> 형식의 반환 값 및 <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">메서드를 결정 하는 대리자 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">이 오버 로드에서 제공 하는 유연성 생각 하는 다른 유용한 방법은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 지정된 된 대리자 메서드 서명 및 메서드 종류 (정적 인스턴스)의 4 가지 다른 조합을 나타낼 수 있다는 것입니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">대리자 형식 고려 <ph id="ph1">`D`</ph> 형식의 인수를 하나 이상 사용 <ph id="ph2">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">다음 메서드를 설명 <ph id="ph1">`D`</ph> 모든 경우에에서 일치 해야 하므로 반환 형식을 무시 하 고 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 형식 인수가 하나만 있는 인스턴스 메서드를 나타낼 수 <ph id="ph2">`C`</ph>인스턴스 메서드가 속한 종류에 관계 없이 합니다.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 되 <ph id="ph2">`firstArgument`</ph> 형식의 인스턴스인 <ph id="ph3">`method`</ph> 속한 결과로 생성 된 대리자는 해당 인스턴스에 대해 닫혀 있는 것으로 간주 합니다.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(다르거나 일반적으로, <ph id="ph1">`D`</ph> 경우 null 참조에 대해 닫을 수도 있습니다 <ph id="ph2">`firstArgument`</ph> 은 <ph id="ph3">`null`</ph>.)</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 인스턴스 메서드를 나타낼 수 <ph id="ph2">`C`</ph> 는 인수가 없는 합니다.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 <ph id="ph2">`firstArgument`</ph> 가 null 참조입니다.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">결과로 생성 된 대리자는 열려 있는 인스턴스 메서드를 나타내며의 인스턴스 <ph id="ph1">`C`</ph> 를 호출할 때마다 제공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 형식의 인수 하나를 사용 하는 정적 메서드를 나타낼 수 <ph id="ph2">`C`</ph>, 메서드가 모든 형식에 속할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 <ph id="ph2">`firstArgument`</ph> 가 null 참조입니다.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">열려 있는 정적 메서드 및 인스턴스의 결과 대리자가 나타내는 <ph id="ph1">`C`</ph> 를 호출할 때마다 제공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 입력에 속하는 정적 메서드를 나타낼 수 <ph id="ph2">`F`</ph> 형식의 인수가 두 개 및 <ph id="ph3">`F`</ph> 유형과 <ph id="ph4">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">때 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 호출 <ph id="ph2">`firstArgument`</ph> 의 인스턴스가 <ph id="ph3">`F`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">결과로 생성 된 대리자의 해당 인스턴스에 대해 닫혀 하는 정적 메서드를 나타내는 <ph id="ph1">`F`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">경우에서에 유의 여기서 <ph id="ph1">`F`</ph> 및 <ph id="ph2">`C`</ph> 같은 종류, 정적 메서드는 해당 형식의 두 인수입니다.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(이 경우 <ph id="ph1">`D`</ph> 경우 null 참조에 대해 닫혀 <ph id="ph2">`firstArgument`</ph> 은 <ph id="ph3">`null`</ph>.)</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains three code examples.</source>
          <target state="translated">이 섹션에는 세 가지 코드 예제가 있습니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">첫 번째 예제에서는 만들 수 있는 대리자의 네 가지 종류: 정적 메서드를 통해 열린 인스턴스 메서드를 통해 열린 인스턴스 메서드를 통해 닫히고 정적 메서드에 대해 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">세 번째 코드 예제는 단일 대리자 형식을 정의 하 고 대리자 형식의 모든 메서드에 나타낼 수를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드 예제에는이 오버 로드를 사용 하 여 대리자를 만들 수 4 가지 방법을 보여 줍니다.는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">두 개의 오버 로드가 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드를 지정 하는 <ph id="ph2">`firstArgument`</ph> 및 <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">이 코드 예제에서는 두 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">이 예제에서는 클래스를 선언 <ph id="ph1">`C`</ph> 정적 메서드가 있는 <ph id="ph2">`M2`</ph> 및 인스턴스 메서드 <ph id="ph3">`M1`</ph>, 대리자 형식이 세: <ph id="ph4">`D1`</ph> 의 인스턴스를 사용 <ph id="ph5">`C`</ph> 및 문자열을 <ph id="ph6">`D2`</ph> 에서는 문자열 및 <ph id="ph7">`D3`</ph>인수가 없는 합니다.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">라는 두 번째 클래스 <ph id="ph1">`Example`</ph> 는 대리자를 만드는 코드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D2`</ph>의 인스턴스에 대해 닫힘 <ph id="ph2">`C`</ph>, 인스턴스 메서드에 대해 만든 <ph id="ph3">`M1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">바인딩된 인스턴스를 보여 주는을 다른 문자열과 대리자는 <ph id="ph1">`C`</ph> 항상 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D1`</ph>를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 <ph id="ph2">`M1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">형식의 대리자 <ph id="ph1">`D2`</ph>, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 <ph id="ph2">`M2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">형식의 대리자 마지막으로, <ph id="ph1">`D3`</ph>, 문자열에 대해 닫혀, 정적 메서드에 대해 만든 <ph id="ph2">`M2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">메서드는 바인딩된 문자열을 사용 한다는 것을 나타내기 위해 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예제 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">사용 하 여이 코드 예제는 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">다른 사용 오버 <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 비슷합니다.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">기본 클래스를 정의 하는 코드 예제에서는 <ph id="ph1">`Base`</ph> 라는 클래스 및 <ph id="ph2">`Derived`</ph> 에서 파생 된 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">파생된 클래스에는 <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> Visual basic에서) 라는 메서드 <ph id="ph3">`MyMethod`</ph> 형식의 매개 변수가 둘 <ph id="ph4">`Base`</ph> 의 반환 형식이 <ph id="ph5">`Derived`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">코드 예제에서는 또한 라는 대리자를 정의 <ph id="ph1">`Example`</ph> 형식의 매개 변수 <ph id="ph2">`Derived`</ph> 의 반환 형식이 <ph id="ph3">`Base`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">코드 예제에서는 대리자 라는 <ph id="ph1">`Example`</ph> 메서드를 나타내는 데 사용할 수 있습니다 <ph id="ph2">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">때문에 대리자에 메서드를 바인딩할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">대리자의 매개 변수 형식 (<ph id="ph1">`Derived`</ph>)의 매개 변수 형식 보다 제한적인 <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>)는 항상 안전 하 게 대리자의 인수를 전달, <ph id="ph4">`MyMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">반환 형식을 <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) 대리자의 매개 변수 형식 보다 제한적인 (<ph id="ph3">`Base`</ph>), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">코드 예제에서는 출력이 없습니다.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>예제 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example shows all the methods a single delegate type can represent.</source>
          <target state="translated">다음 코드 예제에서는 모든 메서드는 단일 대리자 형식이 나타낼 수를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">두 개의 오버 로드가 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> 메서드를 지정 하는 <ph id="ph2">`firstArgument`</ph> 및 <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">이 코드 예제에서는 두 오버 로드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">코드 예제에서는 두 개의 클래스를 정의 <ph id="ph1">`C`</ph> 및 <ph id="ph2">`F`</ph>, 및 대리자 형식은 <ph id="ph3">`D`</ph> 형식의 인수를 하나 이상 사용 <ph id="ph4">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">클래스는 동일한 정적 메서드와 인스턴스 메서드 <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, 및 <ph id="ph3">`M4`</ph>, 클래스 및 <ph id="ph4">`C`</ph> 인스턴스 메서드도 <ph id="ph5">`M2`</ph> 는 인수가 없는 합니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">이라는 세 번째 클래스 <ph id="ph1">`Example`</ph> 는 대리자를 만드는 코드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">대리자는 메서드를 만드는 예를 들어 <ph id="ph1">`M1`</ph> 형식의 <ph id="ph2">`C`</ph> 유형과 <ph id="ph3">`F`</ph>; 각는 각 형식의 인스턴스에 대해 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">메서드 <ph id="ph1">`M1`</ph> 형식의 <ph id="ph2">`C`</ph> 표시는 <ph id="ph3">`ID`</ph> 바인딩된 인스턴스 속성 및 인수입니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">메서드에 대 한 대리자는 <ph id="ph1">`M2`</ph> 형식의 <ph id="ph2">`C`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">이 열려 있는 인스턴스 대리자를 대리자의 인수에는 인스턴스 메서드 숨겨진된 첫 번째 인수를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method has no other arguments.</source>
          <target state="translated">메서드는 다른 인수가 없습니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">대리자가 정적 메서드에 대해 <ph id="ph1">`M3`</ph> 형식의 <ph id="ph2">`C`</ph> 유형과 <ph id="ph3">`F`</ph>; 이러한 대리자는 정적 대리자입니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">마지막으로 대리자는 정적 메서드에 대해 생성 됩니다 <ph id="ph1">`M4`</ph> 형식의 <ph id="ph2">`C`</ph> 유형과 <ph id="ph3">`F`</ph>각 메서드에 첫 번째 인수로 선언 형식이 고 형식의 인스턴스 제공 되므로를 해당 인수에 대해 대리자 닫혔는지 .</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">메서드 <ph id="ph1">`M4`</ph> 형식의 <ph id="ph2">`C`</ph> 표시는 <ph id="ph3">`ID`</ph> 바인딩된 인스턴스 속성 및 인수입니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>를 바인딩할 수 없으므로 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>가 호출되는 클래스 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 인스턴스 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</source>
          <target state="translated">지정된 대/소문자 구분 여부를 기반으로 지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">이 방법은 대리자 예를 들어만 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드 수를 지정 하 <ph id="ph2">`true`</ph> 에 대 한 <ph id="ph3">`throwOnBindFailure`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>는 인스턴스 메서드가 아닙니다.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated">예를 들어 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>는 찾을 수 없기 때문에 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 구현하는 클래스를 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 정적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</source>
          <target state="translated">지정한 대/소문자 구분 여부를 기반으로 지정한 클래스의 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">이 메서드는 정적 메서드만 대 한 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">이 메서드 오버 로드 하는 것은 <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> 메서드 오버 로드 수를 지정 하 <ph id="ph2">`true`</ph> 에 대 한 <ph id="ph3">`throwOnBindFailure`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>이 개방형 제네릭 형식인 경우.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">즉, 해당 <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 속성이 <ph id="ph2">&lt;see langword="true" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="static" /&gt;</ph> 메서드(Visual Basic의 경우 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> 메서드)가 아닌 경우</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated">예를 들어 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>는 찾을 수 없기 때문에 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>가 호출되는 클래스 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 인스턴스 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 바인딩할 수 없습니다. 예외가 발생하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 예외가 발생하지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">지정한 대/소문자 구분과 바인딩 실패 시 지정한 동작을 기반으로 지정한 클래스 인스턴스에서 호출하는 지정한 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">이 방법은 대리자 예를 들어만 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>는 인스턴스 메서드가 아닙니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">예를 들어 찾을 수 없고 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>이기 때문에 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>를 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">만들 대리자의 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 구현하는 클래스를 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">대리자가 나타내는 정적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>메서드<ept id="p1">&lt;/c&gt;</ept>를 바인딩할 수 없습니다. 예외가 발생하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 예외가 발생하지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">지정한 대/소문자 구분과 바인딩 실패 시 지정한 동작을 기반으로 지정한 클래스의 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">이 메서드는 정적 메서드만 대 한 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션의 보안 고려 사항<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>은 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>를 상속하지 않습니다.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>리플렉션의 런타임 형식<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>가 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>가 아닌 경우</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>이 개방형 제네릭 형식인 경우.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">즉, 해당 <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 속성이 <ph id="ph2">&lt;see langword="true" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph>가 <ph id="ph2">&lt;see langword="static" /&gt;</ph> 메서드(Visual Basic의 경우 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> 메서드)가 아닌 경우</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">예를 들어 찾을 수 없고 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>이기 때문에 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>를 바인딩할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="type" /&gt;</ph>의 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 메서드를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">호출자에게 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>에 액세스하는 데 필요한 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">현재 대리자가 나타내는 메서드로 전달할 인수인 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated">현재 대리자가 나타내는 메서드에 인수가 필요하지 않으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">현재 대리자가 나타내는 메서드를 동적으로 호출(런타임에 바인딩)합니다.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">대리자가 나타내는 메서드에서 반환되는 개체입니다.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>This method calls the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph> method.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph> 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph>에 열거된 매개 변수의 개수, 순서, 형식이 유효하지 않은 경우</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">대리자가 나타내는 메서드가 해당 메서드를 지원하지 않는 개체 또는 클래스에서 호출되는 경우</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">대리자가 나타내는 메서드가 인스턴스 메서드이고 대상 개체가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">캡슐화된 메서드 중 하나에서 예외를 throw하는 경우</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">현재 대리자가 나타내는 메서드로 전달할 인수인 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated">현재 대리자가 나타내는 메서드에 인수가 필요하지 않으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">현재 대리자가 나타내는 메서드를 동적으로 호출(런타임에 바인딩)합니다.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">대리자가 나타내는 메서드에서 반환되는 개체입니다.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>This method implements the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph> method.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph> 메서드를 구현합니다.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph>에 열거된 매개 변수의 개수, 순서, 형식이 유효하지 않은 경우</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">대리자가 나타내는 메서드가 해당 메서드를 지원하지 않는 개체 또는 클래스에서 호출되는 경우</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">대리자가 나타내는 메서드가 인스턴스 메서드이고 대상 개체가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">캡슐화된 메서드 중 하나에서 예외를 throw하는 경우</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The object to compare with the current delegate.</source>
          <target state="translated">현재 대리자와 비교할 개체입니다.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</source>
          <target state="translated">지정한 개체와 현재 대리자가 같은 형식이고 같은 대상, 메서드 및 호출 목록을 공유하는지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> and the current delegate have the same targets, methods, and invocation list; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="obj" /&gt;</ph>와 현재 대리자가 같은 대상, 메서드 및 호출 목록을 가지면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">두 대리자 형식이 아닌 경우 같은 간주 되지는 않습니다.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">.NET framework 버전 1.0 및 1.1에서는 두 명의 대리자가 서로 다른 형식의 해당 대상, 메서드 및 호출 목록 같으면 고려 되었습니다.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">메서드와 대상이 다음과 같이 같은지 비교 됩니다.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">비교 되는 두 개의 메서드가 둘 다 정적 동일한 클래스에 있는 같은 메서드를 메서드 같은 개체로 간주 되는지 및 대상도 같다고 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">비교할 두 개의 메서드는 인스턴스 메서드, 동일한 개체에 대해 동일한 메서드 메서드 같은 개체로 간주 되는지 고 대상을 같다고 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">그렇지 않으면 메서드 동일한 것으로 간주 되지 않습니다 하 고 대상 동일한 것으로 간주 되지도 않습니다.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">같은 순서를가지고 있고 두 목록에서 해당 요소를 같은 메서드와 대상을 나타냅니다 경우에 두 호출 목록은 동일한 것으로 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>Returns a hash code for the delegate.</source>
          <target state="translated">대리자의 해시 코드를 반환합니다.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>A hash code for the delegate.</source>
          <target state="translated">대리자의 해시 코드입니다.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>The return value of this method must not be persisted for two reasons.</source>
          <target state="translated">이 메서드의 반환 값 지속 되지 않아야 하는 두 가지 이유입니다.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</source>
          <target state="translated">첫째, 오래 된 해시 함수에서 값 쓸모 향상 된 분포를 생성 하는 클래스의 해시 함수를 변경 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</source>
          <target state="translated">둘째,이 클래스의 기본 구현은 동일한 값이 서로 다른 인스턴스에서 반환 될을 보장 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>Returns the invocation list of the delegate.</source>
          <target state="translated">대리자의 호출 목록을 반환합니다.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>An array of delegates representing the invocation list of the current delegate.</source>
          <target state="translated">현재 대리자의 호출 목록을 나타내는 대리자의 배열입니다.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Each delegate in the array represents exactly one method.</source>
          <target state="translated">배열의 각 대리자는 정확히 하나의 메서드를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</source>
          <target state="translated">배열의 대리자의 순서가 현재 대리자가 해당 대리자가 나타내는 메서드를 호출 하는 순서와 동일 합니다.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The following example assigns three methods to a delegate.</source>
          <target state="translated">다음 예제에서는 대리자를 세 가지 메서드를 할당합니다.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>It then calls the  <ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</source>
          <target state="translated">그런 다음 호출 하는 <ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph> "File"입니다. 대리자를 반대 순서로 실행 하 고 이름이 부분 문자열을 포함 하지 마십시오 메서드를 실행 하는 대리자에 할당 하는 방법의 총 개수를 가져올 메서드입니다.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>Gets the static method represented by the current delegate.</source>
          <target state="translated">현재 대리자가 나타내는 정적 메서드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static method represented by the current delegate.</source>
          <target state="translated">현재 대리자가 나타내는 정적 메서드를 설명하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>This method applies only if the current delegate represents a static method.</source>
          <target state="translated">이 메서드는 현재 대리자가 나타내는 정적 메서드의 경우에 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is not supported.</source>
          <target state="translated">이 메서드는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>Gets the method represented by the delegate.</source>
          <target state="translated">대리자가 나타내는 메서드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the method represented by the delegate.</source>
          <target state="translated">대리자가 나타내는 메서드를 설명하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">비교할 첫째 대리자입니다.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">비교할 둘째 대리자입니다.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are equal.</source>
          <target state="translated">지정된 대리자가 같은지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="d1" /&gt;</ph>와 같으면 <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>이고, 그러지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</source>
          <target state="translated">같은 대상, 메서드 및 호출 목록을 가진 같은 형식의 두 대리자는 같은 것으로 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">두 대리자 형식이 아닌 경우 같은 간주 되지는 않습니다.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">.NET framework 버전 1.0 및 1.1에서는 두 명의 대리자가 서로 다른 형식의 해당 대상, 메서드 및 호출 목록 같으면 고려 되었습니다.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">메서드와 대상이 다음과 같이 같은지 비교 됩니다.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">비교 되는 두 개의 메서드가 둘 다 정적 동일한 클래스에 있는 같은 메서드를 메서드 같은 개체로 간주 되는지 및 대상도 같다고 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">비교할 두 개의 메서드는 인스턴스 메서드, 동일한 개체에 대해 동일한 메서드 메서드 같은 개체로 간주 되는지 고 대상을 같다고 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">그렇지 않으면 메서드 동일한 것으로 간주 되지 않습니다 하 고 대상 동일한 것으로 간주 되지도 않습니다.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">순서 및 같은 메서드와 대상을 두 목록에서 해당 요소를 나타냅니다 두 호출 목록은 동일한 것으로 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">이 연산자는 해당 하는 방법은 <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">비교할 첫째 대리자입니다.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">비교할 둘째 대리자입니다.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are not equal.</source>
          <target state="translated">지정된 대리자가 다른지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="d1" /&gt;</ph>와 다르면 <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>이고, 그러지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</source>
          <target state="translated">다양 한 유형의 인지 여러 가지 방법, 다양 한 대상에 또는 다른 호출 목록이 있는 경우 두 대리자를 동일 하지 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">두 대리자 형식이 아닌 경우 같은 간주 되지는 않습니다.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">.NET framework 버전 1.0 및 1.1에서는 두 명의 대리자가 서로 다른 형식의 해당 대상, 메서드 및 호출 목록 같으면 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">메서드와 대상이 다음과 같이 같은지 비교 됩니다.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">비교 되는 두 개의 메서드가 둘 다 정적 동일한 클래스에 있는 같은 메서드를 메서드 같은 개체로 간주 되는지 및 대상도 같다고 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">비교할 두 개의 메서드는 인스턴스 메서드, 동일한 개체에 대해 동일한 메서드 메서드 같은 개체로 간주 되는지 고 대상을 같다고 간주 됩니다.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">그렇지 않으면 메서드 동일한 것으로 간주 되지 않습니다 하 고 대상 동일한 것으로 간주 되지도 않습니다.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</source>
          <target state="translated">메서드 또는 다른 목록의 해당 요소가 나타내는 다른 한 목록에서 하나 이상의 요소를 나타내는 경우 또는 크기가 다른 서로 다르게 정렬 되어 경우 두 호출 목록은 다릅니다.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">이 연산자는 해당 하는 방법은 <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>값<ept id="p1">&lt;/c&gt;</ept>의 호출 목록을 제거하는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>원본<ept id="p1">&lt;/c&gt;</ept>의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">한 대리자의 호출 목록에 있는 마지막 항목을 다른 대리자의 호출 목록에서 제거합니다.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing the last occurrence of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>의 호출 목록이 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>의 호출 목록에 있는 경우, <ph id="ph3">&lt;paramref name="value" /&gt;</ph>의 호출 목록을 가져오고 <ph id="ph4">&lt;paramref name="source" /&gt;</ph>의 호출 목록에 있는 마지막 항목을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>이거나 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>의 호출 목록이 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>의 호출 목록에 없는 경우 <ph id="ph5">&lt;paramref name="source" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph> or if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 호출 목록이 <ph id="ph2">&lt;paramref name="source" /&gt;</ph>의 호출 목록과 같거나 <ph id="ph3">&lt;paramref name="source" /&gt;</ph>가 null 참조인 경우 null 참조를 반환합니다.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">하는 경우의 호출 목록 <ph id="ph1">`value`</ph> 의 호출 목록에 있는 요소의 연속 집합과 일치 <ph id="ph2">`source`</ph>의 호출 목록에는 다음 <ph id="ph3">`value`</ph> 의 호출 목록 내에서 발생 한다고 <ph id="ph4">`source`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, the last occurrence is removed.</source>
          <target state="translated">하는 경우의 호출 목록 <ph id="ph1">`value`</ph> 의 호출 목록에 두 번 이상 발생 <ph id="ph2">`source`</ph>, 마지막으로 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">대리자 형식이 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>값<ept id="p1">&lt;/c&gt;</ept>의 호출 목록을 제거하는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>원본<ept id="p1">&lt;/c&gt;</ept>의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">한 대리자의 호출 목록에 있는 모든 항목을 다른 대리자의 호출 목록에서 제거합니다.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing all occurrences of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>의 호출 목록이 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>의 호출 목록에 있는 경우, <ph id="ph3">&lt;paramref name="value" /&gt;</ph>의 호출 목록을 가져오고 <ph id="ph4">&lt;paramref name="source" /&gt;</ph>의 호출 목록에 있는 모든 항목을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>이거나 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>의 호출 목록이 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>의 호출 목록에 없는 경우 <ph id="ph5">&lt;paramref name="source" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> contains only a series of invocation lists that are equal to the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 호출 목록이 <ph id="ph2">&lt;paramref name="source" /&gt;</ph>의 호출 목록과 같거나 <ph id="ph3">&lt;paramref name="source" /&gt;</ph>에 <ph id="ph4">&lt;paramref name="value" /&gt;</ph>의 호출 목록과 같은 일련의 호출 목록만 있거나 <ph id="ph5">&lt;paramref name="source" /&gt;</ph>가 null 참조인 경우 null 참조를 반환합니다.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">하는 경우의 호출 목록 <ph id="ph1">`value`</ph> 의 호출 목록에 있는 요소의 연속 집합과 일치 <ph id="ph2">`source`</ph>의 호출 목록에는 다음 <ph id="ph3">`value`</ph> 의 호출 목록 내에서 발생 한다고 <ph id="ph4">`source`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, all occurrences are removed.</source>
          <target state="translated">하는 경우의 호출 목록 <ph id="ph1">`value`</ph> 의 호출 목록에 두 번 이상 발생 <ph id="ph2">`source`</ph>, 모든 항목이 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">대리자 형식이 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</source>
          <target state="translated">현재 대리자의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Removes the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">한 대리자의 호출 목록을 다른 대리자의 호출 목록에서 제거합니다.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found within the current delegate's invocation list.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>의 호출 목록이 현재 대리자의 호출 목록에 있는 경우, 현재 대리자의 호출 목록을 가져오고 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>의 호출 목록을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns the current delegate if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not found within the current delegate's invocation list.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 <ph id="ph3">&lt;paramref name="value" /&gt;</ph>의 호출 목록이 현재 대리자의 호출 목록에 없는 경우 현재 대리자를 반환합니다.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is equal to the current delegate's invocation list.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="value" /&gt;</ph>의 호출 목록이 현재 대리자의 호출 목록과 같으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of <ph id="ph2">`value`</ph> is said to occur within the current delegate's invocation list.</source>
          <target state="translated">하는 경우의 호출 목록 <ph id="ph1">`value`</ph> 연속 된 집합이 현재 대리자의 호출 목록 다음의 호출 목록에 있는 요소를 일치 <ph id="ph2">`value`</ph> 현재 대리자의 호출 목록에 발생 한다고 합니다.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the current delegate's invocation list, the last occurrence is removed.</source>
          <target state="translated">하는 경우의 호출 목록 <ph id="ph1">`value`</ph> 두 번 이상 발생 현재 대리자의 호출 목록에 마지막으로 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="P:System.Delegate.Target">
          <source>Gets the class instance on which the current delegate invokes the instance method.</source>
          <target state="translated">현재 대리자가 인스턴스 메서드를 호출하는 클래스 인스턴스를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the delegate represents a static method.</source>
          <target state="translated">대리자가 인스턴스 메서드를 나타내는 경우 현재 대리자가 인스턴스 메서드를 호출하는 개체이고, 대리자가 정적 메서드를 나타내는 경우 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</source>
          <target state="translated">하나 이상의 인스턴스 메서드를 호출 하는 대리자 호출 목록에서 마지막 인스턴스 메서드의 대상이이 속성으로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>