<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f0536eac77f3171e3a7eeb74486cfcf863ec3d8" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731657" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>대리자는 정적 메서드 또는 클래스 인스턴스 및 해당 클래스의 인스턴스 메서드를 참조하는 데이터 구조입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> 클래스는 대리자 형식에 대 한 기본 클래스입니다. 그러나 시스템 및 컴파일러에서 명시적으로 파생 될 수 있습니다는 <xref:System.Delegate> 클래스 또는 <xref:System.MulticastDelegate> 클래스입니다. 이기도 하지 대리자 형식에서 새 유형을 파생할 수 있습니다. <xref:System.Delegate> 클래스는 대리자 형식으로 간주 되지 않으면 대리자 형식을 파생 하는 데 사용 되는 클래스입니다.  
  
 구현 하는 대부분의 언어는 `delegate` 키워드 및 해당 언어 컴파일러에서 파생 시킬 수 있습니다는 <xref:System.MulticastDelegate> 클래스; 따라서 사용자가 사용 해야는 `delegate` 언어에서 제공 하는 키워드입니다.  
  
> [!NOTE]
>  공용 언어 런타임에서 제공는 `Invoke` 대리자와 동일한 서명 사용 하 여 각 대리자 형식에 대 한 메서드. 이 경우 컴파일러 자동으로 호출 하기 때문에 C#, Visual Basic 또는 Visual c + +에서이 메서드를 명시적으로 호출할 필요가 없습니다. `Invoke` 메서드는에 유용 [리플렉션](~/docs/framework/reflection-and-codedom/reflection.md) 대리자 형식 시그니처를 찾으려는 경우.  
  
 공용 언어 런타임에서 제공 각 대리자 형식에 `BeginInvoke` 및 `EndInvoke` 메서드는 대리자의 비동기 호출을 사용 하도록 합니다. 이러한 메서드에 대 한 자세한 내용은 참조 [대](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.  
  
 대리자 형식의 선언에는 하나 이상의 메서드 서명을 지정 하는 계약을 설정 합니다. 대리자는에 대 한 참조가 대리자 형식의 인스턴스입니다.  
  
-   형식과 해당 형식에 지정할 수 하나의 대상 개체의 인스턴스 메서드.  
  
-   숨겨진 된 형식의 인스턴스 메서드인 `this` 매개 변수 형식 매개 변수 목록에 표시 합니다. 대리자는 열려 있는 인스턴스 대리자를 라고 합니다.  
  
-   정적 메서드입니다.  
  
-   정적 메서드 및 대상 개체는 메서드의 첫 번째 매개 변수를 할당할 수 있습니다. 대리자는 첫 번째 인수에 대해 닫혀 간주 됩니다.  
  
 대리자 바인딩에 대 한 자세한 내용은 참조는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서는 메서드의 서명을 대리자 형식에 지정 된 시그니처를 정확 하 게 일치 하는 경우에 대리자는 메서드를 나타낼 수 있습니다. 따라서 앞의 목록에 첫 번째 및 세 번째 항목이 지원 됩니다 하 고 첫 번째 글머리 기호 형식이 정확히 일치 하는 값 필요로 합니다.  
  
 대리자는 메서드의 진입점에 대 한 참조와 정의 된 형식에 할당할 수 있는 형식의 대상 이라는 개체에 대 한 참조를 저장 대리자에서 첫 번째 인수 (가장 일반적인 경우)에 대해 닫혀 인스턴스 메서드를 나타내는 경우는 메서드입니다. 대리자는 열려 있는 인스턴스 메서드를 나타내는 경우 메서드의 진입점에 대 한 참조를 저장 합니다. 대리자 시그니처는 숨겨진 포함 해야 `this` 매개 변수는 정식 매개 변수 목록의 경우 대리자에는 대상 개체에 대 한 참조 및 대리자를 호출 하는 경우 대상 개체를 제공 해야 합니다.  
  
 대리자는 정적 메서드를 나타내는 대리자 메서드 진입점에 대 한 참조를 저장 합니다. 대리자에서 첫 번째 인수에 대해 닫혀 있는 정적 메서드를 나타내는 대리자 메서드의 진입점에 대 한 참조와 메서드의 첫 번째 인수의 형식에 지정할 수 하나의 대상 개체에 대 한 참조를 저장 합니다. 대리자가 호출 됩니다는 정적 메서드의 첫 번째 인수는 대상 개체를 받습니다.  
  
 대리자의 호출 목록에서 목록의 각 요소에 호출 대리자가 나타내는 방법 중 하나에 정확 하 게 대리자의 정렬된 된 집합은 합니다. 호출 목록에 중복 메서드 포함 될 수 있습니다. 메서드는 호출 하는 동안 호출 목록에 나타나는 순서 대로 호출 됩니다. 대리자는 호출 목록의 모든 메서드를 호출 하려고 합니다. 중복 된 각 시간에 대해 호출 목록에 표시 되 면 호출 됩니다. 대리자는 변경할 수 없습니다. 를 만든 후에 대리자의 호출 목록 변경 되지 않습니다.  
  
 대리자 참조 됩니다 멀티 캐스트 또는 결합할 대리자는 하나 이상의 메서드를 호출할 수 하 고 결합 하는 연산에 사용할 수 있습니다.  
  
 와 같은 작업을 결합 <xref:System.Delegate.Combine%2A> 및 <xref:System.Delegate.Remove%2A>, 기존 대리자를 변경 하지 마십시오. 이러한 작업이 변경 되지 않은 대리자 작업의 결과 포함 하는 새 대리자를 반환 하는 대신, 또는 `null`합니다. 결합 작업을 반환 `null` 때 작업의 결과 하나 이상의 메서드를 참조 하지 않는 대리자입니다. 결합 작업 요청 된 작업의 영향을 주지 않습니다는 변경 되지 않은 대리자를 반환 합니다.  
  
> [!NOTE]
>  언어 사용 하 여 관리 되는 <xref:System.Delegate.Combine%2A> 및 <xref:System.Delegate.Remove%2A> 메서드 대리자 작업을 구현 합니다. 예로 `AddHandler` 및 `RemoveHandler` Visual Basic의 선언문 및 + = 및-= 연산자에 대리자 C#의 형식입니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 제네릭 대리자 형식에서 variant 형식 매개 변수를 가질 수 있습니다. 반공 변 형식 매개 변수는 대리자의 매개 변수 형식으로 사용할 수 및 반환 형식으로 공변 형식 매개 변수를 사용할 수 있습니다. 이 기능을 사용 하면 제네릭 대리자에 설명 된 대로 해당 형식 인수는 참조 형식, 상속 관계에 있는 경우 할당 호환 되도록 동일한 제네릭 형식 정의에서 생성 된 형식을 [공 분산 및 반 공변성](~/docs/standard/generics/covariance-and-contravariance.md)합니다.  
  
> [!NOTE]
>  할당 호환 되는 제네릭 대리자 차이 때문에 없는 함께 사용할 수 있는 것은 아닙니다. 결합할 수 있으려면 형식이 정확히 일치 해야 합니다. 예를 들어 라는 클래스 `Derived` 라는 클래스에서 파생 된 `Base`합니다. 형식의 대리자 `Action<Base>` (`Action(Of Base)` Visual basic에서) 형식의 변수에 할당할 수 `Action<Derived>`, 하지만 두 대리자 형식이 정확히 일치 하지 않기 때문에 함께 사용할 수 없습니다.  
  
 호출 된 메서드가 예외를 throw 하는 경우 메서드가 실행이 중지 되며, 예외는 대리자의 호출자로 다시 전달 됩니다 및 나머지 메서드는 호출 목록의 호출 되지 않습니다. 호출자에 예외를 catch 하는 경우에이 동작을 변경 하지 않습니다.  
  
 반환 값을 포함 하는 대리자에 의해 호출 된 메서드 서명의 경우 대리자 호출 목록에 있는 마지막 요소의 반환 값을 반환 합니다. 서명을 참조로 전달 되는 매개 변수를 포함 하는 경우 매개 변수의 최종 값 순서 대로 실행 및 매개 변수의 값을 업데이트 하는 호출 목록의 모든 메서드의 결과입니다.  
  
 C 또는 c + +에서 대리자를 해당 하는 가장 가까운 함수 포인터입니다. 대리자는 정적 메서드 또는 인스턴스 메서드를 나타낼 수 있습니다. 대리자가 인스턴스 메서드를 나타내는 대리자 메서드 진입점에 대 한 참조를 뿐만 아니라 클래스 인스턴스에 대 한 참조를 저장 합니다. 함수 포인터와 달리 대리자는 개체 지향적 및 형식이 안전 합니다.  
  
   
  
## Examples  
 다음 예제에서는 라는 대리자를 정의 하는 방법을 보여 줍니다. `myMethodDelegate`합니다. 인스턴스 메서드와 정적 메서드는 중첩 된에 대 한이 대리자의 인스턴스를 만들 `mySampleClass` 클래스입니다. 인스턴스 메서드의 대리자의 인스턴스가 필요 `mySampleClass`합니다. `mySampleClass` 이라는 변수에 인스턴스는 저장 되지만 `mySC`합니다.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 대리자를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">대리자가 <c>메서드</c>를 호출하는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <summary>지정된 클래스 인스턴스에서 지정된 인스턴스 메서드를 호출하는 대리자를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다. 오버 로드를 사용 하 여 인스턴스 메서드 이름을 지정 하 여 대리자를 만들려는 <xref:System.Delegate.CreateDelegate%2A> 메서드 이름 및 대상 개체를 지정 하는 메서드. 예를 들어는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> 메서드 오버 로드는 지정 된 이름의 인스턴스 메서드의 대리자를 만듭니다.  
  
 이 생성자만 메서드에 대리자를 예를 들어 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">대상 메서드에 바인딩할 때 오류가 발생한 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <c>메서드</c>를 정의하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <summary>지정된 클래스에서 지정된 정적 메서드를 호출하는 대리자를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다. 오버 로드를 사용 하 여 정적 메서드 이름을 지정 하 여 대리자를 만들려는 <xref:System.Delegate.CreateDelegate%2A> 메서드 메서드 이름을 지정 하는 대상 개체를 지정 하지 않습니다. 예를 들어는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> 메서드 오버 로드는 지정된 된 이름을 가진 메서드에 대 한 정적 대리자를 만듭니다.  
  
 이 생성자만 정적 메서드에 대 한 대리자를 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="target" />이 개방형 제네릭 형식을 나타내는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>대리자의 부분 복사본을 만듭니다.</summary>
        <returns>대리자의 부분 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복사본은 동일한 <xref:System.Type>, 원래 대리자로 대상, 방법 및 호출 목록입니다.  
  
 단순 복사본을 원래 개체와 동일한 형식의 새 인스턴스를 만들고 원래 개체의 비정적 필드를 복사 합니다. 필드 값 형식이 필드의 비트 단위로 복사가 수행 됩니다. 필드 참조 형식인 경우 참조를 복사할 수 있지만 참조 된 개체는 필요는 없습니다. 따라서 원본 개체에 대 한 참조와 복제에 대 한 참조는 동일한 개체를 가리킵니다. 이와 반대로 개체의 전체 복사본을 개체의 필드에서 직접 또는 간접적으로 참조 하는 모든 항목을 복제 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 결합할 수 있는 멀티캐스트 대리자의 호출 목록을 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">결합할 대리자의 배열입니다.</param>
        <summary>대리자 배열의 호출 목록을 연결합니다.</summary>
        <returns>
          <paramref name="delegates" /> 배열의 대리자 호출 목록을 연결하는 호출 목록이 있는 새 대리자입니다. <paramref name="delegates" />가 <see langword="null" />이거나 <paramref name="delegates" />에 요소가 없거나 <paramref name="delegates" />의 모든 항목이 <see langword="null" />인 경우 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `delegates` 배열에 있는 항목 `null`, 이러한 항목은 무시 됩니다.  
  
 호출 목록에 중복 된 항목이; 포함 될 수 있습니다. 즉, 같은 개체에 대해 동일한 메서드를 참조 하는 항목입니다.  
  
> [!NOTE]
>  할당 호환 되는 제네릭 대리자 차이 때문에 없는 함께 사용할 수 있는 것은 아닙니다. 결합할 수 있으려면 형식이 정확히 일치 해야 합니다. 예를 들어 라는 클래스 `Derived` 라는 클래스에서 파생 된 `Base`합니다. 형식의 대리자 `Action<Base>` (`Action(Of Base)` Visual basic에서) 형식의 변수에 할당할 수 있습니다 `Action<Derived>`에 설명 되어 있듯이 [공 분산과 반공 분산](~/docs/standard/generics/covariance-and-contravariance.md), 하지만 두 대리자 형식이 않기 때문에 함께 사용할 수 없습니다 정확히 일치 하지 않습니다.  
  
 <xref:System.Delegate.Combine%2A> 때마다 이벤트를 다중 메서드 호출이 발생 하는 이벤트 처리기를 만드는 데 유용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegates" />의 null이 아닌 모든 항목이 동일한 대리자 형식의 인스턴스인 것은 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">해당 호출 목록이 처음에 나오는 대리자입니다.</param>
        <param name="b">해당 호출 목록이 마지막에 나오는 대리자입니다.</param>
        <summary>두 대리자의 호출 목록을 연결합니다.</summary>
        <returns>호출 목록 <paramref name="a" />와 <paramref name="b" />를 순서대로 연결하는 호출 목록을 가진 새 대리자입니다. <paramref name="b" />가 <see langword="null" />이면 <paramref name="a" />를 반환하고, <paramref name="a" />가 null 참조이면 <paramref name="b" />를 반환하며, <paramref name="a" />와 <paramref name="b" />가 모두 null 참조이면 null 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 목록에 중복 된 항목이; 포함 될 수 있습니다. 즉, 같은 개체에 대해 동일한 메서드를 참조 하는 항목입니다.  
  
> [!NOTE]
>  할당 호환 되는 제네릭 대리자 차이 때문에 없는 함께 사용할 수 있는 것은 아닙니다. 결합할 수 있으려면 형식이 정확히 일치 해야 합니다. 예를 들어 라는 클래스 `Derived` 라는 클래스에서 파생 된 `Base`합니다. 형식의 대리자 `Action<Base>` (`Action(Of Base)` Visual basic에서) 형식의 변수에 할당할 수 있습니다 `Action<Derived>`에 설명 되어 있듯이 [공 분산과 반공 분산](~/docs/standard/generics/covariance-and-contravariance.md), 하지만 두 대리자 형식이 않기 때문에 함께 사용할 수 없습니다 정확히 일치 하지 않습니다.  
  
 <xref:System.Delegate.Combine%2A> 때마다 이벤트를 다중 메서드 호출이 발생 하는 이벤트 처리기를 만드는 데 유용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="a" /> 및 <paramref name="b" /> 모두 <see langword="null" />이 아니며, <paramref name="a" /> 및 <paramref name="b" />가 동일한 대리자 형식의 인스턴스가 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록의 끝에 덧붙일 호출 목록을 가진 결합할 수 있는 멀티캐스트 대리자입니다.</param>
        <summary>지정된 결합할 수 있는 멀티캐스트 대리자와 현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록을 연결합니다.</summary>
        <returns>현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록과 <paramref name="d" />의 호출 목록을 연결하는 호출 목록을 가진 새로운 결합할 수 있는 멀티캐스트 대리자이거나, <paramref name="d" />가 <see langword="null" />인 경우 현재 결합할 수 있는 멀티캐스트 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 대리자가 멀티 캐스트 하는 경우에 적용 됩니다. 결합할 수 있습니다.  
  
 현재 구현에서는 단순히 throw 한 <xref:System.MulticastNotSupportedException>합니다.  
  
 호출 목록에 중복 된 항목이; 포함 될 수 있습니다. 즉, 같은 개체에 대해 동일한 메서드를 참조 하는 항목입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">항상 throw됩니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식의 대리자를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다. .NET Framework 버전 1.0 및 1.1에서는 정적 메서드만 지원됩니다.</param>
        <summary>지정된 정적 메서드를 나타내기 위해서 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 정적 메서드를 나타내기 위한 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 버전 1.0 및 1.1에서는이 메서드 오버 로드만 정적 메서드에 대 한 대리자를 만듭니다. .NET framework 버전 2.0의 경우이 메서드 오버 로드도 만들 수 열려 있는 인스턴스 메서드 대리자; 즉, 명시적으로 숨겨진된 첫 번째 인수를 제공 하는 대리자 인스턴스 메서드. 대 한 자세한 내용은 참조는 보다 일반적인 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드를 위한 인스턴스 또는 정적 메서드를 대리자에 개방형 또는 폐쇄형의 모든 조합을 만들 하 고 필요에 따라 첫 번째 인수를 지정할 수 있습니다.  
  
> [!NOTE]
>  이 메서드 오버 로드 때 사용할지 대리자의 첫 번째 인수에 대해 닫혀 있지 않으면 이므로 좀 더 빠른 경우.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드를 지정 하 고 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 가능한 매개 변수 형식 및 반환 형식  
 .NET Framework 버전 2.0에서에서 매개 변수 형식 및이 메서드 오버 로드를 사용 하 여 만든 대리자의 반환 형식 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식이 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다. .NET framework 버전 1.0 및 1.1에서는 형식이 정확히 일치 해야 바인딩 동작을 완화를 나타냅니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 사용 하 여 대리자 형식의 매개 변수 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 첫 번째 예제에서는이 메서드 오버 로드를 만들 수 있는 대리자의 두 종류: 인스턴스 메서드를 통해 열고 정적 메서드에 대해 엽니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.  
  
 **예 1**  
  
 다음 코드 예제에서는이 오버 로드를 사용 하 여 대리자를 만들 수는 두 가지 방법을 보여 줍니다는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 개의 오버 로드가 <xref:System.Delegate.CreateDelegate%2A> 지정 하는 메서드는 <xref:System.Reflection.MethodInfo> 첫 번째 인수가 아닌; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 이 예제에서는 클래스를 선언 `C` 정적 메서드가 있는 `M2` 및 인스턴스 메서드 `M1`, 두 대리자 형식이: `D1` 의 인스턴스를 사용 `C` 및 문자열, 및 `D2` 문자열을 사용 합니다.  
  
 라는 두 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D1`를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 `M1`합니다. 대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 `M2`합니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.  
  
 기본 클래스를 정의 하는 코드 예제에서는 `Base` 라는 클래스 및 `Derived` 에서 파생 된 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수가 둘 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자 라는 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 대리자에 메서드를 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`)의 매개 변수 형식 보다 제한적인 `MyMethod` (`Base`)는 항상 안전 하 게 대리자의 인수를 전달, `MyMethod`합니다.  
  
-   반환 형식을 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 제한적인 (`Base`), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.  
  
 코드 예제에서는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="method" />가 정적 메서드가 아니고 .NET Framework 버전이 1.0 또는 1.1인 경우  
  
 또는  
  
 <paramref name="method" />를 바인딩할 수 없습니다.  
  
 또는  
  
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="firstArgument">대리자가 바인드되는 개체이거나, <c>메서드</c>를 <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)으로 처리하는 경우 <see langword="null" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>지정한 첫 번째 인수를 사용하여 지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 정적 또는 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 호출 하는 것은 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드를 지정 하 고 `true` 에 대 한 `throwOnBindFailure`합니다. 이러한 두 오버 로드에는 대리자를 만드는 가장 유연한 방법을 제공 합니다. 인스턴스 메서드 또는 정적 대 한 대리자를 만들고 필요에 따라 첫 번째 인수를 지정 하려면 사용할 수 있습니다.  
  
> [!NOTE]
>  첫 번째 인수를 제공 하지 않을 경우 사용 하 여는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 성능 향상을 위해 메서드 오버 로드 합니다.  
  
 대리자 형식 및 메서드의 호환 반환 형식이 있어야 합니다. 반환 형식, 즉 `method` 의 반환 형식에 할당할 수 있어야 `type`합니다.  
  
 경우 `firstArgument` 는에 전달 된 제공 `method` 될 때마다 대리자가 호출 됩니다. `firstArgument` 대리자를 바인딩할 수를 라고 대리자는 첫 번째 인수에 대해 닫혀 있는 것으로 간주 합니다. 경우 `method` 은 `static` (`Shared` Visual basic에서)에서는 대리자를 호출할 때 제공 된 목록이 경우 첫 번째; 제외한 모든 매개 변수를 포함 하는 인수 `method` 는 인스턴스 메서드이므로 다음 `firstArgument` 숨겨진된 인스턴스에 전달 됩니다 매개 변수 (나타내는 `this` C# 또는 `Me` Visual basic에서).  
  
 경우 `firstArgument` 제공 되의 첫 번째 매개 변수 `method` 참조 형식 이어야 하 고 `firstArgument` 해당 형식과 호환 되어야 합니다.  
  
> [!IMPORTANT]
>  경우 `method` 은 `static` (`Shared` Visual basic에서)의 첫 번째 매개 변수는 형식 및 <xref:System.Object> 또는 <xref:System.ValueType>, 다음 `firstArgument` 값 형식일 수 있습니다. 이 경우 `firstArgument` 자동으로 boxed 형식이 있습니다. 가 C# 또는 Visual Basic 함수에서 호출 됩니다. 대로 다른 모든 인수에 대 한 자동 boxing 발생 하지 않습니다.  
  
 경우 `firstArgument` 가 null 참조 및 `method` 는 인스턴스 메서드이므로 결과 서명이 대리자 형식에 따라 달라 집니다 `type` 및의 `method`:  
  
-   하는 경우의 서명을 `type` 의 숨겨진된 첫 번째 매개 변수를 명시적으로 포함 `method`, 열려 있는 인스턴스 메서드를 나타내는 대리자는 간주 합니다. 인수 목록에 첫 번째 인수의 숨겨진된 인스턴스 매개 변수에 전달 되는 대리자를 호출 하는 경우 `method`합니다.  
  
-   하는 경우의 서명을 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다. 대리자를 호출 하 여 인스턴스 메서드는 특히 유용한 작업이 되지 않는 null 인스턴스에서 호출 방법과 비슷합니다.  
  
 경우 `firstArgument` 가 null 참조 및 `method` 은 정적, 결과에 따라 달라 집니다의 대리자 형식 시그니처 `type` 및의 `method`:  
  
-   경우의 서명을 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 열려 있는 정적 메서드를 나타내기 위해 간주 합니다. 이것이 정적 메서드에 대 한 가장 일반적인 경우입니다. 사용 하 여 약간 더 나은 성능을 얻을 수는 경우에 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다.  
  
-   하는 경우의 서명을 `type` 의 두 번째 매개 변수로 시작 `method` 힙이고 다른 매개 변수 형식은 호환 되는 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다. 첫 번째 매개 변수는 null 참조가 전달 되는 대리자를 호출 하는 경우 `method`합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 가능한 매개 변수 형식 및 반환 형식  
 매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식을와 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서는 형식이 정확히 일치 해야 합니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 사용 하 여 대리자 형식의 매개 변수 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>메서드를 결정 하는 대리자 나타낼 수 있습니다.  
 이 오버 로드에서 제공 하는 유연성 생각 하는 다른 유용한 방법은 <xref:System.Delegate.CreateDelegate%2A> 지정된 된 대리자 메서드 서명 및 메서드 종류 (정적 인스턴스)의 4 가지 다른 조합을 나타낼 수 있다는 것입니다. 대리자 형식 고려 `D` 형식의 인수를 하나 이상 사용 `C`합니다. 다음 메서드를 설명 `D` 모든 경우에에서 일치 해야 하므로 반환 형식을 무시 하 고 나타낼 수 있습니다.  
  
-   `D` 형식 인수가 하나만 있는 인스턴스 메서드를 나타낼 수 `C`인스턴스 메서드가 속한 종류에 관계 없이 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 되 `firstArgument` 형식의 인스턴스인 `method` 속한 결과로 생성 된 대리자는 해당 인스턴스에 대해 닫혀 있는 것으로 간주 합니다. (다르거나 일반적으로, `D` 경우 null 참조에 대해 닫을 수도 있습니다 `firstArgument` 가 null 참조입니다.)  
  
-   `D` 인스턴스 메서드를 나타낼 수 `C` 는 인수가 없는 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 `firstArgument` 가 null 참조입니다. 결과로 생성 된 대리자는 열려 있는 인스턴스 메서드를 나타내며의 인스턴스 `C` 를 호출할 때마다 제공 해야 합니다.  
  
-   `D` 형식의 인수 하나를 사용 하는 정적 메서드를 나타낼 수 `C`, 메서드가 모든 형식에 속할 수 있습니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 `firstArgument` 가 null 참조입니다. 열려 있는 정적 메서드 및 인스턴스의 결과 대리자가 나타내는 `C` 를 호출할 때마다 제공 해야 합니다.  
  
-   `D` 입력에 속하는 정적 메서드를 나타낼 수 `F` 형식의 인수가 두 개 및 `F` 유형과 `C`합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 `firstArgument` 의 인스턴스가 `F`합니다. 결과로 생성 된 대리자의 해당 인스턴스에 대해 닫혀 하는 정적 메서드를 나타내는 `F`합니다. 경우에서에 유의 여기서 `F` 및 `C` 같은 종류, 정적 메서드는 해당 형식의 두 인수입니다. (이 경우 `D` 경우 null 참조에 대해 닫혀 `firstArgument` 가 null 참조입니다.)  
  
   
  
## Examples  
 이 섹션에는 세 가지 코드 예제가 있습니다. 첫 번째 예제에서는 만들 수 있는 대리자의 네 가지 종류: 정적 메서드를 통해 열린 인스턴스 메서드를 통해 열린 인스턴스 메서드를 통해 닫히고 정적 메서드에 대해 닫혀 있습니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.  
  
 세 번째 코드 예제는 단일 대리자 형식을 정의 하 고 대리자 형식의 모든 메서드에 나타낼 수를 보여 줍니다.  
  
 **예 1**  
  
 다음 코드 예제에는이 오버 로드를 사용 하 여 대리자를 만들 수 4 가지 방법을 보여 줍니다.는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 개의 오버 로드가 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 이 예제에서는 클래스를 선언 `C` 정적 메서드가 있는 `M2` 및 인스턴스 메서드 `M1`, 대리자 형식이 세: `D1` 의 인스턴스를 사용 `C` 및 문자열을 `D2` 에서는 문자열 및 `D3`인수가 없는 합니다.  
  
 라는 두 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D2`의 인스턴스에 대해 닫힘 `C`, 인스턴스 메서드에 대해 만든 `M1`합니다. 바인딩된 인스턴스를 보여 주는을 다른 문자열과 대리자는 `C` 항상 사용 됩니다.  
  
-   형식의 대리자 `D1`를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 `M1`합니다. 대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 `M2`합니다.  
  
-   형식의 대리자 마지막으로, `D3`, 문자열에 대해 닫혀, 정적 메서드에 대해 만든 `M2`합니다. 메서드는 바인딩된 문자열을 사용 한다는 것을 나타내기 위해 호출 됩니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.  
  
> [!NOTE]
>  사용 하 여이 코드 예제는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다. 다른 사용 오버 <xref:System.Reflection.MethodInfo> 비슷합니다.  
  
 기본 클래스를 정의 하는 코드 예제에서는 `Base` 라는 클래스 및 `Derived` 에서 파생 된 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수가 둘 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자 라는 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 대리자에 메서드를 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`)의 매개 변수 형식 보다 제한적인 `MyMethod` (`Base`)는 항상 안전 하 게 대리자의 인수를 전달, `MyMethod`합니다.  
  
-   반환 형식을 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 제한적인 (`Base`), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.  
  
 코드 예제에서는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **예제 3**  
  
 다음 코드 예제에서는 모든 메서드를 사용 하는 단일 대리자 형식을 나타낼 수는 <xref:System.Delegate.CreateDelegate%2A> 메서드는 대리자를 만들 수 있습니다.  
  
> [!NOTE]
>  두 개의 오버 로드가 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 코드 예제에서는 두 개의 클래스를 정의 `C` 및 `F`, 및 대리자 형식은 `D` 형식의 인수를 하나 이상 사용 `C`합니다. 클래스는 동일한 정적 메서드와 인스턴스 메서드 `M1`, `M3`, 및 `M4`, 클래스 및 `C` 인스턴스 메서드도 `M2` 는 인수가 없는 합니다.  
  
 이라는 세 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   대리자는 메서드를 만드는 예를 들어 `M1` 형식의 `C` 유형과 `F`; 각는 각 형식의 인스턴스에 대해 닫혀 있습니다. 메서드 `M1` 형식의 `C` 표시는 `ID` 바인딩된 인스턴스 속성 및 인수입니다.  
  
-   메서드에 대 한 대리자는 `M2` 형식의 `C`합니다. 이 열려 있는 인스턴스 대리자를 대리자의 인수에는 인스턴스 메서드 숨겨진된 첫 번째 인수를 나타냅니다. 메서드는 다른 인수가 없습니다. 마치는 정적 메서드 호출 됩니다.  
  
-   대리자가 정적 메서드에 대해 `M3` 형식의 `C` 유형과 `F`; 이러한 대리자는 정적 대리자입니다.  
  
-   마지막으로 대리자는 정적 메서드에 대해 생성 됩니다 `M4` 형식의 `C` 유형과 `F`각 메서드에 첫 번째 인수로 선언 형식이 고 형식의 인스턴스 제공 되므로를 해당 인수에 대해 대리자 닫혔는지 . 메서드 `M4` 형식의 `C` 표시는 `ID` 바인딩된 인스턴스 속성 및 인수입니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="method" />를 바인딩할 수 없습니다.  
  
 또는  
  
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <c>메서드</c>가 호출되는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <summary>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 대리자 예를 들어만 메서드를 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 수를 지정 하 `false` 에 대 한 `ignoreCase` 및 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="method" />는 인스턴스 메서드가 아닙니다.  
  
 또는  
  
 예를 들어 <paramref name="method" />는 찾을 수 없기 때문에 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="throwOnBindFailure">
          <c>메서드</c>를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>바인딩 실패 시 지정한 동작을 기반으로 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 정적 메서드를 나타내기 위한 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드 열려 있는 정적 메서드 대리자를 만들 수 있습니다 및 인스턴스 메서드가 대리자를 열고-즉, 대리자의 숨겨진된 첫 번째 인수를 노출 하는 인스턴스 메서드. 대 한 자세한 내용은 참조는 보다 일반적인 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 정적 메서드 또는 메서드 오버 로드를 예를 들어 모든 조합의 개방형 또는 폐쇄형 대리자를 만들 수 있습니다.  
  
> [!NOTE]
>  이 메서드 오버 로드 때 사용할지 대리자의 첫 번째 인수에 대해 닫혀 있지 않으면 이므로 좀 더 빠른 경우.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 가능한 매개 변수 형식 및 반환 형식  
 매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식을와 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서는 형식이 정확히 일치 해야 합니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 사용 하 여 대리자 형식의 매개 변수 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
   
  
## Examples  
 이 섹션에는 두 가지 코드 예제가 포함 되어 있습니다. 첫 번째 예제에서는이 메서드 오버 로드를 만들 수 있는 대리자의 두 종류: 인스턴스 메서드를 통해 열고 정적 메서드에 대해 엽니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.  
  
 **예 1**  
  
 다음 코드 예제에서는이 오버 로드를 사용 하 여 대리자를 만들 수는 두 가지 방법을 보여 줍니다는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 개의 오버 로드가 <xref:System.Delegate.CreateDelegate%2A> 지정 하는 메서드는 <xref:System.Reflection.MethodInfo> 첫 번째 인수가 아닌; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 이 예제에서는 클래스를 선언 `C` 정적 메서드가 있는 `M2` 및 인스턴스 메서드 `M1`, 두 대리자 형식이: `D1` 의 인스턴스를 사용 `C` 및 문자열, 및 `D2` 문자열을 사용 합니다.  
  
 라는 두 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D1`를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 `M1`합니다. 대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 `M2`합니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.  
  
> [!NOTE]
>  사용 하 여이 코드 예제는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다. 다른 사용 오버 <xref:System.Reflection.MethodInfo> 비슷합니다.  
  
 기본 클래스를 정의 하는 코드 예제에서는 `Base` 라는 클래스 및 `Derived` 에서 파생 된 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수가 둘 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자 라는 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 대리자에 메서드를 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`)의 매개 변수 형식 보다 제한적인 `MyMethod` (`Base`)는 항상 안전 하 게 대리자의 인수를 전달, `MyMethod`합니다.  
  
-   반환 형식을 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 제한적인 (`Base`), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.  
  
 코드 예제에서는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="method" />를 바인딩할 수 없으므로 <paramref name="throwOnBindFailure" />가 <see langword="true" />입니다.  
  
 또는  
  
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <c>메서드</c>를 구현하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <summary>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 정적 메서드만 대 한 대리자를 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 수를 지정 하 `false` 에 대 한 `ignoreCase` 및 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우  
  
 또는  
  
 <paramref name="target" />이 개방형 제네릭 형식인 경우. 즉, 해당 <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 <see langword="true" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="static" /> 메서드(Visual Basic의 경우 <see langword="Shared" /> 메서드)가 아닌 경우  
  
 또는  
  
 예를 들어 찾을 수 없고 <paramref name="throwOnBindFailure" />가 <see langword="true" />이기 때문에 <paramref name="method" />를 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 디자이너 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="firstArgument">대리자가 나타내는 메서드의 첫 번째 인수인 <see cref="T:System.Object" />입니다. 인스턴스 메서드의 경우 인스턴스 형식과 호환되어야 합니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="throwOnBindFailure">
          <c>메서드</c>를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>지정한 첫 번째 인수와 바인딩 실패 시 지정한 동작을 기반으로 지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자이거나, <paramref name="throwOnBindFailure" />가 <see langword="false" />이고 대리자를 <paramref name="method" />에 바인딩할 수 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드와 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드를 항상 바인딩 실패 시 throw, 대리자를 만들 수 있는 가장 유연한 방법을 제공 합니다. 만들 대리자에 대 한 정적 또는 인스턴스 메서드로 첫 번째 인수를 사용할 수 있습니다.  
  
> [!NOTE]
>  첫 번째 인수를 제공 하지 않을 경우 사용 하 여는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 성능 향상을 위해 메서드 오버 로드 합니다.  
  
 대리자 형식 및 메서드의 호환 반환 형식이 있어야 합니다. 반환 형식, 즉 `method` 의 반환 형식에 할당할 수 있어야 `type`합니다.  
  
 경우 `firstArgument` 는에 전달 된 제공 `method` 될 때마다 대리자가 호출 됩니다. `firstArgument` 대리자를 바인딩할 수를 라고 대리자는 첫 번째 인수에 대해 닫혀 있는 것으로 간주 합니다. 경우 `method` 은 `static` (`Shared` Visual basic에서)에서는 대리자를 호출할 때 제공 된 목록이 경우 첫 번째; 제외한 모든 매개 변수를 포함 하는 인수 `method` 는 인스턴스 메서드이므로 다음 `firstArgument` 숨겨진된 인스턴스에 전달 됩니다 매개 변수 (나타내는 `this` C# 또는 `Me` Visual basic에서).  
  
 경우 `firstArgument` 제공 되의 첫 번째 매개 변수 `method` 참조 형식 이어야 하 고 `firstArgument` 해당 형식과 호환 되어야 합니다.  
  
> [!IMPORTANT]
>  경우 `method` 은 `static` (`Shared` Visual basic에서)의 첫 번째 매개 변수는 형식 및 <xref:System.Object> 또는 <xref:System.ValueType>, 다음 `firstArgument` 값 형식일 수 있습니다. 이 경우 `firstArgument` 자동으로 boxed 형식이 있습니다. 가 C# 또는 Visual Basic 함수에서 호출 됩니다. 대로 다른 모든 인수에 대 한 자동 boxing 발생 하지 않습니다.  
  
 경우 `firstArgument` 가 null 참조 및 `method` 는 인스턴스 메서드이므로 결과 서명이 대리자 형식에 따라 달라 집니다 `type` 및의 `method`:  
  
-   하는 경우의 서명을 `type` 의 숨겨진된 첫 번째 매개 변수를 명시적으로 포함 `method`, 열려 있는 인스턴스 메서드를 나타내는 대리자는 간주 합니다. 인수 목록에 첫 번째 인수의 숨겨진된 인스턴스 매개 변수에 전달 되는 대리자를 호출 하는 경우 `method`합니다.  
  
-   하는 경우의 서명을 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다. 대리자를 호출 하 여 인스턴스 메서드는 특히 유용한 작업이 되지 않는 null 인스턴스에서 호출 방법과 비슷합니다.  
  
 경우 `firstArgument` 가 null 참조 및 `method` 은 정적, 결과에 따라 달라 집니다의 대리자 형식 시그니처 `type` 및의 `method`:  
  
-   경우의 서명을 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 열려 있는 정적 메서드를 나타내기 위해 간주 합니다. 이것이 정적 메서드에 대 한 가장 일반적인 경우입니다. 사용 하 여 약간 더 나은 성능을 얻을 수는 경우에 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
-   하는 경우의 서명을 `type` 의 두 번째 매개 변수로 시작 `method` 힙이고 다른 매개 변수 형식은 호환 되는 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다. 첫 번째 매개 변수는 null 참조가 전달 되는 대리자를 호출 하는 경우 `method`합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 가능한 매개 변수 형식 및 반환 형식  
 매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식을와 호환 되어야 합니다. 형식이 정확 하 게 일치 필요가 없습니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서에서 형식이 정확히 일치 해야 합니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 사용 하 여 대리자 형식의 매개 변수 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>메서드를 결정 하는 대리자 나타낼 수 있습니다.  
 이 오버 로드에서 제공 하는 유연성 생각 하는 다른 유용한 방법은 <xref:System.Delegate.CreateDelegate%2A> 지정된 된 대리자 메서드 서명 및 메서드 종류 (정적 인스턴스)의 4 가지 다른 조합을 나타낼 수 있다는 것입니다. 대리자 형식 고려 `D` 형식의 인수를 하나 이상 사용 `C`합니다. 다음 메서드를 설명 `D` 모든 경우에에서 일치 해야 하므로 반환 형식을 무시 하 고 나타낼 수 있습니다.  
  
-   `D` 형식 인수가 하나만 있는 인스턴스 메서드를 나타낼 수 `C`인스턴스 메서드가 속한 종류에 관계 없이 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 되 `firstArgument` 형식의 인스턴스인 `method` 속한 결과로 생성 된 대리자는 해당 인스턴스에 대해 닫혀 있는 것으로 간주 합니다. (다르거나 일반적으로, `D` 경우 null 참조에 대해 닫을 수도 있습니다 `firstArgument` 은 `null`.)  
  
-   `D` 인스턴스 메서드를 나타낼 수 `C` 는 인수가 없는 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 `firstArgument` 가 null 참조입니다. 결과로 생성 된 대리자는 열려 있는 인스턴스 메서드를 나타내며의 인스턴스 `C` 를 호출할 때마다 제공 해야 합니다.  
  
-   `D` 형식의 인수 하나를 사용 하는 정적 메서드를 나타낼 수 `C`, 메서드가 모든 형식에 속할 수 있습니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 `firstArgument` 가 null 참조입니다. 열려 있는 정적 메서드 및 인스턴스의 결과 대리자가 나타내는 `C` 를 호출할 때마다 제공 해야 합니다.  
  
-   `D` 입력에 속하는 정적 메서드를 나타낼 수 `F` 형식의 인수가 두 개 및 `F` 유형과 `C`합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 호출 `firstArgument` 의 인스턴스가 `F`합니다. 결과로 생성 된 대리자의 해당 인스턴스에 대해 닫혀 하는 정적 메서드를 나타내는 `F`합니다. 경우에서에 유의 여기서 `F` 및 `C` 같은 종류, 정적 메서드는 해당 형식의 두 인수입니다. (이 경우 `D` 경우 null 참조에 대해 닫혀 `firstArgument` 은 `null`.)  
  
   
  
## Examples  
 이 섹션에는 세 가지 코드 예제가 있습니다. 첫 번째 예제에서는 만들 수 있는 대리자의 네 가지 종류: 정적 메서드를 통해 열린 인스턴스 메서드를 통해 열린 인스턴스 메서드를 통해 닫히고 정적 메서드에 대해 닫혀 있습니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 주고 형식을 반환 합니다.  
  
 세 번째 코드 예제는 단일 대리자 형식을 정의 하 고 대리자 형식의 모든 메서드에 나타낼 수를 보여 줍니다.  
  
 **예 1**  
  
 다음 코드 예제에는이 오버 로드를 사용 하 여 대리자를 만들 수 4 가지 방법을 보여 줍니다.는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 개의 오버 로드가 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 이 예제에서는 클래스를 선언 `C` 정적 메서드가 있는 `M2` 및 인스턴스 메서드 `M1`, 대리자 형식이 세: `D1` 의 인스턴스를 사용 `C` 및 문자열을 `D2` 에서는 문자열 및 `D3`인수가 없는 합니다.  
  
 라는 두 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D2`의 인스턴스에 대해 닫힘 `C`, 인스턴스 메서드에 대해 만든 `M1`합니다. 바인딩된 인스턴스를 보여 주는을 다른 문자열과 대리자는 `C` 항상 사용 됩니다.  
  
-   형식의 대리자 `D1`를 열려 있는 인스턴스 메서드를 나타내는 인스턴스 메서드의 만들어집니다 `M1`합니다. 대리자를 호출 하는 경우 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`, 열려 있는 정적 메서드를 나타내는, 정적 메서드에 대해 만든 `M2`합니다.  
  
-   형식의 대리자 마지막으로, `D3`, 문자열에 대해 닫혀, 정적 메서드에 대해 만든 `M2`합니다. 메서드는 바인딩된 문자열을 사용 한다는 것을 나타내기 위해 호출 됩니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식의 호환성을 보여 주고 형식을 반환 합니다.  
  
> [!NOTE]
>  사용 하 여이 코드 예제는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다. 다른 사용 오버 <xref:System.Reflection.MethodInfo> 비슷합니다.  
  
 기본 클래스를 정의 하는 코드 예제에서는 `Base` 라는 클래스 및 `Derived` 에서 파생 된 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수가 둘 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자 라는 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 대리자에 메서드를 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`)의 매개 변수 형식 보다 제한적인 `MyMethod` (`Base`)는 항상 안전 하 게 대리자의 인수를 전달, `MyMethod`합니다.  
  
-   반환 형식을 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 제한적인 (`Base`), 대리자의 반환 형식으로 메서드의 반환 형식을 캐스팅 해도 안전할 항상 되도록 합니다.  
  
 코드 예제에서는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **예제 3**  
  
 다음 코드 예제에서는 모든 메서드는 단일 대리자 형식이 나타낼 수를 보여 줍니다.  
  
> [!NOTE]
>  두 개의 오버 로드가 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 메서드에 바인딩 실패 시 throw 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 코드 예제에서는 두 개의 클래스를 정의 `C` 및 `F`, 및 대리자 형식은 `D` 형식의 인수를 하나 이상 사용 `C`합니다. 클래스는 동일한 정적 메서드와 인스턴스 메서드 `M1`, `M3`, 및 `M4`, 클래스 및 `C` 인스턴스 메서드도 `M2` 는 인수가 없는 합니다.  
  
 이라는 세 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   대리자는 메서드를 만드는 예를 들어 `M1` 형식의 `C` 유형과 `F`; 각는 각 형식의 인스턴스에 대해 닫혀 있습니다. 메서드 `M1` 형식의 `C` 표시는 `ID` 바인딩된 인스턴스 속성 및 인수입니다.  
  
-   메서드에 대 한 대리자는 `M2` 형식의 `C`합니다. 이 열려 있는 인스턴스 대리자를 대리자의 인수에는 인스턴스 메서드 숨겨진된 첫 번째 인수를 나타냅니다. 메서드는 다른 인수가 없습니다.  
  
-   대리자가 정적 메서드에 대해 `M3` 형식의 `C` 유형과 `F`; 이러한 대리자는 정적 대리자입니다.  
  
-   마지막으로 대리자는 정적 메서드에 대해 생성 됩니다 `M4` 형식의 `C` 유형과 `F`각 메서드에 첫 번째 인수로 선언 형식이 고 형식의 인스턴스 제공 되므로를 해당 인수에 대해 대리자 닫혔는지 . 메서드 `M4` 형식의 `C` 표시는 `ID` 바인딩된 인스턴스 속성 및 인수입니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="method" />를 바인딩할 수 없으므로 <paramref name="throwOnBindFailure" />가 <see langword="true" />입니다.  
  
 또는  
  
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <c>메서드</c>가 호출되는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <summary>지정된 대/소문자 구분 여부를 기반으로 지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 대리자 예를 들어만 메서드를 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 수를 지정 하 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="method" />는 인스턴스 메서드가 아닙니다.  
  
 또는  
  
 예를 들어 <paramref name="method" />는 찾을 수 없기 때문에 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <c>메서드</c>를 구현하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <summary>지정한 대/소문자 구분 여부를 기반으로 지정한 클래스의 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 정적 메서드만 대 한 대리자를 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
 이 메서드 오버 로드 하는 것은 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 수를 지정 하 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우  
  
 또는  
  
 <paramref name="target" />이 개방형 제네릭 형식인 경우. 즉, 해당 <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 <see langword="true" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="static" /> 메서드(Visual Basic의 경우 <see langword="Shared" /> 메서드)가 아닌 경우  
  
 또는  
  
 예를 들어 <paramref name="method" />는 찾을 수 없기 때문에 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <c>메서드</c>가 호출되는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <param name="throwOnBindFailure">
          <c>메서드</c>를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>지정한 대/소문자 구분과 바인딩 실패 시 지정한 동작을 기반으로 지정한 클래스 인스턴스에서 호출하는 지정한 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 대리자 예를 들어만 메서드를 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="method" />는 인스턴스 메서드가 아닙니다.  
  
 또는  
  
 예를 들어 찾을 수 없고 <paramref name="throwOnBindFailure" />가 <see langword="true" />이기 때문에 <paramref name="method" />를 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <c>메서드</c>를 구현하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <param name="throwOnBindFailure">
          <c>메서드</c>를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>지정한 대/소문자 구분과 바인딩 실패 시 지정한 동작을 기반으로 지정한 클래스의 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 정적 메서드만 대 한 대리자를 만듭니다. 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 지정 및 public이 아닌 메서드의 권한 부여 집합은 호출자에 게 제한 하는 경우 집합 또는 하위 집합을 부여 해당 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="target" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
 또는  
  
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
 또는  
  
 <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우  
  
 또는  
  
 <paramref name="target" />이 개방형 제네릭 형식인 경우. 즉, 해당 <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 <see langword="true" />인 경우  
  
 또는  
  
 <paramref name="method" />가 <see langword="static" /> 메서드(Visual Basic의 경우 <see langword="Shared" /> 메서드)가 아닌 경우  
  
 또는  
  
 예를 들어 찾을 수 없고 <paramref name="throwOnBindFailure" />가 <see langword="true" />이기 때문에 <paramref name="method" />를 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">현재 대리자가 나타내는 메서드로 전달할 인수인 개체의 배열입니다.  
  
 또는  
  
 현재 대리자가 나타내는 메서드에 인수가 필요하지 않으면 <see langword="null" />입니다.</param>
        <summary>현재 대리자가 나타내는 메서드를 동적으로 호출(런타임에 바인딩)합니다.</summary>
        <returns>대리자가 나타내는 메서드에서 반환되는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Delegate.DynamicInvokeImpl%2A> 메서드를 호출합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)  
  
 또는  
  
 <paramref name="args" />에 열거된 매개 변수의 개수, 순서, 형식이 유효하지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">대리자가 나타내는 메서드가 해당 메서드를 지원하지 않는 개체 또는 클래스에서 호출되는 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">대리자가 나타내는 메서드가 인스턴스 메서드이고 대상 개체가 <see langword="null" />인 경우  
  
 또는  
  
 캡슐화된 메서드 중 하나에서 예외를 throw하는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">현재 대리자가 나타내는 메서드로 전달할 인수인 개체의 배열입니다.  
  
 또는  
  
 현재 대리자가 나타내는 메서드에 인수가 필요하지 않으면 <see langword="null" />입니다.</param>
        <summary>현재 대리자가 나타내는 메서드를 동적으로 호출(런타임에 바인딩)합니다.</summary>
        <returns>대리자가 나타내는 메서드에서 반환되는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Delegate.DynamicInvoke%2A> 메서드를 구현합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)  
  
 또는  
  
 <paramref name="args" />에 열거된 매개 변수의 개수, 순서, 형식이 유효하지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">대리자가 나타내는 메서드가 해당 메서드를 지원하지 않는 개체 또는 클래스에서 호출되는 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">대리자가 나타내는 메서드가 인스턴스 메서드이고 대상 개체가 <see langword="null" />인 경우  
  
 또는  
  
 캡슐화된 메서드 중 하나에서 예외를 throw하는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">현재 대리자와 비교할 개체입니다.</param>
        <summary>지정한 개체와 현재 대리자가 같은 형식이고 같은 대상, 메서드 및 호출 목록을 공유하는지를 확인합니다.</summary>
        <returns>
          <paramref name="obj" />와 현재 대리자가 같은 대상, 메서드 및 호출 목록을 가지면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 대리자 형식이 아닌 경우 같은 간주 되지는 않습니다.  
  
> [!IMPORTANT]
>  .NET framework 버전 1.0 및 1.1에서는 두 명의 대리자가 서로 다른 형식의 해당 대상, 메서드 및 호출 목록 같으면 고려 되었습니다.  
  
 메서드와 대상이 다음과 같이 같은지 비교 됩니다.  
  
-   비교 되는 두 개의 메서드가 둘 다 정적 동일한 클래스에 있는 같은 메서드를 메서드 같은 개체로 간주 되는지 및 대상도 같다고 간주 됩니다.  
  
-   비교할 두 개의 메서드는 인스턴스 메서드, 동일한 개체에 대해 동일한 메서드 메서드 같은 개체로 간주 되는지 고 대상을 같다고 간주 됩니다.  
  
-   그렇지 않으면 메서드 동일한 것으로 간주 되지 않습니다 하 고 대상 동일한 것으로 간주 되지도 않습니다.  
  
 같은 순서를가지고 있고 두 목록에서 해당 요소를 같은 메서드와 대상을 나타냅니다 경우에 두 호출 목록은 동일한 것으로 간주 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>대리자의 해시 코드를 반환합니다.</summary>
        <returns>대리자의 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 반환 값 지속 되지 않아야 하는 두 가지 이유입니다. 첫째, 오래 된 해시 함수에서 값 쓸모 향상 된 분포를 생성 하는 클래스의 해시 함수를 변경 될 수 있습니다. 둘째,이 클래스의 기본 구현은 동일한 값이 서로 다른 인스턴스에서 반환 될을 보장 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>대리자의 호출 목록을 반환합니다.</summary>
        <returns>현재 대리자의 호출 목록을 나타내는 대리자의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열의 각 대리자는 정확히 하나의 메서드를 나타냅니다.  
  
 배열의 대리자의 순서가 현재 대리자가 해당 대리자가 나타내는 메서드를 호출 하는 순서와 동일 합니다.  
  
   
  
## Examples  
 다음 예제에서는 대리자를 세 가지 메서드를 할당합니다. 그런 다음 호출 하는 <xref:System.Delegate.GetInvocationList%2A> "File"입니다. 대리자를 반대 순서로 실행 하 고 이름이 부분 문자열을 포함 하지 마십시오 메서드를 실행 하는 대리자에 할당 하는 방법의 총 개수를 가져올 메서드입니다.  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 대리자가 나타내는 정적 메서드를 가져옵니다.</summary>
        <returns>현재 대리자가 나타내는 정적 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 대리자가 나타내는 정적 메서드의 경우에 적용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">지원되지 않습니다.</param>
        <param name="context">지원되지 않습니다.</param>
        <summary>지원되지 않습니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 지원되지 않습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>대리자가 나타내는 메서드를 가져옵니다.</summary>
        <value>대리자가 나타내는 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">비교할 첫째 대리자입니다.</param>
        <param name="d2">비교할 둘째 대리자입니다.</param>
        <summary>지정된 대리자가 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="d1" />와 같으면 <paramref name="d2" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 같은 대상, 메서드 및 호출 목록을 가진 같은 형식의 두 대리자는 같은 것으로 간주 됩니다.  
  
 두 대리자 형식이 아닌 경우 같은 간주 되지는 않습니다.  
  
> [!IMPORTANT]
>  .NET framework 버전 1.0 및 1.1에서는 두 명의 대리자가 서로 다른 형식의 해당 대상, 메서드 및 호출 목록 같으면 고려 되었습니다.  
  
 메서드와 대상이 다음과 같이 같은지 비교 됩니다.  
  
-   비교 되는 두 개의 메서드가 둘 다 정적 동일한 클래스에 있는 같은 메서드를 메서드 같은 개체로 간주 되는지 및 대상도 같다고 간주 됩니다.  
  
-   비교할 두 개의 메서드는 인스턴스 메서드, 동일한 개체에 대해 동일한 메서드 메서드 같은 개체로 간주 되는지 고 대상을 같다고 간주 됩니다.  
  
-   그렇지 않으면 메서드 동일한 것으로 간주 되지 않습니다 하 고 대상 동일한 것으로 간주 되지도 않습니다.  
  
 순서 및 같은 메서드와 대상을 두 목록에서 해당 요소를 나타냅니다 두 호출 목록은 동일한 것으로 간주 됩니다.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">비교할 첫째 대리자입니다.</param>
        <param name="d2">비교할 둘째 대리자입니다.</param>
        <summary>지정된 대리자가 다른지를 확인합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="d1" />와 다르면 <paramref name="d2" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다양 한 유형의 인지 여러 가지 방법, 다양 한 대상에 또는 다른 호출 목록이 있는 경우 두 대리자를 동일 하지 간주 됩니다.  
  
 두 대리자 형식이 아닌 경우 같은 간주 되지는 않습니다.  
  
> [!IMPORTANT]
>  .NET framework 버전 1.0 및 1.1에서는 두 명의 대리자가 서로 다른 형식의 해당 대상, 메서드 및 호출 목록 같으면 간주 됩니다.  
  
 메서드와 대상이 다음과 같이 같은지 비교 됩니다.  
  
-   비교 되는 두 개의 메서드가 둘 다 정적 동일한 클래스에 있는 같은 메서드를 메서드 같은 개체로 간주 되는지 및 대상도 같다고 간주 됩니다.  
  
-   비교할 두 개의 메서드는 인스턴스 메서드, 동일한 개체에 대해 동일한 메서드 메서드 같은 개체로 간주 되는지 고 대상을 같다고 간주 됩니다.  
  
-   그렇지 않으면 메서드 동일한 것으로 간주 되지 않습니다 하 고 대상 동일한 것으로 간주 되지도 않습니다.  
  
 메서드 또는 다른 목록의 해당 요소가 나타내는 다른 한 목록에서 하나 이상의 요소를 나타내는 경우 또는 크기가 다른 서로 다르게 정렬 되어 경우 두 호출 목록은 다릅니다.  
  
 이 연산자는 해당 하는 방법은 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <c>값</c>의 호출 목록을 제거하는 대리자입니다.</param>
        <param name="value">
          <c>원본</c>의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</param>
        <summary>한 대리자의 호출 목록에 있는 마지막 항목을 다른 대리자의 호출 목록에서 제거합니다.</summary>
        <returns>
          <paramref name="source" />의 호출 목록이 <paramref name="value" />의 호출 목록에 있는 경우, <paramref name="value" />의 호출 목록을 가져오고 <paramref name="source" />의 호출 목록에 있는 마지막 항목을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다. <paramref name="source" />가 <see langword="null" />이거나 <paramref name="value" />의 호출 목록이 <paramref name="value" />의 호출 목록에 없는 경우 <paramref name="source" />를 반환합니다. <paramref name="value" />의 호출 목록이 <paramref name="source" />의 호출 목록과 같거나 <paramref name="source" />가 null 참조인 경우 null 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 호출 목록 `value` 의 호출 목록에 있는 요소의 연속 집합과 일치 `source`의 호출 목록에는 다음 `value` 의 호출 목록 내에서 발생 한다고 `source`합니다. 하는 경우의 호출 목록 `value` 의 호출 목록에 두 번 이상 발생 `source`, 마지막으로 제거 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <exception cref="T:System.ArgumentException">대리자 형식이 일치하지 않는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <c>값</c>의 호출 목록을 제거하는 대리자입니다.</param>
        <param name="value">
          <c>원본</c>의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</param>
        <summary>한 대리자의 호출 목록에 있는 모든 항목을 다른 대리자의 호출 목록에서 제거합니다.</summary>
        <returns>
          <paramref name="source" />의 호출 목록이 <paramref name="value" />의 호출 목록에 있는 경우, <paramref name="value" />의 호출 목록을 가져오고 <paramref name="source" />의 호출 목록에 있는 모든 항목을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다. <paramref name="source" />가 <see langword="null" />이거나 <paramref name="value" />의 호출 목록이 <paramref name="value" />의 호출 목록에 없는 경우 <paramref name="source" />를 반환합니다. <paramref name="value" />의 호출 목록이 <paramref name="source" />의 호출 목록과 같거나 <paramref name="source" />에 <paramref name="value" />의 호출 목록과 같은 일련의 호출 목록만 있거나 <paramref name="source" />가 null 참조인 경우 null 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 호출 목록 `value` 의 호출 목록에 있는 요소의 연속 집합과 일치 `source`의 호출 목록에는 다음 `value` 의 호출 목록 내에서 발생 한다고 `source`합니다. 하는 경우의 호출 목록 `value` 의 호출 목록에 두 번 이상 발생 `source`, 모든 항목이 제거 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <exception cref="T:System.ArgumentException">대리자 형식이 일치하지 않는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">현재 대리자의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</param>
        <summary>한 대리자의 호출 목록을 다른 대리자의 호출 목록에서 제거합니다.</summary>
        <returns>
          <paramref name="value" />의 호출 목록이 현재 대리자의 호출 목록에 있는 경우, 현재 대리자의 호출 목록을 가져오고 <paramref name="value" />의 호출 목록을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다. <paramref name="value" />가 <see langword="null" />이거나 <paramref name="value" />의 호출 목록이 현재 대리자의 호출 목록에 없는 경우 현재 대리자를 반환합니다. <paramref name="value" />의 호출 목록이 현재 대리자의 호출 목록과 같으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 호출 목록 `value` 연속 된 집합이 현재 대리자의 호출 목록 다음의 호출 목록에 있는 요소를 일치 `value` 현재 대리자의 호출 목록에 발생 한다고 합니다. 하는 경우의 호출 목록 `value` 두 번 이상 발생 현재 대리자의 호출 목록에 마지막으로 제거 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 대리자가 인스턴스 메서드를 호출하는 클래스 인스턴스를 가져옵니다.</summary>
        <value>대리자가 인스턴스 메서드를 나타내는 경우 현재 대리자가 인스턴스 메서드를 호출하는 개체이고, 대리자가 정적 메서드를 나타내는 경우 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스 메서드는; 클래스의 인스턴스와 연결 되는 메서드 정적 메서드는 클래스 자체와 연결 되는 메서드.  
  
 하나 이상의 인스턴스 메서드를 호출 하는 대리자 호출 목록에서 마지막 인스턴스 메서드의 대상이이 속성으로 반환 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>