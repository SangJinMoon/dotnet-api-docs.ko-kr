<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="15f433904f15b52fc408db54f7fd65e20a71b739" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174251" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>.Net Framework 클래스 계층 구조의 모든 클래스를 지원하며 파생 클래스에 하위 수준 서비스를 제공합니다. 또한 .NET Framework의 모든 클래스 중에서 기본 클래스이며 형식 계층 구조의 루트입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 언어에서 상속을 선언 하는 클래스를 일반적으로 필요 하지 않습니다 <xref:System.Object> 상속은 암시적 때문에 있습니다.  
  
 .NET Framework의 모든 클래스에서 파생 되므로 <xref:System.Object>에 정의 된 모든 메서드는 <xref:System.Object> 클래스는 시스템의 모든 개체에서 사용할 수 있습니다. 파생 클래스 수를 포함 하 여 이러한 메서드의 일부 재정의지 않습니다.  
  
-   <xref:System.Object.Equals%2A> -개체 간의 비교를 지원 합니다.  
  
-   <xref:System.Object.Finalize%2A> -개체를 자동으로 회수 하기 전에 정리 작업을 수행 합니다.  
  
-   <xref:System.Object.GetHashCode%2A> -해시 테이블의 사용을 지 원하는 개체의 값에 해당 하는 숫자를 생성 합니다.  
  
-   <xref:System.Object.ToString%2A> 클래스의 인스턴스를 설명 하는 사람이 읽을 수 있는 텍스트 문자열을 제조 합니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 인스턴스를 허용 하는 클래스 멤버를 만들 수 같은 모든 종류의 개체를 처리 해야 하는 컬렉션 클래스를 디자인 하는 경우는 <xref:System.Object> 클래스입니다. 그러나 boxing 및 unboxing 형식의 프로세스는 성능 비용을 전달 합니다. 새 클래스에는 일부 값 형식은 자주 처리를 알고 있는 경우 한 boxing의 비용을 최소화 하기 위해 두 가지 방법 중 하나를 사용할 수 있습니다.  
  
-   허용 하는 일반 메서드 만들기는 <xref:System.Object> 형식과에서 자주 처리 클래스 각각의 값 형식을 허용 하는 형식별 메서드 오버 로드의 집합입니다. 유형별 메서드 호출 매개 변수 형식을 받는 있으면 boxing 발생 하 고 형식 관련 메서드가 호출 됩니다. 메서드 호출 매개 변수 형식과 일치 하는 인수가 없으면 boxed 매개 변수 및 일반 메서드가 호출 됩니다.  
  
-   제네릭을 사용 하 여 형식 및 해당 멤버를 디자인 합니다. 공용 언어 런타임 클래스의 인스턴스를 만들고 제네릭 형식 인수를 지정할 때 폐쇄형된 제네릭 형식을 만듭니다. 제네릭 메서드의 형식 관련 이며 호출 매개 변수를 boxing 하지 않고 호출할 수 있습니다.  
  
 허용 및 반환 하는 범용 클래스를 개발 해야 하는 경우도 있지만 <xref:System.Object> 형식, 또한 자주 사용 되는 형식을 처리 하려면 특정 형식의 클래스를 제공 하 여 성능을 개선할 수 있습니다. 예를 들어 설정 하 고 부울 값을 가져오는에 적용 되는 클래스를 제공 하는 비용 boxing 및 unboxing 부울 값을 제거 합니다.  
  
   
  
## Examples  
 다음 예제에서 파생 되는 지점 형식 정의 <xref:System.Object> 클래스 및 대부분의 가상 메서드를 재정의 <xref:System.Object> 클래스입니다. 이 호출 하는 방법을 설명 또한 메서드와 인스턴스는 <xref:System.Object> 클래스입니다.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual basic에서)이 형식의 멤버는 스레드로부터 안전 합니다. 인스턴스 멤버는 스레드로부터 안전 보장 되지 않습니다.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Object" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 파생된 클래스의 생성자에서 호출 되지만의 인스턴스를 직접 만드는 사용할 수 있습니다는 <xref:System.Object> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 개체 인스턴스가 같은지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">현재 개체와 비교할 개체입니다.</param>
        <summary>지정한 개체와 현재 개체가 같은지 여부를 확인합니다.</summary>
        <returns>지정한 개체가 현재 개체와 같으면 <see langword="true" />이고, 다르면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 인스턴스 간의 비교의 유형 및 `obj` 매개 변수는 현재 인스턴스 참조 형식 또는 값 형식 인지에 따라 달라 집니다.  
  
-   현재 인스턴스 참조 형식인 경우는 <xref:System.Object.Equals%28System.Object%29> 참조 일치에 대 한 테스트 메서드를 호출 하 여 <xref:System.Object.Equals%28System.Object%29> 를 호출 하는 것과 같습니다는 <xref:System.Object.ReferenceEquals%2A> 메서드. 참조 같음 비교 되는 개체 변수가 같은 개체를 참조 하는지 의미 합니다. 다음 예제에서는 이러한 비교의 결과를 보여 줍니다. 정의 `Person` 클래스는 참조 형식, 즉 호출는 `Person` 클래스 생성자를 두 개의 새 인스턴스화하 `Person` 개체 `person1a` 및 `person2`, 동일한 값을 가진 합니다. 자동으로 할당 `person1a` 다른 개체 변수에 `person1b`합니다. 예제에서 출력으로 `person1a` 및 `person1b` 동일한 개체를 참조 하기 때문에 있습니다. 그러나 `person1a` 및 `person2` 동일한 값을 포함 하지만, 같지 않습니다.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   현재 인스턴스의 값 형식인 경우는 <xref:System.Object.Equals%28System.Object%29> 값 일치에 대 한 메서드 테스트 합니다. 값이 같은지 다음을 의미합니다.  
  
    -   두 개체가 동일한 형식의 됩니다. 다음 예제와 같이 한 <xref:System.Byte> 값 12 가진 개체를 같지 않습니다는 <xref:System.Int32> 두 개체가 서로 다른 런타임 형식 때문에 12의 값을 가진 개체를 합니다.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   두 개체의 public 및 private 필드의 값이 같으면 합니다. 다음 예제에서는 값이 같은지 테스트합니다. 정의 `Person` 구조, 즉 값 형식 및 호출은 `Person` 클래스 생성자를 두 개의 새 인스턴스화하 `Person` 개체 `person1` 및 `person2`, 동일한 값을 가진 합니다. 서로 다른 개체에 두 개의 개체 변수를 참조 하지만 예제에서 결과 보여 지 듯이 `person1` 및 `person2` 개인에 대 한 동일한 값이 없으므로 같은지 `personName` 필드입니다.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 때문에 <xref:System.Object> 클래스는.NET Framework의 모든 형식에 대 한 기본 클래스는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드는 다른 모든 형식에 대 한 기본 같음 비교를 제공 합니다. 그러나 형식은 종종 재정의 <xref:System.Object.Equals%2A> 값이 같은지를 구현 하려면 메서드. 자세한 내용은 상속자 참고 사항 섹션에 대 한 정보를 알아보고 호출자에 대 한 참조입니다.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>에 대 한 정보는 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 호출 하는 경우는 <xref:System.Object.Equals%28System.Object%29> 클래스의 메서드 오버 로드는 [!INCLUDE[wrt](~/includes/wrt-md.md)], 재정의 하지 않는 클래스에 대 한 기본 동작을 제공 <xref:System.Object.Equals%28System.Object%29>합니다. 이것은.NET Framework에 대 한 제공 하는 지원의 일부는 [!INCLUDE[wrt](~/includes/wrt-md.md)] (참조 [.NET Framework 지원에 대 한 Windows 스토어 앱 및 Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). 에 있는 클래스는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 상속 받지 않습니다 <xref:System.Object>, 하 고 구현 하지는 <xref:System.Object.Equals%28System.Object%29> 메서드. 그러나 하기로 표시 <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, 및 <xref:System.Object.GetHashCode%2A> 메서드 C# 또는 Visual Basic 코드에서 사용 하 고.NET Framework에서는 이러한 방법에 대 한 기본 동작을 제공 하는 경우.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] C# 또는 Visual Basic에서 작성 된 클래스에서 재정의할 수는 <xref:System.Object.Equals%28System.Object%29> 메서드 오버 로드 합니다.  
  
## <a name="notes-for-callers"></a>호출자에 대 한 참고 사항  
 파생된 클래스를 자주 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값이 같은지를 구현 하려면 메서드. 또한 형식에 추가 강력한 형식의 오버 로드를 자주 제공는 `Equals` 메서드를 구현 하 여 일반적으로 <xref:System.IEquatable%601> 인터페이스입니다. 호출 하는 경우는 `Equals` 같은지를 테스트 하는 메서드 현재 인스턴스 우선 있는지 여부를 알아야 할 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 하 고 이해 하는 방법에 대 한 특정 호출은 `Equals` 방법은 해결 합니다. 그렇지 않으면을 수행할 수도 있습니다는 테스트에 의도 한 것과 다른 같은지 및 메서드가 예기치 않은 값을 반환할 수 있습니다.  
  
 다음 예제에서 이에 대해 설명합니다. 세 개의 인스턴스화하여 <xref:System.Text.StringBuilder> 개체와 동일한 문자열 고 다음 4 개의 호출 하 `Equals` 메서드. 첫 번째 메서드 호출 반환 `true`, 나머지 3 개 반환 `false`합니다.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 강력한 형식의 첫 번째 경우 <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> 어떤 값이 같은지 테스트, 메서드 오버 로드를 호출 됩니다. 두에 할당 된 문자열 이므로 <xref:System.Text.StringBuilder> 메서드 반환 개체가 서로 같은지, `true`합니다. 그러나 <xref:System.Text.StringBuilder> 재정의 하지 않는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>합니다. 이 인해 때는 <xref:System.Text.StringBuilder> 개체 캐스팅 됩니다는 <xref:System.Object>때는 <xref:System.Text.StringBuilder> 인스턴스가 형식의 변수에 할당 됩니다 <xref:System.Object>, 및 시기는 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> 두 메서드에 전달 됩니다 <xref:System.Text.StringBuilder> 개체를 기본 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>메서드를 호출 합니다. 때문에 <xref:System.Text.StringBuilder> 참조 형식인 두 전달 같습니다 <xref:System.Text.StringBuilder> 개체는 <xref:System.Object.ReferenceEquals%2A> 메서드. 하지만 세 가지 모두 <xref:System.Text.StringBuilder> 동일한 문자열을 포함 하는 개체, 세 가지 개체를 참조 합니다. 따라서 이러한 세 개의 메서드 호출 반환 `false`합니다.  
  
 호출 하 여 현재 개체를 참조 일치에 대 한 다른 개체를 비교할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A> 메서드. Visual Basic에서 사용할 수도 있습니다는 `is` 키워드 (예를 들어 `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>상속자 참고 사항  
 해당 형식에 정의 된 기능을 상속 고유한 형식을 정의 하는 경우는 `Equals` 기본 형식의 메서드. 다음 표에서의 기본 구현에서 `Equals` 주요 범주는.NET Framework의 형식에 대 한 메서드.  
  
|형식 범주|로 정의 된 같음|설명|  
|-------------------|-------------------------|--------------|  
|직접 파생 된 클래스 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|참조 같음; 호출에 해당 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>합니다.|  
|구조체|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|값이 같은지 확인 합니다. 직접 바이트 단위로 비교 또는 리플렉션을 사용 하 여 필드 별로 비교 합니다.|  
|열거형|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|값은 열거형 형식이 고 기본값이 있어야 합니다.|  
|대리자|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|대리자에는 동일한 호출 목록 사용 하 여 같은 형식을 이어야 합니다.|  
|인터페이스|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|참조 일치 합니다.|  
  
 값 형식에 대 한 재정의 항상 해야 <xref:System.Object.Equals%2A>, 리플렉션을 사용 하는 같음에 대 한 테스트 성능 저하를 제공 하기 때문입니다. 기본 구현을 재정의할 수도 있습니다 <xref:System.Object.Equals%2A> 참조 일치 대신 값이 같은지를 테스트 하 고 값이 같은지의 정확한 의미를 정의 하는 참조 형식에 대 한 합니다. 구현 <xref:System.Object.Equals%2A> 반환 `true` 동일한 인스턴스에 없는 경우에 두 개체도 동일한 값입니다. 해당 형식의 구현자 결정 하는 개체의 값을 구성 하는 항목 이지만 일반적으로 일부 또는 모든 데이터 개체의 인스턴스 변수에 저장 합니다. 예를 들어 값은 <xref:System.String> ; 문자열의 문자를 기반으로 하는 개체는 <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> 메서드 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 반환 하는 메서드 `true` 인스턴스 동일한 순서로 동일한 문자를 포함 하는 두 개의 문자열에 대 한 합니다.  
  
 재정의 하는 방법을 보여 주는 다음 예제는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값이 같은지를 테스트 하는 메서드. 재정의 <xref:System.Object.Equals%2A> 에 대 한 메서드는 `Person` 클래스입니다. 경우 `Person` , 동등 여부의 기본 클래스 구현을 허용 두 `Person` 개체는 단일 개체를 참조 하는 경우에 동일한 것입니다. 그러나이 경우에에서 두 개의 `Person` 개체는 모두 같은 경우에 대해 같은 값의 `Person.Id` 속성입니다.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 재정의 하는 것 외에도 <xref:System.Object.Equals%2A>를 구현할 수 있습니다는 <xref:System.IEquatable%601> 같음에 대 한 강력한 형식의 테스트를 제공 하는 인터페이스입니다.  
  
 다음 문은 모든의 구현에 대해 충족 해야 합니다.는 <xref:System.Object.Equals%28System.Object%29> 메서드. 목록에서 `x`, `y`, 및 `z` 되지 않는 개체 참조 나타냅니다 **null**합니다.  
  
-   `x.Equals(x)` 반환 `true`, 부동 소수점 형식을 포함 하는 경우를 제외 하 고 있습니다. ISO/IEC/IEEE 60559:2011, 정보 기술-마이크로프로세서 시스템-부동 소수점 연산을 참조 하십시오.  
  
-   `x.Equals(y)` 과 동일한 값을 반환 `y.Equals(x)`합니다.  
  
-   `x.Equals(y)` 반환 `true` 모두 `x` 및 `y` 는 `NaN`합니다.  
  
-   경우 `(x.Equals(y) && y.Equals(z))` 반환 `true`, 다음 `x.Equals(z)` 반환 `true`합니다.  
  
-   에 대 한 연속 호출은 `x.Equals(y)` 같은 값으로 하 여 참조 하는 개체가 반환 `x` 및 `y` 수정 되지 않습니다.  
  
-   `x.Equals(null)`가 `false`를 반환하는 경우  
  
 구현 <xref:System.Object.Equals%2A> ; 예외가 발생 하지 않아야 항상 값 반환 해야 합니다. 예를 들어 경우 `obj` 은 `null`, <xref:System.Object.Equals%2A> 메서드를 반환 하도록 `false` throw 하는 대신는 <xref:System.ArgumentNullException>합니다.  
  
 재정의 하는 경우 다음이 지침에 따라 <xref:System.Object.Equals%28System.Object%29>:  
  
-   구현 하는 형식은 <xref:System.IComparable> 재정의 해야 <xref:System.Object.Equals%28System.Object%29>합니다.  
  
-   재정의 하는 형식은 <xref:System.Object.Equals%28System.Object%29> 재정의 해야 <xref:System.Object.GetHashCode%2A>, 그렇지 않으면 해시 테이블을 올바르게 작동 하지 않을 수 있습니다.  
  
-   구현할 때 고려해 야는 <xref:System.IEquatable%601> 강력 하 게 지원 하기 위해 인터페이스 형식의 같은지 테스트 합니다. 프로그램 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 구현와 일치 하는 결과 반환 해야 <xref:System.Object.Equals%2A>합니다.  
  
-   프로그래밍 언어에서 연산자 오버 로드 하 고 지정된 된 형식에 대 한 같음 연산자를 오버 로드, 재정의 해야 하는 경우는 <xref:System.Object.Equals%28System.Object%29> 같음 연산자와 동일한 결과 반환 하는 메서드. 이렇게 하면 사용 하는 클래스 라이브러리 코드가 <xref:System.Object.Equals%2A> (예: <xref:System.Collections.ArrayList> 및 <xref:System.Collections.Hashtable>) 응용 프로그램 코드에서 같음 연산자를 사용 하는 방식과 일치 하는 방식으로 동작 합니다.  
  
### <a name="guidelines-for-reference-types"></a>참조 형식에 대 한 지침  
 재정의에 다음과 같은 지침이 적용 <xref:System.Object.Equals%28System.Object%29> 참조 형식에 대 한:  
  
-   재정의 하는 것이 좋습니다. <xref:System.Object.Equals%2A> 형식의 의미가 일부 값을 나타내는 경우.  
  
-   재정의 한 경우에 대부분의 참조 형식은 같음 연산자를 재정의 하지 해야 <xref:System.Object.Equals%2A>합니다. 그러나를 복잡 한 숫자 형식 처럼 값 의미를 갖는 참조 형식이 구현 하는 경우 같음 연산자를 재정의 해야 합니다.  
  
-   재정의 하지 않아야 함 <xref:System.Object.Equals%2A> 변경 가능한 참조 형식에 있습니다. 재정의 하기 때문에 이것이 <xref:System.Object.Equals%2A> 도 재정의 하는 필요는 <xref:System.Object.GetHashCode%2A> 메서드, 이전 섹션에서 설명한 대로 합니다. 즉, 해시 테이블 개체를 손실 될 수 있습니다의 수명 동안 변경 가능한 참조 형식의 인스턴스로의 해시 코드를 변경할 수 있습니다.  
  
### <a name="guidelines-for-value-types"></a>값 형식에 대 한 지침  
 재정의에 다음과 같은 지침이 적용 <xref:System.Object.Equals%28System.Object%29> 값 형식을 사용 합니다.  
  
-   하나 이상의 필드를 포함 하는 값 형식을 정의 하는 경우 해당 값은 참조 형식, 재정의 해야 하는 <xref:System.Object.Equals%28System.Object%29>합니다. <xref:System.Object.Equals%28System.Object%29> 구현에서 제공 <xref:System.ValueType> 갖는 값 형식에 대 한 바이트 단위 비교를 수행 합니다. 필드는 모든 값 형식은 있지만 리플렉션을 사용 하 여 해당 필드 참조 형식을 포함 하는 값 형식의 필드 별로 비교를 수행 합니다.  
  
-   재정의 하는 경우 <xref:System.Object.Equals%2A> 개발 언어 연산자 오버 로드를 지원 하 고, 같음 연산자를 오버 로드 해야 합니다.  
  
-   구현 해야는 <xref:System.IEquatable%601> 인터페이스입니다. 강력한 형식의 호출 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> boxing을 방지 하는 메서드는 `obj` 인수입니다.  
  
   
  
## Examples  
 다음 예제와 `Point` 재정의 하는 클래스는 <xref:System.Object.Equals%2A> 값이 같은지를 제공 하는 메서드 및 `Point3D` 클래스에서 파생 된 `Point`합니다. 때문에 `Point` 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값이 같은지를 테스트 하는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드가 호출 되지 않습니다. 그러나 `Point3D.Equals` 호출 `Point.Equals` 때문에 `Point` 구현 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값이 같은지를 제공 하는 방식에서입니다.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals` 메서드 확인 되도록 하는 `obj` 인수가 **null** 이 개체와 동일한 형식의 인스턴스를 참조 하 고 있습니다. 메서드가 반환 하는 경우 검사에 실패할 `false`합니다.  
  
 `Point.Equals` 메서드 호출의 <xref:System.Object.GetType%2A> 메서드를 두 개체의 런타임 형식이 동일한 지 확인 합니다. 메서드가 폼의 확인을 사용 하는 경우 `obj is Point` C# 또는 `TryCast(obj, Point)` Visual Basic의 경우에 반환 합니다 `true` 경우에서 여기서 `obj` 의 파생된 클래스의 인스턴스가 `Point`경우라도, `obj` 및 현재 인스턴스는 같은 런타임 형식이 아닙니다. 것을 확인 했으면는 두 개체가 동일한 형식의 메서드 캐스트 `obj` 입력 `Point` 두 개체의 인스턴스 필드를 비교의 결과 반환 합니다.  
  
 `Point3D.Equals`, 상속 된 `Point.Equals` 메서드로 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, 인스턴스인지 전에 호출 됩니다. 때문에 `Point3D` 클래스는 봉인 클래스 (`NotInheritable` Visual basic에서), 형식에서 확인을 `obj is Point` C# 또는 `TryCast(obj, Point)` Visual Basic에서 충족 되도록 적절 한지 `obj` 은 `Point3D` 개체. 이 경우는 `Point3D` 개체로 캐스팅 되는 `Point` 개체 및의 기본 클래스 구현에 전달 <xref:System.Object.Equals%2A>합니다. 경우에만 상속 된 `Point.Equals` 메서드 반환 `true` 메서드 비교는는 `z` 인스턴스 필드 파생된 클래스에서 도입 되었습니다.  
  
 다음 예제에서는 정의 `Rectangle` 내부적으로 두 개의 사각형을 구현 하는 클래스 `Point` 개체입니다. `Rectangle` 클래스도 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 하기 위해 값이 같은지 확인 합니다.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 C# 및 Visual Basic과 같은 일부 언어 연산자 오버 로드를 지원 합니다. 형식이 같음 연산자를 오버 하는 경우 재정의 해야는 <xref:System.Object.Equals%28System.Object%29> 메서드를 같은 기능을 제공 합니다. 작성 하 여 일반적으로 이렇게는 <xref:System.Object.Equals%28System.Object%29> 메서드 오버 로드 된 같음 연산자는 다음 예제 에서처럼 기준으로 합니다.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 때문에 `Complex` 은 값 형식에서 파생 될 수 없습니다.  따라서 재정의 <xref:System.Object.Equals%28System.Object%29> 메서드를 호출 하지 않아도 <xref:System.Object.GetType%2A> 결정 하는 정확한 런타임 형식이 수 없지만 각 개체의 대신 사용 하 여는 `is` C#에서 연산자 또는 `TypeOf` 는 형식을확인하려면VisualBasic의연산자`obj` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">비교할 첫 번째 개체입니다.</param>
        <param name="objB">비교할 두 번째 개체입니다.</param>
        <summary>지정한 개체 인스턴스가 동일한지를 확인합니다.</summary>
        <returns>개체가 동일한 것으로 간주되면 <see langword="true" />이고, 간주되지 않으면 <see langword="false" />입니다. <paramref name="objA" /> 및 <paramref name="objB" />가 **null**인 경우 메서드는 <see langword="true" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 메서드 두 개체가 하는지, 나타냅니다 `objA` 및 `objB`, 같은지 합니다. 값이 개체를 테스트할 수도 있습니다 **null** 같음에 대 한 합니다. 비교 `objA` 및 `objB` 다음과 같이 같음:  
  
-   두 개체가 동일한 개체 참조를 나타내는지 여부를 결정 합니다. 메서드가 반환 하는 경우 그럴 경우 `true`합니다. 이 테스트 하는 것은 <xref:System.Object.ReferenceEquals%2A> 메서드. 또한 두 경우 `objA` 및 `objB` 는 **null**, 메서드가 반환 `true`합니다.  
  
-   결정 여부 중 `objA` 또는 `objB` 은 **null**합니다. 따라서 반환 하는 경우 `false`합니다.  
  
-   두 개체가 동일한 개체 참조를 나타내지 않는 및 이용할 수 없는 경우 **null**, 호출 `objA`.`Equals` (`objB`) 결과 반환 합니다. 즉 `objA` 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> ,이 재정의 메서드는 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 메서드 하 고 사용 하 여 비교는 <xref:System.Object.ReferenceEquals%2A> 메서드.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가비지 컬렉션이 회수하기 전에 개체가 리소스를 해제하고 다른 정리 작업을 수행할 수 있게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A> 메서드를 사용 하는 개체가 소멸 되기 전에 현재 개체에서 보유 하는 관리 되지 않는 리소스에서 정리 작업을 수행 합니다. 메서드가 보호와 이므로 다음이 클래스 또는 파생된 클래스를 통해 액세스할 수 있는 합니다.  
  
 섹션 내용  
  
-   [종료의 작동 원리](#How)  
  
-   [구현자 참고 사항](#Notes)  
  
-   [SafeHandle 대안](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>종료의 작동 원리  
 <xref:System.Object> 클래스에 대 한 구현을 제공는 <xref:System.Object.Finalize%2A> 메서드와 가비지 수집기에서 파생 된 유형을 표시 하지 않는 <xref:System.Object> 종료를 재정의 하지 않는 한는 <xref:System.Object.Finalize%2A> 메서드.  
  
 형식에서 재정의 하는 경우는 <xref:System.Object.Finalize%2A> 메서드를 가비지 수집기는 종료 큐 라는 내부 구조에는 유형의 각 항목에 대 한 항목을 추가 합니다. 종료 큐 가비지 수집기가 메모리를 회수할 수 전에 종료 코드를 실행 해야 하는 관리 되는 힙의 모든 개체에 대 한 항목을 포함 합니다. 그런 다음 호출 하는 가비지 수집기는 <xref:System.Object.Finalize%2A> 자동으로 다음과 같은 조건 메서드:  
  
-   가비지 수집기가 개체에를 호출 하 여 종료에서 제외 된 경우가 아니면 개체에 액세스할 수 아닌지 검색 한 후의 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드.  
  
-   응용 프로그램 도메인의 종료 하는 동안 없으면 개체를 종료에서 제외 합니다. 여전히 액세스할 수 있는도 개체를 종료 하는 동안 종료 됩니다.  
  
 <xref:System.Object.Finalize%2A> 자동으로 한 번만 호출 지정한 인스턴스에서 개체와 같은 메커니즘을 사용 하 여 다시 등록 하지 않는 한 <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> 및 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드 이후에 호출 되지 않았습니다.  
  
 <xref:System.Object.Finalize%2A> 작업은 다음과 같은 제한 사항이 있습니다.  
  
-   종료 자가 실행 되는 경우 정확한 시간 정의 되지 않습니다. 인스턴스 클래스의 구현에 대 한 리소스의 명확한 해제를 위해는 `Close` 메서드를 제공 하거나는 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 구현 합니다.  
  
-   두 개체의 종료자 다른 하나의 개체가 참조 하는 경우에 특정 순서로 실행 되도록 보장 되지 않습니다. 즉, 개체 A가 개체 B에 대 한 참조 하는 경우 둘 다 종료자 개체 B 수 이미 종료 되었을 A의 종료 자가 시작 될 때입니다.  
  
-   종료 자가 실행 되는 스레드 지정 되지 않았습니다.  
  
 <xref:System.Object.Finalize%2A> 메서드가 완료 될 때까지 실행 되지 않거나 다음과 같은 예외적인 전혀 실행 되지 않습니다.  
  
-   다른 종료자 무기한으로 차단 하는 경우 (이 되는 무한 루프에는 잠금 수를 가져오려면 및 등 하지을 가져오려고 시도). 런타임에 종료자 실행이 완료 하려고 하기 때문에 다른 종료자 수 경우 호출 종료자 블록 무기한 합니다.  
  
-   프로세스는 런타임을 정리할 수 있는 기회를 제공 하지 않고도 종료 합니다. 이 경우 런타임 종료 프로세스의 첫 번째 알림을 DLL_PROCESS_DETACH 알림입니다.  
  
 런타임에서 줄어드는 경우 개체의 수를 계속 하는 동안에 개체를 종료 하는 동안 종료를 계속 합니다.  
  
 경우 <xref:System.Object.Finalize%2A> 또는 재정의 <xref:System.Object.Finalize%2A> 에서 예외를 throw 하 고 런타임이 기본 정책 보다 우선 하는 응용 프로그램에서 호스트 되지 않는, 활성화와 프로세스를 종료 하는 런타임 `try` / `finally` 블록 또는 종료자 실행 됩니다. 이 동작은 종료자 있음 없거나 리소스를 삭제 하는 경우 프로세스의 무결성을 보장 합니다.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Finalize 메서드를 재정의합니다. 
 재정의 해야 <xref:System.Object.Finalize%2A> 파일 핸들 또는 가비지 수집 중에 사용 하는 관리 되는 개체는 삭제 될 때 해제 해야 하는 데이터베이스 연결 등의 관리 되지 않는 리소스를 사용 하는 클래스에 대 한 합니다. 구현 하지 않아야는 <xref:System.Object.Finalize%2A> 메서드를 가비지 수집기는 관리 되는 리소스를 자동으로 해제 하기 때문에 개체를 관리 합니다.  
  
> [!IMPORTANT]
>  경우는 <xref:System.Runtime.InteropServices.SafeHandle> 개체를 사용할 수를 래핑하는 관리 되지 않는 리소스는 safehandle 사용 하 여 dispose 패턴을 구현 하 고 재정의 하지 하는 메서드 대신 <xref:System.Object.Finalize%2A>합니다. 자세한 내용은 참조 [The SafeHandle 대안](#SafeHandle) 섹션.  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 기본적으로도 메서드는 아무 작업도 수행 하지만 재정의 해야 하는 <xref:System.Object.Finalize%2A> 경우에 필요한 유일한 관리 되지 않는 리소스를 해제 합니다. 메모리를 회수는 두 개 이상의 가비지 수집 필요 하기 때문에 종료 작업을 실행 하는 경우 훨씬 더 오래 걸릴 경향이 있습니다. 또한를 재정의 해야 하는 <xref:System.Object.Finalize%2A> 메서드 참조에 대 한 형식에 합니다. 공용 언어 런타임에서 참조 형식만 종료합니다. 값 형식에서 종료자를 무시합니다.  

범위는 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 방법은 `protected`합니다. 클래스의 메서드를 재정의 하는 경우에이 제한 된 범위를 유지 해야 합니다. 유지 하 여 한 <xref:System.Object.Finalize%2A> 보호 되는 메서드, 하면 개체의 호출에서 응용 프로그램의 사용자가 <xref:System.Object.Finalize%2A> 메서드를 직접 합니다.
  
 모든 구현 <xref:System.Object.Finalize%2A> 파생 된 형식에 해당 기본 형식 구현을 호출 해야 <xref:System.Object.Finalize%2A>합니다. 이 경우에 코드를 호출할 수 있는 응용 프로그램에서 <xref:System.Object.Finalize%2A>합니다. 개체의 <xref:System.Object.Finalize%2A> 메서드는 기본 클래스의 다른 모든 개체에 메서드를 호출 하지 않아야 합니다. 호출 되는 다른 개체에 수집 될 수도 호출 하는 개체와 같은 시간와 같은 공용 언어 런타임 종료의 경우 때문입니다. 
  
> [!NOTE]
>  C# 컴파일러를 재정의할 수를 허용 하지 않습니다는 <xref:System.Object.Finalize%2A> 메서드. 대신 종료자를 구현 하 여 제공 된 [소멸자](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) 클래스에 대 한 합니다. C# 소멸자는 자동으로 기본 클래스의 소멸자를 호출합니다.  
>   
>  Visual c + + 구현 하기 위한 자체 구문이 제공는 <xref:System.Object.Finalize%2A> 메서드. 자세한 내용은의 "소멸자 및 종료자" 섹션을 참조 하십시오. [하는 방법: 정의 및 소비 클래스와 구조체 (C + + CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)합니다.  
  
 가비지 수집 명확 하지 않은 이기 때문에 가비지 수집기가 종료를 수행 하는 경우에 정확 하 게 알지 못하는 합니다. 리소스를 해제 하려면 즉시 수도 있습니다를 구현 하는 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md) 및 <xref:System.IDisposable> 인터페이스입니다. <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 구현 클래스의 소비자가 관리 되지 않는 리소스를 해제 하 여 호출할 수 있으며 사용할 수 있습니다는 <xref:System.Object.Finalize%2A> 관리 되지 않는 리소스를 해제 하는 방법에는 <xref:System.IDisposable.Dispose%2A> 메서드가 호출 되지 않습니다.  
  
 <xref:System.Object.Finalize%2A> 가비지 수집 중 의해 정리 된 후에 개체 (즉, 개체가 액세스할 수 있도록 다시) 부활 하기 등 거의 모든 작업을 수행할 수 있습니다. 그러나 개체 수만 복원할 되지 않습니다. <xref:System.Object.Finalize%2A> 가비지 수집 중 부활 개체에서 호출할 수 없습니다. 하나의 액션이 있습니다 하는의 구현 <xref:System.Object.Finalize%2A> 받아들이지 해야: 예외를 throw 하지 해야 합니다. 메서드에 의해 throw 된 예외에서 호출 된 경우는 <xref:System.Object.Finalize%2A> 메서드는 처리 되지는 <xref:System.Object.Finalize%2A> 메서드, 런타임 가정 하는 <xref:System.Object.Finalize%2A> 메서드가 반환 되 고 계속 호출 하는 <xref:System.Object.Finalize%2A> 다른 개체의 메서드. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 대안  
 신뢰할 수 있는 종료자를 만드는 것이 쉽지 않습니다, 응용 프로그램의 상태에 대 한 가정을 만들 수 없습니다와 같은 시스템 예외를 처리 하지 않은 있으므로 <xref:System.OutOfMemoryException> 및 <xref:System.StackOverflowException> 종료자를 종료 합니다. 관리 되지 않는 리소스를 해제 하 여 클래스에 대 한 종료자를 구현 하는 대신에서 파생 된 개체를 사용할 수는 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 에서는 관리 되지 않는 리소스를 래핑하는 클래스 및 다음 종료자 없이 dispose 패턴을 구현 합니다. .NET Framework에서는 다음 클래스는 <xref:Microsoft.Win32?displayProperty=nameWithType> 네임 스페이스에서 파생 된 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 열려 있는 파일 핸들에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 메모리 매핑된 파일 핸들에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 관리 되지 않는 메모리 블록에 대 한 포인터에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle><xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, 및 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 암호화 핸들에 대 한 래퍼 클래스입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 파이프 핸들에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 레지스트리 키에 대 한 핸들에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 대기 핸들에 대 한 래퍼 클래스가입니다.  
  
 다음 예제에서는 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md) 재정의 하는 대신 safehandle와는 <xref:System.Object.Finalize%2A> 메서드. 정의 `FileAssociation` 특정 파일 확장명을 가진 파일을 처리 하는 응용 프로그램에 대 한 레지스트리 정보를 래핑하는 클래스입니다. 로 반환 하는 두 개의 레지스트리 핸들 `out` Windows에서 매개 변수 [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) 함수 호출에 전달 되는 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 생성자입니다. 종류의 보호 `Dispose` 메서드를 호출는 `SafeRegistryHandle.Dispose` 메서드를 이러한 두 핸들을 해제 합니다.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 다음 예제를 확인 하는 <xref:System.Object.Finalize%2A> 메서드는 재정의 하는 개체가 <xref:System.Object.Finalize%2A> 소멸 됩니다. 유의 프로덕션 응용 프로그램에서의 <xref:System.Object.Finalize%2A> 개체에서 보유 하는 관리 되지 않는 리소스를 해제 하기 위해 메서드를 재정의 해야 합니다. 또한 C# 예제에서는 재정의 하는 대신 소멸자를 제공 하는지 유의 <xref:System.Object.Finalize%2A> 메서드.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 재정의 하는 추가 예제는 <xref:System.Object.Finalize%2A> 메서드를 참조는 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 해시 함수로 작동합니다.</summary>
        <returns>현재 개체의 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해시 코드를 삽입 하 고 같은 해시를 기반으로 컬렉션의 개체를 식별 하는 데 사용 되는 숫자 값은는 <xref:System.Collections.Generic.Dictionary%602> 클래스는 <xref:System.Collections.Hashtable> 클래스 또는에서 파생 된 형식이 <xref:System.Collections.DictionaryBase> 클래스입니다. <xref:System.Object.GetHashCode%2A> 메서드 개체 같음 빠른 검사 해야 하는 알고리즘에 대 한이 해시 코드를 제공 합니다.  
  
> [!NOTE]
>  해시 테이블의 해시 코드 사용 방법에 대 한 내용은 및 일부 추가 해시 코드 알고리즘에 대 한 참조는 [해시 함수](https://en.wikipedia.org/wiki/Hash_function) Wikipedia 항목입니다.  
  
 두 개체는 같은 반환 같은 해시 코드입니다. 그러나 반대는 성립 하지 않습니다: 서로 다른 (같지 않음) 개체는 동일한 해시 코드를 가질 수 있으므로 같은 해시 코드 개체 같음 의미 하지 않습니다. 또한.NET Framework의 기본 구현은 보장 하지 않습니다는 <xref:System.Object.GetHashCode%2A> 메서드와이 메서드가 반환 다를 수 있습니다 32 비트 및 64 비트 플랫폼에서와 같은 플랫폼 및.NET Framework 버전 간의 값입니다. 이러한 이유로, 사용 하지 마십시오이 메서드의 기본 구현 고유한 개체 식별자로 해시를 위해. 두 개의 결과에서이 수행합니다.  
  
-   같은 해시 코드 개체 같음 의미는 가정 하지 않아야 합니다.  
  
-   하지 유지 하거나 응용 프로그램 도메인, 프로세스 및 플랫폼 간에 동일한 개체 해시 수 때문에 생성 된 응용 프로그램 도메인 외부 해시 코드를 사용 해야 합니다.  
  
> [!WARNING]
>  해시 코드는 효율적인 삽입 및 해시 테이블을 기반으로 하는 컬렉션에서 조회를 위한 것입니다. 해시 코드는 영구 값이 아닙니다. 이러한 이유로:  
>   
>  -   해시 코드 값을 serialize 하거나 데이터베이스에 저장 하지 마십시오.  
> -   키가 지정 된 컬렉션에서 개체를 검색 하는 키로 해시 코드를 사용 하지 마십시오.  
> -   응용 프로그램 도메인 또는 프로세스 간에 해시 코드를 전송 하지 마십시오. 경우에 따라 프로세스별 또는 응용 프로그램 도메인 별로 해시 코드를 계산할 수 있습니다.  
> -   암호화 된 강력한 해시 해야 할 경우 암호화 해시 함수에서 반환 된 값 대신 해시 코드를 사용 하지 마십시오. 파생 된 클래스를 사용 하 여 암호화 해시에 대 한는 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 또는 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 클래스입니다.  
> -   두 개체가 같은지 여부를 결정 하는 해시 코드의 같음 여부 테스트 하지 마십시오. (같지 않은 개체에 동일한 해시 코드를 있을 수 있습니다.) 같은지 여부를 테스트 하려면 호출는 <xref:System.Object.ReferenceEquals%2A> 또는 <xref:System.Object.Equals%2A> 메서드.  
  
 <xref:System.Object.GetHashCode%2A> 파생 된 형식에서 메서드를 재정의할 수 있습니다. 경우 <xref:System.Object.GetHashCode%2A> 은 재정의 되지 않으면 해시 코드를 호출 하 여 참조 형식을 계산 되는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 참조 하십시오; 자세한 내용은 참조는 개체에 대해 해시 코드를 계산 하는 기본 클래스의 메서드 기반 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>합니다. 즉, 두 개체는 <xref:System.Object.ReferenceEquals%2A> 메서드 반환 `true` 동일한 해시 코드를 있는 합니다. 값 형식을 재정의 하지 않는 경우 <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> 기본 클래스의 메서드 리플렉션을 사용 하 여 해당 형식의 필드의 값을 기반으로 해시 코드를 계산 합니다. 즉, 해당 필드는 같은 값이 값 형식에는 같은 해시 코드가 있습니다. 재정의 대 한 자세한 내용은 <xref:System.Object.GetHashCode%2A>하십시오 "상속자 참고 사항" 섹션을 참조 하세요.  
  
> [!WARNING]
>  재정의 하는 경우는 <xref:System.Object.GetHashCode%2A> 메서드를 재정의 해야 하는 또한 <xref:System.Object.Equals%2A>, 그 반대의 합니다. 경우 재정의 된 <xref:System.Object.Equals%2A> 메서드 반환 `true` 재정의 된 같음에 대 한 두 개체는 검사 될 때 <xref:System.Object.GetHashCode%2A> 메서드는 두 개체에 대해 동일한 값을 반환 해야 합니다.  
  
 해시 테이블에서 키로 사용 되는 개체의 유용한 구현을 경우 제공 하지 않습니다 <xref:System.Object.GetHashCode%2A>를 제공 하 여 해시 코드 공급자를 지정할 수 있습니다는 <xref:System.Collections.IEqualityComparer> 의 오버 로드 중 하나를 구현은 <xref:System.Collections.Hashtable> 클래스 생성자입니다.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>에 대 한 정보는 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 호출 하는 경우는 <xref:System.Object.GetHashCode%2A> 클래스의 메서드는 [!INCLUDE[wrt](~/includes/wrt-md.md)], 재정의 하지 않는 클래스에 대 한 기본 동작을 제공 <xref:System.Object.GetHashCode%2A>합니다. 이것은.NET Framework에 대 한 제공 하는 지원의 일부는 [!INCLUDE[wrt](~/includes/wrt-md.md)] (참조 [.NET Framework 지원에 대 한 Windows 스토어 앱 및 Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). 에 있는 클래스는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 상속 받지 않습니다 <xref:System.Object>, 하 고 구현 하지는 <xref:System.Object.GetHashCode%2A>합니다. 그러나 하기로 표시 <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, 및 <xref:System.Object.GetHashCode%2A> 메서드 C# 또는 Visual Basic 코드에서 사용 하 고.NET Framework에서는 이러한 방법에 대 한 기본 동작을 제공 하는 경우.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] C# 또는 Visual Basic에서 작성 된 클래스에서 재정의할 수는 <xref:System.Object.GetHashCode%2A> 메서드.  
  
   
  
## Examples  
 동일 하거나 보다 작은 범위에는 숫자 값에 대 한 해시 코드를 계산 하는 가장 간단한 방법 중 하나는 <xref:System.Int32> 값 단순히 값을 반환 합니다. 다음 예제에서는 이러한 구현에 대 한는 `Number` 구조입니다.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 대부분의 경우 형식에 해시 코드를 생성에 참여할 수 있는 여러 개의 데이터 필드입니다. 사용 하 여 이러한 필드를 조합 하는 해시 코드를 생성 하는 한 가지 방법은 `XOR (eXclusive OR)` 다음 예제와 같이 작업 합니다.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 앞의 예제 (n1, n2)에 대 한 동일한 해시 코드를 반환 합니다. (n2, n 1) 및 등과 바람직한 것 보다 더 많은 충돌을 생성할 수 있습니다. 솔루션의 수를 사용 하 여 이러한 경우에 해시 코드는 동일 합니다. 해시 코드를 반환 하는 것 하나는 `Tuple` 각 필드의 순서를 반영 하는 개체입니다. 다음 예제에서는 가능한 구현을 사용 하 여 <xref:System.Tuple%602> 클래스입니다. 하지만 인스턴스화하는 성능 오버 헤드는 `Tuple` 개체 해시 테이블에 많은 수의 개체를 저장 하는 응용 프로그램의 전반적인 성능에 큰 영향 수 있습니다.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 두 번째 대체 솔루션으로 비트를 두 개 이상의 연속 된 필드의 해시 코드 왼쪽-이동 하 여 개별 해시 코드를 가중치 포함 됩니다. 최적으로 삭제 되 고 대신 31 비트를 벗어나 이동 비트 주위 하지 않고 삭제 됩니다. 비트 왼쪽 시프트 연산자 C# 및 Visual Basic 모두에 의해는 무시 되는 이후 다음과 같은 왼쪽된 shift 잘림 메서드 만들기 필요 합니다.  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 다음 예제에서는 다음 방법을 사용 하 여이 shift 잘림의 해시 코드를 계산 하는 `Point` 앞의 예제에 사용 되는 구조입니다.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>개체의 값에 해당 하는 숫자 (해시 코드)를 빠르게 생성 하는 해시 함수가 사용 됩니다. 해시 함수는 일반적으로 각 유형에 맞게 하 고 고유성을 위해 사용 해야 인스턴스 필드 중 하나 이상 입력으로 합니다. 정적 필드의 값을 사용 하 여 해시 코드를 계산할 수 해야 합니다.  파생 된 클래스에 <see cref="T:System.Object" />, <see langword="GetHashCode" /> 메서드는 기본 클래스에 게 위임할 수 <see cref="M:System.Object.GetHashCode" /> 파생된 클래스 참조 일치에 일치 여부를 정의 하는 경우에 구현 합니다. 기본 구현은 <see cref="M:System.Object.GetHashCode" /> 참조에 대 한 형식으로 반환 된 것에 해당 하는 해시 코드를 반환 된 <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> 메서드. 재정의할 수 <see cref="M:System.Object.GetHashCode" /> 변경할 수 없는 참조 형식에 대 한 합니다. 일반적으로 변경할 수 있는 참조 형식에 대 한 재정의 해야 <see cref="M:System.Object.GetHashCode" /> 경우에 해당:-; 변경할 수 없는 필드의 해시 코드를 계산할 수 있습니다 또는-변경할 수 있는 개체의 해시 코드는 collecti에 개체가 포함 된 동안 변경 되지 않습니다 확인할 수 있습니다 그에 해당 해시 코드를 사용합니다.  그렇지 않으면 해시 테이블에서 변경할 수 있는 개체를 옮기면 생각할 수 있습니다. 재정의 하려는 경우 <see cref="M:System.Object.GetHashCode" /> 변경 가능한 참조 형식에 대 한 설명서를 수행 하는 형식의 사용자 개체는 해시 테이블에 저장 하는 동안 개체 값을 수정 하지 않아야 함을 명확 하 합니다.  값 형식에 대 한 <see cref="M:System.ValueType.GetHashCode" /> 리플렉션을 사용 하는 기본 해시 코드 구현을 제공 합니다. 성능 향상을 위해 재정의 하는 것이 좋습니다.  <block subset="none" type="note"><para> 자세한 내용과 다양 한 방법에에서 대 한 해시 코드를 계산 하는 예제에 대 한 "예" 섹션을 참조 하십시오.  </para></block>  해시 함수는 다음과 같은 속성이 있어야 합니다.:-두 개체 같음으로 비교 하는 경우는 <see cref="M:System.Object.GetHashCode" /> 각 개체에 대 한 메서드는 같은 값을 반환 해야 합니다. 그러나 경우 두 개체를 동일한 것으로 비교 하지 않습니다는 <see cref="M:System.Object.GetHashCode" /> 두 개체에 대 한 메서드를 다른 값을 반환할 필요가 없습니다.  - <see cref="M:System.Object.GetHashCode" /> 메서드는 개체에 대 한 개체의 [System.Object.Equals](xref:System.Object.Equals*) 방법 반환 값을 결정 하는 개체 상태를 수정 하지 않으면으로 동일한 해시 코드를 일관성 있게 반환 해야 합니다입니다. Note이 응용 프로그램의 현재 실행에 대해서만 true이 고 다른 해시 코드를 응용 프로그램을 다시 실행 하는 경우 반환 될 수 있습니다.  -에 대해 최상의 성능을 얻으려면 해시 함수는 균등 한 분포가 클러스터 과도 하 게 하는 입력을 포함 하 여 모든 입력에 대 한 생성 해야 합니다. 구현은 개체 상태를 작은 수정 해야 최상의 성능 얻으려면 해시 테이블에 대 한 결과 해시 코드를 큰 수정을 될 것입니다.  해시 함수를 계산 하는 데 비용이 취소 해야 합니다.  - <see cref="M:System.Object.GetHashCode" /> 메서드 예외를 throw 하지 않아야 합니다.  구현 예를 들어는 <see cref="M:System.String.GetHashCode" /> 에서 제공 되는 <see cref="T:System.String" /> 클래스 동일한 문자열 값에 대해 동일한 해시 코드를 반환 합니다. 따라서 두 <see cref="T:System.String" /> 동일한 문자열 값을 나타내는 경우 개체는 동일한 해시 코드를 반환 합니다. 또한 메서드를 사용 하 여 모든 문자는 문자열에 입력 특정 범위에 클러스터 된 경우에 무작위 분포 된 출력을 생성 (예를 들어 많은 사용자가 있는 경우에만 낮은 128 ASCII 문자를 포함 하는 문자열을 문자열에 포함할 수 있는 65, 535 유니코드 문자)입니다.  좋은 해시 함수는 클래스에서 제공 하는 해시 테이블에 해당 개체를 추가 하는 성능 크게 저하 될 수 있습니다. 해시 함수를 구현 하는 키가 있는 해시 테이블에서 요소를 검색 시간이 일정 (예: o (1) 작업). 해시 함수의 잘 구현 하는 해시 테이블 검색의 속도 해시 테이블에 있는 항목의 수에 비례 (O('n') 작업 예를 들어 여기서 ' n '은 해시 테이블에서 항목의 수)입니다. 악의적인 사용자는 다음과 같은 경우 해시 테이블에 종속 된 응용 프로그램의 성능을 상당히 저하 될 수 있는 충돌 수를 증가 하는 데이터를 입력할 수:-이 해시 함수는 자주 충돌을 생성 합니다.  -경우 해시 테이블에 있는 개체의 상당 같은지 또는 약 서로 값이 있는 해시 코드를 생성 합니다.  -사용자 입력의 해시 코드 계산 데이터입니다.  재정의 하는 클래스를 파생 <see cref="M:System.Object.GetHashCode" /> 도 재정의 해야 합니다 <see cref="M:System.Object.Equals(System.Object)" /> 되도록 두 개체가 동일한 해시 코드입니다; 그렇지 않으면는 <see cref="T:System.Collections.Hashtable" /> 형식을 올바르게 작동 하지 않을 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>현재 인스턴스의 정확한 런타임 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때문에 <xref:System.Object?displayProperty=nameWithType> 는.NET Framework 형식 시스템의 모든 형식에 대 한 기본 클래스는 <xref:System.Object.GetType%2A> 메서드를 사용 하 여 반환할 수 있습니다 <xref:System.Type> 모든.NET Framework 형식을 나타내는 개체입니다. .NET Framework에는 다음과 같은 다섯 가지 범주의 형식 인식합니다.  
  
-   파생 되는 클래스를 <xref:System.Object?displayProperty=nameWithType>,  
  
-   값 형식에서 파생 <xref:System.ValueType?displayProperty=nameWithType>합니다.  
  
-   인터페이스에서 파생 되는 <xref:System.Object?displayProperty=nameWithType> .NET Framework 2.0부터 시작 합니다.  
  
-   열거형에서 파생 된 <xref:System.Enum?displayProperty=nameWithType>합니다.  
  
-   파생 되는 대리자 <xref:System.MulticastDelegate?displayProperty=nameWithType>합니다.  
  
 두 개체에 대 한 `x` 및 `y` 동일한 런타임 형식이 있는 `Object.ReferenceEquals(x.GetType(),y.GetType())` 반환 `true`합니다. 다음 예제에서는 <xref:System.Object.GetType%2A> 메서드는 <xref:System.Object.ReferenceEquals%2A> 하나의 숫자 값이 동일한 두 개의 다른 숫자 값 형식이 있는지 여부를 결정 하는 메서드.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  개체는 특정 형식 인지를 확인 하려면 해당 언어의 형식을 비교 키워드를 사용 하거나 생성 수 있습니다. 예를 들어, 사용할 수는 `TypeOf…Is` Visual Basic의 생성 또는 `is` C# 키워드입니다.  
  
 <xref:System.Object.GetType%2A> 메서드에서 파생 되는 모든 형식에서 상속 되 <xref:System.Object>합니다. 즉, 즉, 사용자 고유의 언어의 비교 키워드를 사용 하는 것 외에도 사용할 수 있습니다는 <xref:System.Object.GetType%2A> 메서드를 다음 예제와 같이 특정 개체의 유형을 결정 합니다.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type> 현재 클래스와 연결 된 메타 데이터를 노출 하는 개체 <xref:System.Object>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 것을 보여 줍니다 <xref:System.Object.GetType%2A> 현재 인스턴스의 런타임 형식을 반환 합니다.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Object" />의 단순 복사본을 만듭니다.</summary>
        <returns>현재 <see cref="T:System.Object" />의 단순 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A> 메서드는 새 개체를 만들고 다음 새 개체를 현재 개체의 비정적 필드에 복사 하 여 단순 복사본을 만듭니다. 필드 값 형식이 필드의 비트 단위로 복사가 수행 됩니다. 필드 참조 형식인 경우 참조를 복사할 수 있지만 참조 된 개체는 필요는 없습니다. 따라서 원래 개체 퓨 터와 복제본 같은 개체를 참조 합니다.  
  
 예를 들어 3. 참조 개체를 참조 하는 개체 A 개체 B 차례로 X 라는 개체 X의 단순 복사본을 만듭니다 개체 A와 B를 참조 하는 새 개체 X2 반면, X의 전체 복사본을 A2 및 b 2를 A의 복사본 인 새 개체를 참조 하는 새 개체 X2 만들고 B. b 2 C의 복사본 인 새 개체 C2, 참조 이 예제에서는 단순 복사와 전체 복사 작업의 차이점을 보여 줍니다.  
  
 단순 복사 작업을 수행할 경우 전체 복사 작업을 구현 하는 방법은 여러 가지가 <xref:System.Object.MemberwiseClone%2A> 메서드 요구를 충족 하지 않습니다. 이러한 요구 사항은 다음과 같습니다.  
  
-   첫 번째 개체에서 가져온 속성 값을 사용 하 여 두 번째 개체를 만들려면 복사할 개체의 클래스 생성자를 호출 합니다. 이 개체의 값 클래스 생성자에 의해 완전히 정의 가정 합니다.  
  
-   호출 된 <xref:System.Object.MemberwiseClone%2A> 메서드를 개체의 단순 복사본을 만들고 해당 값은 모든 속성이 나 필드 값은 참조 형식에 원래 개체와 동일한 새 개체를 할당 합니다. `DeepCopy` 메서드 예제에서이 방법을 보여 줍니다.  
  
-   복사 하 고, 심층 되도록 개체를 직렬화 하 고 서로 다른 개체 변수에 serialize 된 데이터를 복원 합니다.  
  
-   재귀 리플렉션을 사용 하 여 전체 복사 작업을 수행 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Object.MemberwiseClone%2A> 메서드. 정의 `ShallowCopy` 메서드를 호출 하는 <xref:System.Object.MemberwiseClone%2A> 에 단순 복사 작업을 수행 하는 메서드는 `Person` 개체입니다. 또한 정의 `DeepCopy` 전체 복사 작업에 대해 수행 하는 메서드는 `Person` 개체입니다.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 이 예제에서는 `Person.IdInfo` 속성에서 반환 된 `IdInfo` 개체입니다. 예제에서 출력으로 때는 `Person` 개체를 호출 하 여 복제 되는 <xref:System.Object.MemberwiseClone%2A> 메서드, 복제 된 `Person` 제외 하 고 동일한 공유 개체는 원래 개체의 독립 복사본 `Person.IdInfo` 개체 참조입니다. 결과적으로, 복제본의 수정 `Person.IdInfo` 원래 개체의 속성이 변경 될 `Person.IdInfo` 속성입니다. 반면에 전체 복사 작업을 수행 될 때, 복제 된 `Person` 개체를 포함 하 여 해당 `Person.IdInfo` 원래 개체에 영향을 주지 않고 속성을 수정할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">비교할 첫 번째 개체입니다.</param>
        <param name="objB">비교할 두 번째 개체입니다.</param>
        <summary>지정한 <see cref="T:System.Object" /> 인스턴스가 동일한지 여부를 확인합니다.</summary>
        <returns>
          <paramref name="objA" />와 <paramref name="objB" />의 인스턴스가 같거나 둘 다 **null**인 경우 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 달리는 <xref:System.Object.Equals%2A> 메서드 및 같음 연산자는 <xref:System.Object.ReferenceEquals%2A> 메서드를 재정의할 수 없습니다. 이 인해 테스트 하려는 경우 두 개체 같음에 대 한 참조 및의 구현에 대 한 확실 하지 않은 `Equals` 메서드를 호출할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A> 메서드.  
  
 그러나의 반환 값은 <xref:System.Object.ReferenceEquals%2A> 메서드는 이러한 두 가지 시나리오에서 비정상으로 나타날 수 있습니다.  
  
-   값 형식을 비교 합니다. 경우 `objA` 및 `objB` 는 값 형식이 boxed에 전달 되기 전에 <xref:System.Object.ReferenceEquals%2A> 메서드. 즉, 모두 `objA` 및 `objB` 값 형식을 동일한 인스턴스는 <xref:System.Object.ReferenceEquals%2A> 메서드 그럼에도 불구 하 고 반환 `false`다음 예제와 같이 합니다.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Boxing 값 형식에 대 한 자세한 내용은 참조 하십시오. [Boxing 및 Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)합니다.  
  
-   문자열 비교 합니다. 경우 `objA` 및 `objB` 은 문자열이 <xref:System.Object.ReferenceEquals%2A> 메서드 반환 `true` 문자열 내부 풀에 추가 하는 경우. 값이 동일한 테스트를 수행 하지 않습니다.  다음 예에서 `s1` 및 `s2` 은 단일 인턴 지정된 문자열의 두 인스턴스 되기 때문에 동일 합니다. 그러나 `s3` 및 `s4` 해당 문자열이 인턴 지정 동일한 문자열 값을가 없지만 때문에, 같지 않습니다.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     문자열 인터닝에 대 한 자세한 내용은 참조 <xref:System.String.IsInterned%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Object.ReferenceEquals%2A> 두 개체가 동일한 인스턴스에를 확인 합니다.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 개체를 나타내는 문자열을 반환합니다.</summary>
        <returns>현재 개체를 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 주 서식 지정 메서드에.NET Framework의 합니다. 표시에 적합 한 되도록 개체를 문자열 표현으로 변환 합니다. (.NET framework에서 지원 형식에 대 한 정보를 참조 하십시오. [형식 지정](~/docs/standard/base-types/formatting-types.md).) 기본 구현은 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드는 개체 형식의 정규화 된 이름을 반환 합니다.  
  
> [!IMPORTANT]
>  다른 형식의 멤버 목록에서 링크를 수행 하 여이 페이지로 이동 하면 합니다. 해당 형식을 재정의 하지 않는 때문 <xref:System.Object.ToString%2A?displayProperty=nameWithType>합니다. 대신,의 기능을 상속 되는 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드.  
  
 형식은 자주 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 특정 유형의 더 적합 한 문자열 표현을 제공 합니다. 형식은 자주 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 형식 문자열 또는 문화권 구분 서식 지정에 대 한 지원을 제공 합니다.  
  
 섹션 내용  
  
 [기본 Object.ToString() 메서드](#Default)   
 [Object.ToString() 메서드 재정의](#Overriding)   
 [ToString 메서드를 오버 로드](#Overloading)   
 [Object.ToString 메서드를 확장합니다.](#Extending)   
 [Windows 런타임에 대 한 참고 사항](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>기본 Object.ToString() 메서드  
 기본 구현에서 <xref:System.Object.ToString%2A> 메서드 반환 형식의 정규화 된 이름을 <xref:System.Object>다음 예제와 같이 합니다.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 때문에 <xref:System.Object> 모든 참조 형식의 기본 클래스는.NET framework에서는이 동작 재정의 하지 않는 참조 형식에 상속 되는 <xref:System.Object.ToString%2A> 메서드. 다음은 이에 대한 예입니다. 클래스를 정의 `Object1` 를 받는 모든의 기본 구현은 <xref:System.Object> 멤버입니다. 해당 <xref:System.Object.ToString%2A> 메서드는 개체의 정규화 된 형식 이름을 반환 합니다.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Object.ToString() 메서드 재정의  
 형식은 일반적으로 재정의 하는 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드 개체 인스턴스를 나타내는 문자열을 반환 합니다. 예를 들어와 같은 기본 형식은 <xref:System.Char>, <xref:System.Int32>, 및 <xref:System.String> 제공 <xref:System.Object.ToString%2A> 문자열 형식의 개체를 나타내는 값을 반환 하는 구현 합니다. 다음 예제에서는 클래스를 정의 `Object2`, 재정의 하는 <xref:System.Object.ToString%2A> 형식 이름과 해당 값을 반환 하는 메서드.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 다음 표에서.NET Framework의 형식 범주를 나열 하 고 재정의 여부를 나타내는 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드.  
  
|형식 범주|Object.ToString() 재정의|동작|  
|-------------------|-----------------------------------|--------------|  
|클래스|N/A|N/A|  
|구조체|예 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Object.ToString()와 동일|  
|열거형|예 (<xref:System.Enum.ToString?displayProperty=nameWithType>)|멤버 이름|  
|인터페이스|아니요|N/A|  
|대리자|아니요|N/A|  
  
 재정의에 대 한 자세한 내용은 상속자 참고 사항 섹션에 메모를 참조 하세요. <xref:System.Object.ToString%2A>합니다.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>ToString 메서드를 오버 로드  
 매개 변수가 없는 재정의 하는 것 외에도 <xref:System.Object.ToString?displayProperty=nameWithType> 메서드, 다양 한 형식을 오버 로드는 `ToString` 매개 변수를 허용 하는 방법의 버전을 제공 하는 메서드. 가장 일반적으로 이것은 변수 형식 지정 및 문화권 구분 서식 지정에 대 한 지원을 제공 합니다.  
  
 다음 예에서는 오버 로드는 `ToString` 의 다양 한 필드의 값을 포함 하는 결과 문자열을 반환 하는 메서드는 `Automobile` 클래스입니다. 4 개의 형식 문자열을 정의: 모델 이름 및 연도 반환 하는 G 모델 이름, 연도, 및; 도어 수를 반환 하는 D 모델 이름, 연도 및 실린더; 수를 반환 하는 C 및 A에는 모든 4 개의 필드 값이 포함 된 문자열을 반환 합니다.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 다음 예제에서는 호출 오버 로드 된 <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드를 통화 값의 문화권 구분 서식 지정을 표시 합니다.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 문화권 구분 서식 지정 및 형식 문자열에 대 한 자세한 내용은 참조 하십시오. [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다. 숫자 값에서 지원 되는 형식 문자열에 대 한 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 날짜 및 시간 값에서 지원 되는 형식 문자열에 대 한 참조 [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 및 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다.  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Object.ToString 메서드를 확장합니다.  
 기본값을 상속 하는 형식은 때문에 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 있습니다 동작 바람직하지 않은 찾아서 변경할 것입니다. 배열 및 컬렉션 클래스의 경우 특히 그렇습니다. 수 있지만 `ToString` 메서드는 배열 또는 컬렉션 클래스의 해당 멤버의 값을 표시 하려면 대신 표시 형식을 정규화 된 형식 이름을 다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 원하는 결과 문자열을 생성 하는 몇 가지 옵션이 있습니다.  
  
-   형식이 배열, 컬렉션 개체 또는 구현 하는 개체는 <xref:System.Collections.IEnumerable> 또는 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스를 사용 하 여 해당 요소를 열거할 수 있습니다는 `foreach` C# 문 또는 `For Each...Next` Visual Basic에서 구성 합니다.  
  
-   클래스가 없으면 `sealed` (C#에서) 또는 `NotInheritable` (Visual Basic의 경우)의 해당 기본 클래스에서 상속 되는 래퍼 클래스를 개발할 수 있습니다 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 사용자 지정 하려는 방법입니다. 여기에 최소한 다음을 수행 하면이 필요 합니다.  
  
    1.  필요한 생성자를 구현 합니다. 파생된 클래스의 기본 클래스 생성자를 상속 하지 않습니다.  
  
    2.  재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 선택 하는 결과 문자열을 반환 합니다.  
  
     다음 예제에 대 한 래퍼 클래스 정의 <xref:System.Collections.Generic.List%601> 클래스입니다. 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드 정규화 된 형식 이름이 아닌 컬렉션의 각 방법의 값을 표시 합니다.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   개발는 [확장 메서드](~/docs/standard/design-guidelines/extension-methods.md) 원하는 결과 문자열을 반환 하는 합니다. 기본값을 재정의할 수 없습니다 참고 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 이러한 방식으로 메서드 (확장 클래스 (C#) 또는 (Visual Basic)에서는 모듈 라는 매개 변수가 없는 메서드를 사용할 수 없습니다, 즉 `ToString` 원래 형식 대신 호출 되 `ToString` 메서드 . 프로그램 매개 변수가 없는 대 한 몇 가지 다른 이름을 제공 해야 합니다. `ToString` 대체 합니다.  
  
     다음 예제에서는 정의 확장 하는 두 가지 방법은 <xref:System.Collections.Generic.List%601> 클래스: 매개 변수가 없는 `ToString2` 메서드를 및 `ToString` 사용 하 여 메서드는 <xref:System.String> 서식 문자열을 나타내는 매개 변수입니다.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>에 대 한 정보는 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 호출 하는 경우는 <xref:System.Object.ToString%2A> 클래스의 메서드는 [!INCLUDE[wrt](~/includes/wrt-md.md)], 재정의 하지 않는 클래스에 대 한 기본 동작을 제공 <xref:System.Object.ToString%2A>합니다. 이것은.NET Framework에 대 한 제공 하는 지원의 일부는 [!INCLUDE[wrt](~/includes/wrt-md.md)] (참조 [.NET Framework 지원에 대 한 Windows 스토어 앱 및 Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). 에 있는 클래스는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 상속 받지 않습니다 <xref:System.Object>, 고 항상 구현 하지는 <xref:System.Object.ToString%2A>합니다. 그러나 항상 보이도록가 <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, 및 <xref:System.Object.GetHashCode%2A> 메서드 C# 또는 Visual Basic 코드에서 사용 하 고.NET Framework에서는 이러한 방법에 대 한 기본 동작을 제공 하는 경우.  
  
 부터는 [!INCLUDE[net_v451](~/includes/net-v451-md.md)], 공용 언어 런타임 ´ ֲ [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 에 [!INCLUDE[wrt](~/includes/wrt-md.md)] 개체의 기본 구현은로 대체 되기 이전의 <xref:System.Object.ToString%2A?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] C# 또는 Visual Basic에서 작성 된 클래스에서 재정의할 수는 <xref:System.Object.ToString%2A> 메서드.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] 와 IStringable 인터페이스  
 부터는 [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] 포함는 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 인터페이스의 단일 메서드인 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), 기본 서식 지정 지원을 제공 하는 제공한 <xref:System.Object.ToString%2A?displayProperty=nameWithType>합니다. 명확 하 게 하려면 구현 해서는 안 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 에 관리 되는 형식입니다.  
  
 네이티브 코드 또는 JavaScript 또는 C + 등의 언어로 작성 된 코드에서 관리 되는 개체 호출 될 때 + /CX에서는 표시 되는 구현 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)합니다. 공용 언어 런타임의 호출을 자동으로 라우팅하므로 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 를 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 이벤트 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 관리 되는 개체에서 구현 되지 않습니다.  
  
> [!WARNING]
>  공용 언어 런타임 자동 구현 하기 때문에 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 모든 관리 되는 형식에서 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 응용 프로그램, 권장는 제공 하지 않으면 고유한 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 구현 합니다. 구현 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 호출 하는 경우 의도 하지 않은 동작이 발생할 수 있습니다 `ToString` 에서 [!INCLUDE[wrt](~/includes/wrt-md.md)], C + + /CX에서는 또는 JavaScript 합니다.  
  
 구현 하기로 선택한 경우 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 에 내보내진 관리 되는 공용 형식에는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 구성 요소를 다음과 같은 제한 사항이 적용 됩니다.  
  
-   정의할 수는 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 와 같은 "클래스 구현" 관계 에서만에서 인터페이스  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     C#  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     Visual Basic  
  
-   구현할 수 없습니다 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 인터페이스에 있습니다.  
  
-   형식 매개 변수를 선언할 수 없습니다 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)합니다.  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 반환 형식의 메서드, 속성 또는 필드 일 수 없습니다.  
  
-   숨길 수 없습니다 프로그램 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 다음과 같은 메서드 정의 사용 하 여 기본 클래스에서 구현 합니다.  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     대신,는 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 구현은 항상 기본 클래스 구현을 재정의 해야 합니다. 강력한 형식의 클래스 인스턴스에서 호출해야만 `ToString` 구현을 숨길 수 있습니다.  
  
 여러 가지 다른 조건에서에서 호출 하는 네이티브 코드를 구현 하는 관리 되는 형식 참고 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 표시 하거나 숨깁니다 해당 [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 구현 예기치 않은 동작이 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 해야 형식을 사용자를 구현할 때는 <see cref="M:System.Object.ToString" /> 메서드를 이러한 형식에 대 한 의미 있는 값을 반환 합니다. 보다 서식을 더 많이 제어할 필요가 있는 클래스를 파생 <see cref="M:System.Object.ToString" /> 제공 구현할 수는 <see cref="T:System.IFormattable" /> 인터페이스입니다. 해당 <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> 메서드를 사용 하면 서식 지정을 제어 하는 형식 문자열을 정의 하 고 사용 하는 <see cref="T:System.IFormatProvider" /> culture 별 서식 지정에 제공할 수 있는 개체입니다.  재정의 <see cref="M:System.Object.ToString" /> 메서드 다음이 지침을 따르십시오:-친숙 하 고 사용자가 읽을 수는 반환 된 문자열 이어야 합니다.  -는 반환 된 문자열 개체 인스턴스의 값을 고유 하 게 식별 해야 합니다.  -는 반환 된 문자열 해야 가능한 한 짧게 하므로 디버거에 표시 하기에 적합 합니다.  - <see cref="M:System.Object.ToString" /> 재정의 반환 해서는 안 <see cref="F:System.String.Empty" /> 또는 null 문자열입니다.  - <see cref="M:System.Object.ToString" /> 재정의 예외를 throw 해서는 안 됩니다.  -인스턴스의 문자열 표현을 문화권을 구분 하거나 여러 가지 방법으로 서식을 지정할 수 있습니다, 경우에 구현 된 <see cref="T:System.IFormattable" /> 인터페이스입니다.  -반환 되는 문자열에서 중요 한 정보를 포함 하는 경우 적절 한 권한이 먼저 요청 해야 합니다. 요청이 성공 하면; 중요 한 정보를 반환할 수 있습니다. 그렇지 않으면 중요 한 정보를 제외 하는 문자열을 반환 해야 합니다.  - <see cref="M:System.Object.ToString" /> 재정의 디버깅에 문제가 발생 하지 않도록 하려면 observable 파생 작업이 있어야 합니다. 에 대 한 호출 예를 들어는 <see cref="M:System.Object.ToString" /> 메서드는 인스턴스 필드의 값을 바꾸지 않아야 합니다.  -사용자 형식을 구문 분석 방법을 구현 하는 경우 (또는 <see langword="Parse" /> 또는 <see langword="TryParse" /> 메서드, 생성자 또는 문자열에서 형식의 인스턴스를 인스턴스화하는 다른 정적 메서드)를 반환 하는 문자열 확인 해야는 <see cref="M:System.Object.ToString" /> 메서드 일 수 있습니다 개체 인스턴스로 변환 합니다.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>