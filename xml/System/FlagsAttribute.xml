<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FlagsAttribute.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b4a43daf94141e166fdacae6f0ba6f4be584c7b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b4a43daf94141e166fdacae6f0ba6f4be584c7b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.FlagsAttribute">
          <source>Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</source>
          <target state="translated">열거형을 비트 필드 즉, 플래그 집합으로 처리할 수 있음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</source>
          <target state="translated">비트 필드는 열거형 상수는 일반적으로 함께 사용할 수 없는 요소의 목록을 사용 하는 반면 조합에서 발생할 수 있는 요소의 목록에 대 한 일반적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</source>
          <target state="translated">따라서 비트 필드는 열거 상수에는 없는 반면 명명 되지 않은 값을 생성 하는 비트 OR 연산을 함께 사용 하도록 설계 되었습니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Languages vary in their use of bit fields compared to enumeration constants.</source>
          <target state="translated">언어와 열거형 상수는 비트 필드의 용도 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Attributes of the FlagsAttribute</source>
          <target state="translated">FlagsAttribute 특성</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> is applied to this class, and its <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> property specifies <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> 이 클래스에 적용 되 고 해당 <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> 속성 지정 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This attribute can only be applied to enumerations.</source>
          <target state="translated">이 특성은 열거형에만 적용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Guidelines for FlagsAttribute and Enum</source>
          <target state="translated">FlagsAttribute 및 e m '에 대 한 지침</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use the <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</source>
          <target state="translated">사용 된 <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> 연산을 (AND, OR, 포함 또는 제외)는 숫자 값에서 수행 해야 하는 경우에 열거형에 대 한 사용자 지정 특성입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</source>
          <target state="translated">즉, 1, 2, 4, 8, 등에 2의 거듭제곱에 열거 상수를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This means the individual flags in combined enumeration constants do not overlap.</source>
          <target state="translated">즉, 개별 플래그 조합 된 열거형 상수에 겹치지 않습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consider creating an enumerated constant for commonly used flag combinations.</source>
          <target state="translated">일반적으로 사용 하는 플래그 조합에 대 한 열거형된 상수를 만드는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, if you have an enumeration used for file I/O operations that contains the enumerated constants <ph id="ph1">`Read = 1`</ph> and <ph id="ph2">`Write = 2`</ph>, consider creating the enumerated constant <ph id="ph3">`ReadWrite = Read OR Write`</ph>, which combines the <ph id="ph4">`Read`</ph> and <ph id="ph5">`Write`</ph> flags.</source>
          <target state="translated">예를 들어 파일 I/O 작업에 사용 되는 열거형을 사용 하는 경우 포함 하는 열거 상수 <ph id="ph1">`Read = 1`</ph> 및 <ph id="ph2">`Write = 2`</ph>, 열거형된 상수를 만드는 것이 좋습니다 <ph id="ph3">`ReadWrite = Read OR Write`</ph>, 결합 하 여 <ph id="ph4">`Read`</ph> 및 <ph id="ph5">`Write`</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</source>
          <target state="translated">또한 OR 연산은 플래그를 조합 하는 데 사용 하지 않아야 하는 간단한 작업에 필요한 경우에 따라 고급 개념을 간주 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</source>
          <target state="translated">여러 플래그 위치가 혼동 코드를 만들 수 있습니다 및 코딩 오류 들이 1로 설정할 수 때문에 플래그 열거 상수 음수를 정의 하는 경우에 주의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</source>
          <target state="translated">숫자 값과 플래그에 해당 하지 않는 0으로 숫자 값의 모든 비트를 설정 하는 플래그 열거 상수를 사이 비트 AND 연산을 수행 하는 숫자 값에는 플래그가 설정 되어 있는지 여부를 테스트 하는 편리한 방법 그런 다음 해당 작업의 결과 플래그 열거형된 상수와 같은지 여부를 테스트 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use <ph id="ph1">`None`</ph> as the name of the flag enumerated constant whose value is zero.</source>
          <target state="translated">사용 하 여 <ph id="ph1">`None`</ph> 플래그의 이름을 값이 0 인 상수를 열거 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>You cannot use the <ph id="ph1">`None`</ph> enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</source>
          <target state="translated">사용할 수 없습니다는 <ph id="ph1">`None`</ph> 플래그에 대 한 테스트 결과 항상 0 이므로 비트 AND 연산 열거 된 상수입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>However, you can perform a logical, not a bitwise, comparison between the numeric value and the <ph id="ph1">`None`</ph> enumerated constant to determine whether any bits in the numeric value are set.</source>
          <target state="translated">그러나 수행할 수 있습니다는 논리 숫자 값 간에 비트, 비교 하지 및 <ph id="ph1">`None`</ph> 숫자 값의 모든 비트가 설정 되었는지 여부를 결정 하는 열거형된 상수입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a <ph id="ph1">`None`</ph> enumerated constant.</source>
          <target state="translated">여전히 열거형 플래그 열거 하는 대신 값 열거를 만드는 경우는 <ph id="ph1">`None`</ph> 열거형된 상수입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</source>
          <target state="translated">기본적으로 0으로 열거형에 사용 되는 메모리 초기화 되는 이유는 공용 언어 런타임에 의해 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</source>
          <target state="translated">따라서 값이 0 인 상수를 정의 하지 않는 경우 만들어질 때 열거형 잘못 된 값이 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</source>
          <target state="translated">응용 프로그램에서 표시 해야 하는 명확한 기본 경우가 이면 값이 기본값을 나타내기 위해 0 인 열거형된 상수를 사용 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</source>
          <target state="translated">기본 케이스가 없는 경우에 다른 열거 상수 중 하나로 표시 되지 않는 경우를 의미 하는 0 값은 열거형된 상수를 사용 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not define an enumeration value solely to mirror the state of the enumeration itself.</source>
          <target state="translated">열거형 값의 형식은 열거형의 상태를 미러링 하는 데에 정의 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, do not define an enumerated constant that merely marks the end of the enumeration.</source>
          <target state="translated">예를 들어 단순히 열거형의 끝을 표시 하는 열거형된 상수를 정의 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you need to determine the last value of the enumeration, check for that value explicitly.</source>
          <target state="translated">열거형의 마지막 값을 결정 해야 하는 경우 해당 값을 명시적으로 확인 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</source>
          <target state="translated">또한 범위 내 모든 값을 사용할 경우 첫 번째 및 마지막 열거 상수에 대 한 범위 검사를 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not specify enumerated constants that are reserved for future use.</source>
          <target state="translated">나중에 사용 하도록 예약 된 열거 상수를 지정 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>When you define a method or property that takes an enumerated constant as a value, consider validating the value.</source>
          <target state="translated">메서드 또는 값으로는 열거형된 상수를 사용 하는 속성을 정의할 때 값 유효성을 검사 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</source>
          <target state="translated">이유는이 숫자 값을 열거형에 정의 되지 않은 경우에 숫자 값을 열거형 형식으로 캐스팅할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">`FlagsAttribute`</ph> 특성 및에 영향을 보여 줍니다.는 <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> 메서드를 사용 하 여 <ph id="ph3">`FlagsAttribute`</ph> 에 <ph id="ph4">&lt;xref:System.Enum&gt;</ph> 선언 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example defines two color-related enumerations, <ph id="ph1">`SingleHue`</ph> and <ph id="ph2">`MultiHue`</ph>.</source>
          <target state="translated">다음 예제에서는 두 가지 색상 관련 열거형 <ph id="ph1">`SingleHue`</ph> 및 <ph id="ph2">`MultiHue`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The latter has the <ph id="ph1">`FlagsAttribute`</ph> attribute; the former does not.</source>
          <target state="translated"><ph id="ph1">`FlagsAttribute`</ph> 특성; 전자는 그렇지 않습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</source>
          <target state="translated">이 예제는 범위의 정수를 열거형 형식의 기본 값을 나타내지 않는 정수를 포함 하 여 열거 형식 및 표시 문자열 표현으로 캐스팅 하는 경우 동작의 차이 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, note that 3 cannot be represented as a <ph id="ph1">`SingleHue`</ph> value because 3 is not the underlying value of any <ph id="ph2">`SingleHue`</ph> member, whereas the <ph id="ph3">`FlagsAttribute`</ph> attribute makes it possible to represent 3 as a <ph id="ph4">`MultiHue`</ph> value of <ph id="ph5">`Black, Red`</ph>.</source>
          <target state="translated">예를 들어 3로 나타낼 수 없는 유의 <ph id="ph1">`SingleHue`</ph> 3의 모든 기본 값 없기 때문에 값 <ph id="ph2">`SingleHue`</ph> 멤버 반면는 <ph id="ph3">`FlagsAttribute`</ph> 특성을 사용 하면 3으로 나타낼 수는 <ph id="ph4">`MultiHue`</ph> 값 <ph id="ph5">`Black, Red`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.FlagsAttribute.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example defines a <ph id="ph1">`PhoneService`</ph> enumeration that represents forms of communication provided by a telephone company.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`PhoneService`</ph> 통신 회사에서 제공 하는 통신의 형태를 나타내는 열거형입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</source>
          <target state="translated">세 명의 다른 명인 가구에 제공 되는 서비스를 나타내는 세 개의 변수를 초기화 하 고 나타냅니다는 명인 가구 어떤 명인 가구 휴대 전화 서비스만 있고 어떤 명인 가구 휴대 전화 및 토지 모두 줄 서비스가 서비스가 없습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>Finally, it implicitly calls the <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method to display the types of service provided to each household.</source>
          <target state="translated">마지막으로 암시적으로 호출 하는 <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> 메서드를 각 가계에 제공 되는 서비스 유형을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">`FlagsAttribute`</ph> 특성 및에 영향을 보여 줍니다.는 <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> 메서드를 사용 하 여 <ph id="ph3">`FlagsAttribute`</ph> 에 <ph id="ph4">&lt;xref:System.Enum&gt;</ph> 선언 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>