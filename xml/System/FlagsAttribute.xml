<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4b2417901d3ec970c72a2c6cc0524b2108855ce0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431666" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="a0eef-101">열거형을 비트 필드 즉, 플래그 집합으로 처리할 수 있음을 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0eef-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0eef-102">비트 필드는 열거형 상수는 일반적으로 함께 사용할 수 없는 요소의 목록을 사용 하는 반면 조합에서 발생할 수 있는 요소의 목록에 대 한 일반적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="a0eef-103">따라서 비트 필드는 열거 상수에는 없는 반면 명명 되지 않은 값을 생성 하는 비트 OR 연산을 함께 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="a0eef-104">언어와 열거형 상수는 비트 필드의 용도 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="a0eef-105">FlagsAttribute 특성</span><span class="sxs-lookup"><span data-stu-id="a0eef-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="a0eef-106"><xref:System.AttributeUsageAttribute> 이 클래스에 적용 되 고 해당 <xref:System.AttributeUsageAttribute.Inherited%2A> 속성 지정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="a0eef-107">이 특성은 열거형에만 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="a0eef-108">FlagsAttribute 및 e m '에 대 한 지침</span><span class="sxs-lookup"><span data-stu-id="a0eef-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="a0eef-109">사용 된 <xref:System.FlagsAttribute> 연산을 (AND, OR, 포함 또는 제외)는 숫자 값에서 수행 해야 하는 경우에 열거형에 대 한 사용자 지정 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="a0eef-110">즉, 1, 2, 4, 8, 등에 2의 거듭제곱에 열거 상수를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="a0eef-111">즉, 개별 플래그 조합 된 열거형 상수에 겹치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="a0eef-112">일반적으로 사용 하는 플래그 조합에 대 한 열거형된 상수를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="a0eef-113">예를 들어 파일 I/O 작업에 사용 되는 열거형을 사용 하는 경우 포함 하는 열거 상수 `Read = 1` 및 `Write = 2`, 열거형된 상수를 만드는 것이 좋습니다 `ReadWrite = Read OR Write`, 결합 하 여 `Read` 및 `Write` 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="a0eef-114">또한 OR 연산은 플래그를 조합 하는 데 사용 하지 않아야 하는 간단한 작업에 필요한 경우에 따라 고급 개념을 간주 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="a0eef-115">여러 플래그 위치가 혼동 코드를 만들 수 있습니다 및 코딩 오류 들이 1로 설정할 수 때문에 플래그 열거 상수 음수를 정의 하는 경우에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="a0eef-116">숫자 값과 플래그에 해당 하지 않는 0으로 숫자 값의 모든 비트를 설정 하는 플래그 열거 상수를 사이 비트 AND 연산을 수행 하는 숫자 값에는 플래그가 설정 되어 있는지 여부를 테스트 하는 편리한 방법 그런 다음 해당 작업의 결과 플래그 열거형된 상수와 같은지 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="a0eef-117">사용 하 여 `None` 플래그의 이름을 값이 0 인 상수를 열거 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="a0eef-118">사용할 수 없습니다는 `None` 플래그에 대 한 테스트 결과 항상 0 이므로 비트 AND 연산 열거 된 상수입니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="a0eef-119">그러나 수행할 수 있습니다는 논리 숫자 값 간에 비트, 비교 하지 및 `None` 숫자 값의 모든 비트가 설정 되었는지 여부를 결정 하는 열거형된 상수입니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="a0eef-120">여전히 열거형 플래그 열거 하는 대신 값 열거를 만드는 경우는 `None` 열거형된 상수입니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="a0eef-121">기본적으로 0으로 열거형에 사용 되는 메모리 초기화 되는 이유는 공용 언어 런타임에 의해 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="a0eef-122">따라서 값이 0 인 상수를 정의 하지 않는 경우 만들어질 때 열거형 잘못 된 값이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="a0eef-123">응용 프로그램에서 표시 해야 하는 명확한 기본 경우가 이면 값이 기본값을 나타내기 위해 0 인 열거형된 상수를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="a0eef-124">기본 케이스가 없는 경우에 다른 열거 상수 중 하나로 표시 되지 않는 경우를 의미 하는 0 값은 열거형된 상수를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="a0eef-125">열거형 값의 형식은 열거형의 상태를 미러링 하는 데에 정의 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="a0eef-126">예를 들어 단순히 열거형의 끝을 표시 하는 열거형된 상수를 정의 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="a0eef-127">열거형의 마지막 값을 결정 해야 하는 경우 해당 값을 명시적으로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="a0eef-128">또한 범위 내 모든 값을 사용할 경우 첫 번째 및 마지막 열거 상수에 대 한 범위 검사를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="a0eef-129">나중에 사용 하도록 예약 된 열거 상수를 지정 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="a0eef-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="a0eef-130">메서드 또는 값으로는 열거형된 상수를 사용 하는 속성을 정의할 때 값 유효성을 검사 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="a0eef-131">이유는이 숫자 값을 열거형에 정의 되지 않은 경우에 숫자 값을 열거형 형식으로 캐스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0eef-132">다음 예제에서는 `FlagsAttribute` 특성 및에 영향을 보여 줍니다.는 <xref:System.Enum.ToString%2A> 메서드를 사용 하 여 `FlagsAttribute` 에 <xref:System.Enum> 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="a0eef-133">다음 예제에서는 두 가지 색상 관련 열거형 `SingleHue` 및 `MultiHue`합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="a0eef-134">`FlagsAttribute` 특성; 전자는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="a0eef-135">이 예제는 범위의 정수를 열거형 형식의 기본 값을 나타내지 않는 정수를 포함 하 여 열거 형식 및 표시 문자열 표현으로 캐스팅 하는 경우 동작의 차이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="a0eef-136">예를 들어 3로 나타낼 수 없는 유의 `SingleHue` 3의 모든 기본 값 없기 때문에 값 `SingleHue` 멤버 반면는 `FlagsAttribute` 특성을 사용 하면 3으로 나타낼 수는 `MultiHue` 값 `Black, Red`합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0eef-137">
            <see cref="T:System.FlagsAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0eef-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0eef-138">다음 예제에서는 정의 `PhoneService` 통신 회사에서 제공 하는 통신의 형태를 나타내는 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="a0eef-139">세 명의 다른 명인 가구에 제공 되는 서비스를 나타내는 세 개의 변수를 초기화 하 고 나타냅니다는 명인 가구 어떤 명인 가구 휴대 전화 서비스만 있고 어떤 명인 가구 휴대 전화 및 토지 모두 줄 서비스가 서비스가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="a0eef-140">마지막으로 암시적으로 호출 하는 <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> 메서드를 각 가계에 제공 되는 서비스 유형을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="a0eef-141">다음 예제에서는 `FlagsAttribute` 특성 및에 영향을 보여 줍니다.는 <xref:System.Enum.ToString%2A> 메서드를 사용 하 여 `FlagsAttribute` 에 <xref:System.Enum> 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="a0eef-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>