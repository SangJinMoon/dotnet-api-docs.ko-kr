<Type Name="Double" FullName="System.Double">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c15da40cd4c6f9918c0ee1953e5b3d059b86e2bb" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34255143" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>배정밀도 부동 소수점 숫자를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double> 값 형식은 음수 1.79769313486232 e 308에서 양수 또는 음수 0, 뿐만 아니라 양수 1.79769313486232 e 308 까지의 값을 가진 배정도 64 비트 숫자를 나타냅니다 <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>, 및 not-a-number (<xref:System.Double.NaN>). (예: 행 또는 은하계 사이의 거리) 매우 큰 수 또는 매우 작은 (으로 물질의 분자 질량)과 종종 없는지 (예: 까지의 거리 지구 다른 태양계)을 정확 하 게 하는 값을 나타내는 것이 고 <xref:System.Double> 종류는 IEC 60559: 1989 (IEEE 754) 이진 부동 소수점 연산에 대 한 표준 준수 합니다.  
  
 이 항목은 다음 섹션으로 구성되어 있습니다.  
  
-   [부동 소수점 표현 및 정밀도](#Precision)  
  
-   [같음에 대 한 테스트](#Equality)  
  
-   [부동 소수점 값 및 예외](#Exceptions)  
  
-   [형식 변환 및 Double 구조체](#Conversions)  
  
-   [부동 소수점 기능](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>부동 소수점 표현 및 정밀도  
 <xref:System.Double> 데이터 형식은 다음 표에 나와 있는 것 처럼 64 비트 이진 형식에서에서 배정밀도 부동 소수점 값을 저장 합니다.  
  
|파트|비트|  
|----------|----------|  
|Significand 또는 수|0-51|  
|지 수|52-62|  
|기호 (0 = 1 양수, 음수 =)|63|  
  
 소수 일부 소수 값을 정확 하 게 표현할 수 없는 경우와 마찬가지로 (1/3 등 또는 <xref:System.Math.PI?displayProperty=nameWithType>), 이진 분수가 일부 소수 자릿수 값을 나타낼 수 없습니다. 예를 들어 1/10, 소수 부분으로 순서 대로.1 요소로 정확 하 게 표시 되는 패턴 "0011" 반복으로 무한대로와 이진 소수로.001100110011으로 표시 됩니다. 이 경우 부동 소수점 값 표시 되는 숫자의 정확 하지 않은 표현을 제공 합니다. 원래 부동 소수점 값에 추가적인 수치 연산을 실행 빈도가 정밀도 부족 증가 경향이 있습니다. 예를 들어.1으로 10을 곱한 결과를 비교 하는 경우.1 순서 대로.1 9 번 추가, 보면 해당 더하기 8 개는 다양 한 작업 관련가 있기 때문에 보다 덜 정확한 결과 생성 했습니다. 이 불일치가 두 표시 하는 경우에 그렇습니다는 <xref:System.Double> "R"을 사용 하 여 값 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md)이며 필요한에서 지 원하는 전체 자릿수가 17 자리를 모두 표시 하는 경우는 <xref:System.Double> 유형입니다.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 일부 숫자는 소수 이진 값과 동일 하 게 표현할 수 없는 때문에 대략적인 실수 부동 소수점 숫자에 수 있습니다.  
  
 모든 부동 소수점 숫자에 레이블에도 제한 된 수의 유효 자릿수 부동 소수점 값을 근사치 숫자는 실수를 계산 하는 방식을 정확 하 게 결정 합니다.   A <xref:System.Double> 값에 최대 15 자리의 정밀도, 내부적으로 최대 17 자리가 유지 합니다. 즉, 부동 소수점 연산 부동 변경 하려면 정밀도 없는 경우도 소수점 값입니다. 다음 예제에서 이에 대해 설명합니다. 매우 큰 부동 소수점 값을 정의 하 고 다음의 제품에 추가 <xref:System.Double.Epsilon?displayProperty=nameWithType> 및를 하나 quadrillion 합니다. 그러나 제품을 용량이 부족 원래 부동 소수점 값을 수정 합니다. 가장 덜 중요 한 자리는 1/1000, 제품의 최대 유효 자릿수는 1 하는 반면<sup>-312</sup>합니다.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 제한 된 정밀도 부동 소수점 숫자의 몇 가지 결과가 발생 합니다.  
  
-   최소 유효 자릿수가 다르기 때문에 특정 전체 자릿수에 대 한 동일 하 게 나타나는 두 부동 소수점 숫자가 같은지 비교 하지 수도 있습니다. 다음 예제에서는 일련의 숫자를 더한 및 고 합계가 예상 되는 전체와 비교 됩니다. 두 값이 동일한 경우에 대 한 호출을 표시 하지만 `Equals` 메서드는 없다는 것을 나타냅니다.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     형식 항목을 변경 하는 경우는 <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> 에서 문을 `{0}` 및 `{1}` 를 `{0:R}` 및 `{1:R}` 두 유효 자릿수가 모두 표시 하려면 <xref:System.Double> 값이 명확한 경우 두 값이 서로 같지 않은지 때문에 추가 작업 중 전체 자릿수의 손실입니다. 이 경우 호출 하 여 문제를 해결할 수 있습니다는 <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> 반올림 하는 메서드는 <xref:System.Double> 비교를 수행 하기 전에 원하는 정밀도 값입니다.  
  
-   부동 소수점 숫자를 사용 하는 수치 또는 비교 연산을 하지 산출할 수 동일한 결과 10 진수를 사용 하는 경우 이진 부동 소수점 숫자는 10 진수과 같지 않을 때문에입니다. 이전 예제.1으로 10을 곱한 및.1 번 추가의 결과 표시 하 여이 나와 있습니다.  
  
     사용할 수 있습니다 소수 값이 포함 된 숫자 연산에는 정확도 중요 한 경우는 <xref:System.Decimal> 보다는 <xref:System.Double> 유형입니다. 때의 범위를 벗어난 정수 값으로 숫자 연산에는 정확도 <xref:System.Int64> 또는 <xref:System.UInt64> 사용 하 여 형식을 반드시는 <xref:System.Numerics.BigInteger> 형식입니다.  
  
-   부동 소수점 숫자가 포함 된 경우 왕복 하지 않는 값 않을 수 있습니다. 값 이라고 라운드트립 작업은 원래 부동 소수점 숫자를 다른 형식으로 변환 하 고 역 작업이 변환에서 변환 된 형식을 부동 소수점 숫자에 다시 최종 부동 소수점 숫자가 원래 같지 않습니다. 부동 소수점 수입니다. 하나 이상의 최하위 유효 자릿수가 손실 되거나 변환에서 변경 때문에 대 한 왕복은 실패할 수 있습니다. 다음 예제에서는 세 가지 <xref:System.Double> 값을 문자열로 변환 되 고 파일에 저장 합니다. 하지만 결과 같이, 값을 동일한 것으로 나타날 경우에 복원 된 값의 원래 값과 같지 않습니다.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     이 경우 값 수 성공적으로 라운드트립 되 고 "G17"를 사용 하 여 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 의 전체 자릿수를 유지 하기 위해 <xref:System.Double> 다음 예제와 같이 값입니다.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  와 함께 사용할 경우는 <xref:System.Double> 값, 일부 경우에는 "R" 형식 지정자의 원래 값을 성공적으로 라운드트립 실패 합니다. 되도록 <xref:System.Double> "G17" 형식 지정자를 사용 하는 값을 성공적으로 라운드트립 합니다.

-   <xref:System.Single> 값 보다 적은 정밀도 <xref:System.Double> 값입니다. A <xref:System.Single> 겉보기 해당 하는 변환 된 값 <xref:System.Double> 종종과 같지 않습니다는 <xref:System.Double> 정밀도의 차이 때문에 값입니다. 다음 예제에서는 동일한 나누기 작업의 결과에 할당 됩니다는 <xref:System.Double> 및 <xref:System.Single> 값입니다. 이후에 <xref:System.Single> 값으로 캐스팅 되는 <xref:System.Double>, 두 값의 비교는 같지 않은 것을 보여 줍니다.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     이 문제를 방지 하려면 하나를 사용는 <xref:System.Double> 대신는 <xref:System.Single> 데이터 형식이 나 사용 하 여는 <xref:System.Math.Round%2A> 메서드 두 값이 같은 정밀도 갖도록 합니다.  
  
 또한 산술 및 할당 작업의 결과 <xref:System.Double> 값이 다른 약간 플랫폼에서의 전체 자릿수 손실이 발생 하므로 <xref:System.Double> 유형입니다. 예를 들어 리터럴을 할당 하도록 결과 <xref:System.Double> 값 32 비트 및 64 비트 버전의.NET Framework에서 달라질 수 있습니다. 다음 예제에서는이 때 그 차이 리터럴 값-4.42330604244772 e-305와 해당 값이-4.42330604244772 e 변수-305에 할당 되는 <xref:System.Double> 변수입니다. 결과 <xref:System.Double.Parse%28System.String%29> 메서드가 경우 문제가 발생 하지 않는 전체 자릿수 손실이 발생 하지 않도록에서 합니다.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>같음에 대 한 테스트  
 같은, 두 개의 <xref:System.Double> 값 동일한 값을 나타내야 합니다. 그러나 값을 정밀도에서 차이점이 있기 때문에 또는 하나 또는 두 값에 따라 정밀도 손실 때문에 종종 동일한 것으로 예상 되는 부동 소수점 값으로 판명 최소 유효 자릿수가에 차이가 있으므로 동일 하지 않은 것입니다. 결과적으로,에 대 한 호출이 <xref:System.Double.Equals%2A> 대 한 호출이 나 두 값이 같은지를 확인 하는 <xref:System.Double.CompareTo%2A> 메서드 두 관계를 확인 하려면 <xref:System.Double> 값, 종종 하면 예기치 않은 결과가 합니다. 이 다음 예제에서 분명 하 게 한 두 개의 분명히과 같아야 <xref:System.Double> 두 번째 17에 있을 때 첫 번째는 15 자리의 전체 자릿수, 때문에 같지 않은 것으로 판명 된 값입니다.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 계산 된 값을 서로 다른 코드 경로 따르는 및 다양 한 방법에서 종종 조작 되는 같지 않은 것으로 증명 합니다. 다음 예제에서는 하나의 <xref:System.Double> 값을 제곱 하 고 원래 값을 복원 하기 위해 제곱근 계산 되는 다음 합니다. 두 번째 <xref:System.Double> 3.51으로 곱하고 원래 값으로 복원 3.51 나눈 결과의 제곱근 전에 제곱 됩니다. 가 두 값을 동일한 것으로 표시 되지만에 대 한 호출에서 <xref:System.Double.Equals%28System.Double%29> 메서드는 같지 않은 것을 나타냅니다. 두 번째 값.0000000000001 임을 보여주고 "R" 표준 형식 문자열을 사용 하 여 각 Double 값의 모든 유효 자릿수가 표시 하는 결과 문자열을 반환할 첫 번째 보다 작아야 합니다.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 정밀도의 손실 비교의 결과 영향을 줄 가능성이 높은 경우에 호출 하 고 다음 대체 방법 중 하나 채택할 수 있습니다.는 <xref:System.Double.Equals%2A> 또는 <xref:System.Double.CompareTo%2A> 메서드:  
  
-   호출의 <xref:System.Math.Round%2A?displayProperty=nameWithType> 값이 모두 같은 정밀도 갖도록 하는 메서드입니다. 다음 예제에서는 두 개의 소수 값이 같으면 되도록이 방법을 사용 하도록 이전 예제를 수정 합니다.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Note, 하지만 정밀도 문제 중간점 값의 반올림에 계속 적용 되도록 합니다. 자세한 내용은 <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> 메서드를 참조하세요.  
  
-   대략적인 같음 테스트를 일치 하는 대신 합니다. 절대 중 하나를 정의 하는이 위해서는 두 값 다를 수 있지만 여전히는 양 같아야 또는 더 작은 값 보다 큰 값에서 벗어날 수 있는 상대 크기를 정의 합니다.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> 두 개의 사이의 거리를 측정 하는 절대로 사용 되기도 <xref:System.Double> 같은지 테스트할 때 값입니다.  그러나 <xref:System.Double.Epsilon?displayProperty=nameWithType> , 추가 하거나에서 뺀 수 있는 가능한 가장 작은 값을 측정 한 <xref:System.Double> 값이 0 인 합니다. 대부분 양수 및 음수 <xref:System.Double> 값, 값 <xref:System.Double.Epsilon?displayProperty=nameWithType> 감지 너무 작습니다. 따라서 값 0을 제외 하 고 권장 하지는 않습니다 같음에 대 한 테스트에 사용 합니다.  
  
     다음 예제에서는 후자의 방법을 사용할 경우 사용 하 여 정의 `IsApproximatelyEqual` 두 값 간의 상대적 차이 테스트 하는 메서드. 결과에 대 한 호출 또한 대조는 `IsApproximatelyEqual` 메서드 및 <xref:System.Double.Equals%28System.Double%29> 메서드.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>부동 소수점 값 및 예외  
 정수 계열 형식의 경우 0으로 오버플로 또는 나누기와 같은 잘못 된 작업의 경우에 예외를 throw, 작업과 달리 부동 소수점 값을 사용 하 여 작업 예외를 throw 하지 않습니다. 대신 예외 상황 부동 소수점 연산의 결과 0, 양의 무한대, 음의 무한대 또는 (nan 숫자가) not-a-number:  
  
-   부동 소수점 연산의 결과 대상 형식에 너무 작은 경우의 결과 0입니다. 다음 예제와 같이 두 매우 작은 숫자 곱할 경우 발생할 수 있습니다.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   부동 소수점 연산의 결과의 크기가 대상 형식의 범위를 초과한 경우 작업의 결과 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>결과의 부호에 따라 합니다. 오버플로 하는 작업의 결과 <xref:System.Double.MaxValue?displayProperty=nameWithType> 은 <xref:System.Double.PositiveInfinity>, 및를 오버플로 하는 작업의 결과 <xref:System.Double.MinValue?displayProperty=nameWithType> 은 <xref:System.Double.NegativeInfinity>다음 예제와 같이 합니다.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> 또한 양의 피제수와 0으로 나누기에서 발생 하 고 <xref:System.Double.NegativeInfinity> 음수 피제수와 0으로 나누기에서 결과입니다.  
  
-   부동 소수점 연산이 유효 하지 않을 경우 작업의 결과 <xref:System.Double.NaN>합니다. 예를 들어 <xref:System.Double.NaN> 다음과 같은 작업에서 발생 합니다.  
  
    -   0 피제수와 0으로 나누었습니다. 참고에서 결과가 0으로 나누기의 경우 다른 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>합니다.  
  
-   부동 소수점 작업을 입력이 잘못 되었습니다. 예를 들어 호출는 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> 음수 값을 가진 메서드가 반환 <xref:System.Double.NaN>호출 마찬가지로는 <xref:System.Math.Acos%2A?displayProperty=nameWithType> 값 보다 하나 이하의 보다 큰 음수 1을 사용 하 여 메서드.  
  
-   값이 인수가 지정 된 모든 작업 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>형식 변환 및 Double 구조체  
 <xref:System.Double> 컴파일러에 의해 변환이 구현 하는 대신; 구조 모든 명시적 또는 암시적 변환 연산자를 정의 하지 않습니다.  
  
 기본 숫자 형식의 값 변환은 <xref:System.Double> 확대 변환 하 고 따라서 있고이 명시적 캐스트 연산자는 컴파일러에서 명시적으로 요청 하지 않는 변환 메서드를 호출 합니다. C# 컴파일러에서 변환에 대 한 캐스팅 연산자를 필요로 하는 예를 들어 <xref:System.Decimal> 를 <xref:System.Double>, Visual Basic 컴파일러는 손실 됩니다. 다음 예제에서는 다른 기본 숫자 형식의 최소값 또는 최대값 값 변환는 <xref:System.Double>합니다.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 또한는 <xref:System.Single> 값 <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 를 변환할 <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>각각.  
  
 일부 숫자 형식의 값 변환은 <xref:System.Double> 값 정밀도 손실 될 수 있습니다. 변환할 때 정밀도의 손실 될 수 예제와 같이 <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, 및 <xref:System.UInt64> 값을 <xref:System.Double> 값입니다.  
  
 변환 된 <xref:System.Double> 값을 다른 기본 숫자 데이터 형식의 값은 축소 변환 하 고 캐스트 연산자 (C#에서), (Visual Basic의 경우)의 변환 메서드 또는에 대 한 호출 필요는 <xref:System.Convert> 메서드. 대상 유형으로 정의 된 대상 데이터 형식의 범위 밖에 있는 값 `MinValue` 및 `MaxValue` 속성을 다음 표에 나와 있는 것 처럼 동작 합니다.  
  
|대상 형식|결과|  
|-----------------|------------|  
|다른 정수 계열 형식|<xref:System.OverflowException> checked 컨텍스트에서 변환이 발생 하는 경우는 예외입니다.<br /><br /> Unchecked 컨텍스트에서 (C#에서 기본값) 변환을 수행 하는 경우 변환 작업은 성공 하지만 값 오버플로가 발생 합니다.|  
|<xref:System.Decimal>|<xref:System.OverflowException> 예외입니다.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 음수 값입니다.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 양수 값입니다.|  
  
 또한 <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> throw는 <xref:System.OverflowException> 컨텍스트 있지만 unchecked 컨텍스트에서 정수로 변환 하는 경우 이러한 값 오버플로 정수로 변환 합니다. 변환에 대 한 <xref:System.Decimal>, 항상 throw 한 <xref:System.OverflowException>합니다. 변환에 대 한 <xref:System.Single>를 변환 <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>각각.  
  
 정밀도의 손실을 변환 하 여 발생할 수는 <xref:System.Double> 값을 다른 숫자 형식입니다. 정수 계열이 아닌 변환의 경우 <xref:System.Double> 값을 예제의 출력에서 볼 수 있듯이 소수 부분이 손실 되는 경우는 <xref:System.Double> 값 반올림 됩니다 (예: Visual Basic) 또는 (예: C#) 잘립니다. 변환에 대 한 <xref:System.Decimal> 및 <xref:System.Single> 값의 <xref:System.Double> 값이 정확한 표시 대상 데이터 형식에 없을 수도 있습니다.  
  
 다음 예제에서는 다양 한 변환 <xref:System.Double> 값을 다른 여러 가지 숫자 형식입니다. (기본값) Visual basic에서 및 C#에서 확인 된 컨텍스트에서 발생 하는 변환을 (때문에 [체크](~/docs/csharp/language-reference/keywords/checked.md) 키워드)입니다. 예제의 출력에서 선택 된 변환에 대 한 결과 보여 줍니다. unchecked 컨텍스트. 사용 하 여 컴파일하면 Visual Basic에서는 unchecked 컨텍스트에서 변환을 수행할 수 있습니다는 `/removeintchecks+` 컴파일러 스위치와 C# 주석으로 처리 하 여는 `checked` 문.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 숫자 형식의 변환 작업에 대 한 자세한 내용은 참조 하십시오. [.NET Framework의 형식 변환](~/docs/standard/base-types/type-conversion.md) 및 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md)합니다.  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>부동 소수점 기능  
 <xref:System.Double> 구조와 관련 된 형식을 다음 영역에서 작업을 수행 하는 메서드를 제공 합니다.  
  
-   **값의 비교**합니다. 호출할 수 있습니다는 <xref:System.Double.Equals%2A> 두 지 여부를 결정 하는 메서드 <xref:System.Double> 값이 같으면 또는 <xref:System.Double.CompareTo%2A> 메서드를 두 값 간에 관계를 결정 합니다.  
  
     <xref:System.Double> 구조는 또한 비교 연산자의 전체 집합을 지원 합니다. 예를 들어 같음 또는 같지 않음, 테스트 또는 하나의 값 보다 크거나 같은 다른 적용 되는지 확인 수 있습니다. 피연산자 중 하나는 숫자 이외의 형식인 경우는 <xref:System.Double>, 변환할는 <xref:System.Double> 비교를 수행 하기 전에.  
  
    > [!WARNING]
    >  전체 자릿수의 차이 때문에 두 개의 <xref:System.Double> 동일한 것으로 예상 하는 값 수 판명 같지 않은 것을 비교 결과 영향을 주는 합니다. 참조는 [같음 테스트](#Equality) 두 개를 비교 하는 방법에 대 한 자세한 내용은 섹션 <xref:System.Double> 값입니다.  
  
     호출할 수도 있습니다는 <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, 및 <xref:System.Double.IsNegativeInfinity%2A> 를 이러한 특수 값에 대 한 테스트 합니다.  
  
-   **수학 연산을**합니다. 가 아닌 언어 컴파일러 및 공용 중간 언어 (CIL) 지침을 보려면 여 더하기, 빼기, 곱하기 및 나누기, 같은 일반적인 산술 연산을 구현 <xref:System.Double> 메서드. 수치 연산에서 피연산자 중 하나는 숫자 이외의 형식인 경우는 <xref:System.Double>로 변환 됩니다는 <xref:System.Double> 작업을 수행 하기 전에. 작업의 결과 이기도 한 <xref:System.Double> 값입니다.  
  
     호출 하 여 다른 수학 작업을 수행할 수 `static` (`Shared` Visual basic에서)의 메서드는 <xref:System.Math?displayProperty=nameWithType> 클래스입니다. 연산에 대해 일반적으로 사용 되는 추가 메서드를 포함 (같은 <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, 및 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), 기 하 도형 (와 같은 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 및 <xref:System.Math.Sin%2A?displayProperty=nameWithType>), 및 미적분 법 (같은 <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     개별 비트를 조작할 수도 있습니다는 <xref:System.Double> 값입니다. <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> 메서드 전처리는 <xref:System.Double> 값 비트 패턴의 64 비트 정수에에서의 합니다. <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> 메서드는 바이트 배열에 해당 비트 패턴을 반환 합니다.  
  
-   **반올림**합니다. 반올림는 대개 기술로 부동 소수점 표현 및 정밀도 문제로 인해 발생 하는 값 사이의 차이의 영향을 줄이기 위한 합니다. 반올림할 수는 <xref:System.Double> 호출 하 여 값의 <xref:System.Math.Round%2A?displayProperty=nameWithType> 메서드.  
  
-   **서식 지정**합니다. 변환할 수는 <xref:System.Double> 값을 호출 하 여 해당 문자열 표현에서 <xref:System.Double.ToString%2A> 메서드 또는 합성 서식 지정 기능을 사용 하 여 합니다. 형식 문자열에서 부동 소수점 값의 문자열 표현을 제어 하는 방법에 대 한 정보에 대 한 참조는 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md) 항목입니다.  
  
-   **문자열 구문 분석**합니다. 부동 소수점 값으로의 문자열 표현을 변환할 수 있습니다는 <xref:System.Double> 호출 하 여 값의 <xref:System.Double.Parse%2A> 또는 <xref:System.Double.TryParse%2A> 메서드. 구문 분석이 실패 하는 경우는 <xref:System.Double.Parse%2A> 메서드 예외를 throw 하는 반면는 <xref:System.Double.TryParse%2A> 메서드 반환 `false`합니다.  
  
-   **형식 변환**합니다. <xref:System.Double> 구조에 대 한 명시적 인터페이스 구현을 제공는 <xref:System.IConvertible> 인터페이스에는 두 개의 표준.NET Framework 데이터 형식 간의 변환만 지원 합니다. 언어 컴파일러에 다른 모든 표준 숫자 형식에 값의 암시적 변환도 지원 <xref:System.Double> 값입니다. 표준 숫자 형식의 값 변환 하는 <xref:System.Double> 확대 변환이 캐스팅 연산자나 변환 메서드가 사용자 필요 하지 않습니다  
  
     그러나 변환 <xref:System.Int64> 및 <xref:System.Single> 값 정밀도 손실 될 수 있습니다. 다음 표에 이러한 각 형식에 대 한 전체 자릿수의 차이가 있습니다.  
  
    |형식|최대 전체 자릿수|내부 정밀도|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 10 진수|19 10 진수|  
    |<xref:System.Single>|10 진수 7 자리|9 10 진수|  
  
     정밀도의 문제에 영향을 가장 많이 <xref:System.Single> 변환 된 값 <xref:System.Double> 값입니다. 다음 예제에서는 동일한 나누기 연산에 의해 발생 하는 두 개의 값 다르면 변환할 단 정밀도 부동 소수점 값 이므로 값 중 하나는 <xref:System.Double>합니다.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 유형의 모든 멤버는 스레드로부터 안전 합니다. 멤버 인스턴스 상태를 수정 하려면 표시 되는 실제로 새 값으로 초기화 하는 새 인스턴스를 반환 합니다. 으로 다른 종류와이 형식의 인스턴스를 포함 하는 공유 변수를 읽고 쓰는 보호 해야 스레드로부터 안전을 보장 하려면 잠금에 의해.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스를 지정된 개체나 <see cref="T:System.Double" /> 개체와 비교하고 이 인스턴스의 값이 지정된 개체나 <see cref="T:System.Double" /> 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">비교할 배정밀도 부동 소수점 숫자입니다.</param>
        <summary>이 인스턴스를 지정된 배정밀도 부동 소수점 숫자와 비교하고 이 인스턴스의 값이 지정된 배정밀도 부동 소수점 숫자 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>이 인스턴스와 <paramref name="value" />의 상대 값을 나타내는 부호 있는 숫자입니다.  
  
 <list type="table"><listheader><term> 반환 값  </term><description> 설명  </description></listheader><item><term> 0보다 작음  </term><description> 이 인스턴스는 <paramref name="value" />보다 작습니다.  -또는-  이 인스턴스가 숫자(<see cref="F:System.Double.NaN" />)가 아니고 <paramref name="value" />이 숫자입니다.  </description></item><item><term> 0  </term><description> 이 인스턴스가 <paramref name="value" />과 같습니다.  -또는-  이 인스턴스와 <paramref name="value" /> 모두 숫자(<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> 또는 <see cref="F:System.Double.NegativeInfinity" />가 아닙니다.  </description></item><item><term> 0보다 큼  </term><description> 이 인스턴스는 <paramref name="value" />보다 큽니다.  -또는-  이 인스턴스가 번호이고 <paramref name="value" />가 숫자(<see cref="F:System.Double.NaN" />)가 아닙니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 같은 동일 해야 합니다. 특히 부동 소수점 값이 여러 수학 연산을에 종속 하는 경우에 정밀도 떨어질 수 및 최소 유효 자릿수가 제외 하 고 거의 동일 하 게 해당 값에 대 한 일반적입니다. 반환 값이로 인해는 <xref:System.Double.CompareTo%2A> 메서드 때때로 보일 수 있지만 놀라운 합니다. 예를 들어 동일한 값으로 나누기 뒤 특정 값을 곱하는 식은 원래 값을 생성 해야 합니다. 그러나 다음 예에서 계산 된 값으로 밝혀졌습니다 원래 값 보다 커야 합니다. "R"을 사용 하 여 두 값의 모든 유효 자릿수가 표시 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 의 최하위 유효 자릿수가의 원래 값에서 계산 된 값이 다른 것을 나타냅니다. 이러한 비교를 처리 하는 방법은의 설명 섹션을 참조 하십시오.는 <xref:System.Double.Equals%28System.Double%29> 메서드.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 이 메서드를 구현 하는 <xref:System.IComparable%601?displayProperty=nameWithType> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> 메서드 변환할 필요가 없기 때문에 `value` 매개 변수를 개체로 합니다.  
  
 하지만 해당 값이 개체 <xref:System.Double.NaN> 값이 다른 개체에 같지 않은 경우 <xref:System.Double.NaN> (심지어 자체)는 <xref:System.IComparable%601> 인터페이스에서는 `A.CompareTo(A)` 0을 반환 합니다.  
  
## <a name="widening-conversions"></a>확대 변환  
 프로그래밍 언어에 따라 코딩할 수는 <xref:System.Double.CompareTo%2A> 메서드 매개 변수 형식이 비트 수가 적은 보다 인스턴스 형식입니다. 일부 프로그래밍 언어 매개 변수를 나타내는 형식으로 비트 수는 인스턴스와 암시적 확대 변환을 수행 하기 때문에 이것이 가능 합니다.  
  
 예를 들어 인스턴스 형식이 <xref:System.Double> 매개 변수 형식이 고 <xref:System.Int32>합니다. Microsoft C# 컴파일러는 매개 변수의 값을 나타내는 명령을 생성 한 <xref:System.Double> 개체를 생성 합니다는 <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> 확대 표현의 매개 변수 및 인스턴스 값을 비교 하는 메서드.  
  
 해당 컴파일러에서 숫자 형식을 암시적으로 확대 변환을 수행 하는지 확인 하려면 해당 프로그래밍 언어의 설명서를 참조 하십시오. 자세한 내용은 참조는 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md) 항목입니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 개의 특정 숫자 비교.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 및 제네릭이 아닌 버전을 보여 줍니다.는 <xref:System.Double.CompareTo%2A> 여러 값 및 참조 형식에 대 한 메서드.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">비교할 개체 또는 <see langword="null" />입니다.</param>
        <summary>이 인스턴스를 지정된 개체와 비교하고 이 인스턴스의 값이 지정된 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>이 인스턴스와 <paramref name="value" />의 상대 값을 나타내는 부호 있는 숫자입니다.  
  
 <list type="table"><listheader><term> 값  </term><description> 설명  </description></listheader><item><term> 음의 정수  </term><description> 이 인스턴스가 <paramref name="value" />보다 작습니다.  -또는-  이 인스턴스가 숫자(<see cref="F:System.Double.NaN" />)가 아니고 <paramref name="value" />이 숫자입니다.  </description></item><item><term> 0  </term><description> 이 인스턴스가 <paramref name="value" />와 같습니다.  -또는-  이 인스턴스 및 <paramref name="value" />가 모두 <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />입니다. 또는 <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> 양의 정수  </term><description> 이 인스턴스가 <paramref name="value" />보다 큽니다.  -또는-  이 인스턴스가 숫자이고 <paramref name="value" />가 숫자(<see cref="F:System.Double.NaN" />)가 아닙니다.  -또는- <paramref name="value" />가 <see langword="null" />입니다.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 매개 변수 여야 `null` 또는 인스턴스의 `Double`, 그러지 않으면 예외가 throw 됩니다. 모든 인스턴스 <xref:System.Double>, 해당 값에 관계 없이 보다 큰 것으로 간주 됩니다 `null`합니다.  
  
 값은 같은 동일 해야 합니다. 특히 부동 소수점 값이 여러 수학 연산을에 종속 하는 경우에 정밀도 떨어질 수 및 최소 유효 자릿수가 제외 하 고 거의 동일 하 게 해당 값에 대 한 일반적입니다. 반환 값이로 인해는 <xref:System.Double.CompareTo%2A> 메서드 때때로 보일 수 있지만 놀라운 합니다. 예를 들어 동일한 값으로 나누기 뒤 특정 값을 곱하는 식은 원래 값을 생성 해야 합니다. 그러나 다음 예에서 계산 된 값으로 밝혀졌습니다 원래 값 보다 커야 합니다. "R"을 사용 하 여 두 값의 모든 유효 자릿수가 표시 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 의 최하위 유효 자릿수가의 원래 값에서 계산 된 값이 다른 것을 나타냅니다. 이러한 비교를 처리 하는 방법은의 설명 섹션을 참조 하십시오.는 <xref:System.Double.Equals%28System.Double%29> 메서드.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 이 메서드는 지원 하도록 구현 된 <xref:System.IComparable> 인터페이스입니다. 없지만 <xref:System.Double.NaN> 간에 동일한 것으로 간주 되지 않으며 <xref:System.Double.NaN> (심지어 자체)는 <xref:System.IComparable> 인터페이스에서는 `A.CompareTo(A)` 0을 반환 합니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 개의 특정 숫자 비교.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `CompareTo` 의 컨텍스트에서 `Double`합니다.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />가 <see cref="T:System.Double" />가 아닌 경우</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>0보다 큰 양의 최소 <see cref="T:System.Double" /> 값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.Double.Epsilon> 속성은 가장 작은 양수를 반영 <xref:System.Double> 값은 숫자 연산 또는 비교에서 중요 하 때의 값은 <xref:System.Double> 인스턴스는 0입니다. 예를 들어 다음 코드와 0 및 <xref:System.Double.Epsilon> 반면 같지 않은 값으로 간주 됩니다의 절반 및 값 <xref:System.Double.Epsilon> 동일한 것으로 간주 됩니다.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 부동 보다 정확 하 게 지점은 기호, 52 비트가 수 또는, significand 및 11 비트 지 수의 형식으로 구성 됩니다. 다음 예제와 같이 0에-1022의 지 수 및 0의가 수 있습니다. <xref:System.Double.Epsilon> -1022의 지 수에 1의가 수 있습니다. 즉 <xref:System.Double.Epsilon> 가 가장 작은 양수가 <xref:System.Double> 0 보다 큰 값을 나타내고, 가능한 가장 작은 값에 대 한 가능한 가장 작은 증가값은 <xref:System.Double> 인 지 수는-1022입니다.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 그러나는 <xref:System.Double.Epsilon> 속성은 일반 측정 한 값의 전체 자릿수 없습니다는 <xref:System.Double> ; 입력에 적용 됩니다 <xref:System.Double> 값은 0 또는-1022의 지수가 인스턴스.  
  
> [!NOTE]
>  값은 <xref:System.Double.Epsilon> 속성 부동 소수점 연산에서 반올림 상대 오차의 상한을 나타내는 컴퓨터 엡실론 동일 하지 않습니다.  
  
 이 상수의 값은 4.94065645841247 e-324입니다.  
  
 두 명백히 같은 부동 소수점 숫자가 수 것으로 간주 최소 유효 자릿수가에 차이가 있으므로 합니다. 예를 들어 C# 식 `(double)1/3 == (double)0.33333`, 같은지 비교 하지 왼쪽에서 나누기 연산을 반면 상수 오른쪽에는 지정 된 자릿수로 최대 전체 자릿수에 있기 때문에 있습니다. 알고리즘의 값에 기반 하는 지 여부를 두 개의 부동 소수점 숫자 취급 될 수 있습니다를 결정 하는 사용자 지정 알고리즘을 만드는 경우이 방법은 권장 되지 않습니다는 <xref:System.Double.Epsilon> 소수점의 차이 값을 설정 하는 상수 두 값을 같은 것으로 간주 됩니다.  (일반적으로 해당 차이 값은 이러한 <xref:System.Double.Epsilon>.) 두 개의 배정밀도 부동 소수점 값을 비교 하는 방법에 대 한 정보를 참조 하십시오. <xref:System.Double> 및 <xref:System.Double.Equals%28System.Double%29>합니다.  
  
## <a name="platform-notes"></a>플랫폼 참고 사항  
 ARM 시스템에서의 값은 <xref:System.Double.Epsilon> 상수 0과 같으며 이므로 너무 작아 검색할 수 있습니다. 2.2250738585072014 e 해당 하는 대체 epsilon 값을 정의할 수 있습니다-308 대신 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Double" />의 두 인스턴스가 같은 값을 표시하는지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 <see cref="T:System.Double" /> 개체입니다.</param>
        <summary>이 인스턴스의 값과 지정된 <see cref="T:System.Double" /> 개체의 값이 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see langword="true" />가 이 인스턴스와 같으면 <paramref name="obj" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 구현 하는 <xref:System.IEquatable%601?displayProperty=nameWithType> 인터페이스를 하 고 수행 보다 조금 더 나은 <xref:System.Double.Equals%2A> 변환할 필요가 없기 때문에 `obj` 매개 변수를 개체로 합니다.  
  
## <a name="widening-conversions"></a>확대 변환  
 프로그래밍 언어에 따라 코딩할 수는 <xref:System.Double.Equals%2A> 메서드 매개 변수 형식이 비트 수가 적은 보다 인스턴스 형식입니다. 일부 프로그래밍 언어 매개 변수를 나타내는 형식으로 비트 수는 인스턴스와 암시적 확대 변환을 수행 하기 때문에 이것이 가능 합니다.  
  
 예를 들어 인스턴스 형식이 <xref:System.Double> 매개 변수 형식이 고 <xref:System.Int32>합니다. Microsoft C# 컴파일러는 매개 변수의 값을 나타내는 명령을 생성 한 <xref:System.Double> 개체를 생성 합니다는 <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> 확대 표현의 매개 변수 및 인스턴스 값을 비교 하는 메서드.  
  
 해당 컴파일러에서 숫자 형식을 암시적으로 확대 변환을 수행 하는지 확인 하려면 해당 프로그래밍 언어의 설명서를 참조 하십시오. 자세한 내용은 참조는 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md) 항목입니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 <xref:System.Double.Equals%2A> 값 나타날 수 있는 두 값의 정밀도 차이 때문에 주의 해야 메서드를 사용 해야 합니다. 다음 예제에서는 보고 하는 <xref:System.Double> .333333 값 및 <xref:System.Double> 1 3으로 분할 하 여 반환 된 값이 다른 지 합니다.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 동일한 지 비교 하는 대신 하나 정의 하는 방법을 허용 가능한 상대 오차 두 값 사이의 차이 (같은. 001%의 값 중 하나). 절대 값의 두 값 사이의 차이 보다 작거나 동일한 경우 차이점은 전체 자릿수의 차이가 있기 때문에 발생할 가능성이 며 따라서 값 않습니다를 동일한 것입니다. 다음 예제에서는이 방법을 사용 하 여 33333과 1/3, 두 개의 비교 <xref:System.Double> 이전 코드 예제에서는 동일 하지 않은 것으로 확인 하는 값입니다. 이 경우 값이 같으면 합니다.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  때문에 <xref:System.Double.Epsilon> 최소 식을 정의 합니다. 해당 범위는 0에 가까운 양수 값의 유사한 두 값 사이의 차이 보다 커야 <xref:System.Double.Epsilon>합니다. 일반적으로 여러 번 보다 크면 <xref:System.Double.Epsilon>합니다. 이 인해 사용 하지 않으면 권장 <xref:System.Double.Epsilon> 비교할 때 <xref:System.Double> 같음에 대 한 값입니다.  
  
 두 번째 기술은 일부 절대 값으로 두 개의 부동 소수점 숫자의 차이 비교 하는 작업이 포함 됩니다. 차이 절대 값 보다 작은 경우 숫자는 동일 합니다. 큰 경우 숫자가 같지 않습니다. 한 가지 대안은 임의로 절대 값을 선택 하는 것입니다. 하지만이 문제가 될 수 있습니다 차이의 허용 가능한 오차의 규모에 따라 다르기 때문에 <xref:System.Double> 값입니다. 두 번째 대안에서는 부동 소수점 형식의 디자인 기능 활용: 두 개의 부동 소수점 값의 정수 표현 간의 차이 분리 하는 가능한 부동 소수점 값의 수를 나타냅니다. 예를 들어 0.0 사이의 차이 및 <xref:System.Double.Epsilon> 있으므로 1 <xref:System.Double.Epsilon> 는 표현 가능한 가장 작은 값으로 작업할 때는 <xref:System.Double> 값이 0 인 합니다. 다음 예제에서는이 방법을 사용 하 여은 두 33333과 1/3을 비교 <xref:System.Double> 있는 값이 이전 코드 예제와는 <xref:System.Double.Equals%28System.Double%29> 를 동일 하지 않은 메서드를 찾을 수 있습니다. 이 예에서는 사용 하는 <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> 배정밀도 부동 소수점 값을 정수 표현으로 변환 하는 메서드입니다.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 개의 특정 숫자 비교.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
 두 개 <xref:System.Double.NaN?displayProperty=nameWithType> 값을 호출 하 여 같은지 테스트할는 <xref:System.Double.Equals%2A> 메서드, 메서드에 반환 `true`합니다. 그러나 두 개 <xref:System.Double.NaN> 연산자 반환 값을 같음 연산자를 사용 하 여 같은지 테스트할 `false`합니다. 확인 하려면 여부의 값은 <xref:System.Double> (NaN) 숫자가 아니거나 대신 호출 하는 것는 <xref:System.Double.IsNaN%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>컴파일러 오버 로드 확인의 두 동작에는 명백한 차이 고려 될 수 있습니다 <see cref="M:System.Double.Equals(System.Object)" /> 메서드 오버 로드 합니다. 경우 간에 암시적 변환이 <paramref name="obj" /> 인수 및 <see cref="T:System.Double" /> 정의 및 인수 인수로 형식화 되지 않습니다는 <see cref="T:System.Object" />, 컴파일러는 암시적 변환 및 호출 수행할 수 있습니다는 <see cref="M:System.Double.Equals(System.Double)" /> 메서드. 호출 그렇지 않은 경우는 <see cref="M:System.Double.Equals(System.Object)" /> 메서드는 항상 반환 <see langword="false" /> 경우 해당 <paramref name="obj" /> 인수가 <see cref="T:System.Double" /> 값입니다. 다음 예제에서는 두 개의 메서드 오버 로드 간의 동작 차이 보여 줍니다. 제외한 모든 기본 숫자 형식의 경우 <see cref="T:System.Decimal" /> C#에서는 첫 번째 비교 반환 <see langword="true" /> 컴파일러가 확대 변환 및 호출에 자동으로 수행 하기 때문에 <see cref="M:System.Double.Equals(System.Double)" /> 메서드를 반면 두 번째 비교 반환 <see langword="false" /> 컴파일러를 호출 하기 때문에 <see cref="M:System.Double.Equals(System.Object)" /> 메서드.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 개체입니다.</param>
        <summary>이 인스턴스가 지정된 개체와 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="obj" />의 인스턴스이고 이 인스턴스의 값과 같으면 <see cref="T:System.Double" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Equals%2A> 값 나타날 수 있는 두 값의 정밀도 차이 때문에 주의 해야 메서드를 사용 해야 합니다. 다음 예제에서는 <xref:System.Double> .3333 값 및 <xref:System.Double> 분할 하 여 반환 된 1을 3 같지 않습니다.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 호출에 대 한 대안에 대 한는 <xref:System.Double.Equals%2A> 메서드에 대 한 설명서를 참조는 <xref:System.Double.Equals%28System.Double%29> 오버 로드 합니다.  
  
> [!NOTE]
>  때문에 <xref:System.Double.Epsilon> 최소 식을 정의 합니다. 해당 범위는 0에 가까운 양수 값의 유사한 두 값 사이의 차이 보다 커야 <xref:System.Double.Epsilon>합니다. 일반적으로 여러 번 보다 크면 <xref:System.Double.Epsilon>합니다.  
  
 초과 문서화 된 정밀도 부동 소수점 숫자의 정밀도 특정 구현 및.NET Framework의 버전입니다. 따라서 전체 자릿수는 수의 내부 표현 변경 될 수 있으므로 두 개의 특정 숫자 비교.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
 두 개 <xref:System.Double.NaN?displayProperty=nameWithType> 값을 호출 하 여 같은지 테스트할는 <xref:System.Double.Equals%2A> 메서드, 메서드에 반환 `true`합니다. 그러나 두 개 <xref:System.Double.NaN> 연산자 반환 값을 같음 연산자를 사용 하 여 같은지 테스트할 `false`합니다. 확인 하려면 여부의 값은 <xref:System.Double> (NaN) 숫자가 아니거나 대신 호출 하는 것는 <xref:System.Double.IsNaN%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>컴파일러 오버 로드 확인의 두 동작에는 명백한 차이 고려 될 수 있습니다 <see cref="M:System.Double.Equals(System.Object)" /> 메서드 오버 로드 합니다. 경우 간에 암시적 변환이 <paramref name="obj" /> 인수 및 <see cref="T:System.Double" /> 정의 및 인수 인수로 형식화 되지 않습니다는 <see cref="T:System.Object" />, 컴파일러는 암시적 변환 및 호출 수행할 수 있습니다는 <see cref="M:System.Double.Equals(System.Double)" /> 메서드. 호출 그렇지 않은 경우는 <see cref="M:System.Double.Equals(System.Object)" /> 메서드는 항상 반환 <see langword="false" /> 경우 해당 <paramref name="obj" /> 인수가 <see cref="T:System.Double" /> 값입니다. 다음 예제에서는 두 개의 메서드 오버 로드 간의 동작 차이 보여 줍니다. 제외한 모든 기본 숫자 형식의 경우 <see cref="T:System.Decimal" /> C#에서는 첫 번째 비교 반환 <see langword="true" /> 컴파일러가 확대 변환 및 호출에 자동으로 수행 하기 때문에 <see cref="M:System.Double.Equals(System.Double)" /> 메서드를 반면 두 번째 비교 반환 <see langword="false" /> 컴파일러를 호출 하기 때문에 <see cref="M:System.Double.Equals(System.Object)" /> 메서드.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.TypeCode" /> 값 형식에 대한 <see cref="T:System.Double" />를 반환합니다.</summary>
        <returns>열거형 상수인 <see cref="F:System.TypeCode.Double" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 음의 무한대로 계산되는지 양의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="d" />가 <see cref="F:System.Double.PositiveInfinity" /> 또는 <see cref="F:System.Double.NegativeInfinity" />로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity> 오버플로 조건을 신호를 보내 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 값이 숫자가 아닌지(<see cref="F:System.Double.NaN" />) 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="d" />가 <see cref="F:System.Double.NaN" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.NaN> 신호를 보내 해당 연산의 결과가 정의 되지 않습니다. 예를 들어 0.0으로 0.0 구분으로 인해 <xref:System.Double.NaN>합니다.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> 반환 `false` 경우는 <xref:System.Double> 값 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>합니다. 이러한 값을 테스트 하려면는 <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, 및 <xref:System.Double.IsNegativeInfinity%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 음의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="d" />가 <see cref="F:System.Double.NegativeInfinity" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.NegativeInfinity> 오버플로 조건을 신호를 보내 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 양의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="d" />가 <see cref="F:System.Double.PositiveInfinity" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.PositiveInfinity> 오버플로 조건을 신호를 보내 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>
          <see cref="T:System.Double" />의 가능한 최대값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 양의 1.7976931348623157 e + 308입니다.  
  
 초과 하는 작업의 결과 <xref:System.Double.MaxValue?displayProperty=nameWithType> 은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 다음 예에서 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 결과가 초과 하면 더하기, 곱하기 및 지 수 연산에서 결과 <xref:System.Double.MaxValue?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>
          <see cref="T:System.Double" />의 최소값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 음수 1.7976931348623157 e + 308입니다.  
  
 작업의 결과 보다 작은 <xref:System.Double.MinValue?displayProperty=nameWithType> 은 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다. 다음 예에서 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 결과가 빼기 및 곱하기 작업에서 결과 보다 작은 <xref:System.Double.MinValue?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>숫자가 아닌 값을 나타냅니다(<see langword="NaN" />). 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 또는 연산자 반환 <xref:System.Double.NaN> 때 연산의 결과가 정의 되지 않습니다. 예를 들어 0으로 나눈 결과 <xref:System.Double.NaN>다음 예제와 같이 합니다. (하지만 분모가 0이 아닌 숫자를 0을 반환 하거나 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>제수의 부호에 따라.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 메서드 호출 또한는 <xref:System.Double.NaN> 값 또는 작업에는 <xref:System.Double.NaN> 반환 값 <xref:System.Double.NaN>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 사용 하 여는 <xref:System.Double.IsNaN%2A> 메서드 값을 숫자 인지 확인할 수 있습니다. <xref:System.Double.op_Equality%2A> 두 연산자 고려 <xref:System.Double.NaN> 를 서로 동일 하지 않은 값입니다. 일반적으로 <xref:System.Double> 비교 연산자를 사용할 수 없습니다 <xref:System.Double.NaN?displayProperty=nameWithType> 다른 <xref:System.Double> 있지만 값 비교 방법 (같은 <xref:System.Double.Equals%2A> 및 <xref:System.Double.CompareTo%2A>) 수 있습니다. 다음 예제에서는 간의 동작 차이 보여 줍니다. <xref:System.Double> 비교 연산자와 메서드.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 다음 예제는 <xref:System.Double.NaN>의 사용 방법을 보여 줍니다.  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>음의 무한대를 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 음수 0으로 나눈 결과입니다.  
  
 작업의 결과이 상수가 반환은 보다 작은 <xref:System.Double.MinValue>합니다.  
  
 사용 하 여 <xref:System.Double.IsNegativeInfinity%2A> 하는 값이 음의 무한대로 계산 되는지 확인 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Double" /> 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />과 <paramref name="right" />가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Equality%2A> 메서드 정의 대 한 같음 연산자 <xref:System.Double> 값입니다.  
  
 두 개 <xref:System.Double.NaN?displayProperty=nameWithType> 값을 같음 연산자를 사용 하 여 같은지 테스트할 이면 결과 `false`두; <xref:System.Double.NaN?displayProperty=nameWithType> 값 같은 간주 되지 않습니다. 확장 저장 프로시저를 호출 하 여 같은지 테스트 되는 경우는 <xref:System.Double.Equals%2A> 메서드, 결과 `true`합니다.  확인 하려면 여부의 값은 <xref:System.Double> (NaN) 숫자가 아니거나 대신 호출 하는 것는 <xref:System.Double.IsNaN%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThan%2A> 큼의 작업을 정의 하는 방법-에 대 한 연산자 보다 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />가 <paramref name="right" />보다 크거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThanOrEqual%2A> 메서드 정의 대 한 또는 같음 연산자의 연산을 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Double" /> 값이 같지 않은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Inequality%2A> 메서드 정의 대 한 같지 않음 연산자 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThan%2A> 메서드 작음 연산을 정의-에 대 한 연산자 보다 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThanOrEqual%2A> 작거나 같음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, 또는 형식의 문자열:  
  
 [*ws*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 부호 기호 (-) 또는 더하기 기호 (+) 기호입니다. 선행 기호만 사용할 수 있습니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 실행 *정수 계열 자릿수* 그룹 구분 기호로 분할할 수 있습니다. 예를 들어, 일부 문화권 쉼표 (,) 개의 그룹을 구분 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.|  
|,|Culture 별 1000 단위 구분 기호입니다.|  
|이어야 합니다.|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 `s` 매개 변수를 조합 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. 즉, 해당 공백과 1000 상태인 통화 기호, 구분 기호 허용 됩니다. 에 대 한 보다 세밀 하 게 제어 요소가 허용 되는 스타일 `s` 구문 분석 작업이 성공 하기 위해 호출 된 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> 또는 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 해석 됩니다는 <xref:System.Globalization.NumberFormatInfo> 현재 스레드 문화권에 따라 초기화 된 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>을 참조하세요. 다른 문화권의 서식 지정 정보를 사용 하는 문자열을 구문 분석 하려면 호출는 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 또는 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드, 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 또는 <xref:System.Double.MaxValue> throw 한 <xref:System.OverflowException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Double.Parse%28System.String%29> 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style">
          <c>s</c>에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />의 조합입니다.</param>
        <summary>지정된 스타일의 숫자에 대한 문자열 표현을 해당하는 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` 스타일 요소를 정의 하는 매개 변수 (공백, 1000 단위와 같은 구분 기호 및 통화 기호)에 허용 되는 `s` 구문 분석 작업이 성공 하려면에 대 한 매개 변수입니다. 비트 플래그의 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>합니다. 값에 따라 `style`, 형태를 취할 수 있습니다.  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|$|Culture 별 통화 기호입니다. 문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 현재 문화권의 통화 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.|  
|*sign*|음수 부호 기호 (-) 또는 더하기 기호 (+) 기호입니다. 부호의 시작 부분에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그입니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.|  
|,|Culture 관련 그룹 구분 기호입니다. 현재 문화권의 그룹 구분 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그|  
|이어야 합니다.|Culture 별 소수점 기호입니다. 에 현재 문화권의 소수점 기호가 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다. 소수 자릿수에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `s` 경우 매개 변수 지 수 표기법으로 숫자를 나타낼 수 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버 있을 수 있지만 입력된 문자열에서 제공 되어야 할 필요는 없습니다 있는 요소를 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 있을 수 있는 요소에 영향을 `s`합니다.  
  
|NumberStyles 값|에 허용 되는 요소 `s` 숫자 이외에|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*정수 계열 자릿수* 요소만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (*.*) 및 *소수 자릿수가* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자 지 수 표기법을 나타냅니다. 단독으로이 플래그는 폼의 값을 지원 *자리*E*자릿수*추가; 양수 또는 음수 부호 및 소수점 기호 등의 요소를 사용 하 여 문자열을 구문 분석 하는 데 필요한 플래그입니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*ws* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*ws* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*기호* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*기호* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*기호* 숫자 값이 들어 괄호 안에 형식 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1000 단위 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `s` 16 진수 또는 숫자를 지 수 표기법으로 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 부분이 나 끝 부분에 요소 `s`, *기호* 맨 앞에 `s`, 소수점 (.) 기호입니다. `s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 1000 단위 구분 기호 (,) 및 소수점 (.) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `s` 16 진수를 나타낼 수 없습니다.|  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 따라 초기화 된 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>을 참조하세요.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드, 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 또는 <xref:System.Double.MaxValue> throw 한 <xref:System.OverflowException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 의 문자열 표현을 구문 분석할 메서드의 <xref:System.Double> EN-US 문화권을 사용 하 여 값입니다.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  -또는-  <paramref name="style" />이 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값을 포함합니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="provider">
          <c>s</c>에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 형식의 숫자에 대한 문자열 표현을 해당하는 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드는 여러 가지 방법으로 서식을 지정할 수 있는 텍스트 변환 데 일반적으로 <xref:System.Double> 값입니다. 예를 들어 숫자 값을 위해 HTML 텍스트 상자에 사용자가 입력 하는 텍스트 변환에 사용할 수 있습니다.  
  
 `s` 매개 변수를 조합 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. `s` 매개 변수가 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 로 지정 된 문화권에 대 한 `provider`, 또는 형식의 문자열을 포함할 수 있습니다.  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "자리" 라는 용어를 포함 하는 요소는 일련의 0에서 9 사이의 숫자 문자로 구성 됩니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 부호 기호 (-) 또는 더하기 기호 (+) 기호입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 실행 *정수 계열 자릿수* 그룹 구분 기호로 분할할 수 있습니다. 예를 들어, 일부 문화권 쉼표 (,) 개의 그룹을 구분 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.|  
|이어야 합니다.|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 숫자 형식에 대 한 자세한 내용은 참조는 [형식 지정](~/docs/standard/base-types/formatting-types.md) 항목입니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 의 형식을 해석에 사용 되는 문화권별 정보를 제공 하는 개체 `s`합니다. 일반적으로 <xref:System.Globalization.NumberFormatInfo> 또는 <xref:System.Globalization.CultureInfo> 개체입니다. 경우 `provider` 은 `null` 또는 <xref:System.Globalization.NumberFormatInfo> 를 가져올 수 없으며 서식 지정 정보는 현재 시스템 문화권이 사용 됩니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드, 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 또는 <xref:System.Double.MaxValue> throw 한 <xref:System.OverflowException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 단추 클릭 Web form의 이벤트 처리기입니다. 반환 된 배열을 사용 하 여는 <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> 속성을 사용자의 로캘을 결정 합니다. 그런 다음는 <xref:System.Globalization.CultureInfo> 해당 로캘에 해당 하는 개체입니다. <xref:System.Globalization.NumberFormatInfo> 하에 속하는 개체는 <xref:System.Globalization.CultureInfo> 에 다음 전달 된 개체는 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드는 사용자 입력을 <xref:System.Double> 값입니다.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style">
          <c>s</c>에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />입니다.</param>
        <param name="provider">
          <c>s</c>에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 스타일 및 문화권별 형식의 숫자에 대한 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns>
          <paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` 스타일 요소를 정의 하는 매개 변수 (공백, 1000 단위와 같은 구분 기호 및 통화 기호)에 허용 되는 `s` 구문 분석 작업이 성공 하려면에 대 한 매개 변수입니다. 비트 플래그의 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` 매개 변수에 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 로 지정 된 문화권에 대 한 `provider`합니다. 값에 따라 `style`, 형태를 취할 수 있습니다.  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([및])는 선택적 요소에 구성 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|$|Culture 별 통화 기호입니다. 문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 현재 문화권의 통화 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.|  
|*sign*|음수 부호 기호 (-) 또는 더하기 기호 (+) 기호입니다. 부호의 시작 부분에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그입니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 되어는 *소수 자릿수* 요소입니다.|  
|,|Culture 관련 그룹 구분 기호입니다. 현재 문화권의 그룹 구분 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그|  
|이어야 합니다.|Culture 별 소수점 기호입니다. 에 현재 문화권의 소수점 기호가 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다. 소수 자릿수에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `s` 경우 매개 변수 지 수 표기법으로 숫자를 나타낼 수 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버 있을 수 있지만 입력된 문자열에서 제공 되어야 할 필요는 없습니다 있는 요소를 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 있을 수 있는 요소에 영향을 `s`합니다.  
  
|NumberStyles 값|에 허용 되는 요소 `s` 숫자 이외에|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*정수 계열 자릿수* 요소만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (*.*) 및 *소수 자릿수가* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자 지 수 표기법을 나타냅니다. 단독으로이 플래그는 폼의 값을 지원 *자리*E*자릿수*추가; 양수 또는 음수 부호 및 소수점 기호 등의 요소를 사용 하 여 문자열을 구문 분석 하는 데 필요한 플래그입니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*ws* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*ws* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*기호* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*기호* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*기호* 숫자 값이 들어 괄호 안에 형식 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1000 단위 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `s` 16 진수 또는 숫자를 지 수 표기법으로 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 부분이 나 끝 부분에 요소 `s`, *기호* 맨 앞에 `s`, 소수점 (.) 기호입니다. `s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 1000 단위 구분 기호 (,) 및 소수점 (.) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `s` 16 진수를 나타낼 수 없습니다.|  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 의 형식을 해석에 사용 되는 문화권별 정보를 제공 하는 개체 `s`합니다. 일반적으로 <xref:System.Globalization.NumberFormatInfo> 또는 <xref:System.Globalization.CultureInfo> 개체입니다. 경우 `provider` 은 `null` 또는 <xref:System.Globalization.NumberFormatInfo> 를 가져올 수 없으며 서식 지정 정보는 현재 시스템 문화권이 사용 됩니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드, 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 또는 <xref:System.Double.MaxValue> throw 한 <xref:System.OverflowException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드를 할당 하는 온도 값의 여러 문자열 표현을 `Temperature` 개체입니다.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />가 숫자 값을 나타내지 않는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  -또는-  <paramref name="style" />이 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값입니다.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>양의 무한대를 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 양의 숫자를 0으로 나눈 결과입니다.  
  
 이 상수는 작업의 결과 보다 크면 반환 됩니다 <xref:System.Double.MaxValue>합니다.  
  
 사용 하 여 <xref:System.Double.IsPositiveInfinity%2A> 값이 양의 무한대로 계산 되는지 확인 하려면.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 인스턴스의 값이 0이 아니면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Byte" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 변환은 지원되지 않습니다. 이 메서드를 사용하려고 하면 <see cref="T:System.InvalidCastException" />이 throw됩니다.</summary>
        <returns>이 변환은 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">모든 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 변환은 지원되지 않습니다. 이 메서드를 사용하려고 하면 <see cref="T:System.InvalidCastException" />이 throw됩니다.</summary>
        <returns>이 변환은 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">모든 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Decimal" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>변경되지 않은 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Int16" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Int32" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Int64" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.SByte" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.Single" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">이 <see cref="T:System.Double" /> 값을 변환할 대상 형식입니다.</param>
        <param name="provider">반환된 값의 형식에 대한 문화권별 정보를 제공하는 <see cref="T:System.IFormatProvider" /> 구현입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <paramref name="type" />으로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 `static` (`Shared` Visual basic에서) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.UInt16" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.UInt32" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>
          <see cref="T:System.UInt64" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 메서드 대신 호출 하는 것은 <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString> 메서드 형식을 <xref:System.Double> 에서 값을 기본값 ("G" 또는 일반)는 현재 문화권의 형식입니다. 다른 형식, 전체 자릿수 또는 culture를 지정 하려는 경우 사용의 다른 오버 로드는 <xref:System.Double.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|특정 문화권|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|특정 형식 또는 전체 자릿수|기본 (현재) 문화권|<xref:System.Double.ToString%28System.String%29>|  
|특정 형식 또는 전체 자릿수|특정 문화권|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 형식의 문자열:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "자리" 라는 용어를 포함 하는 요소는 일련의 0에서 9 사이의 숫자 문자로 구성 됩니다. 다음 표에 나열 된 요소가 지원 됩니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*sign*|음수 부호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자는 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|'*.*'|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자의 소수 부분을 지정 하는 숫자입니다.|  
|'*e*'|소문자 'e' 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|*exponential-digits*|일련의 지 수를 지정 하는 숫자입니다.|  
  
 반환 값의 예로 "100", "-123456789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" 및 "-Infinity"입니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 <xref:System.Double.ToString?displayProperty=nameWithType> 메서드의 숫자의 문자열 표현을 표시를 <xref:System.Double> 값입니다.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 다음 예제에서는 <xref:System.Double.ToString%2A>합니다.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 형식 정보를 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스의 값을 <paramref name="provider" />에 지정된 내용에 따라 나타낸 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.IFormatProvider%29> 메서드 형식을 <xref:System.Double> 에서 값을 기본값 ("G" 또는 일반) 지정된 된 문화권의 형식입니다. 다른 형식이 나 문화권을 지정 하려는 경우 사용의 다른 오버 로드는 <xref:System.Double.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재)|<xref:System.Double.ToString>|  
|특정 형식 또는 전체 자릿수|기본 (현재) 문화권|<xref:System.Double.ToString%28System.String%29>|  
|특정 형식 또는 전체 자릿수|특정 문화권|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 형식의 문자열:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "자리" 라는 용어를 포함 하는 요소는 일련의 0에서 9 사이의 숫자 문자로 구성 됩니다. 다음 표에 나열 된 요소가 지원 됩니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*sign*|음수 부호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자는 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|'*.*'|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자의 소수 부분을 지정 하는 숫자입니다.|  
|'*e*'|소문자 'e' 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|*exponential-digits*|일련의 지 수를 지정 하는 숫자입니다.|  
  
 반환 값의 예로 "100", "-123456789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" 및 "-Infinity"입니다.  
  
 이 인스턴스의 형식은 일반 숫자 형식 지정자 ("G")로 지정 됩니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. 일반적으로 `provider` 는 <xref:System.Globalization.CultureInfo> 개체 또는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. `provider` 매개 변수에서 서식 지정에 사용 되는 문화권별 정보를 제공 합니다. 경우 `provider` 은 `null`를 사용 하 여 반환 값의 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 문자열 표현을 표시 <xref:System.Double> 사용 하 여 값 <xref:System.Globalization.CultureInfo> 서로 다른 문화권을 나타내는 개체입니다.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 다음 예제에서는 <xref:System.Double.ToString%2A>해는 <xref:System.String> 및 <xref:System.IFormatProvider> 매개 변수로 합니다.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">숫자 서식 문자열입니다.</param>
        <summary>지정된 형식을 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스의 값을 <paramref name="format" />에 지정된 내용에 따라 나타낸 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%29> 메서드 형식을 <xref:System.Double> 현재 문화권의 규칙을 사용 하 여 지정 된 형식에서 값입니다. 다른 형식이 나 문화권을 지정 하려는 경우 사용의 다른 오버 로드는 <xref:System.Double.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재) 문화권|<xref:System.Double.ToString>|  
|기본 ("G") 형식|특정 문화권|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|특정 형식 또는 전체 자릿수|특정 문화권|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는로 지정 된 숫자의 문자열 표현을 `format`합니다.  
  
 `format` 매개 변수는 D 및 X를 제외한 모든 유효한 표준 숫자 서식 지정자 및 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 경우 `format` 은 `null` 이거나 빈 문자열이 면 반환 값 ("G")는 일반 숫자 형식 지정자와 함께 지정 됩니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 기본적으로 반환 값만 포함 15 자리의 전체 자릿수 내부적으로 최대 17 자리가 유지 합니다. 이 인스턴스의 값이 15 자리 보다 큰 경우 <xref:System.Double.ToString%2A> 반환 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 또는 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 를 초과 합니다. 정교한 정밀도 필요로 하는 경우 지정 `format` 는 항상 반환 17 자리 전체 자릿수 또는 "R", "G17" 형식 지정을 반환 하는 15 자리 수만 될 수 있는 경우 해당 정밀도, 17 자리로 나타낼 수 있는 최대 전체 자릿수도 표시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 숫자 값을 정의 찾아서을 통화 값으로 "C" 표준 숫자 서식 문자열을 사용 하 여과 세 개의 소수 자릿수 숫자 값으로 "N" 표준 숫자 형식 문자열을 사용 하 여입니다. 결과 문자열은 EN-US 문화권의 규칙을 사용 하 여 형식이 지정 됩니다. 숫자 형식 문자열에 대 한 자세한 내용은 참조 하십시오. [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 다음 예제에서는 여러 <xref:System.Double> 와 세 개의 사용자 지정 숫자 형식 문자열을 함께 지원 되는 표준 숫자 서식 지정자를 사용 하 여 값입니다. 패딩 하는 방법을 보여 줍니다 이러한 사용자 지정 형식 문자열 중 하나는 <xref:System.Single> 값 앞에 오는 0입니다. 또한이 예제에서는 "R"를 제외한 각 표준 형식 지정자와 함께 전체 자릿수 지정자를 사용합니다. 전체 자릿수 지정자 범위는 0에서 3 값입니다. 숫자 값을 문자열로 변환할 예제에서는 EN-US 문화권의 형식 규칙을 사용 합니다.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.</exception>
        <block subset="none" type="usage">
          <para>경우에 따라 <see cref="T:System.Double" /> 사용 하 여 컴파일 값은 "R" 표준 숫자 형식 문자열 성공적으로 라운드트립되지 않는로 포맷 된 <see langword="/platform:x64" /> 또는 <see langword="/platform:anycpu" /> 스위치와 64 비트 시스템에서 실행된 합니다. 이 문제를 해결하려면 "G17" 표준 숫자 형식 문자열을 사용하여 <see cref="T:System.Double" /> 값의 형식을 지정할 수 있습니다. 다음 예제에서는 "R" 형식 문자열을 사용 하 여 한 <see cref="T:System.Double" /> 성공적으로 라운드트립되지 않는 값을 사용 하 고 "G17" 형식 문자열도을 성공적으로 라운드트립 원래 값입니다.  [! 코드 csharp [System.Double.ToString#6] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. Double.ToString/cs/roundtripex2.cs#6)] [! vb 코드 [System.Double.ToString#6] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">숫자 서식 문자열입니다.</param>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 형식 및 문화권별 형식 정보를 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>
          <paramref name="format" /> 및 <paramref name="provider" />로 지정된 이 인스턴스 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드 형식을 <xref:System.Double> 지정된 된 문화권의 지정 된 형식에서 값입니다. 다른 형식이 나 문화권을 지정 하려는 경우 사용의 다른 오버 로드는 <xref:System.Double.ToString%2A> 다음과 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 하 여|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재) 문화권|<xref:System.Double.ToString>|  
|기본 ("G") 형식|특정 문화권|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|특정 형식 또는 전체 자릿수|기본 (현재) 문화권|<xref:System.Double.ToString%28System.String%29>|  
  
 반환 값일 수 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는로 지정 된 숫자의 문자열 표현을 `format`합니다.  
  
 `format` 매개 변수는 D 및 X를 제외한 모든 유효한 표준 숫자 서식 지정자 및 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 경우 `format` 은 `null` 이거나 빈 문자열을이 인스턴스에 대 한 반환 값 ("G")는 일반 숫자 형식 지정자와 함께 지정 됩니다.  
  
 .NET Framework에서는 다음 서식 지정 항목에 자세히 설명 하는 광범위 한 서식 지정 지원을 제공 합니다.  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 [표준 숫자 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정 숫자 형식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   서식 지정 하는 방법에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현 인 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. 일반적으로 `provider` 는 <xref:System.Globalization.CultureInfo> 개체 또는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. `provider` 매개 변수에서 서식 지정에 사용 되는 문화권별 정보를 제공 합니다. 경우 `provider` 은 `null`를 사용 하 여 반환 값의 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.  
  
 기본적으로 반환 값만 포함 15 자리의 전체 자릿수 내부적으로 최대 17 자리가 유지 합니다. 이 인스턴스의 값이 15 자리 보다 큰 경우 <xref:System.Double.ToString%2A> 반환 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 또는 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 를 초과 합니다. 정교한 정밀도 필요로 하는 경우 지정 `format` 는 항상 반환 17 자리 전체 자릿수 또는 "R", "G17" 형식 지정을 반환 하는 15 자리 수만 될 수 있는 경우 해당 정밀도, 17 자리로 나타낼 수 있는 최대 전체 자릿수도 표시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 표시 된 <xref:System.Double> 각 지원 되는 표준 숫자 서식 지정자를 사용 하 여 다양 한 문화권에 대 한 값입니다.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 다음 예제에서는 <xref:System.Double.ToString%2A>해는 <xref:System.String> 및 <xref:System.IFormatProvider> 매개 변수로 합니다.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>경우에 따라 <see cref="T:System.Double" /> 사용 하 여 컴파일 값은 "R" 표준 숫자 형식 문자열 성공적으로 라운드트립되지 않는로 포맷 된 <see langword="/platform:x64" /> 또는 <see langword="/platform:anycpu" /> 스위치와 64 비트 시스템에서 실행된 합니다. 이 문제를 해결하려면 "G17" 표준 숫자 형식 문자열을 사용하여 <see cref="T:System.Double" /> 값의 형식을 지정할 수 있습니다. 다음 예제에서는 "R" 형식 문자열을 사용 하 여 한 <see cref="T:System.Double" /> 성공적으로 라운드트립되지 않는 값을 사용 하 고 "G17" 형식 문자열도을 성공적으로 라운드트립 원래 값입니다.  [! 코드 csharp [System.Double.ToString#5] (~/samples/snippets/csharp/VS_Snippets_CLR_System/시스템입니다. Double.ToString/cs/roundtripex1.cs#5)] [! vb 코드 [System.Double.ToString#5] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/시스템입니다. Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="result">이 메서드는 변환이 성공한 경우 <c>s</c> 매개 변수의 배정밀도 부동 소수점 숫자를 반환하고 변환이 실패한 경우 0을 반환합니다. <c>s</c> 매개 변수가 <see langword="null" /> 또는 <see cref="F:System.String.Empty" />이거나 올바른 형식의 숫자가 아니거나, <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타내는 경우 변환이 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다. 원래 <c>result</c>에 제공된 모든 값을 덮어쓰게 됩니다.</param>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 성공적으로 변환되었으면 <paramref name="s" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 다른이 오버 로드는 <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> 메서드 구문 분석 된 숫자 값을 반환 하는 대신 구문 분석 작업이 성공 했는지를 나타내는 부울 값을 반환 합니다. 테스트 하기 위해 예외 처리를 사용할 필요가 <xref:System.FormatException> 에 `s` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (문자열 비교는 대/소문자 구분) 또는 형식의 문자열:  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 부호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|*,*|Culture 관련 그룹 구분 기호입니다.|  
|*.*|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다.|  
|*E*|대 / 소문자 구분 문자 'e' 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|*exponential-digits*|일련의 숫자 0에서 하는 9 사이의 지 수를 지정 합니다.|  
  
 숫자 형식에 대 한 자세한 내용은 참조 [형식 지정](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `s` 매개 변수는 함께 사용 하 여 해석 됩니다는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. 즉, 공백과 천 단위 구분 기호는 사용할 수 있지만 통화 기호를 없는 합니다. 요소를 명시적으로 정의 하려면 (통화 기호, 1000 단위와 같은 구분 기호 및 공백)에 나타날 수 있는 `s`를 사용 하 여는 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 따라 초기화 된 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>을 참조하세요. 구문 분석 하려면 문화권 지정 다른 서식 지정 정보를 사용 하 여, 사용 된 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.TryParse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드, 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 또는 <xref:System.Double.MaxValue> throw 한 <xref:System.OverflowException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 10 진수를 그룹 구분 기호 및 구문 분석 작업을 사용 하는 동안 매개 변수는 동일, 구문 분석 작업의 구분 기호는 그룹 구분 기호가 아니라 소수 구분 기호로 간주 합니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> 숫자 값의 문자열 표현을 상호 변환 하는 메서드 <xref:System.Double> 값입니다. 해당 EN-US가 현재 문화권이 가정 합니다.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style">
          <c>s</c>에 사용할 수 있는 형식을 나타내는 <see cref="T:System.Globalization.NumberStyles" /> 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />입니다.</param>
        <param name="provider">
          <c>s</c>에 대한 문화권별 서식 지정 정보를 제공하는 <see cref="T:System.IFormatProvider" />입니다.</param>
        <param name="result">이 메서드는 변환이 성공한 경우 <c>s</c>에 포함된 숫자 값이나 기호의 배정밀도 부동 소수점 숫자를 반환하며 변환이 실패한 경우 0을 반환합니다. <c>s</c> 매개 변수가 <see langword="null" /> 또는 <see cref="F:System.String.Empty" />이거나, <c>스타일</c>과 규격 형식이 아니거나, <see cref="F:System.SByte.MinValue" />보다 작거나 <see cref="F:System.SByte.MaxValue" />보다 큰 숫자를 나타내거나, <c>스타일</c>이 <see cref="T:System.Globalization.NumberStyles" /> 열거형 상수의 유효한 조합이 아닌 경우 변환이 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다. 원래 <c>result</c>에 제공된 모든 값을 덮어쓰게 됩니다.</param>
        <summary>지정된 스타일 및 문화권별 형식의 숫자에 대한 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 성공적으로 변환되었으면 <paramref name="s" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.TryParse%2A> 방법은 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드와 변환에 실패 하면이 메서드가 예외를 throw 하지 않습니다. 반환 값은 변환이 성공 `true` 및 `result` 매개 변수 변환의 결과를 설정 합니다. 반환 값은 변환이 실패할 경우 `false` 및 `result` 매개 변수를 0으로 설정 합니다. 이렇게 하면 테스트 하기 위해 예외 처리를 사용할 필요가 없습니다. 한 <xref:System.FormatException> 에 `s` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 `style` 매개 변수를 허용 되는 형식을 정의 `s` 구문 분석 작업이 성공 하려면에 대 한 매개 변수입니다. 비트 플래그의 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s` 매개 변수에 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 하 여 지정 된 문화권에 대 한 `provider`합니다. 값에 따라 또한 `style`, `s` 매개 변수는 다음과 같은 요소가 포함 될 수 있습니다.  
  
 [ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 플래그입니다. 끝에 나 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|*$*|Culture 별 통화 기호입니다. 위치는 문자열에 의해 정의 됩니다는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 또는 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 의 속성은 <xref:System.Globalization.NumberFormatInfo> 에서 반환 된 개체는 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 의 메서드는 `provider` 매개 변수입니다. 통화 기호에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.|  
|*sign*|가 선택적 부호입니다. 부호의 시작 부분에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 의 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그입니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 정수 계열 자릿수 수 없어야 경우 소수 자릿수입니다.|  
|*,*|Culture 별 1000 단위 구분 기호입니다. 현재 문화권의 천 단위 구분 기호에 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다.|  
|*.*|Culture 별 소수점 기호입니다. 에 현재 문화권의 소수점 기호가 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다. 소수 자릿수에 나타날 수 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*e*|E 또는 E 문자 임을 나타내는 `s` 지 수 표기법을 사용 하 여 숫자를 표시할 수 있습니다. `s` 매개 변수 스타일을 포함 하는 경우 지 수 표기법으로 숫자를 나타낼 수는 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 사이의 숫자입니다.|  
  
 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버 요소는 입력된 문자열에 필요 하지 않을 수도 있는 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 있을 수 있는 요소에 영향을 `s`합니다.  
  
|NumberStyles 값|S에서 숫자 허용 되는 요소|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*정수 계열 자릿수* 요소만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* 및 *소수 자릿수가* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다. 이 플래그를 단독으로 폼의 값을 지원 *정수 계열 숫자*E*자리 지 수*추가; 등의 요소와 지 수 표기법에서 문자열을 구문 분석 하는 데 필요한 플래그 양수 또는 음수 기호 및 소수점 기호입니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*ws* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*ws* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*기호* 의 시작 부분에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*기호* 의 끝에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*기호* 숫자 값이 들어 괄호 안에 형식 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*,* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|* $ * 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모두. `s` 매개 변수를 16 진수 숫자 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 부분이 나 끝 부분에 요소 `s`, *기호* 맨 앞에 `s`, 및 *합니다.* 기호입니다. `s` 매개 변수로 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 1000 단위 구분 기호 (*,),* 및 소수점 (*.*) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 스타일 제외 하 고 `s` 16 진수를 나타낼 수 없습니다.|  
  
 `provider` 매개 변수는 한 <xref:System.IFormatProvider> 구현에서와 같은 <xref:System.Globalization.NumberFormatInfo> 또는 <xref:System.Globalization.CultureInfo> 개체입니다. `provider` 매개 변수에서 구문 분석에 사용 되는 문화권별 정보를 제공 합니다. 경우 `provider` 은 `null` 또는 <xref:System.Globalization.NumberFormatInfo> 개체를 가져올 수, 현재 문화권에 대 한 형식 정보를 사용 합니다.  
  
 변환에 실패는 `s` 매개 변수는 `null` 또는 숫자 값이 아닌,는 `provider` 매개 변수를 생성 하지 않습니다는 <xref:System.Globalization.NumberFormatInfo> 개체 또는 `style` 매개 변수가의 비트 플래그의 조합을 않습니다는 <xref:System.Globalization.NumberStyles> 열거형입니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.TryParse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열에는 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드, 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도 손실 때문에 값 아니어야 동일 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 또는 <xref:System.Double.MaxValue> throw 한 <xref:System.OverflowException>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 분석 및 적용 가능한 통화 또는 숫자의 소수 하는 동안 매개 변수 및 그룹 구분 기호가 동일 합니다. 구문 분석 작업의 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 특정 스타일 및 특정 문화권의 규칙을 사용 하 여 서식이 지정 된 숫자의 문자열 표현을 구문 분석 하는 메서드.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  -또는-  <paramref name="style" />이 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값을 포함합니다.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>