<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de1a8d1ecd07f9f8d0291eb6d18e2d042042a9b2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730037" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.AppDomain" />의 인스턴스에 추가할 수 있는 어셈블리 바인딩 정보를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 변경는 <xref:System.AppDomainSetup> 인스턴스가 기존에 영향을 주지 않는 <xref:System.AppDomain>합니다. 만들 때에 새의 영향을 줄 수 <xref:System.AppDomain>때는 <xref:System.AppDomain.CreateDomain%2A> 메서드는 <xref:System.AppDomainSetup> 인스턴스를 매개 변수로 합니다.  
  
 이 클래스는 <xref:System.IAppDomainSetup> 인터페이스를 구현합니다.  
  
> [!CAUTION]
>  기본값은 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> 속성이 false입니다. 이 설정은 서비스에 대 한 안전 하지 않습니다. 서비스 부분적으로 신뢰할 수 있는 코드를 다운로드 하는 것을 방지 하려면이 속성을 true로 설정  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">응용 프로그램 도메인에 사용할 활성화 컨텍스트입니다.</param>
        <summary>응용 프로그램 도메인의 매니페스트 기반 활성화에 사용하기 위해 지정된 활성화 컨텍스트를 사용하여 <see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext> 개체에 대해 지정 된 `activationContext` 생성 하는 데 사용 되는 <xref:System.Runtime.Hosting.ActivationArguments> 새 응용 프로그램 도메인을 활성화 하는 데 필요한 정보가 들어 있는 개체입니다. 이 <xref:System.Runtime.Hosting.ActivationArguments> 개체를 사용 하 여 액세스할 수는 <xref:System.AppDomainSetup.ActivationArguments%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" />가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">새 응용 프로그램 도메인의 매니페스트 기반 활성화에 필요한 정보를 지정하는 개체입니다.</param>
        <summary>응용 프로그램 도메인의 매니페스트 기반 활성화에 필요한 지정된 활성화 인수를 사용하여 <see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 지정 된 개체가 `activationArguments` 를 사용 하 여 액세스할 수는 <xref:System.AppDomainSetup.ActivationArguments%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인의 활성화에 대한 데이터를 가져오거나 설정합니다.</summary>
        <value>응용 프로그램 도메인의 활성화에 대한 데이터가 들어 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 예외가 throw 되지 `null`합니다.  
  
 제공한 정보는 <xref:System.Runtime.Hosting.ActivationArguments> 개체가 매니페스트 기반 활성화를 지원 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">응용 프로그램 ID가 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 속성이 반환한 <see cref="T:System.Security.Policy.ApplicationTrust" /> 개체의 응용 프로그램 ID와 일치하지 않는 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 개체로 속성이 설정되어 있습니다. <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 속성이 <see langword="null" />이면 예외가 발생하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인이 초기화될 때 호출되는 콜백 메서드를 나타내는 <see cref="T:System.AppDomainInitializer" /> 대리자를 가져오거나 설정합니다.</summary>
        <value>응용 프로그램 도메인이 초기화될 때 호출되는 콜백 메서드를 나타내는 대리자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 콜백 메서드에 정보를 전달 하려면 문자열의 배열에 할당할는 <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 속성입니다. 배열의 때마다 콜백 메서드로 전달 되는 <xref:System.AppDomain> 초기화 됩니다.  
  
 콜백 메서드는 새로 만든된 응용 프로그램 도메인의 컨텍스트에서 실행 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 자식 응용 프로그램 도메인 `ChildDomain`를 사용 하 여 프로그램 <xref:System.AppDomainSetup> 개체와 기본 응용 프로그램 도메인의 증명 합니다. <xref:System.AppDomainSetup.AppDomainInitializer%2A> 속성은 콜백 메서드로 `AppDomainInit`, 자식 도메인이 초기화 될 때 호출 되는 합니다. 콜백 메서드에 대 한 인수에 할당 하는 문자열의 배열에 배치 됩니다는 <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 속성입니다. 자식 도메인이 만들어지면 콜백 메서드는 단순히 문자열을 출력 합니다.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.AppDomainInitializer" /> 대리자가 나타내는 콜백 메서드로 전달되는 인수를 가져오거나 설정합니다. 콜백 메서드는 응용 프로그램 도메인이 초기화될 때 호출됩니다.</summary>
        <value>
          <see cref="T:System.AppDomain" />이 초기화되는 동안 콜백 메서드가 호출될 때 <see cref="T:System.AppDomainInitializer" /> 대리자가 나타내는 콜백 메서드로 전달되는 문자열 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 속성을 지정 하는 동안 호출 되는 콜백 메서드 <xref:System.AppDomain> 초기화 합니다. 경우는 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 속성이 설정 되지 않으면,이 속성에 할당 된 배열 사용 되지 않습니다.  
  
 콜백 메서드는 새로 만든된 응용 프로그램 도메인의 컨텍스트에서 실행 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 자식 응용 프로그램 도메인을 만듭니다 `ChildDomain`를 사용 하 여 프로그램 <xref:System.AppDomainSetup> 개체와 기본 응용 프로그램 도메인의 증명 합니다. <xref:System.AppDomainSetup.AppDomainInitializer%2A> 속성은 콜백 메서드로 `AppDomainInit`, 자식 도메인이 초기화 될 때 호출 되는 합니다. 콜백 메서드에 대 한 인수에 할당 하는 문자열의 배열에 배치 됩니다는 <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 속성입니다. 자식 도메인이 만들어지면 콜백 메서드는 단순히 문자열을 출력 합니다.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.AppDomainSetup" /> 개체를 사용하여 만든 응용 프로그램 도메인에 대한 응용 프로그램 도메인 관리자의 형식을 제공하는 어셈블리의 표시 이름을 가져오거나 설정합니다.</summary>
        <value>응용 프로그램 도메인 관리자의 <see cref="T:System.Type" />을 제공하는 어셈블리의 표시 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 도메인 관리자의 종류를 지정 하려면이 두 속성을 설정 및 <xref:System.AppDomainSetup.AppDomainManagerType%2A> 속성입니다. 이러한 속성 중 하나를 설정 하지 않으면 다른 무시 됩니다.  
  
 응용 프로그램 도메인 관리자 없는 형식이 제공 하는 경우 부모 응용 프로그램 도메인와 동일한 형식에서 생성 됩니다 (즉, 응용 프로그램 도메인을는 <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> 메서드는).  
  
 응용 프로그램 도메인이 로드 되 면 <xref:System.TypeLoadException> 어셈블리가 없는 경우 또는 어셈블리에 지정 된 형식 없는 경우 throw 되는 <xref:System.AppDomainSetup.AppDomainManagerType%2A> 속성입니다. <xref:System.IO.FileLoadException> 어셈블리를 찾았지만 버전 정보가 일치 하지 않는 경우 throw 됩니다.  
  
 기본 응용 프로그램 도메인에 대 한 응용 프로그램 도메인 관리자를 설정 하려면는 [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) 및 [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) 요소에는 [ \<런타임 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) 섹션에 설명 된 환경 변수를 사용 하 여 응용 프로그램 구성 파일의 <xref:System.AppDomainManager>합니다.  
  
 이 기능에는 응용 프로그램을 완전 신뢰 권한이 필요 합니다. (예를 들어 데스크톱에서 실행 중인 응용 프로그램에 완전 신뢰.) 응용 프로그램에 완전 신뢰가 없는 경우는 <xref:System.TypeLoadException> throw 됩니다.  
  
 형식의 어셈블리 표시 이름 지정 하 여는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.AppDomainSetup" /> 개체를 사용하여 만든 응용 프로그램 도메인에 대한 응용 프로그램 도메인 관리자를 제공하는 형식의 전체 이름을 가져오거나 설정합니다.</summary>
        <value>네임스페이스를 포함한 형식의 전체 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 도메인 관리자의 종류를 지정 하려면이 두 속성을 설정 및 <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> 속성입니다. 이러한 속성 중 하나를 설정 하지 않으면 다른 무시 됩니다.  
  
 응용 프로그램 도메인 관리자 없는 형식이 제공 하는 경우 부모 응용 프로그램 도메인와 동일한 형식에서 생성 됩니다 (즉, 응용 프로그램 도메인을는 <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> 메서드는).  
  
 응용 프로그램 도메인이 로드 되 면 <xref:System.TypeLoadException> 어셈블리에서 지정 된 경우 throw 되는 <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> 속성에이 속성에서 지정 된 유형이 포함 되어 있지 않습니다.  
  
 기본 응용 프로그램 도메인에 대 한 응용 프로그램 도메인 관리자를 설정 하려면는 [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) 및 [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) 요소에는 [ \<런타임 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) 섹션에 설명 된 환경 변수를 사용 하 여 응용 프로그램 구성 파일의 <xref:System.AppDomainManager>합니다.  
  
 이 기능에는 응용 프로그램을 완전 신뢰 권한이 필요 합니다. (예를 들어 데스크톱에서 실행 중인 응용 프로그램에 완전 신뢰.) 응용 프로그램에 완전 신뢰가 없는 경우는 <xref:System.TypeLoadException> throw 됩니다.  
  
 형식의 전체 이름의 형식을 지정 하 여는 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 들어 있는 디렉터리의 이름을 가져오거나 설정합니다.</summary>
        <value>응용 프로그램 기준 위치 디렉터리의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 기본 디렉터리에서 어셈블리 관리자 시작 어셈블리에 대 한 검색입니다.  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성은 응용 프로그램 도메인에 부여 되는 권한에 영향을 줄 수 있습니다. 예를 들어 일반적으로 로컬 컴퓨터에서 시작 된 응용 프로그램 도메인은 원래 위치에 따라 완전 신뢰를 받습니다. 그러나 경우는 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성의 <xref:System.AppDomain> 인트라넷 디렉터리의 전체 이름으로 설정 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 설정은 LocalIntranet grant 응용 프로그램 도메인에도 응용 프로그램 도메인 부여 하는 권한을 제한 실제로 로컬 컴퓨터에서 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성을 여기서 어셈블리 로더가 새 응용 프로그램 도메인에 로드 하는 어셈블리에 대 한 조사를 시작 하는 위치를 설정 합니다.  
  
> [!NOTE]
>  지정한 폴더가 있는지 확인 해야 합니다.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 이름을 가져오거나 설정합니다.</summary>
        <value>응용 프로그램의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 설정 하는 방법을 보여 주는 다음 예제는 <xref:System.AppDomainSetup.ApplicationName%2A> 새 응용 프로그램 도메인을 만들 때 속성입니다.  
  
 이 예제에서는 새 응용 프로그램 도메인을 만들고 호출 합니다는 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> 새 응용 프로그램 도메인에 예제에서는 어셈블리를 로드 하의 인스턴스를 만들고 메서드는 `Worker` 클래스입니다. `Worker` 클래스 상속 <xref:System.MarshalByRefObject>예제에서 반환 되는 프록시를 사용할 수 있도록, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 호출 하는 `TestLoad` 메서드.  
  
 `TestLoad` 메서드 지정 하는 어셈블리를 로드 합니다. 유효한 정규화 된 어셈블리 이름을 지정 하거나 주석으로 처리 해야는 <xref:System.Reflection.Assembly.Load%28System.String%29> 메서드. `TestLoad` 메서드는 지정 된 어셈블리 및 예제에서는 어셈블리를 로드 했는지 보여 주는 새 응용 프로그램 도메인에 로드 된 어셈블리를 나열 합니다.  
  
 이 예제에서는 사용 된 <xref:System.LoaderOptimizationAttribute> 어떻게 공유 하는 코드 응용 프로그램 도메인 간에 어셈블리 로더를 구별 하는 특성입니다.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보안과 신뢰 정보가 들어 있는 개체를 가져오거나 설정합니다.</summary>
        <value>보안과 신뢰 정보가 들어 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 `null` 때는 <xref:System.AppDomainSetup> 만들어집니다. 이 변경 되 면 null 참조로 다시 설정할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">응용 프로그램 ID가 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 속성이 반환한 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 개체의 응용 프로그램 ID와 일치하지 않는 <see cref="T:System.Security.Policy.ApplicationTrust" /> 개체로 속성이 설정되어 있습니다. <see cref="P:System.AppDomainSetup.ActivationArguments" /> 속성이 <see langword="null" />이면 예외가 발생하지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">속성이 <see langword="null" />로 설정됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파일을 섀도 복사한 응용 프로그램 관련 영역의 이름을 가져오거나 설정합니다.</summary>
        <value>파일을 섀도 복사한 디렉터리 경로와 파일의 정규화된 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 적용을 위해는 <xref:System.AppDomainSetup.ApplicationName%2A> 속성 설정 해야 합니다. 경우는 <xref:System.AppDomainSetup.ApplicationName%2A> 속성이 설정 되어 있지는 <xref:System.AppDomainSetup.CachePath%2A> 속성이 무시 되 고 섀도 복사본 캐시 위치는 다운로드 캐시 기본적으로 합니다.  
  
 섀도 복사에 대 한 자세한 내용은 참조 하십시오. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인의 구성 파일 이름을 가져오거나 설정합니다.</summary>
        <value>구성 파일의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구성 파일 검색 규칙 및 응용 프로그램 도메인에 대 한 구성 데이터를 설명합니다. 응용 프로그램 도메인을 만드는 호스트는 의미 있는 값 다 상황에 있기 때문에이 데이터를 제공 합니다.  
  
 예를 들어 ASP.NET 응용 프로그램에 대 한 구성 데이터는 각 응용 프로그램, 사용자 및 컴퓨터에 대 한 실행 파일에 대 한 구성 데이터는 저장 하는 동안 각 응용 프로그램, 사이트 및 컴퓨터에 대 한 저장 됩니다. 호스트만 특정 상황에 대 한 구성 데이터의 고유 정보를 알고 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로드할 어셈블리를 검색할 때 응용 프로그램 기본 경로와 전용 이진 경로를 검색할지 여부를 지정합니다.</summary>
        <value>
          검색이 허용되지 않으면 <see langword="true" />이고, 허용되면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> 속성은 `true`의 값은 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성은 무시 됩니다. 즉, 어셈블리가 없는에서 검색 하 여 지정 된 디렉터리는 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성입니다. 또한 값은 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성 및 <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> 속성은 무시 됩니다. 어셈블리가 없는으로 지정 된 디렉터리에서 검색 된 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성입니다.  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> 속성 로드 프로세스에 대 한 제어의 추가 계층을 제공 합니다. 일반 어셈블리 로딩 시퀀스, 응용 프로그램 기준 위치 하기 전에 검색 된는 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트가 발생 합니다. 그러나 일부 응용 프로그램에서 지정 된 디렉터리에서 또는 전역 어셈블리 캐시에 고유한 알려진된 위치 또는 문서 내 OLE 복합 파일에서 어셈블리를 로드 해야 할 수는 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성입니다. 이러한 응용 프로그램에서 사용할 수는 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> 일반 검색로 인해 지연이 발생을 방지 하 고 일반 검색 경로에 위치할 수 있습니다 하는 데 필요한 어셈블리의 복사본을 로드 하지 않도록 하려면 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인에서 어셈블리 바인딩 리디렉션을 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          어셈블리 리디렉션이 허용되지 않으면 <see langword="true" />이고, 허용되면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> 속성은 어셈블리 바인딩 리디렉션 하지 않은 응용 프로그램 시나리오의 일부 서비스 및 서버 응용 프로그램에서 사용 되도록 설계 되었습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인에서 HTTP를 사용하여 어셈블리를 다운로드할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          HTTP를 사용하여 어셈블리를 다운로드할 수 없으면 <see langword="true" />이고, 다운로드할 수 있으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> 속성은 사용 하도록 서비스 및 응용 프로그램 서버에서 인트라넷 또는 인터넷에서 다운로드 코드는 응용 프로그램 시나리오의 일부가 아닙니다.  
  
> [!CAUTION]
>  기본값은 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> 속성은 `false`합니다. 이 설정은 서비스에 대 한 안전 하지 않습니다. 서비스 부분적으로 신뢰할 수 있는 코드를 다운로드 하는 것을 방지 하려면이 속성을 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>구성 파일의 [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) 섹션이 응용 프로그램 도메인에 적용되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          응용 프로그램 도메인에 대한 구성 파일의 <see langword="&lt;publisherPolicy&gt;" /> 섹션이 무시되면 <see langword="true" />이고, 적용되면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> 속성이 로컬로 로드 되는 웹 응용 프로그램에 특별히 적용 됩니다. 안전 모드에서 안전 하지 않은 웹 응용 프로그램을 실행 하는 악의적인 시도 방지 하려면이 속성을 사용 합니다.  
  
 게시자 정책을 무시 하는 방법에 대 한 자세한 내용은 참조는 [어셈블리 버전 리디렉션](~/docs/framework/configure-apps/redirect-assembly-versions.md) 항목입니다. 안전 모드에 대 한 자세한 내용은의 "구성 파일 검사" 섹션을 참조 하십시오.는 [런타임에서 어셈블리를 찾는 방법을](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) 항목입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적으로 생성된 파일의 디렉터리가 있는 기본 디렉터리를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="P:System.AppDomain.DynamicDirectory" />가 위치한 디렉터리입니다.  
 <block subset="none" type="note"><para>  
 이 속성의 반환 값은 할당된 값과 다릅니다.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 새 응용 프로그램 도메인에 대 한 동적 디렉터리를 배치할 기본 디렉터리를 설정 하려면이 속성을 사용 합니다. 새 응용 프로그램 도메인에서 코드 어셈블리, 어셈블리 확인이 로드 될 때 일반 검색 경로에서 첫 번째 찾습니다. 어셈블리를 찾지 못하면 경우 검색에서 반환 되는 동적 디렉터리는 <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> 속성입니다. 로드 되 고 새 응용 프로그램 도메인에서 실행 하는 동적 어셈블리에 배치할 수 있습니다.  
  
 에 대 한 경로 할당 하면는 <xref:System.AppDomainSetup.DynamicBase%2A> 속성을 추가 하위 디렉터리가 추가 됩니다;이 하위 디렉터리의 이름에 할당 된 값의 해시 코드를는 <xref:System.AppDomainSetup.ApplicationName%2A> 속성입니다. 되므로이 속성에서 반환 된 기본 디렉터리는 항상 할당 된 값과에서 다릅니다.  
  
> [!IMPORTANT]
>  이 속성에 값을 할당 하는 모든 디렉터리 생성 되지 않습니다. 디렉터리는 생성 해야 하거나 메트릭을 사용 하는 코드에서 확인할 수 있습니다.  
  
 동적 디렉터리의 하위 디렉터리가 <xref:System.AppDomainSetup.DynamicBase%2A>합니다. 간단한 이름은 반환 값은 고 <xref:System.AppDomainSetup.ApplicationName%2A> 속성, 해당 형식은입니다 *원래 경로*\\*해시 코드*\\*응용 프로그램 이름*.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 <xref:System.AppDomainSetup.DynamicBase%2A> 동적 어셈블리를 로드할 때 응용 프로그램 도메인의 경로 설정 하려면 속성 검색 합니다.  
  
 이 예에서는 만듭니다는 <xref:System.AppDomainSetup> 개체 및 집합의 <xref:System.AppDomainSetup.ApplicationName%2A> 속성을 "예" 및 해당 <xref:System.AppDomainSetup.DynamicBase%2A> 속성을 "C:\DynamicAssemblyDir"입니다. 이 예제에서는 다음 표시는 <xref:System.AppDomainSetup.DynamicBase%2A> 원래 할당 된 경로의 하위 디렉터리로 응용 프로그램 이름이의 해시 코드를 추가 된 하 합니다.  
  
> [!NOTE]
>  이 예제의 기본 디렉터리는 예제 응용 프로그램에 대 한 검색 경로 이외의 되도록 만들어졌습니다. 다른 위치에 예제를 컴파일하려면 해야 합니다. 기본 디렉터리 및 모든 하위 디렉터리는 예제를 실행할 때마다 삭제 합니다.  
  
 이 예에서는 사용 하 여 새 응용 프로그램 도메인을 만듭니다는 <xref:System.AppDomainSetup> 개체입니다. 그런 다음 예제에서는 아직 없는 경우 동적 디렉터리를 만듭니다. 이 예제에서는 응용 프로그램 도메인을 사용 하지는 않지만 <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> 동적 디렉터리의 이름을 가져올 속성을 쉽게 발생할 수 디렉터리 미리 원래 경로 응용 프로그램 이름의 해시 코드를 연결 하 여 및 응용 프로그램 이름입니다.  
  
 이 예제에는 `GenerateDynamicAssembly` 명명 된 어셈블리를 내보내고 메서드 `DynamicHelloWorld.dll` 새 응용 프로그램 도메인의 동적 디렉터리에 저장 합니다. 동적 어셈블리 유형에서는 포함 되어 `HelloWorld`, 하는 정적 메서드 (`Shared` Visual Basic의에서 메서드) 라는 `HelloFromAD`합니다. 이 메서드를 호출 응용 프로그램 도메인의 이름을 표시 합니다.  
  
 `Example` 클래스에서 파생 <xref:System.MarshalByRefObject>예제에서는 새 응용 프로그램 도메인 및 호출에서 클래스의 인스턴스를 만들 수 있으므로 해당 `Test` 메서드. `Test` 메서드 표시 이름을 사용 하 여 동적 어셈블리를 로드 하 고 정적 호출 `HelloFromAD` 메서드.  
  
 이라는 어셈블리에 대 한 코드를 작성 하 여 일반 검색 경로 후 동적 디렉터리 검색 됩니다 표시할 수 있습니다 `DynamicHelloWorld.dll` 및이 예제와 동일한 디렉터리에 컴파일입니다. 어셈블리에는 라는 클래스를 사용 해야 합니다. `HelloWorld` 라는 정적 메서드가 있는 `HelloFromAD`합니다. 이 메서드는 예제;에 있는 것과 동일한 기능을 제공 하지 않아도 콘솔에 문자열을 표시 하기만 하면 것입니다. 어셈블리 있어야는 <xref:System.Reflection.AssemblyVersionAttribute> 특성을 해당 버전을 1.0.0.0으로 설정 합니다. 예제를 실행 하는 경우 현재 디렉터리에 컴파일된 어셈블리가 동적 디렉터리를 검색 하기 전에.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">응용 프로그램 도메인의 응용 프로그램 이름이 <see langword="null" />이므로 이 속성을 설정할 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 메서드로 설정된 XML 구성 정보를 반환합니다. 이 구성 정보는 응용 프로그램의 XML 구성 정보를 재정의합니다.</summary>
        <returns>
          <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 메서드로 의해 설정된 XML 구성 정보가 들어 있는 배열이거나, <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 메서드가 호출되지 않았으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드를 새 응용 프로그램 도메인을 만드는 응용 프로그램의 구성 정보를 재정의 하는 방법을 제공 합니다. 구성 파일 정보 `value` 응용 프로그램에 대 한 구성 파일 정보를 재정의 합니다. 예를 들어 Example.exe 응용 프로그램이 새 응용 프로그램 도메인을 만들 때 처음에 확보 Example.exe.config 파일에서 구성 정보를 재정의할 수 있습니다.  
  
> [!IMPORTANT]
>  구성 파일에 대 한 정보의 소비자가 저장 한 정보를 사용 하지 마십시오는 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드. 런타임에서이 적용 하지 않습니다. 사용을 보장 하기 위해 모든 구성 파일 정보는 새 응용 프로그램 도메인에서 재정의 되는 <xref:System.AppDomainSetup.ConfigurationFile%2A> 속성을 구성 파일을 지정 합니다. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드는 어셈블리 바인딩에 영향 을지 않습니다.  
  
 XML `value` 같습니다 일반 구성 파일에서 XML로 저장 된 제외 하 고는 <xref:System.Byte> 배열입니다.  
  
 응용 프로그램 도메인에 대 한 구성 바이트에 액세스 하려면 사용 하 여는 <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> 가져올 속성의 <xref:System.AppDomainSetup> 개체 응용 프로그램 도메인에 대 한 다음 사용 하 여는 <xref:System.AppDomainSetup.GetConfigurationBytes%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 도메인과 관련된 라이센스 파일의 위치를 가져오거나 설정합니다.</summary>
        <value>라이선스 파일의 위치 및 이름입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>실행 파일을 로드하는 데 사용되는 최적화 정책을 지정합니다.</summary>
        <value>
          <see cref="T:System.LoaderOptimizationAttribute" />와 함께 사용되는 열거형 상수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예에서는 동적 어셈블리를 만들고 디스크를 사용 하 여 다음에 저장 된 <xref:System.AppDomainSetup.LoaderOptimization%2A> 속성을 응용 프로그램 도메인에 어셈블리를 로드 하는 데 사용 하는 최적화 정책을 설정 합니다.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>샌드박스가 적용된 응용 프로그램 도메인에서 실행 중인 부분 신뢰 코드에 보이는 <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> 플래그로 표시된 어셈블리의 목록을 가져오거나 설정합니다.</summary>
        <value>각 부분 이름이 단순한 이름과 공개 키로 구성되는 부분 어셈블리 이름의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Security.AllowPartiallyTrustedCallersAttribute> 설정 하 여 조건을 (APTCA) 특성을 만들 수 있습니다는 <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> 속성을 <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>합니다. 로 표시 된 APTCA 어셈블리 <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> 호스트 응용 프로그램에서 허용 하지 않는 한 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.  
  
 샌드 박싱된 응용 프로그램 도메인의 호스트는 단순한 이름 및 각 어셈블리의 공개 키를 포함 하는 배열을 만들고이 속성에 할당 하 여 조건부 APTCA 특성이 있는 어셈블리를 사용 하려면 응용 프로그램 도메인에서 코드를 허용 합니다. For example, an element of the array might look like the following: "MyAssembly, PublicKey=0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  서브 클래스를 사용 하는 경우 <xref:System.AppDomainManager>, 조건부 APTCA 특성으로 표시 된 어셈블리에 정의 하는 어셈블리가 종속, 전달 하는 목록에서 해당 어셈블리를 포함 해야 하 고는 <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> 는 속성<xref:System.AppDomainSetup>응용 프로그램 도메인을 만드는 데 사용 합니다. 그렇지 않은 경우 조건부 APTCA 특성으로 표시 되는 어셈블리를 사용할 수 없습니다.  
  
> [!NOTE]
>  샌드 박싱된 응용 프로그램 도메인에서 실행 되는 응용 프로그램을 디버깅 하는 경우 일부 <xref:System.Security.SecurityException> 메시지 잘못 될 수 있습니다. 예를 들어 메시지는 하거나 완전히 신뢰할 수 있는 어셈블리 중 하나에 제한 된 사용 권한을, 샌드 박싱된 응용 프로그램 도메인의 권한 부여 집합을 초과 하는 보안 요청 샌드 박싱된 응용 프로그램 도메인 경계에 전파 된 경우 문제의 실제 원인을 나타낼 수 있습니다 및 실패 했습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 기본 디렉터리 아래에 있는 전용 어셈블리를 검색할 디렉터리 목록을 가져오거나 설정합니다.</summary>
        <value>세미콜론으로 구분된 디렉터리 이름의 목록입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 전용 어셈블리는 응용 프로그램과 동일한 디렉터리 구조에 배포 됩니다. 디렉터리에 대해 지정 된 경우 <xref:System.AppDomainSetup.PrivateBinPath%2A> 아래에 있지 않으면 <xref:System.AppDomainSetup.ApplicationBase%2A>, 무시 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 검색 경로에서 <see cref="P:System.AppDomainSetup.ApplicationBase" />를 포함하거나 제외하고 <see cref="P:System.AppDomainSetup.PrivateBinPath" />만 검색하는 문자열을 가져오거나 설정합니다.</summary>
        <value>어셈블리를 검색할 때 응용 프로그램 기준 위치 경로를 포함하려면 Null 참조(Visual Basic의 경우 <see langword="Nothing" />)이고, 이 경로를 제외하려면 Null이 아닌 임의의 문자열 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 null이 아닌 문자열 값으로이 속성을 설정 합니다. 포함 하 여 <xref:System.String.Empty?displayProperty=nameWithType> (""), 응용 프로그램 디렉터리 경로 제외 하려면-즉, <xref:System.AppDomainSetup.ApplicationBase%2A> -응용 프로그램 및 어셈블리를 검색할 검색 경로에서 에서만 <xref:System.AppDomainSetup.PrivateBinPath%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>각 호출에 대해 <c>QueryInterface</c>가 수행되도록 응용 프로그램 도메인의 interop 호출에 대한 인터페이스 캐싱을 비활성화할지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>
          현재 <see cref="T:System.AppDomainSetup" /> 개체로 만든 응용 프로그램 도메인의 interop 호출에 대한 인터페이스 캐싱이 비활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Interop 호출의 성능이 인터페이스 캐싱을 사용 하지 않도록 설정에 상당한 영향을 줍니다.  
  
 에 도입 된이 멤버는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">호환성 스위치를 지정하는 열거 가능한 문자열 값이거나 기존 호환성 스위치를 제거하는 <see langword="null" />입니다.</param>
        <summary>지정된 스위치를 설정하여 지정된 문제에 대해 이전 버전의 .NET Framework와 호환되는 응용 프로그램 도메인을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 따라.NET Framework의 주 버전을 이전 버전의 주요 변경 내용을 소개합니다. 예를 들어는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 적은 수의 주요 변경 내용에서 소개 된 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다. 사용 하 여는 <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> 메서드를 이러한 주요 변경 사항 중 하나 이상을 지정 롤백해야 응용 프로그램 도메인의 동작을 이전 버전의.NET Framework와 호환 되도록 합니다.  
  
 이 메서드를 호출할 때마다 기존 스위치 설정을 대체 합니다. 설정을 지우려면 지정 `null` 에 대 한는 `switches` 매개 변수입니다.  
  
 에 대해 제공 하는 문자열 값의 집합 `switches` 배열 구현 하기 때문에 간단한 문자열 배열을 수는 <xref:System.Collections.IEnumerable> 인터페이스입니다.  
  
 다음 표에서 이전 버전의.NET Framework의 동작을 복원할로 설정할 수 있는 호환성 스위치의 예제를 제공 합니다.  
  
|전환|의미|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|에 대 한 코드 액세스 보안 (CA)는 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 합니다. 참조 [ &lt;NetFx40_LegacySecurityPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)합니다.|  
|"NetFx40_Legacy20SortingBehavior"|문자열 정렬에 대 한 기본값은 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 활성화 됩니다. 레거시 정렬 동작을 성공적으로 복원 로컬 시스템에서 사용할 수 있도록 sort00001000.dll 동적 링크 라이브러리도 필요 합니다. 참조 [ &lt;CompatSortNLSVersion&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)합니다.|  
|"NetFx40_Legacy40SortingBehavior"|문자열 정렬에 대 한 기본값은 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 유니코드 5.0이 응용 프로그램 도메인에서 사용할 수 있습니다. 레거시 정렬 동작을 성공적으로 복원 하면 sort00060101.dll 동적 연결 라이브러리를 로컬 시스템에서 사용할 수 있어야 합니다.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 서식 지정에 대 한 동작의 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 합니다. 참조 [ &lt;TimeSpan_LegacyFormatMode&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) 및의 "레거시 TimeSpan 서식 복원" 섹션에서 <xref:System.TimeSpan> 항목입니다.|  
|"UseRandomizedStringHashAlgorithm"|문자열에 대 한 해시 코드를 계산 하는 런타임에서 응용 프로그램 도메인 간에 일관 된 해시 코드를 생성 하는 단일 해시 알고리즘을 사용 하는 대신 응용 프로그램 도메인 단위로 합니다. 참조 [ &lt;UseRandomizedStringHashAlgorithm&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)합니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">응용 프로그램 도메인에 사용할 XML 구성 정보가 들어 있는 배열입니다.</param>
        <summary>응용 프로그램 도메인에 XML 구성 정보를 제공하여 응용 프로그램의 XML 구성 정보를 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드를 새 응용 프로그램 도메인을 만드는 응용 프로그램의 구성 정보를 대체 하는 방법을 제공 합니다. 구성 파일 정보 `value` 응용 프로그램에 대 한 구성 파일 정보를 대체 합니다. 예를 들어 Example.exe 응용 프로그램이 새 응용 프로그램 도메인을 만들 때 처음에 확보 Example.exe.config 파일에서 구성 정보를 바꿀 수 것입니다.  
  
> [!IMPORTANT]
>  구성 파일에 대 한 정보의 소비자가 저장 한 정보를 사용 하지 마십시오는 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드. 런타임에서이 적용 하지 않습니다. 새 응용 프로그램 도메인에서 모든 구성 파일 정보가 대체 되도록 하려면 사용 하 여는 <xref:System.AppDomainSetup.ConfigurationFile%2A> 속성을 구성 파일을 지정 합니다. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드는 어셈블리 바인딩에 영향 을지 않습니다.  
  
 XML `value` 같습니다 일반 구성 파일에서 XML로 저장 된 제외 하 고는 <xref:System.Byte> 배열입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">재정의할 문자열 비교 함수의 이름입니다.</param>
        <param name="functionVersion">함수 버전입니다. [!INCLUDE[net_v45](~/includes/net-v45-md.md)]의 경우 값은 1 이상이어야 합니다.</param>
        <param name="functionPointer">
          <c>functionName</c>을 재정의하는 함수에 대한 포인터입니다.</param>
        <summary>공용 언어 런타임에 문자열 비교 함수의 대체 구현을 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 문자열 비교 및 정렬 방법을으로 재정의할 수 있습니다는 <xref:System.AppDomainSetup.SetNativeFunction%2A> 메서드:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 이러한 함수에 대 한 정보를 참조 하십시오. [국가별 언어 지원 기능](http://go.microsoft.com/fwlink/?LinkId=228134)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" />가 1 이상입니다.  
  
 또는  
  
 <paramref name="functionPointer" />가 <see cref="F:System.IntPtr.Zero" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>섀도 복사할 어셈블리가 들어 있는 디렉터리의 이름을 가져오거나 설정합니다.</summary>
        <value>세미콜론으로 구분된 디렉터리 이름의 목록입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본값은 섀도 복사본; 검색을 통해 찾은 모든 어셈블리를 섀도 복사를 사용 하는 경우 즉, 지정 된 디렉터리에서는 <xref:System.AppDomainSetup.PrivateBinPath%2A> 및 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성입니다. <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 속성으로 지정 된 디렉터리에서 어셈블리를 섀도 복사를 제한 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>합니다.  
  
 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 속성에 문자열을 할당하거나 이 속성을 `null`로 설정하면 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성을 통해 지정된 디렉터리의 모든 어셈블리가 섀도 복사됩니다.  
  
> [!IMPORTANT]
>  세미콜론은 구분 기호 문자이므로 디렉터리 경로에 세미콜론을 포함하면 안 됩니다. 세미콜론에 대한 이스케이프 문자는 없습니다.  
  
 섀도 복사 되 고 어셈블리를 로드 하기 전에 어셈블리 파일을 다른 위치로 복사 됩니다. 업데이트할 수 있도록 원래 어셈블리 파일 잠겨 있지 않습니다. 섀도 복사에 대 한 자세한 내용은 참조 하십시오. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>섀도 복사를 설정하거나 해제할지 여부를 나타내는 문자열을 가져오거나 설정합니다.</summary>
        <value>섀도 복사가 설정되었음을 나타내려면 문자열 값 "true"이고, 섀도 복사가 해제되었음을 나타내려면 "false"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 섀도 복사에 대 한 자세한 내용은 참조 하십시오. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> 생성자가 구문 분석할 수 있는 형식으로 응용 프로그램에 대한 .NET Framework의 대상 버전 및 프로필을 지정하는 문자열을 가져오거나 설정합니다.</summary>
        <value>.NET Framework의 대상 버전 및 프로필입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 실행 중인 버전의.NET Framework 응용 프로그램 도메인 로드 대상 버전 및 프로필에 대 한 컴파일된 어셈블리를 실행 하는이 속성을 설정 합니다. 현재 실행 중인 버전의.NET Framework 대상 버전으로 컴파일된 코드의 호환성에 영향을 주는 선택적 동작 있으면 것 설정 하거나 해제할 수 호환성을 개선 하기 위해 적절 하 게 이러한 동작 합니다. 응용 프로그램에서 별도 응용 프로그램 도메인에서이 실행 하 여 여러 버전의.NET Framework를 사용 하 여 컴파일된 추가 기능을 지 원하는 경우에 유용할 수 있습니다.  
  
 클라이언트 응용 프로그램의 값에 대 한는 <xref:System.AppDomainSetup.TargetFrameworkName%2A> 속성에서 유추 되는 <xref:System.Runtime.Versioning.TargetFrameworkAttribute> 특성입니다. [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] 이 특성은 프로젝트의 설정에 따라 자동으로 어셈블리에 추가 하는 나중 및 **대상 프레임 워크** 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>