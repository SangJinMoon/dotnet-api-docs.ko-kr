<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Exception.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52f4b69061befa3abe028db5ebd872b4e0edcdf12.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2f4b69061befa3abe028db5ebd872b4e0edcdf12</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Exception">
          <source>Represents errors that occur during application execution.</source>
          <target state="translated">응용 프로그램을 실행할 때 나타나는 오류를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This class is the base class for all exceptions.</source>
          <target state="translated">이 클래스는 모든 예외에 대 한 기본 클래스입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an error occurs, either the system or the currently executing application reports it by throwing an exception that contains information about the error.</source>
          <target state="translated">오류가 발생 하면 시스템이 나 현재 실행 중인 응용 프로그램 오류에 대 한 정보를 포함 하는 예외를 throw 하 여 보고 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>After an exception is thrown, it is handled by the application or by the default exception handler.</source>
          <target state="translated">예외가 throw 되 면 응용 프로그램이 나 기본 예외 핸들러에서 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this section:</source>
          <target state="translated">섹션 내용</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Errors and exceptions<ept id="p1">](#Errors)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>오류 및 예외<ept id="p1">](#Errors)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Try/catch blocks<ept id="p1">](#TryCatch)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Try/catch 블록<ept id="p1">](#TryCatch)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Exception type features<ept id="p1">](#Features)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>예외 형식 기능<ept id="p1">](#Features)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Exception class properties<ept id="p1">](#Properties)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>예외 클래스 속성<ept id="p1">](#Properties)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Performance considerations<ept id="p1">](#Performance)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>성능 고려 사항<ept id="p1">](#Performance)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Re-throwing an exception<ept id="p1">](#Rethrow)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>다시 예외를 throw합니다.<ept id="p1">](#Rethrow)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Choosing standard exceptions<ept id="p1">](#Standard)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>표준 예외를 선택합니다.<ept id="p1">](#Standard)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Implementing custom exceptions<ept id="p1">](#Custom)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>사용자 지정 예외를 구현합니다.<ept id="p1">](#Custom)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Errors and exceptions</source>
          <target state="translated">오류 및 예외</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Run-time errors can occur for a variety of reasons.</source>
          <target state="translated">런타임 오류는 여러 가지 이유로 발생할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>However, not all errors should be handled as exceptions in your code.</source>
          <target state="translated">그러나 모든 오류 코드에서 예외로 처리 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Here are some categories of errors that can occur at run time and the appropriate ways to respond to them.</source>
          <target state="translated">다음은 몇 가지 종류의 실행 시간과 적절 하 게 응답할 수에 발생할 수 있는 오류입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>Usage errors.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>사용 현황 오류가 발생 했습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A usage error represents an error in program logic that can result in an exception.</source>
          <target state="translated">사용 오류를 예외가 발생할 수 있는 프로그램 논리에서 오류를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>However, the error should be addressed not through exception handling but by modifying the faulty code.</source>
          <target state="translated">그러나 예외 처리를 통해 하지 않지만 잘못 된 코드를 수정 하 여 오류를 해결 해야 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, the override of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method in the following example assumes that the <ph id="ph2">`obj`</ph> argument must always be non-null.</source>
          <target state="translated">예를 들어 재정의 <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> 다음 예제에서 메서드 있다고 가정는 <ph id="ph2">`obj`</ph> 인수에 null이 아닌 여야 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> exception that results when <ph id="ph2">`obj`</ph> is <ph id="ph3">`null`</ph> can be eliminated by modifying the source code to explicitly test for null before calling the <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> override and then re-compiling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 결과로 생성 되는 예외 때 <ph id="ph2">`obj`</ph> 은 <ph id="ph3">`null`</ph> 소스 코드를 명시적으로 호출 하기 전에 null에 대 한 테스트를 수정 하 여 제거할 수는 <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> override 및 다시 컴파일입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example contains the corrected source code that handles a <ph id="ph1">`null`</ph> argument.</source>
          <target state="translated">다음 예제에서는 처리 하는 수정 된 소스 코드를 포함 한 <ph id="ph1">`null`</ph> 인수입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead of using exception handling for usage errors, you can use the <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType&gt;</ph> method to identify usage errors in debug builds, and the <ph id="ph2">&lt;xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType&gt;</ph> method to identify usage errors in both debug and release builds.</source>
          <target state="translated">예외 사용 오류에 대 한 처리를 사용 하는 대신 사용할 수는 <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType&gt;</ph> 디버그 빌드에서 사용 오류를 식별 하는 메서드 및 <ph id="ph2">&lt;xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType&gt;</ph> 에 디버그 및 릴리스를 모두 사용 오류를 식별 하는 메서드를 작성 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see <bpt id="p1">[</bpt>Assertions in Managed Code<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>관리 코드에 어설션<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>Program errors.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>프로그램 오류가 발생 했습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A program error is a run-time error that cannot necessarily be avoided by writing bug-free code.</source>
          <target state="translated">프로그램 오류에는 반드시 오류가 없는 코드를 작성 하 여 방지할 수 없는 런타임 오류가입니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In some cases, a program error may reflect an expected or routine error condition.</source>
          <target state="translated">경우에 따라 프로그램 오류는 예상 또는 라우팅 오류 상태를 반영할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this case, you may want to avoid using exception handling to deal with the program error and instead retry the operation.</source>
          <target state="translated">이 경우 다음 예외 처리를 사용 하 여 프로그램 오류를 처리 하 고 대신 작업을 다시 시도를 방지 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if the user is expected to input a date in a particular format, you can parse the date string by calling the <ph id="ph1">&lt;xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> value that indicates whether the parse operation succeeded, instead of using the <ph id="ph3">&lt;xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType&gt;</ph> method, which throws a <ph id="ph4">&lt;xref:System.FormatException&gt;</ph> exception if the date string cannot be converted to a <ph id="ph5">&lt;xref:System.DateTime&gt;</ph> value.</source>
          <target state="translated">예를 들어 사용자는 특정 형식으로 날짜를 입력 해야 하는 경우 구문을 분석할 수 있습니다 날짜 문자열 호출 하 여는 <ph id="ph1">&lt;xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType&gt;</ph> 반환 하는 <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> 구문 분석 작업이 성공 했는지를 나타내는는 를사용하는대신값<ph id="ph3">&lt;xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType&gt;</ph>throw 하는 메서드는 <ph id="ph4">&lt;xref:System.FormatException&gt;</ph> 날짜 문자열을 변환할 수 없는 경우 예외는 <ph id="ph5">&lt;xref:System.DateTime&gt;</ph> 값입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Similarly, if a user tries to open a file that does not exist, you can first call the <ph id="ph1">&lt;xref:System.IO.File.Exists%2A?displayProperty=nameWithType&gt;</ph> method to check whether the file exists and, if it does not, prompt the user whether he or she wants to create it.</source>
          <target state="translated">마찬가지로, 존재 하지 않는 파일을 사용자가을 먼저 호출는 <ph id="ph1">&lt;xref:System.IO.File.Exists%2A?displayProperty=nameWithType&gt;</ph> 메서드를 있는지 확인 하는 파일이 고, 존재 하지 않는 경우 사용자 만들 하려고 하는지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In other cases, a program error reflects an unexpected error condition that can be handled in your code.</source>
          <target state="translated">다른 경우에 프로그램 오류 코드에서 처리 될 수 있는 예기치 않은 오류 조건을 반영 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, even if you've checked to ensure that a file exists, it may be deleted before you can open it, or it may be corrupted.</source>
          <target state="translated">예를 들어 파일을 포함 하기 위한를 선택한 경우에이 삭제 될 수 있습니다 열 수 또는 손상 되었을 수 있기 전에 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In that case, trying to open the file by instantiating a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object or calling the <ph id="ph2">&lt;xref:System.IO.File.Open%2A&gt;</ph> method may throw a <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph> exception.</source>
          <target state="translated">인스턴스화하여 파일을 열려고 할 경우에 <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> 개체 또는 호출의 <ph id="ph2">&lt;xref:System.IO.File.Open%2A&gt;</ph> 메서드가 throw 할 수 있습니다는 <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In these cases, you should use exception handling to recover from the error.</source>
          <target state="translated">이러한 경우 예외 처리 오류에서 복구를 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>System failures.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>시스템 오류가 발생 했습니다.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A system failure is a run-time error that cannot be handled programmatically in a meaningful way.</source>
          <target state="translated">시스템 오류는 의미 있는 방식으로 프로그래밍 방식으로 처리할 수 없는 런타임 오류입니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, any method can throw an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception if the common language runtime is unable to allocate additional memory.</source>
          <target state="translated">예를 들어 모든 메서드가 throw 할 수는 <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> 공용 언어 런타임 추가 메모리를 할당할 수 없는 경우 예외입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Ordinarily, system failures are not handled by using exception handling.</source>
          <target state="translated">일반적으로 시스템 오류 예외 처리를 사용 하 여 처리 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, you may be able to use an event such as <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> and call the <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> method to log exception information and notify the user of the failure before the application terminates.</source>
          <target state="translated">대신,와 같은 이벤트를 사용할 수 있습니다 <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> 호출의 <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> 예외 정보를 기록 하는 응용 프로그램을 종료 하기 전에 실패의 사용자에 게 알리는 메서드.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Try/catch blocks</source>
          <target state="translated">Try/catch 블록</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The common language runtime provides an exception handling model that is based on the representation of exceptions as objects, and the separation of program code and exception handling code into <ph id="ph1">`try`</ph> blocks and <ph id="ph2">`catch`</ph> blocks.</source>
          <target state="translated">프로그램 코드와 예외 처리 코드를 분리 및 예외 개체로 표시를 기반으로 하는 예외 처리 모델을 제공 하는 공용 언어 런타임 <ph id="ph1">`try`</ph> 블록 및 <ph id="ph2">`catch`</ph> 블록입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>There can be one or more <ph id="ph1">`catch`</ph> blocks, each designed to handle a particular type of exception, or one block designed to catch a more specific exception than another block.</source>
          <target state="translated">하나 이상의 수 <ph id="ph1">`catch`</ph> 각각은 특정 유형의 예외 또는 다른 블록 보다 더 구체적인 예외를 catch 하는 데 사용 하기 위한 처리 차단 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If an application handles exceptions that occur during the execution of a block of application code, the code must be placed within a <ph id="ph1">`try`</ph> statement and is called a <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">내 코드에 존재 해야 응용 프로그램에서 응용 프로그램 코드 블록을 실행 하는 동안 발생 하는 예외를 처리 하는 경우는 <ph id="ph1">`try`</ph> 문을 라고는 <ph id="ph2">`try`</ph> 블록입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Application code that handles exceptions thrown by a <ph id="ph1">`try`</ph> block is placed within a <ph id="ph2">`catch`</ph> statement and is called a <ph id="ph3">`catch`</ph> block.</source>
          <target state="translated">발생 한 예외를 처리 하는 응용 프로그램 코드는 <ph id="ph1">`try`</ph> 블록 내에 배치 되는 <ph id="ph2">`catch`</ph> 문을 라고 하 고는 <ph id="ph3">`catch`</ph> 블록.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Zero or more <ph id="ph1">`catch`</ph> blocks are associated with a <ph id="ph2">`try`</ph> block, and each <ph id="ph3">`catch`</ph> block includes a type filter that determines the types of exceptions it handles.</source>
          <target state="translated">0 개 이상의 <ph id="ph1">`catch`</ph> 블록 연관 된 한 <ph id="ph2">`try`</ph> 블록 및 각 <ph id="ph3">`catch`</ph> 블록을 처리 하는 예외의 형식을 결정 하는 형식 필터를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an exception occurs in a <ph id="ph1">`try`</ph> block, the system searches the associated <ph id="ph2">`catch`</ph> blocks in the order they appear in application code, until it locates a <ph id="ph3">`catch`</ph> block that handles the exception.</source>
          <target state="translated">예외가 발생 하는 경우는 <ph id="ph1">`try`</ph> 블록, 시스템 연결 된 검색 <ph id="ph2">`catch`</ph> 찾을 때까지 응용 프로그램 코드에서 나타나는 순서에 저장 되어 블록는 <ph id="ph3">`catch`</ph> 예외를 처리 하는 블록입니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A <ph id="ph1">`catch`</ph> block handles an exception of type <ph id="ph2">`T`</ph> if the type filter of the catch block specifies <ph id="ph3">`T`</ph> or any type that <ph id="ph4">`T`</ph> derives from.</source>
          <target state="translated">A <ph id="ph1">`catch`</ph> 형식의 예외를 처리 하는 블록 <ph id="ph2">`T`</ph> catch 블록의 형식 필터를 지정 하는 경우 <ph id="ph3">`T`</ph> 있는 모든 형식 또는 <ph id="ph4">`T`</ph> 에서 파생 됩니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The system stops searching after it finds the first <ph id="ph1">`catch`</ph> block that handles the exception.</source>
          <target state="translated">첫 번째를 찾은 다음 검색 시스템이 중지 <ph id="ph1">`catch`</ph> 예외를 처리 하는 블록입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For this reason, in application code, a <ph id="ph1">`catch`</ph> block that handles a type must be specified before a <ph id="ph2">`catch`</ph> block that handles its base types, as demonstrated in the example that follows this section.</source>
          <target state="translated">응용 프로그램 코드에서 이러한 이유로 <ph id="ph1">`catch`</ph> 전에 형식을 처리 하는 블록을 지정 해야 합니다는 <ph id="ph2">`catch`</ph> 이 섹션 다음에 나오는 예제에서와 같이 해당 기본 형식의 처리 하는 블록입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A catch block that handles <ph id="ph1">`System.Exception`</ph> is specified last.</source>
          <target state="translated">처리 하는 catch 블록 <ph id="ph1">`System.Exception`</ph> 마지막에 지정 됩니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If none of the <ph id="ph1">`catch`</ph> blocks associated with the current <ph id="ph2">`try`</ph> block handle the exception, and the current <ph id="ph3">`try`</ph> block is nested within other <ph id="ph4">`try`</ph> blocks in the current call, the <ph id="ph5">`catch`</ph> blocks associated with the next enclosing <ph id="ph6">`try`</ph> block are searched.</source>
          <target state="translated">아닌 경우는 <ph id="ph1">`catch`</ph> 블록과 연결 된 현재 <ph id="ph2">`try`</ph> 블록 처리는 예외와 현재 <ph id="ph3">`try`</ph> 내 다른 블록에 중첩 <ph id="ph4">`try`</ph> 현재 호출에서 차단는 <ph id="ph5">`catch`</ph> 다음와 연결 된 블록 바깥쪽 <ph id="ph6">`try`</ph> 블록이 검색 됩니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no <ph id="ph1">`catch`</ph> block for the exception is found, the system searches previous nesting levels in the current call.</source>
          <target state="translated">되지 않은 경우 <ph id="ph1">`catch`</ph> 발견 되는 예외에 대 한 블록, 현재 호출에서 이전 중첩 수준을 검색 합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no <ph id="ph1">`catch`</ph> block for the exception is found in the current call, the exception is passed up the call stack, and the previous stack frame is searched for a <ph id="ph2">`catch`</ph> block that handles the exception.</source>
          <target state="translated">없는 경우 <ph id="ph1">`catch`</ph> 현재 호출에서 예외가 발견 예외 호출 스택에서 전달 되 고 이전 스택 프레임에 대 한 검색에 대 한 차단는 <ph id="ph2">`catch`</ph> 예외를 처리 하는 블록입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The search of the call stack continues until the exception is handled or until no more frames exist on the call stack.</source>
          <target state="translated">호출 스택 검색에 더 이상 프레임이 호출 스택에 있을 때까지 또는 예외가 처리 될 때까지 계속 됩니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If the top of the call stack is reached without finding a <ph id="ph1">`catch`</ph> block that handles the exception, the default exception handler handles it and the application terminates.</source>
          <target state="translated">찾지 못한 채 호출 스택의 위쪽에 도달 하는 경우는 <ph id="ph1">`catch`</ph> 기본 예외 핸들러가 예외를 처리 하는 블록을 처리 하 고 응용 프로그램을 종료 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception type features</source>
          <target state="translated">예외 형식 기능</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception types support the following features:</source>
          <target state="translated">예외 형식은 다음과 같은 기능을 지원합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Human-readable text that describes the error.</source>
          <target state="translated">오류를 설명 하는 사람이 읽을 수 있는 텍스트입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an exception occurs, the runtime makes a text message available to inform the user of the nature of the error and to suggest action to resolve the problem.</source>
          <target state="translated">예외가 발생 하면 실행은 문제를 해결 하려면 작업을 제안 하 고 오류의 특성의 사용자에 게에 사용할 수 있는 문자 메시지입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This text message is held in the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the exception object.</source>
          <target state="translated">이 문자 메시지에 유지 되는 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 예외 개체의 속성입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>During the creation of the exception object, you can pass a text string to the constructor to describe the details of that particular exception.</source>
          <target state="translated">예외 개체를 만드는 동안 해당 특정 예외에 대 한 세부 정보를 설명 하기 위해 생성자에는 텍스트 문자열을 전달할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no error message argument is supplied to the constructor, the default error message is used.</source>
          <target state="translated">오류 메시지 인수 없는 생성자에 제공 되는 경우 기본 오류 메시지에 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성을 참조하세요.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The state of the call stack when the exception was thrown.</source>
          <target state="translated">호출 스택에 예외가 throw 되었을 때의 상태입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property carries a stack trace that can be used to determine where the error occurs in the code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> 속성은 오류 코드에서 발생 한 위치를 결정 하는 데 사용할 수 있는 스택 추적을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The stack trace lists all the called methods and the line numbers in the source file where the calls are made.</source>
          <target state="translated">스택 추적에서 호출된 되는 모든 메서드 및 호출 하 여 수행 되는 소스 파일의 줄 번호를 나열 합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception class properties</source>
          <target state="translated">예외 클래스 속성</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class includes a number of properties that help identify the code location, the type, the help file, and the reason for the exception: <ph id="ph2">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Exception.Message%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Exception.HelpLink%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Exception.HResult%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Exception.Source%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Exception.Data%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph> 코드 위치, 유형, 도움말 파일 및 예외에 대 한 이유를 식별 하는 데 도움이 되는 속성의 수를 포함 하는 클래스: <ph id="ph2">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Exception.Message%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Exception.HelpLink%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Exception.HResult%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Exception.Source%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>, 및 <ph id="ph9">&lt;xref:System.Exception.Data%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When a causal relationship exists between two or more exceptions, the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property maintains this information.</source>
          <target state="translated">둘 이상의 예외 간에 인과 관계가 존재 하는 경우는 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성은이 정보를 유지 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The outer exception is thrown in response to this inner exception.</source>
          <target state="translated">이 내부 예외에 대 한 응답으로 외부 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The code that handles the outer exception can use the information from the earlier inner exception to handle the error more appropriately.</source>
          <target state="translated">외부 예외를 처리 하는 코드 오류를 보다 적절 하 게 처리할 수 이전 내부 예외에서 정보를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Supplementary information about the exception can be stored as a collection of key/value pairs in the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property.</source>
          <target state="translated">키/값 쌍의 컬렉션으로 예외에 대 한 보충 정보를 저장할 수 있습니다는 <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The error message string that is passed to the constructor during the creation of the exception object should be localized and can be supplied from a resource file by using the <ph id="ph1">&lt;xref:System.Resources.ResourceManager&gt;</ph> class.</source>
          <target state="translated">예외 개체를 만드는 동안 생성자에 전달 되는 오류 메시지 문자열을 지역화 해야 하 고 사용 하 여 리소스 파일에서 제공 될 수 있습니다는 <ph id="ph1">&lt;xref:System.Resources.ResourceManager&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information about localized resources, see the <bpt id="p1">[</bpt>Creating Satellite Assemblies<ept id="p1">](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)</ept> and <bpt id="p2">[</bpt>Packaging and Deploying Resources<ept id="p2">](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)</ept> topics.</source>
          <target state="translated">지역화 된 리소스에 대 한 자세한 내용은 참조는 <bpt id="p1">[</bpt>위성 어셈블리 만들기<ept id="p1">](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)</ept> 및 <bpt id="p2">[</bpt>리소스 패키징 및 배포<ept id="p2">](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To provide the user with extensive information about why the exception occurred, the <ph id="ph1">&lt;xref:System.Exception.HelpLink%2A&gt;</ph> property can hold a URL (or URN) to a help file.</source>
          <target state="translated">예외가 발생 한 이유에 대 한 광범위 한 정보로 사용자를 제공 하는 <ph id="ph1">&lt;xref:System.Exception.HelpLink%2A&gt;</ph> 속성 도움말 파일에 대 한 URL 또는 URN을 보유할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class uses the HRESULT COR_E_EXCEPTION, which has the value 0x80131500.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph> 0x80131500 값이 있는 HRESULT COR_E_EXCEPTION 클래스를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For a list of initial property values for an instance of the <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class, see the <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructors.</source>
          <target state="translated">인스턴스에 대 한 초기 속성 값 목록은 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 클래스를 참조 하십시오.는 <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Performance considerations</source>
          <target state="translated">성능 고려 사항</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Throwing or handling an exception consumes a significant amount of system resources and execution time.</source>
          <target state="translated">Throw 되거나 예외 처리는 상당한 양의 시스템 리소스 및 실행 시간을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Throw exceptions only to handle truly extraordinary conditions, not to handle predictable events or flow control.</source>
          <target state="translated">정말 비정상적인 상태를 예측 가능한 이벤트를 처리 하거나 제어 흐름 처리에 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, in some cases, such as when you're developing a class library, it's reasonable to throw an exception if a method argument is invalid, because you expect your method to be called with valid parameters.</source>
          <target state="translated">예를 들어 클래스 라이브러리를 개발 하는 경우 등 일부 경우에 상태일 메서드 인수 유효 하지 않을 경우, 유효한 매개 변수와 함께 호출 될 메서드를 예상 하기 때문에 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An invalid method argument, if it is not the result of a usage error, means that something extraordinary has occurred.</source>
          <target state="translated">잘못 된 메서드 인수로 사용 오류 결과인 경우에 비정상적인 상황이 발생 했습니다 의미 합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Conversely, do not throw an exception if user input is invalid, because you can expect users to occasionally enter invalid data.</source>
          <target state="translated">반대로, 사용자 입력 유효 하지 않을 경우, 사용자가을 때때로 잘못 된 데이터를 입력할 수도 있으므로 예외를 throw 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, provide a retry mechanism so users can enter valid input.</source>
          <target state="translated">대신, 사용자가 유효한 입력을 입력할 수 있도록 다시 시도 메커니즘을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Nor should you use exceptions to handle usage errors.</source>
          <target state="translated">예외 사용 오류 처리를 사용 해야 하거나.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, use <bpt id="p1">[</bpt>assertions<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept> to identify and correct usage errors.</source>
          <target state="translated">대신를 사용 하 여 <bpt id="p1">[</bpt>어설션을<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept> 식별 하 고 사용 오류를 수정 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In addition, do not throw an exception when a return code is sufficient; do not convert a return code to an exception; and do not routinely catch an exception, ignore it, and then continue processing.</source>
          <target state="translated">반환 코드는; 충분 한 경우 예외를 throw 하지 않는 또한 예외를 반환 코드를 변환 하지 마십시오 및 수행 하지 정기적으로 catch 예외,를 무시 하 고 처리를 계속 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Re-throwing an exception</source>
          <target state="translated">예외 다시 throw</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In many cases, an exception handler simply wants to pass the exception on to the caller.</source>
          <target state="translated">에서는 대부분의 경우 예외 처리기 단순히가 호출자에 게는 예외를 전달 합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This most often occurs in:</source>
          <target state="translated">이 대부분에서 자주 발생 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A class library that in turn wraps calls to methods in the .NET Framework class library or other class libraries.</source>
          <target state="translated">래핑합니다.NET Framework 클래스 라이브러리 또는 다른 클래스 라이브러리에 대 한 메서드를 호출 하는 클래스 라이브러리입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An application or library that encounters a fatal exception.</source>
          <target state="translated">응용 프로그램 또는 치명적인 예외가 발생 하는 라이브러리입니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The exception handler can log the exception and then re-throw the exception.</source>
          <target state="translated">예외 처리기는 예외를 기록 하 고 예외를 다시 throw 수입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The recommended way to re-throw an exception is to simply use the <bpt id="p1">[</bpt>throw<ept id="p1">](~/docs/csharp/language-reference/keywords/throw.md)</ept> statement in C# and the <bpt id="p2">[</bpt>Throw<ept id="p2">](~/docs/visual-basic/language-reference/statements/throw-statement.md)</ept> statement in Visual Basic without including an expression.</source>
          <target state="translated">사용 하 여 다시 예외를 throw 하는 권장된 방법은는 <bpt id="p1">[</bpt>throw<ept id="p1">](~/docs/csharp/language-reference/keywords/throw.md)</ept> C# 문 및 <bpt id="p2">[</bpt>Throw<ept id="p2">](~/docs/visual-basic/language-reference/statements/throw-statement.md)</ept> 식을 포함 하지 않고 Visual Basic의 문입니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This ensures that all call stack information is preserved when the exception is propagated to the caller.</source>
          <target state="translated">이렇게 하면 예외를 호출자에 게 전파 될 때 모든 호출 스택 정보가 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example illustrates this.</source>
          <target state="translated">다음은 이에 대한 예입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A string extension method, <ph id="ph1">`FindOccurrences`</ph>, wraps one or more calls to <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> without validating its arguments beforehand.</source>
          <target state="translated">문자열 확장 메서드를 <ph id="ph1">`FindOccurrences`</ph>, 하나 이상의 호출을 래핑합니다 <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> 미리 인수 유효성 검사 하지 않고 있습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A caller then calls <ph id="ph1">`FindOccurrences`</ph> twice.</source>
          <target state="translated">그런 다음 호출 하는 호출자가 <ph id="ph1">`FindOccurrences`</ph> 두 번입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In the second call to <ph id="ph1">`FindOccurrences`</ph>, the caller passes a <ph id="ph2">`null`</ph> as the search string, which cases the <ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to throw an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
          <target state="translated">두 번째 호출에서 <ph id="ph1">`FindOccurrences`</ph>, 호출자에 게 전달은 <ph id="ph2">`null`</ph> 검색 문자열로 사례는 <ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> throw 하는 메서드는 <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> 예외입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This exception is handled by the <ph id="ph1">`FindOccurrences`</ph> method and passed back to the caller.</source>
          <target state="translated">이 예외를 처리는 <ph id="ph1">`FindOccurrences`</ph> 메서드 그리고 호출자에 게 다시 전달된 합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Because the throw statement is used with no expression, the output from the example shows that the call stack is preserved.</source>
          <target state="translated">Throw 문은 식 없이 사용 되므로 예제에서 출력 된 호출 스택을 유지 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In contrast, if the exception is re-thrown by using the</source>
          <target state="translated">반대로, 사용 하 여 예외 예외가 다시 throw 하는 경우에</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>statement, the full call stack is not preserved, and the example would generate the following output:</source>
          <target state="translated">문, 전체 호출 스택을 유지 되지 않습니다 및 예제는 다음과 같은 출력 생성:</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A slightly more cumbersome alternative is to throw a new exception, and to preserve the original exception's call stack information in an inner exception.</source>
          <target state="translated">새 예외를 throw 하 고 내부 예외에는 원래 예외 호출 스택 정보를 유지 하는 하는 대신 멤버를 약간 더 복잡 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The caller can then use the new exception's <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property to retrieve stack frame and other information about the original exception.</source>
          <target state="translated">호출자에 게 새 예외를 사용 하 여 수 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 스택 프레임 및 원래 예외에 대 한 기타 정보를 검색할 속성입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this case, the throw statement is:</source>
          <target state="translated">이 경우에 throw 문은입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The user code that handles the exception has to know that the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property contains information about the original exception, as the following exception handler illustrates.</source>
          <target state="translated">사용자 예외를 처리 하는 것을 알고는 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성 다음과 같은 예외 처리기와 같이 원래 예외에 대 한 정보를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Choosing standard exceptions</source>
          <target state="translated">표준 예외를 선택합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When you have to throw an exception, you can often use an existing exception type in the .NET Framework instead of implementing a custom exception.</source>
          <target state="translated">예외를 throw 해야 할 경우 사용자 지정 예외를 구현 하는 대신.NET Framework의 기존 예외 형식을 자주 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should use a standard exception type under these two conditions:</source>
          <target state="translated">이러한 두 가지 조건에 표준 예외 형식을 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You are throwing an exception that is caused by a usage error (that is, by an error in program logic made by the developer who is calling your method).</source>
          <target state="translated">사용 현황 오류로 인해 발생 하는 예외를 throw (즉, 개발자의 메서드를 호출 하는 프로그램 논리의 오류로 인해).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Typically, you would throw an exception such as <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>, <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, or <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">와 같은 예외를 throw 합니다는 일반적으로 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>, <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, 또는 <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The string you supply to the exception object's constructor when instantiating the exception object should describe the error so that the developer can fix it.</source>
          <target state="translated">예외 개체를 인스턴스화하는 오류에 설명 개발자가 문제를 해결할 수 있도록 하는 경우 예외 개체의 생성자에 제공 하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성을 참조하세요.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You are handling an error that can be communicated to the caller with an existing .NET Framework exception.</source>
          <target state="translated">기존.NET Framework 예외를 사용 하 여 호출자에 게 알려 줄 수 있는 오류를 처리 하는 합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should throw the most derived exception possible.</source>
          <target state="translated">가능 하면 가장 많이 파생 된 예외를 throw 해야 합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if a method requires an argument to be a valid member of an enumeration type, you should throw an <ph id="ph1">&lt;xref:System.ComponentModel.InvalidEnumArgumentException&gt;</ph> (the most derived class) rather than an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">예를 들어 메서드 열거형의 유효한 멤버 이어야 하는 인수를 필요한 경우 throw 해야는 <ph id="ph1">&lt;xref:System.ComponentModel.InvalidEnumArgumentException&gt;</ph> (가장 클래스를 파생 하는 데 사용) 아닌 <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following table lists common exception types and the conditions under which you would throw them.</source>
          <target state="translated">다음 표에서 일반적인 예외 형식과 되는 사용자가 throw 할 조건을 나열 합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception</source>
          <target state="translated">예외</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Condition</source>
          <target state="translated">조건</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A non-null argument that is passed to a method is invalid.</source>
          <target state="translated">메서드에 전달 되는 null이 아닌 인수가 유효 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An argument that is passed to a method is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">메서드에 전달 되는 인수는 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An argument is outside the range of valid values.</source>
          <target state="translated">인수가 유효한 값의 범위를 벗어납니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Part of a directory path is not valid.</source>
          <target state="translated">디렉터리 경로의 일부가 잘못 되었습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The denominator in an integer or <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> division operation is zero.</source>
          <target state="translated">분모는 정수에서 또는 <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> 나누기 작업은 0입니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A drive is unavailable or does not exist.</source>
          <target state="translated">드라이브를 사용할 수 없거나 존재 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A file does not exist.</source>
          <target state="translated">파일이 존재 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A value is not in an appropriate format to be converted from a string by a conversion method such as <ph id="ph1">`Parse`</ph>.</source>
          <target state="translated">값을 변환할 문자열에서 변환 메서드와 같은 적절 한 형식이 <ph id="ph1">`Parse`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An index is outside the bounds of an array or collection.</source>
          <target state="translated">인덱스는 배열 또는 컬렉션의 범위를 벗어났습니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method call is invalid in an object's current state.</source>
          <target state="translated">메서드 호출이 개체의 현재 상태에서는 올바르지 않습니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The specified key for accessing a member in a collection cannot be found.</source>
          <target state="translated">컬렉션의 멤버에 액세스 하기 위한 지정된 된 키를 찾을 수 없습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method or operation is not implemented.</source>
          <target state="translated">메서드 또는 연산이 구현 되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method or operation is not supported.</source>
          <target state="translated">메서드 또는 작업이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An operation is performed on an object that has been disposed.</source>
          <target state="translated">삭제 된 개체에서 연산이 수행 됩니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An arithmetic, casting, or conversion operation results in an overflow.</source>
          <target state="translated">산술, 캐스팅 또는 변환 작업 결과로 오버플로가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A path or file name exceeds the maximum system-defined length.</source>
          <target state="translated">경로나 파일 이름이 시스템에서 정의한 최대 길이 초과합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The operation is not supported on the current platform.</source>
          <target state="translated">작업은 현재 플랫폼에서 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An array with the wrong number of dimensions is passed to a method.</source>
          <target state="translated">차원 수가 잘못 된 배열은 메서드에 전달 됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The time interval allotted to an operation has expired.</source>
          <target state="translated">작업에 할당 된 시간 간격이 만료 되었습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An invalid Uniform Resource Identifier (URI) is used.</source>
          <target state="translated">잘못 된 식별자 URI (Uniform Resource) 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Implementing custom exceptions</source>
          <target state="translated">사용자 지정 예외를 구현합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In the following cases, using an existing .NET Framework exception to handle an error condition is not adequate:</source>
          <target state="translated">다음과 같은 경우에는 오류 조건을 처리 하기 위해 기존.NET Framework 예외를 사용 하 여 적합 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When the exception reflects a unique program error that cannot be mapped to an existing .NET Framework exception.</source>
          <target state="translated">예외 기존.NET Framework 예외에 매핑할 수 없는 고유 프로그램 오류를 일으킬 때.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When the exception requires handling that is different from the handling that is appropriate for an existing .NET Framework exception, or the exception must be disambiguated from a similar exception.</source>
          <target state="translated">예외를 처리 하는 것은 처리 되는 기존.NET Framework 예외 나 예외에 대 한 적합 다릅니다 필요한 경우에 유사한 예외가에서 명확히 구분 해야 합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if you throw an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception when parsing the numeric representation of a string that is out of range of the target integral type, you would not want to use the same exception for an error that results from the caller not supplying the appropriate constrained values when calling the method.</source>
          <target state="translated">예를 들어, throw 되는 경우는 <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> 대상 정수 계열 형식의 범위를 벗어났습니다 하는 문자열의 숫자 값을 구문 분석할 때 예외를 하지 않을 제공 안 함 호출자의 결과로 생성 되는 오류에 대 한 동일한 예외를 사용 하는 적절 한 제한 메서드를 호출할 때 값.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class is the base class of all exceptions in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph> 클래스는.NET Framework의 모든 예외의 기본 클래스입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Many derived classes rely on the inherited behavior of the members of the <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class; they do not override the members of <ph id="ph2">&lt;xref:System.Exception&gt;</ph>, nor do they define any unique members.</source>
          <target state="translated">대부분의 파생된 클래스의 멤버의 상속 된 동작에 의존는 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> ; 클래스의 멤버를 재정의 하지 않는 <ph id="ph2">&lt;xref:System.Exception&gt;</ph>, 고유한 멤버를 정의할 것입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To define your own exception class:</source>
          <target state="translated">클래스를 정의 하려면 사용자 고유의 예외:</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Define a class that inherits from <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">상속 되는 클래스를 정의 <ph id="ph1">&lt;xref:System.Exception&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If necessary, define any unique members needed by your class to provide additional information about the exception.</source>
          <target state="translated">필요한 경우 클래스에는 예외에 대 한 추가 정보를 제공 하는 데 필요한 고유 멤버를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, the <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> class includes a <ph id="ph2">&lt;xref:System.ArgumentException.ParamName%2A&gt;</ph> property that specifies the name of the parameter whose argument caused the exception, and the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> property includes a <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A&gt;</ph> property that indicates the time-out interval.</source>
          <target state="translated">예를 들어는 <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> 클래스를 포함 한 <ph id="ph2">&lt;xref:System.ArgumentException.ParamName%2A&gt;</ph> 해당 인수에는 예외의 원인인 매개 변수의 이름을 지정 하는 속성 및 <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 속성 포함 된는 <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A&gt;</ph> 시간 제한 간격을 나타내는 속성입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If necessary, override any inherited members whose functionality you want to change or modify.</source>
          <target state="translated">필요한 경우 모든 상속 된 멤버 변경 하거나 수정 하려면 해당 기능을 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Note that most existing derived classes of <ph id="ph1">&lt;xref:System.Exception&gt;</ph> do not override the behavior of inherited members.</source>
          <target state="translated">대부분 기존 클래스의 파생 된 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 상속 된 멤버의 동작을 재정의 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Determine whether your custom exception object is serializable.</source>
          <target state="translated">사용자 지정 예외 개체를 직렬화 가능 인지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Serialization enables you to save information about the exception and permits exception information to be shared by a server and a client proxy in a remoting context.</source>
          <target state="translated">Serialization 예외에 대 한 정보를 저장 하 고 예외 정보를 클라이언트 프록시 서버에 의해 원격 컨텍스트에서 공유할 수를 허용 합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To make the exception object serializable, mark it with the <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> attribute.</source>
          <target state="translated">예외 개체를 직렬화 가능 하도록 하려면으로 표시 된 <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Define the constructors of your exception class.</source>
          <target state="translated">Exception 클래스의 생성자를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Typically, exception classes have one or more of the following constructors:</source>
          <target state="translated">일반적으로, 예외 클래스는 생성자 중 하나 이상을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor&gt;</ph>, which uses default values to initialize the properties of a new exception object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor&gt;</ph>를 기본값 새 예외 개체의 속성을 초기화를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%29&gt;</ph>, which initializes a new exception object with a specified error message.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%29&gt;</ph>는 지정 된 오류 메시지와 함께 새 예외 개체를 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29&gt;</ph>, which initializes a new exception object with a specified error message and inner exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29&gt;</ph>는 지정 된 오류 메시지와 내부 예외가 발생 하 여 새 예외 개체를 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29&gt;</ph>, which is a <ph id="ph2">`protected`</ph> constructor that initializes a new exception object from serialized data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29&gt;</ph>이 <ph id="ph2">`protected`</ph> serialize 된 데이터에서 새 예외 개체를 초기화 하는 생성자입니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should implement this constructor if you've chosen to make your exception object serializable.</source>
          <target state="translated">예외 개체를 직렬화 할 수 있도록 선택한 경우이 생성자를 구현 해야 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example illustrates the use of a custom exception class.</source>
          <target state="translated">다음 예제에서는 사용자 지정 예외 클래스의 용도를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>It defines a <ph id="ph1">`NotPrimeException`</ph> exception that is thrown when a client tries to retrieve a sequence of prime numbers by specifying a starting number that is not prime.</source>
          <target state="translated">정의 <ph id="ph1">`NotPrimeException`</ph> 클라이언트가 주요 하지 않은 시작 번호를 지정 하 여 소수 시퀀스를 검색 하려고 할 때 throw 되는 예외입니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The exception defines a new property, <ph id="ph1">`NonPrime`</ph>, that returns the non-prime number that caused the exception.</source>
          <target state="translated">새 속성을 정의 하는 예외 <ph id="ph1">`NonPrime`</ph>, 예외를 발생 하는 비-prime 번호를 반환 하 합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Besides implementing a protected parameterless constructor and a constructor with <ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph> parameters for serialization, the <ph id="ph3">`NotPrimeException`</ph> class defines three additional constructors to support the <ph id="ph4">`NonPrime`</ph> property.</source>
          <target state="translated">보호 된 매개 변수가 없는 생성자 및 사용 하 여 생성자 구현 외에도 <ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph> serialization에 대 한 매개 변수는 <ph id="ph3">`NotPrimeException`</ph> 클래스 정의 지원 하기 위해 세 명의 추가 생성자는 <ph id="ph4">`NonPrime`</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Each constructor calls a base class constructor in addition to preserving the value of the non-prime number.</source>
          <target state="translated">각 생성자의는 비-소수 값을 유지 하는 것 외에도 기본 클래스 생성자를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`NotPrimeException`</ph> class is also marked with the <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">`NotPrimeException`</ph> 도 표시 되는 <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`PrimeNumberGenerator`</ph> class shown in the following example uses the Sieve of Eratosthenes to calculate the sequence of prime numbers from 2 to a limit specified by the client in the call to its class constructor.</source>
          <target state="translated"><ph id="ph1">`PrimeNumberGenerator`</ph> 다음 예제에 표시 된 클래스 에라토스테네스의 체를 사용 하 여 클라이언트가 해당 클래스 생성자에 대 한 호출에 지정 된 한계에 2에서 소수의 시퀀스를 계산 합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`GetPrimesFrom`</ph> method returns all prime numbers that are greater than or equal to a specified lower limit, but throws a <ph id="ph2">`NotPrimeException`</ph> if that lower limit is not a prime number.</source>
          <target state="translated"><ph id="ph1">`GetPrimesFrom`</ph> 메서드 모든 소수를 지정 된 하한값 보다 크거나 반환 하지만 발생 한 <ph id="ph2">`NotPrimeException`</ph> 해당 하한값 prime 숫자가 아닌 경우.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example makes two calls to the <ph id="ph1">`GetPrimesFrom`</ph> method with non-prime numbers, one of which crosses application domain boundaries.</source>
          <target state="translated">두 번 호출 하는 다음 예제는 <ph id="ph1">`GetPrimesFrom`</ph> 메서드와 소수가 아닌, 중 하나는 응용 프로그램 도메인 경계를 이동 합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In both cases, the exception is thrown and successfully handled in client code.</source>
          <target state="translated">두 경우 모두에서 예외가 throw 되 고 클라이언트 코드에서 성공적으로 처리 합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Windows Runtime and <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></source>
          <target state="translated">Windows 런타임 및 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> for <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph>, some exception information is typically lost when an exception is propagated through non-.NET Framework stack frames.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> 에 대 한 <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph>,.NET Framework 이외의 스택 프레임을 통해 예외 전파 될 때 일부 예외 정보에는 일반적으로 손실 됩니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> and <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the common language runtime continues to use the original <ph id="ph3">&lt;xref:System.Exception&gt;</ph> object that was thrown unless that exception was modified in a non-.NET Framework stack frame.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> 및 <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, 공용 언어 런타임 계속 원래 사용 <ph id="ph3">&lt;xref:System.Exception&gt;</ph> 해당 예외를.NET Framework 이외의 스택 프레임에서 수정 하지 않으면 throw 된 개체를 합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example demonstrates a <ph id="ph1">`catch`</ph> block that is defined to handle <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> errors.</source>
          <target state="translated">다음 예제는 <ph id="ph1">`catch`</ph> 처리 하기 위해 정의 된 블록 <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> 오류입니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This <ph id="ph1">`catch`</ph> block also catches <ph id="ph2">&lt;xref:System.DivideByZeroException&gt;</ph> errors, because <ph id="ph3">&lt;xref:System.DivideByZeroException&gt;</ph> derives from <ph id="ph4">&lt;xref:System.ArithmeticException&gt;</ph> and there is no <ph id="ph5">`catch`</ph> block explicitly defined for <ph id="ph6">&lt;xref:System.DivideByZeroException&gt;</ph> errors.</source>
          <target state="translated">이 <ph id="ph1">`catch`</ph> catch 블록도 <ph id="ph2">&lt;xref:System.DivideByZeroException&gt;</ph> 오류 때문에 <ph id="ph3">&lt;xref:System.DivideByZeroException&gt;</ph> 에서 파생 <ph id="ph4">&lt;xref:System.ArithmeticException&gt;</ph> 있으면 없습니다 <ph id="ph5">`catch`</ph> 블록에 대해 명시적으로 정의 된 <ph id="ph6">&lt;xref:System.DivideByZeroException&gt;</ph> 오류입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="T:System.Exception">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance to a system-supplied message that describes the error and takes into account the current system culture.</source>
          <target state="translated">이 생성자는 새 인스턴스의 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성을 현재 시스템 문화권에 기반하여 해당 오류를 설명하는 시스템 제공 메시지로 초기화합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>All the derived classes should provide this default constructor.</source>
          <target state="translated">모든 파생된 클래스는이 기본 생성자를 제공 해야 합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">다음 표에서는 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 인스턴스의 초기 속성 값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">null 참조(Visual Basic의 경우 <ph id="ph1">`Nothing`</ph>)</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>A system-supplied localized description.</source>
          <target state="translated">시스템이 제공하는 지역화된 설명입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> that uses a predefined message.</source>
          <target state="translated">다음 코드 예제에서는 파생 되는 <ph id="ph1">`Exception`</ph> 미리 정의 된 메시지를 사용 하 합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The code demonstrates the use of the parameterless constructor for the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">파생된 클래스와 기본에 대 한 매개 변수가 없는 생성자를 사용 하는 방법을 보여 줍니다 코드 <ph id="ph1">`Exception`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String)">
          <source>The message that describes the error.</source>
          <target state="translated">@FSHO2@오류를 설명하는 메시지입니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with a specified error message.</source>
          <target state="translated">지정된 오류 메시지를 사용하여 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance by using the <ph id="ph2">`message`</ph> parameter.</source>
          <target state="translated">이 생성자는 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 를 사용 하 여 새 인스턴스의 속성은 <ph id="ph2">`message`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>If the <ph id="ph1">`message`</ph> parameter is <ph id="ph2">`null`</ph>, this is the same as calling the <ph id="ph3">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">경우는 <ph id="ph1">`message`</ph> 매개 변수는 <ph id="ph2">`null`</ph>를 호출할 때와 동일는 <ph id="ph3">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">다음 표에서는 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 인스턴스의 초기 속성 값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">null 참조(Visual Basic의 경우 <ph id="ph1">`Nothing`</ph>)</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The error message string.</source>
          <target state="translated">오류 메시지 문자열</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> for a specific condition.</source>
          <target state="translated">다음 코드 예제에서는 파생 되는 <ph id="ph1">`Exception`</ph> 특정 조건에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The code demonstrates the use of the constructor that takes a caller-specified message as a parameter, for both the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">코드는 호출자가 지정한 메시지 파생된 클래스와 기본에 대 한 매개 변수로 사용 하는 생성자의 사용법을 보여줍니다 <ph id="ph1">`Exception`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized object data about the exception being thrown.</source>
          <target state="translated">throw되는 예외에 대해 serialize된 개체 데이터를 보유하는 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains contextual information about the source or destination.</source>
          <target state="translated">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with serialized data.</source>
          <target state="translated">serialize된 데이터를 사용하여 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</source>
          <target state="translated">이 생성자는 deserialization을 수행하는 동안 호출되어 스트림을 통해 전송된 예외 개체를 다시 구성합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>XML 및 SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The following code example defines a derived serializable <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">다음 코드 예제에서는 파생 정의 직렬화 가능 <ph id="ph1">`Exception`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code forces a divide-by-0 error and then creates an instance of the derived exception using the (<ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph>) constructor.</source>
          <target state="translated">코드는 0으로 나누기 오류를 강제로 사용 하 여 파생된 예외 인스턴스를 만든 후의 (<ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph>) 생성자입니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</source>
          <target state="translated">코드 파일에 인스턴스를 serialize, 파일, throw 하는 새 예외도 deserialize 한 다음를 catch 하는 예외 데이터를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The class name is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Exception.HResult" /&gt;</ph> is zero (0).</source>
          <target state="translated">클래스 이름이 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이거나 <ph id="ph2">&lt;see cref="P:System.Exception.HResult" /&gt;</ph>가 0입니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The error message that explains the reason for the exception.</source>
          <target state="translated">@FSHO2@예외 이유를 설명하는 오류 메시지입니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The exception that is the cause of the current exception, or a null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) if no inner exception is specified.</source>
          <target state="translated">현재 예외를 발생시킨 예외이거나 내부 예외를 지정하지 않은 경우 null 참조(Visual Basic에서는 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>)입니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with a specified error message and a reference to the inner exception that is the cause of this exception.</source>
          <target state="translated">지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property.</source>
          <target state="translated">이전 예외의 직접적인 결과로 throw되는 예외의 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성에는 이전 예외에 대한 참조가 들어 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property returns the same value that is passed into the constructor, or a null reference (<ph id="ph2">`Nothing`</ph> in Visual Basic) if the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property does not supply the inner exception value to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성은 생성자에 전달된 값과 같은 값을 반환하거나 <ph id="ph2">`Nothing`</ph> 속성이 생성자에 내부 예외 값을 제공하지 않는 경우에는 null 참조(Visual Basic의 경우 <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>)를 반환합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">다음 표에서는 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 인스턴스의 초기 속성 값을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Property</source>
          <target state="translated">속성</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Value</source>
          <target state="translated">값</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The inner exception reference.</source>
          <target state="translated">내부 예외 참조</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The error message string.</source>
          <target state="translated">오류 메시지 문자열</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> for a specific condition.</source>
          <target state="translated">다음 코드 예제에서는 파생 되는 <ph id="ph1">`Exception`</ph> 특정 조건에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The code demonstrates the use of the constructor that takes a message and an inner exception as parameters, for both the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">코드는 메시지 및 내부 예외를 파생된 클래스와 기본에 대 한 매개 변수로 사용 하는 생성자의 사용을 보여주는 <ph id="ph1">`Exception`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="P:System.Exception.Data">
          <source>Gets a collection of key/value pairs that provide additional user-defined information about the exception.</source>
          <target state="translated">예외에 대한 사용자 정의 추가 정보를 제공하는 키/값 쌍의 컬렉션을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>An object that implements the <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> interface and contains a collection of user-defined key/value pairs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 인터페이스를 구현하며 사용자 정의 키/값 쌍의 컬렉션을 포함하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The default is an empty collection.</source>
          <target state="translated">기본값은 빈 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Use the <ph id="ph1">&lt;xref:System.Collections.IDictionary?displayProperty=nameWithType&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Exception.Data%2A&gt;</ph> property to store and retrieve supplementary information relevant to the exception.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Collections.IDictionary?displayProperty=nameWithType&gt;</ph> 에서 반환 된 개체는 <ph id="ph2">&lt;xref:System.Exception.Data%2A&gt;</ph> 속성을 저장 하 고 예외와 관련 된 보충 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The information is in the form of an arbitrary number of user-defined key/value pairs.</source>
          <target state="translated">정보는 임의 개수의 사용자 정의 키/값 쌍의 형태로 표현 합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The key component of each key/value pair is typically an identifying string, whereas the value component of the pair can be any type of object.</source>
          <target state="translated">각 키/값 쌍의 핵심 구성 요소는 일반적으로 식별 문자열 쌍의 값 구성 요소에는 모든 종류의 개체 일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Key/Value Pair Security</source>
          <target state="translated">키/값 쌍 보안</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The key/value pairs stored in the collection returned by the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property are not secure.</source>
          <target state="translated">반환 된 컬렉션에 저장 된 키/값 쌍은 <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> 속성은 안전 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If your application calls a nested series of routines, and each routine contains exception handlers, the resulting call stack contains a hierarchy of those exception handlers.</source>
          <target state="translated">응용 프로그램에서 중첩된 된 일련의 루틴을 호출 하는 경우 예외 처리기를 포함 하는 각 루틴 결과 호출 스택에 예외 처리기의 계층을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If a lower-level routine throws an exception, any upper-level exception handler in the call stack hierarchy can read and/or modify the key/value pairs stored in the collection by any other exception handler.</source>
          <target state="translated">하위 수준의 루틴에서 예외를 throw 하는 경우 모든 상위 수준의 예외 처리기 호출 스택 계층 구조에서 읽거나 다른 예외 처리기에 의해 컬렉션에 저장 된 키/값 쌍을 수정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>This means you must guarantee that the information in the key/value pairs is not confidential and that your application will operate correctly if the information in the key/value pairs is corrupted.</source>
          <target state="translated">즉, 키/값 쌍의 정보 기밀 아닌지 하며 키/값 쌍의 정보가 손상 된 경우 응용 프로그램에서는 올바르게 작동을 보장 해야 합니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Key Conflicts</source>
          <target state="translated">키 충돌</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>A key conflict occurs when different exception handlers specify the same key to access a key/value pair.</source>
          <target state="translated">키/값 쌍에 액세스 하려면 동일한 키를 지정 하는 여러 예외 처리기 키 충돌이 발생 합니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Use caution when developing your application because the consequence of a key conflict is that lower-level exception handlers can inadvertently communicate with higher-level exception handlers, and this communication might cause subtle program errors.</source>
          <target state="translated">키 충돌의 결과 하위 수준의 예외 처리기 잘못 통신할 수 있으며 더 높은 수준의 예외 처리기 및이 통신 미묘한 프로그램 오류를 일으킬 수 때문에 응용 프로그램을 개발할 때는 주의 해야 합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>However, if you are cautious you can use key conflicts to enhance your application.</source>
          <target state="translated">그러나 주의 하려는 경우 응용 프로그램을 향상 시키기 위해 키 충돌을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Avoiding Key Conflicts</source>
          <target state="translated">키 충돌 방지</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Avoid key conflicts by adopting a naming convention to generate unique keys for key/value pairs.</source>
          <target state="translated">키/값 쌍에 대 한 고유 키를 생성 하는 명명 규칙을 사용 하 여 키 충돌을 방지 합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>For example, a naming convention might yield a key that consists of the period-delimited name of your application, the method that provides supplementary information for the pair, and a unique identifier.</source>
          <target state="translated">예를 들어 명명 규칙 쌍 및 고유 식별자에 대 한 보충 정보를 제공 하는 방법, 응용 프로그램의 마침표로 구분 된 이름으로 구성 된 키를 생성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Suppose two applications, named Products and Suppliers, each has a method named Sales.</source>
          <target state="translated">제품과 공급 업체 두 응용 프로그램 이라는 가정 각각에 Sales 라는 메서드가 있습니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The Sales method in the Products application provides the identification number (the stock keeping unit or SKU) of a product.</source>
          <target state="translated">제품 응용 프로그램에서 Sales 메서드는 제품의 id 번호 (stock keeping 단위 또는 SKU)를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The Sales method in the Suppliers application provides the identification number, or SID, of a supplier.</source>
          <target state="translated">공급 업체 응용 프로그램에서 Sales 메서드 id 번호 또는 공급 업체의 SID를 제공합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Consequently, the naming convention for this example yields the keys, "Products.Sales.SKU" and "Suppliers.Sales.SID".</source>
          <target state="translated">따라서이 예제에 대 한 명명 규칙 "Products.Sales.SKU" 및 "Suppliers.Sales.SID" 키를 생성합니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Exploiting Key Conflicts</source>
          <target state="translated">키 충돌 활용</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Exploit key conflicts by using the presence of one or more special, prearranged keys to control processing.</source>
          <target state="translated">하나 이상의 특수, 미리 정렬 된 키의 존재를 사용 하 여 처리를 제어 하 여 키 충돌을 악용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Suppose, in one scenario, the highest level exception handler in the call stack hierarchy catches all exceptions thrown by lower-level exception handlers.</source>
          <target state="translated">예를 들어, 한 가지 시나리오 하위 수준의 예외 처리기에서 throw 된 모든 예외를 catch 하는 호출 스택 계층 구조에서 가장 높은 수준의 예외 처리기입니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If a key/value pair with a special key exists, the high-level exception handler formats the remaining key/value pairs in the <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> object in some nonstandard way; otherwise, the remaining key/value pairs are formatted in some normal manner.</source>
          <target state="translated">수준 높은 예외 처리기의 나머지 키/값 쌍 형식 특수 키와 키/값 쌍이 있는 경우는 <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> 일부 비표준 방식에서 개체 나머지 키/값 쌍 표준 방식으로 서식이 지정 된 그렇지 않은 경우.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Now suppose, in another scenario, the exception handler at each level of the call stack hierarchy catches the exception thrown by the next lower-level exception handler.</source>
          <target state="translated">이제 예를 들어, 또 다른 시나리오에서는 호출 스택 계층의 각 수준에서 예외 처리기 다음 하위 수준의 예외 처리기에서 throw 된 예외를 catch 합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>In addition, each exception handler knows the collection returned by the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property contains a set of key/value pairs that can be accessed with a prearranged set of keys.</source>
          <target state="translated">또한 각 예외 처리기에서 반환 된 컬렉션을 알고는 <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> 속성 미리 정렬 된 키 집합을 사용 하 여 액세스할 수 있는 키/값 쌍 집합이 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Each exception handler uses the prearranged set of keys to update the value component of the corresponding key/value pair with information unique to that exception handler.</source>
          <target state="translated">각 예외 핸들러에서 해당 예외 처리기에 고유 정보로 업데이트 하는 해당 하는 키/값 쌍의 값 구성 요소를 미리 정렬 된 키 집합을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>After the update process is complete, the exception handler throws the exception to the next higher-level exception handler.</source>
          <target state="translated">업데이트 프로세스가 완료 되 면 예외 처리기는 다음 상위 수준의 예외 처리기에 대 한 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Finally, the highest level exception handler accesses the key/value pairs and displays the consolidated update information from all the lower-level exception handlers.</source>
          <target state="translated">마지막으로, 최상위 수준의 예외 처리기는 키/값 쌍을 액세스 하 고 모든 하위 수준의 예외 처리기에서 통합된 업데이트 정보를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The following example demonstrates how to add and retrieve information using the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property.</source>
          <target state="translated">다음 예제에서는 추가 하 고 사용 하 여 정보 검색는 <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> that is the root cause of one or more subsequent exceptions.</source>
          <target state="translated">파생 클래스에서 재정의된 경우 하나 이상의 후속 예외의 근본 원인이 되는 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>The first exception thrown in a chain of exceptions.</source>
          <target state="translated">예외의 체인에서 throw된 첫째 예외입니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>If the <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> property of the current exception is a null reference (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), this property returns the current exception.</source>
          <target state="translated">현재 예외의 <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> 속성이 null 참조(Visual Basic에서는 <ph id="ph2">&lt;see langword="Nothing" /&gt;</ph>)인 경우, 이 속성은 현재 예외를 반환합니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>A chain of exceptions consists of a set of exceptions such that each exception in the chain was thrown as a direct result of the exception referenced in its <ph id="ph1">`InnerException`</ph> property.</source>
          <target state="translated">예외의 체인은 체인에서 각 예외에서 참조 되는 예외의 직접적인 결과로 throw 된 예외 집합으로 이루어져 그 <ph id="ph1">`InnerException`</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>For a given chain, there can be exactly one exception that is the root cause of all other exceptions in the chain.</source>
          <target state="translated">주어진된 체인에서 체인에 있는 다른 모든 예외의 근본 원인이 되는 정확히 하나의 예외 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>This exception is called the base exception and its <ph id="ph1">`InnerException`</ph> property always contains a null reference.</source>
          <target state="translated">이 예외는 기본 예외 라고 하며 <ph id="ph1">`InnerException`</ph> 속성은 항상 null 참조를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>For all exceptions in a chain of exceptions, the <ph id="ph1">`GetBaseException`</ph> method must return the same object (the base exception).</source>
          <target state="translated">예외의 체인의 모든 예외에 대 한는 <ph id="ph1">`GetBaseException`</ph> 메서드 (기본 예외) 동일한 개체를 반환 해야 합니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>Use the <ph id="ph1">`GetBaseException`</ph> method when you want to find the root cause of an exception but do not need information about exceptions that may have occurred between the current exception and the first exception.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`GetBaseException`</ph> 예외의 근본 원인을 찾습니다 하려고 하지만 현재 예외와 첫 번째 예외 간에 발생 했을 수 있는 예외에 대 한 정보가 필요 하지 않은 경우 방법입니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The following code example defines two derived <ph id="ph1">`Exception`</ph> classes.</source>
          <target state="translated">다음 코드 예제에서는 파생 된 두 개의 정의 <ph id="ph1">`Exception`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>It forces an exception and then throws it again with each of the derived classes.</source>
          <target state="translated">예외를 강제로 수행 하 고 각각의 파생된 클래스와 다시 throw 합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The code shows the use of the <ph id="ph1">`GetBaseException`</ph> method to retrieve the original exception.</source>
          <target state="translated">코드의 사용을 보여 줍니다.는 <ph id="ph1">`GetBaseException`</ph> 원래 예외를 검색 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The <ph id="ph1">&lt;see langword="GetBaseException" /&gt;</ph> method is overridden in classes that require control over the exception content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="GetBaseException" /&gt;</ph> 예외 내용 또는 형식을 제어할 필요가 있는 클래스에서 메서드를 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized object data about the exception being thrown.</source>
          <target state="translated">throw되는 예외에 대해 serialize된 개체 데이터를 보유하는 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains contextual information about the source or destination.</source>
          <target state="translated">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>When overridden in a derived class, sets the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> with information about the exception.</source>
          <target state="translated">파생 클래스에서 재정의된 경우 예외에 관한 정보를 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>에 설정합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">`GetObjectData`</ph> sets a <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> with all the exception object data targeted for serialization.</source>
          <target state="translated"><ph id="ph1">`GetObjectData`</ph>는 serialization을 위해 대상으로 하는 모든 예외 개체 데이터를 사용하여 <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>를 설정합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>During deserialization, the exception is reconstituted from the <ph id="ph1">`SerializationInfo`</ph> transmitted over the stream.</source>
          <target state="translated">deserialization을 수행하는 동안 스트림을 통해 전송된 <ph id="ph1">`SerializationInfo`</ph>에서 예외가 다시 구성됩니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The following code example defines a derived serializable <ph id="ph1">`Exception`</ph> class that implements <ph id="ph2">`GetObjectData`</ph>, which makes minor changes to two properties and then calls the base class to perform the serialization.</source>
          <target state="translated">다음 코드 예제에서는 파생 정의 직렬화 가능 <ph id="ph1">`Exception`</ph> 구현 하는 클래스 <ph id="ph2">`GetObjectData`</ph>, 두 개의 속성에 사소한 변경 사항 수 있게 해줍니다 다음 기본 클래스를 호출 하는 직렬화를 수행 하려면.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The example forces a divide-by-0 error and then creates an instance of the derived exception.</source>
          <target state="translated">이 예제에서는 0으로 나누기 오류를 강제로 다음 파생된 예외 인스턴스를 만듭니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</source>
          <target state="translated">코드 파일에 인스턴스를 serialize, 파일, throw 하는 새 예외도 deserialize 한 다음를 catch 하는 예외 데이터를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is a null reference (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph>매개 변수가 null 참조(Visual Basic에서는 <ph id="ph2">&lt;see langword="Nothing" /&gt;</ph>)인 경우</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Exception.GetType">
          <source>Gets the runtime type of the current instance.</source>
          <target state="translated">현재 인스턴스의 런타임 형식을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Exception.GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the exact runtime type of the current instance.</source>
          <target state="translated">현재 인스턴스의 정확한 런타임 형식을 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Exception.GetType%2A&gt;</ph> method exists to support the .NET Framework infrastructure, and internally invokes the fundamental method, <ph id="ph2">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.GetType%2A&gt;</ph> 메서드는.NET Framework 인프라를 지원 하기 위해 존재 하 고 내부적으로 기본 메서드를 호출 <ph id="ph2">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Exception.HelpLink">
          <source>Gets or sets a link to the help file associated with this exception.</source>
          <target state="translated">이 예외와 연결된 도움말 파일에 대한 링크를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The Uniform Resource Name (URN) or Uniform Resource Locator (URL).</source>
          <target state="translated">URN(Uniform Resource Name)이거나, URL(Uniform Resource Locator)입니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The return value, which represents a help file, is a URN or URL.</source>
          <target state="translated">반환 값은 도움말 파일을 나타내며 URN 또는 URL입니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>For example, the <ph id="ph1">`HelpLink`</ph> value could be:</source>
          <target state="translated">예를 들어는 <ph id="ph1">`HelpLink`</ph> 값일 수 없습니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</source>
          <target state="translated">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> that sets the <ph id="ph2">`HelpLink`</ph> property in its constructor and then catches the exception and displays <ph id="ph3">`HelpLink`</ph>.</source>
          <target state="translated">다음 코드 예제에서는 throw는 <ph id="ph1">`Exception`</ph> 로 설정 하는 <ph id="ph2">`HelpLink`</ph> 해당 생성자 및 다음 catch 된 예외와 표시 속성을 사용한 <ph id="ph3">`HelpLink`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Exception.HResult">
          <source>Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception.</source>
          <target state="translated">특정 예외에 할당된 코드화된 숫자 값인 HRESULT를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The HRESULT value.</source>
          <target state="translated">HRESULT 값입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>HRESULT is a 32-bit value, divided into three different fields: a severity code, a facility code, and an error code.</source>
          <target state="translated">HRESULT는 32 비트 값으로 세 개의 서로 다른 필드는: 심각도 코드, 기능 코드 및 오류 코드입니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The severity code indicates whether the return value represents information, warning, or error.</source>
          <target state="translated">심각도 코드 정보, 경고 또는 오류 반환 값을 나타내는지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The facility code identifies the area of the system responsible for the error.</source>
          <target state="translated">기능 코드 오류를 시스템의 영역을 식별합니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The error code is a unique number that is assigned to represent the exception.</source>
          <target state="translated">오류 코드는 예외를 나타내기 위해 할당 된 고유 번호입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>Each exception is mapped to a distinct HRESULT.</source>
          <target state="translated">각 예외는 고유한 HRESULT에 매핑됩니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>When managed code throws an exception, the runtime passes the HRESULT to the COM client.</source>
          <target state="translated">관리 코드에서 예외를 throw 하는 경우 런타임 HRESULT를 COM 클라이언트에 전달 합니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>When unmanaged code returns an error, the HRESULT is converted to an exception, which is then thrown by the runtime.</source>
          <target state="translated">비관리 코드에서 오류를 반환 하는 경우 다음 런타임에 의해 throw 되는 예외를 HRESULT에서 변환 됩니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>For information about HRESULT values and their corresponding .NET Framework exceptions, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">HRESULT 값과 해당 하는.NET Framework 예외가 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>하는 방법: 지도 Hresult 및 예외<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>See <bpt id="p1">[</bpt>Common HRESULT Values<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)</ept> in the Windows documentation for a list of the values you are most likely to encounter.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>일반적인 HRESULT 값<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)</ept> 발생할 가능성이 가장 높은 값의 목록에 대 한 Windows 설명서의 합니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Exception.HResult%2A&gt;</ph> property's setter is protected, whereas its getter is public.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Exception.HResult%2A&gt;</ph> 낮으므로 getter는 공용 속성 setter 보호 됩니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>In previous versions of the .NET Framework, both getter and setter are protected.</source>
          <target state="translated">.NET Framework의 이전 버전에서는 getter와 setter 중 하나가 보호 됩니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The following code example defines a derived <ph id="ph1">`Exception`</ph> class that sets the <ph id="ph2">`HResult`</ph> property to a custom value in its constructor.</source>
          <target state="translated">다음 코드 예제에서는 파생 정의 <ph id="ph1">`Exception`</ph> 설정 하는 클래스는 <ph id="ph2">`HResult`</ph> 속성의 생성자에 사용자 지정 값입니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="P:System.Exception.InnerException">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instance that caused the current exception.</source>
          <target state="translated">현재 예외를 발생시킨 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 인스턴스를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>An object that describes the error that caused the current exception.</source>
          <target state="translated">현재 예외를 발생시키는 오류를 설명하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> property returns the same value as was passed into the <ph id="ph2">&lt;see cref="M:System.Exception.#ctor(System.String,System.Exception)" /&gt;</ph> constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the inner exception value was not supplied to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> 속성은 <ph id="ph2">&lt;see cref="M:System.Exception.#ctor(System.String,System.Exception)" /&gt;</ph> 생성자로 전달된 것과 동일한 값을 반환하거나 생성자에 내부 예외 값을 제공하지 않은 경우 <ph id="ph3">&lt;see langword="null" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>This property is read-only.</source>
          <target state="translated">이 속성은 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>When an exception <ph id="ph1">`X`</ph> is thrown as a direct result of a previous exception <ph id="ph2">`Y`</ph>, the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property of <ph id="ph4">`X`</ph> should contain a reference to <ph id="ph5">`Y`</ph>.</source>
          <target state="translated">예외가 <ph id="ph1">`X`</ph> 이전 예외의 직접적인 결과로 throw 되 <ph id="ph2">`Y`</ph>, <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성 <ph id="ph4">`X`</ph> 에 대 한 참조를 포함 해야 <ph id="ph5">`Y`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>Use the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property to obtain the set of exceptions that led to the current exception.</source>
          <target state="translated">현재 예외의 원인이 된 예외 집합을 얻으려면 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성을 사용합니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>You can create a new exception that catches an earlier exception.</source>
          <target state="translated">이전 예외를 catch 하는 새 예외를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The code that handles the second exception can make use of the additional information from the earlier exception to handle the error more appropriately.</source>
          <target state="translated">오류를 보다 적절 하 게 처리할 예외를 처리는 두 번째 수의 추가 정보는 이전 예외를 사용 하는 코드입니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>Suppose that there is a function that reads a file and formats the data from that file.</source>
          <target state="translated">파일을 읽고 해당 파일에서 데이터의 형식을 지정 하는 함수 가정 합니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>In this example, as the code tries to read the file, an <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> is thrown.</source>
          <target state="translated">이 예제에서는 파일을 읽을 수 코드 시도로 <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The function catches the <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> and throws a <ph id="ph2">&lt;xref:System.IO.FileNotFoundException&gt;</ph>.</source>
          <target state="translated">함수를 catch는 <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> throw 한 <ph id="ph2">&lt;xref:System.IO.FileNotFoundException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> could be saved in the <ph id="ph2">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph>, enabling the code that catches the <ph id="ph4">&lt;xref:System.IO.FileNotFoundException&gt;</ph> to examine the cause of the initial error.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> 에 저장 될 수는 <ph id="ph2">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성의는 <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph>를 catch 하는 경우 코드가 <ph id="ph4">&lt;xref:System.IO.FileNotFoundException&gt;</ph> 초기 오류를 검사 하 합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property, which holds a reference to the inner exception, is set upon initialization of the exception object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 속성이 내부 예외에 대 한 참조를 보유 하는 예외 개체의 초기화할 때 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The following example demonstrates throwing and catching an exception that references an inner exception.</source>
          <target state="translated">다음 예제에서는 throw 하 고 내부 예외를 참조 하는 예외를 catch 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Exception.Message">
          <source>Gets a message that describes the current exception.</source>
          <target state="translated">현재 예외를 설명하는 메시지를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The error message that explains the reason for the exception, or an empty string ("").</source>
          <target state="translated">예외의 원인을 설명하는 오류 메시지 또는 빈 문자열("").입니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Error messages target the developer who is handling the exception.</source>
          <target state="translated">오류 메시지는 개발자에 게 예외를 처리 하는 대상으로 합니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The text of the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property should completely describe the error and, when possible, should also explain how to correct the error.</source>
          <target state="translated">텍스트는 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성 오류 완벽 하 게 설명 하 고, 가능한 경우 오류를 수정 하는 방법을 설명도 해야 합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Top-level exception handlers may display the message to end-users, so you should ensure that it is grammatically correct and that each sentence of the message ends with a period.</source>
          <target state="translated">문법적으로 올바른 인지 하 고 메시지의 각 문장의 마침표로 끝나는 있는지 확인 해야 하므로 최상위 예외 처리기, 최종 사용자에 게 메시지를 표시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Do not use question marks or exclamation points.</source>
          <target state="translated">물음표 또는 느낌표를 사용 하지 마십시오.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If your application uses localized exception messages, you should ensure that they are accurately translated.</source>
          <target state="translated">응용 프로그램에서 지역화 된 예외 메시지를 사용 하는 경우 정확 하 게 변환 있는지 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Do not disclose sensitive information in exception messages without checking for the appropriate permissions.</source>
          <target state="translated">적절 한 사용 권한을 확인 하지 않고 예외 메시지의 중요 한 정보를 공개 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The value of the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property is included in the information returned by <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph>.The <ph id="ph3">&lt;xref:System.Exception.Message%2A&gt;</ph> property is set only when creating an <ph id="ph4">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">값은 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성에서 반환 된 정보에 포함 되어 <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph>합니다. <ph id="ph3">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성이 만들 때만 <ph id="ph4">&lt;xref:System.Exception&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If no message was supplied to the constructor for the current instance, the system supplies a default message that is formatted using the current system culture.</source>
          <target state="translated">메시지를 현재 인스턴스에 대 한 생성자에 제공 하는 경우 시스템 현재 시스템 문화권을 사용 하 여 서식이 지정 된 기본 메시지를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Windows Runtime and <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></source>
          <target state="translated">Windows 런타임 및 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> and <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the fidelity of error messages from exceptions that are propagated from Windows Runtime types and members that are not part of the .NET Framework is improved.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> 및 <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, Windows 런타임 형식 및.NET Framework의 일부가 아닌 멤버에서 전파 되는 예외에서 오류 메시지의 정확성이 향상 됩니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>In particular, exception messages from Visual C++ component extensions (C++/CX) are now propagated back into .NET Framework <ph id="ph1">&lt;xref:System.Exception&gt;</ph> objects.</source>
          <target state="translated">특히 Visual c + + 구성 요소 확장에서 메시지를 예외 (C + + /cli CX) 이제.NET Framework에 다시 전파 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The following code example throws and then catches an <ph id="ph1">&lt;xref:System.Exception&gt;</ph> Exception and displays the exception's text message using the <ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">다음 코드 예제에서는 throw 및 catch 합니다는 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 예외 예외의 텍스트를 표시 하 고 사용 하 여 메시지는 <ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If you throw an exception from a property, and you need to refer in the text of <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> to the property argument that you set or get, use "value" as the name of the property argument.</source>
          <target state="translated">속성에서 예외를 throw 하 고 텍스트에 참조 해야 할 경우 <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> 설정 또는 가져오기 속성 인수 속성 인수 이름으로 "value"를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> property is overridden in classes that require control over message content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> 속성 메시지 내용 또는 형식을 제어할 필요가 있는 클래스에서 재정의 됩니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Application code typically accesses this property when it needs to display information about an exception that has been caught.</source>
          <target state="translated">일반적으로 응용 프로그램 코드를 발생 했습니다 예외에 대 한 정보를 표시 해야 할 때이 속성에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The error message should be localized.</source>
          <target state="translated">오류 메시지를 지역화 해야 합니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="E:System.Exception.SerializeObjectState">
          <source>Occurs when an exception is serialized to create an exception state object that contains serialized data about the exception.</source>
          <target state="translated">예외에 대한 serialize된 데이터를 포함하는 예외 상태 개체를 만들기 위해 예외를 serialize할 때 발생합니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The exception state object implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interface.</source>
          <target state="translated">예외 상태 개체를 구현 하는 <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>When the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is subscribed to, the exception is deserialized and created as an empty exception.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 이벤트를 구독 하는, 예외는 역직렬화 하 고 빈 예외도 생성 합니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The exception's constructor is not run, and the exception state is also deserialized.</source>
          <target state="translated">예외의 생성자 실행 되지 않습니다 및 예외 상태를 역직렬화 할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A&gt;</ph> callback method of the exception state object is then notified so that it can push deserialized data into the empty exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A&gt;</ph> 예외 상태 개체의 콜백 메서드는 빈 예외를 역직렬화 된 데이터를 푸시 수 있도록 다음 알림이 전송 됩니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event enables transparent exception types to serialize and deserialize exception data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 이벤트를 사용 하면 투명 예외 형식을 serialize 하 고 예외 데이터를 deserialize 합니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>Transparent code can execute commands within the bounds of the permission set it is operating within, but cannot execute, call, derive from, or contain critical code.</source>
          <target state="translated">투명 코드 수, 내에서 작동 하는 사용 권한 집합의 범위 내에서 명령을 실행 하지만 없습니다 실행, 호출, 컨트롤에서 파생 또는 중요 한 코드를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>If the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is not subscribed to, deserialization occurs as usual using the <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 이벤트 구독 하지 않습니다, deserialization이 발생 일반적으로 사용 하는 <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>Typically, a handler for the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is added in the exception's constructor to provide for its serialization.</source>
          <target state="translated">에 대 한 처리기 일반적으로 <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 이벤트의 serialization을 위해 제공 하는 예외 생성자에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>But because the constructor is not executed when the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event handler executes, serializing a deserialized exception can throw a <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationException&gt;</ph> exception when you try to deserialize the exception.</source>
          <target state="translated">생성자가 없기 때문에 하지만 될 때 실행 되는 <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 이벤트 처리기를 실행, 직렬화 역직렬화 된 예외를 throw 할 수는 <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationException&gt;</ph> 예외를 deserialize 하려고 할 때 예외입니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>To avoid this, you should also add the handler for the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event in the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">이 방지 하려면도 추가 해야에 대 한 처리기는 <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 이벤트에는 <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>See the Examples section for an illustration.</source>
          <target state="translated">예 섹션을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The following example defines a <ph id="ph1">`BadDivisionException`</ph> that handles the <ph id="ph2">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`BadDivisionException`</ph> 처리 하는 <ph id="ph2">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>It also contains a state object, which is a nested structure named <ph id="ph1">`BadDivisionExceptionState`</ph> that implements the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interface.</source>
          <target state="translated">또한 중첩 된 상태 개체를 포함 되어 라는 구조 <ph id="ph1">`BadDivisionExceptionState`</ph> 구현 하는 <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">`BadDivisionException`</ph> exception is thrown when a floating-point division by zero occurs.</source>
          <target state="translated"><ph id="ph1">`BadDivisionException`</ph> 0으로 부동 소수점 나누기가 발생 하는 경우 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>During the first division by zero, the example instantiates a <ph id="ph1">`BadDivisionException`</ph> object, serializes it, and throws the exception.</source>
          <target state="translated">이 예제에서는 0으로, 첫 번째 나누기 동안 인스턴스화합니다는 <ph id="ph1">`BadDivisionException`</ph> 개체를 serialize 하 고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>When subsequent divisions by zero occur, the example deserializes the  previously serialized object, reserializes it, and throws the exception.</source>
          <target state="translated">0으로 후속 부서 발생 하는 경우 예제는 이전에 직렬화 된 개체를 역직렬화 하, reserializes 고 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>To provide for object serialization, deserialization, reserialization, and deserialization, the example adds the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event handler both in the <ph id="ph2">`BadDivisionException`</ph> class constructor and in the <ph id="ph3">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">이 예제에서는 개체 serialization, deserialization, reserialization, 및 역직렬화를 제공 하려면 추가 <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> 의 이벤트 처리기 두는 <ph id="ph2">`BadDivisionException`</ph> 클래스 생성자에서는 <ph id="ph3">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> 구현 합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>If this event is subscribed to and used, all derived types that follow in the inheritance hierarchy must implement the same serialization mechanism.</source>
          <target state="translated">이 이벤트를 구독을 사용 하는 경우 상속 계층 구조 아래에 나오는 모든 파생된 형식 동일한 serialization 메커니즘을 구현 해야 합니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Exception.Source">
          <source>Gets or sets the name of the application or the object that causes the error.</source>
          <target state="translated">오류를 발생시키는 응용 프로그램 또는 개체의 이름을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>The name of the application or the object that causes the error.</source>
          <target state="translated">오류를 발생시키는 응용 프로그램 또는 개체의 이름입니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>If the <ph id="ph1">&lt;xref:System.Exception.Source%2A&gt;</ph> property is not set explicitly, the runtime automatically sets it to the name of the assembly in which the exception originated.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Exception.Source%2A&gt;</ph> 속성이 명시적으로 설정 되지 않은 경우, 런타임이 자동으로로 설정 되는 예외 시작 된 어셈블리의 이름입니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>The following example throws an <ph id="ph1">`Exception`</ph> that sets the <ph id="ph2">`Source`</ph> property in its constructor and then catches the exception and displays <ph id="ph3">`Source`</ph>.</source>
          <target state="translated">다음 예제에서는 throw는 <ph id="ph1">`Exception`</ph> 로 설정 하는 <ph id="ph2">`Source`</ph> 해당 생성자 및 다음 catch 된 예외와 표시 속성을 사용한 <ph id="ph3">`Source`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="P:System.Exception.Source">
          <source>The object must be a runtime <ph id="ph1">&lt;see cref="N:System.Reflection" /&gt;</ph> object</source>
          <target state="translated">개체는 런타임 <ph id="ph1">&lt;see cref="N:System.Reflection" /&gt;</ph> 개체여야 합니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="P:System.Exception.StackTrace">
          <source>Gets a string representation of the immediate frames on the call stack.</source>
          <target state="translated">호출 스택의 직접 실행 프레임 문자열 표현을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>A string that describes the immediate frames of the call stack.</source>
          <target state="translated">호출 스택의 직접 실행 프레임을 설명하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The execution stack keeps track of all the methods that are in execution at a given instant.</source>
          <target state="translated">실행 스택은 특정 시점에 실행 중인 모든 메서드를 추적합니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>A trace of the method calls is called a stack trace.</source>
          <target state="translated">메서드 호출을 추적하는 것을 스택 추적이라고 합니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The stack trace listing provides a way to follow the call stack to the line number in the method where the exception occurs.</source>
          <target state="translated">스택 추적 목록에는 예외가 발생 메서드의 줄 번호를 호출 스택을 따를 수가 있습니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property returns the frames of the call stack that originate at the location where the exception was thrown.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> 속성 예외가 throw 된 위치에서 발생 하는 호출 스택의 프레임을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>You can obtain information about additional frames in the call stack by creating a new instance of the <ph id="ph1">&lt;xref:System.Diagnostics.StackTrace?displayProperty=nameWithType&gt;</ph> class and using its <ph id="ph2">&lt;xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">새 인스턴스를 만들어 호출 스택에 추가 프레임에 대 한 정보를 얻을 수 있습니다는 <ph id="ph1">&lt;xref:System.Diagnostics.StackTrace?displayProperty=nameWithType&gt;</ph> 클래스와 사용 하 여 해당 <ph id="ph2">&lt;xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The common language runtime (CLR) updates the stack trace whenever an exception is thrown in application code (by using the <ph id="ph1">`throw`</ph> keyword).</source>
          <target state="translated">공용 언어 런타임 (CLR) 응용 프로그램 코드에서 예외가 throw 될 때마다 스택 추적을 업데이트 (사용 하 여는 <ph id="ph1">`throw`</ph> 키워드)입니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>If the exception was rethrown in a method that is different than the method where it was originally thrown, the stack trace contains both the location in the method where the exception was originally thrown, and the location in the method where the exception was rethrown.</source>
          <target state="translated">위치는 원래 예외가, 메서드의 위치와 메서드의 예외 있었던 위치 스택 추적에 포함 되어 메서드에서 다른 방법 보다 원래 예외가 다시 throw 된 예외를 하는 경우 다시 throw 합니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>If the exception is thrown, and later rethrown, in the same method, the stack trace only contains the location where the exception was rethrown and does not include the location where the exception was originally thrown.</source>
          <target state="translated">예외가 throw 되 고 나중에 다시 throw 동일한 메서드의 경우 스택 추적은 예외가 다시 throw 된 위치와 원래 예외가 throw 된 위치를 포함 하지 않습니다 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property may not report as many method calls as expected because of code transformations, such as inlining, that occur during optimization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> 속성와 같은 코드 변환으로 인해 예상 만큼 많은 메서드 호출을 보고 하지 않거나 인라인 처리를 최적화 하는 동안 발생 하는 합니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> and then catches it and displays a stack trace using the <ph id="ph2">`StackTrace`</ph> property.</source>
          <target state="translated">다음 코드 예제에서는 throw 한 <ph id="ph1">`Exception`</ph> 한 후 catch 하 여 스택 추적 표시는 <ph id="ph2">`StackTrace`</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;see langword="StackTrace" /&gt;</ph> property is overridden in classes that require control over the stack trace content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="StackTrace" /&gt;</ph> 속성 스택 추적 내용이 나 형식을 제어할 필요가 있는 클래스에서 재정의 됩니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>By default, the stack trace is captured immediately before an exception object is thrown.</source>
          <target state="translated">기본적으로 스택 추적에 예외 개체를 throw 되기 직전 캡처됩니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>Use <ph id="ph1">&lt;see cref="P:System.Environment.StackTrace" /&gt;</ph> to get stack trace information when no exception is being thrown.</source>
          <target state="translated">사용 하 여 <ph id="ph1">&lt;see cref="P:System.Environment.StackTrace" /&gt;</ph> 예외가 throw 되는 경우 스택 추적 정보를 얻을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="P:System.Exception.TargetSite">
          <source>Gets the method that throws the current exception.</source>
          <target state="translated">현재 예외를 throw하는 메서드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that threw the current exception.</source>
          <target state="translated">현재 예외를 발생시킨 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>If the method that throws this exception is not available and the stack trace is not a null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), <ph id="ph2">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> obtains the method from the stack trace.</source>
          <target state="translated">이 예외를 throw 하는 메서드를 사용할 수는 스택 추적이 null 참조 하는 경우 (<ph id="ph1">`Nothing`</ph> Visual basic에서), <ph id="ph2">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> 스택 추적에서 메서드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>If the stack trace is a null reference, <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> also returns a null reference.</source>
          <target state="translated">스택 추적이 null 참조인 경우 <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>도 null 참조를 반환합니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> property may not accurately report the name of the method in which an exception was thrown if the exception handler handles an exception across application domain boundaries.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> 속성 예외 처리기 응용 프로그램 도메인 경계를 넘어 예외를 처리 하는 경우 예외가 throw 된 메서드의 이름을 정확 하 게 보고할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> and then catches it and displays the originating method using the <ph id="ph2">`TargetSite`</ph> property.</source>
          <target state="translated">다음 코드 예제에서는 throw는 <ph id="ph1">`Exception`</ph> 다음 catch 하 고 사용 하 여 원래 메서드를 표시 하는 <ph id="ph2">`TargetSite`</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Exception.ToString">
          <source>Creates and returns a string representation of the current exception.</source>
          <target state="translated">현재 예외에 대한 문자열 표현을 만들고 반환합니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Exception.ToString">
          <source>A string representation of the current exception.</source>
          <target state="translated">현재 예외에 대한 문자열 표현입니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source><ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> returns a representation of the current exception that is intended to be understood by humans.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> 이해를 돕기 위한 것은 현재 예외 건의 표현을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Where the exception contains culture-sensitive data, the string representation returned by <ph id="ph1">`ToString`</ph> is required to take into account the current system culture.</source>
          <target state="translated">문자열 표현에서 반환 된 문화권을 구분 데이터를 포함 하는 예외, 여기서 <ph id="ph1">`ToString`</ph> 현재 시스템 문화권을 고려 하는 데 필요 합니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Although there are no exact requirements for the format of the returned string, it should attempt to reflect the value of the object as perceived by the user.</source>
          <target state="translated">반환 된 문자열의 형식에 대 한 정확한 요구에는 없지만 사용자가 인식으로 개체의 값을 반영 하도록 않아야 합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The default implementation of <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> obtains the name of the class that threw the current exception, the message, the result of calling <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph> on the inner exception, and the result of calling <ph id="ph3">&lt;xref:System.Environment.StackTrace%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">기본 구현은 <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> 현재 예외, 메시지, 호출의 결과 발생 시킨 클래스의 이름을 가져옵니다 <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph> 내부 예외 및 호출의 결과에 <ph id="ph3">&lt;xref:System.Environment.StackTrace%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>If any of these members is <ph id="ph1">`null`</ph>, its value is not included in the returned string.</source>
          <target state="translated">이러한 멤버 중 하나라도 <ph id="ph1">`null`</ph>, 값은 반환된 된 문자열에 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>If there is no error message or if it is an empty string (""), then no error message is returned.</source>
          <target state="translated">오류 메시지가 없는 경우 또는 빈 문자열 (""), 아니면 오류 메시지가 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The name of the inner exception and the stack trace are returned only if they are not <ph id="ph1">`null`</ph>.</source>
          <target state="translated">내부 예외 및 스택 추적의 이름이 없는 경우에 반환 됩니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The following example causes an exception and displays the result of calling <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> on that exception.</source>
          <target state="translated">다음 예제에서는 예외가 발생 하 고 호출의 결과 표시 <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> 그 예외에서 합니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Note that the <ph id="ph1">&lt;xref:System.Exception.ToString%2A?displayProperty=nameWithType&gt;</ph> method is called implicitly when the Exception class instance appears in the argument list of the <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.ToString%2A?displayProperty=nameWithType&gt;</ph> 메서드는 암시적으로 인수 목록에 표시 되는 예외 클래스 인스턴스는 <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>