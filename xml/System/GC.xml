<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="GC.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a32cca487ba8110051f97ff67e6a71e25b17a046.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a32cca487ba8110051f97ff67e6a71e25b17a046</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Controls the system garbage collector, a service that automatically reclaims unused memory.</source>
          <target state="translated">사용하지 않는 메모리를 자동적으로 회수하는 서비스인 시스템 가비지 수집기를 제어합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</source>
          <target state="translated">가비지 수집기가 할당 하 고 관리 되는 메모리 해제를 제어 하는 공용 언어 런타임 구성 요소입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</source>
          <target state="translated">이 클래스의 메서드는 개체와 개체에 의해 할당 된 리소스를 해제 하는 경우 가비지 컬렉션이 수행 될 때 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</source>
          <target state="translated">이 클래스의 속성 시스템 연령 범주 또는 개체에 할당 된 메모리의 생성에 사용할 수 있는 메모리의 총 금액에 대 한 정보를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tracks and reclaims objects allocated in managed memory.</source>
          <target state="translated">가비지 수집기를 추적 하 고 관리 되는 메모리에 할당 된 개체를 회수 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</source>
          <target state="translated">정기적으로 가비지 수집기는 참조가 유효 하지 않은 개체에 할당 된 메모리를 회수할 가비지 수집을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</source>
          <target state="translated">가비지 수집 사용 가능한 메모리를 사용 하 여 메모리에 대 한 요청을 충족할 수 없는 때 자동으로 발생 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Alternatively, an application can force garbage collection using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">또는 응용 프로그램 사용 하 여 가비지 컬렉션 강제로 수는 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection consists of the following steps:</source>
          <target state="translated">가비지 수집은 다음 단계로 구성 됩니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector searches for managed objects that are referenced in managed code.</source>
          <target state="translated">가비지 수집기는 관리 코드에서 참조 되는 관리 되는 개체를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tries to finalize objects that are not referenced.</source>
          <target state="translated">가비지 수집기는 참조 되지 않는 개체를 종료 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector frees objects that are not referenced and reclaims their memory.</source>
          <target state="translated">가비지 수집기가 참조 되지 않는 개체 및 해당 메모리를 회수 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This topic includes the following sections:</source>
          <target state="translated">이 항목은 다음 섹션으로 구성되어 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>The garbage collector and unmanaged resources<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>가비지 수집기와 관리 되지 않는 리소스<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Object aging and generations<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>개체 에이징 및 세대<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Disallowing garbage collection<ept id="p1">](#NoGCRegion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>가비지 수집을 허용 하지 않습니다.<ept id="p1">](#NoGCRegion)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector and unmanaged resources</source>
          <target state="translated">가비지 수집기와 관리 되지 않는 리소스</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</source>
          <target state="translated">컬렉션 중 하나 이상의 참조 된 개체에 관리 코드에서 발견 되 면 가비지 수집기는 개체를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</source>
          <target state="translated">그러나 가비지 수집기 비관리 코드에서 개체에 대 한 참조를 인식 하지 못하고 이렇게에서 명시적으로 금지 하지 않는 한 비관리 코드에서 단독으로 사용 하는 개체를 해제할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> 메서드는 가비지 수집기에서 여전히 사용 비관리 코드에 있는 개체를 수집 하지 않도록 설정 하는 메커니즘을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</source>
          <target state="translated">관리 되는 메모리 할당 하는 것 외 가비지 수집기의 구현 파일 핸들 또는 데이터베이스 연결 등의 개체에서 보유 한 리소스에 대 한 정보를 유지 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</source>
          <target state="translated">형식이 형식 인스턴스의 메모리가 회수 되기 전에 해제 해야 하는 관리 되지 않는 리소스를 사용 하면 형식 종료자를 구현할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, finalizers are implemented by overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">대부분의 경우 종료자를 재정의 하 여 구현 되는 <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> 메서드; 작성 된 C# 또는 c + + 형식에서 소멸자를 하는데 컴파일러의 재정의로 변경를 구현 하는 반면 <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</source>
          <target state="translated">대부분의 경우에서 개체가 종료자를 사용 하면 가비지 수집기가 호출 된 개체를 해제 하기 전에 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector is not required to call finalizers in all situations; for example, the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method explicitly prevents an object's finalizer from being called.</source>
          <target state="translated">하지만 가비지 수집기는 모든 상황에서 종료자를 호출 하는 데 필요 예를 들어는 <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> 메서드를 호출할 개체의 종료자를 명시적으로 않도록 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</source>
          <target state="translated">또한 가비지 수집기는 특정 스레드를 사용 하 여 개체를 종료 하거나 그렇지 않은 가비지 수집을 사용할 수 있지만 서로 참조 하는 개체에 대 한 종료자가 호출 되는 순서가 확정 되어 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In scenarios where resources must be released at a specific time, classes can implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, which contains the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method that performs resource management and cleanup tasks.</source>
          <target state="translated">특정 시간에 리소스를 해제 해야 합니다는 여기서 시나리오에서는 클래스에서 구현할 수는 <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> 를 포함 하는 인터페이스는 <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> 리소스 관리 및 정리 작업을 수행 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Classes that implement <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</source>
          <target state="translated">구현 하는 클래스 <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> 일부로 지정 해야, 클래스 계약의 경우 소비자 클래스 개체를 정리 하려면 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector does not, by default, call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method; however, implementations of the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method can call methods in the <ph id="ph3">&lt;xref:System.GC&gt;</ph> class to customize the finalization behavior of the garbage collector.</source>
          <target state="translated">가비지 수집기 호출 하지 않으며, 기본적으로는 <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> 메서드 소비량이 적어지지만 구현의 <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> 메서드의 메서드를 호출할 수는 <ph id="ph3">&lt;xref:System.GC&gt;</ph> 가비지 수집기의 종료 동작 사용자 지정 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>For more information on object finalization and the dispose pattern, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">개체를 종료 하 고 dispose 패턴에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>관리 되지 않는 리소스 정리<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging and generations</source>
          <target state="translated">개체 에이징 및 세대</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector in the common language runtime supports object aging using generations.</source>
          <target state="translated">공용 언어 런타임의 가비지 수집기는 세대를 사용 하 여 개체 에이징을 지원 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>A generation is a unit of measure of the relative age of objects in memory.</source>
          <target state="translated">생성은 메모리에 개체의 상대적 기간의 측정 단위입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The generation number, or age, of an object indicates the generation to which an object belongs.</source>
          <target state="translated">생성 번호 또는 개체의 보존 기간 개체 속해 있는 생성을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</source>
          <target state="translated">만든 개체 더 최근에 새로운 세대의 일부인 하며 응용 프로그램 수명 앞부분에서 만든 개체 주기 보다 더 낮은 세대 번호입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects in the most recent generation are in generation 0.</source>
          <target state="translated">가장 최근 세대 개체는 0 세대에서입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</source>
          <target state="translated">이 구현은 가비지 수집기의 세 가지 개체 세대가, 0, 1 및 2 세대를 지원합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum generation number supported by the system.</source>
          <target state="translated">값을 검색할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> 속성을 시스템에서 지 원하는 가장 큰 세대 번호를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</source>
          <target state="translated">개체 에이징 가비지 수집기가 모든 세대를 평가 하는 것이 아니라 세대 특정 집합에 대상 가비지 컬렉션에 응용 프로그램을 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method that include a <ph id="ph2">`generation`</ph> parameter allow you to specify the oldest generation to be garbage collected.</source>
          <target state="translated">오버 로드는 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 포함 하는 메서드는 <ph id="ph2">`generation`</ph> 매개 변수를 사용 하면 가장 오래 된 세대 가비지 수집을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Disallowing garbage collection</source>
          <target state="translated">가비지 수집을 허용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, 가비지 수집기를 비 GC 지역 대기 시간 모드는 가비지 컬렉션 수는 응용 프로그램의 성능이 저하 되는 중요 한 경로 실행 하는 동안 사용할 수 있는 지원 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</source>
          <target state="translated">비 GC 지역 대기 시간 모드 방해를 받지 않고 가비지 수집기에서 할당 될 수 있는 메모리 양을 지정 하는 필요 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</source>
          <target state="translated">런타임에서 해당 메모리를 할당할 수, 런타임에서 수행 하지 않습니다 가비지 수집을 요주의 경로에 코드 실행 하는 동안 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You define the beginning of the critical path of the no GC region by calling one of the overloads of the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.</source>
          <target state="translated">오버 로드 중 하나를 호출 하 여 중요 한 경로 없음 GC 영역의 시작 부분 정의 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You specify the end of its critical path by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">중요 한 경로 끝에 호출 하 여 지정 된 <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">에 대 한 호출을 중첩 시킬 수 없습니다는 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드를 호출 해야 합니다.는 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드는 런타임에서 현재 비 GC 지역 대기 시간 모드 경우.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">즉, 호출 하면 안 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 여러 번 (첫 번째 메서드 호출 후 후속 호출은 성공 하지 것입니다), 호출을 기대할 수 없습니다 및 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 해 서 첫 번째 호출에 성공 하려면 <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 성공 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</source>
          <target state="translated">다음 예제에서는 생성 및 사용 하지 않는 개체의 블록에 대 한 메모리 정보를 콘솔에 인쇄 GC는 여러 가지 방법을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The unused objects are then collected, and the resulting memory totals are displayed.</source>
          <target state="translated">사용 되지 않은 개체는 다음 모두 수집 하 고 총 메모리 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The incremental amount of unmanaged memory that has been allocated.</source>
          <target state="translated">할당된 관리되지 않는 메모리의 증가량입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</source>
          <target state="translated">가비지 컬렉션을 예약할 때 고려해야 할 많은 양의 관리되지 않는 메모리 할당을 런타임에 알립니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">가비지 수집을 예약 하는 시기를 결정할 때, 런타임에 고려 얼마나 많은 관리 되는 메모리를 할당 합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">관리 되는 작은 개체는 많은 양의 관리 되지 않는 메모리를 할당 하면 런타임에서 관리 되는 메모리만 고려 하 고 가비지 수집을 예약 하는 긴급도 따라서에서는 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 메서드 시스템 메모리의 추가 사용을 런타임에 알립니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">가장 간단한 사용 패턴에 관리 되는 개체 생성자에 관리 되지 않는 메모리를 할당 및 해제는 <ph id="ph1">`Dispose`</ph> 또는 <ph id="ph2">`Finalize`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">호출의 <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 관리 되지 않는 메모리를 할당 한 후 메서드를 호출 하 고는 <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> 해제 한 후 메서드.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">여기서는 관리 되지 않는 메모리 할당 크게 변경 되는 관리 되는 개체의 수명 동안, 더 복잡 한 시나리오에서 호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> 런타임에 이러한 증분 변경 내용을 통신 하는 방법입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">추가한 압력 양은 정확 하 게 제거 하는 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">이렇게 정의 하면 오랜 시간 동안 실행 되는 응용 프로그램에서 시스템의 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph>가 0보다 작거나 같은 경우</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">32비트 컴퓨터에서 <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">가비지 수집 우선 순위를 조작할 때 비관리 코드를 호출 하는 기능입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>Cancels the registration of a garbage collection notification.</source>
          <target state="translated">가비지 컬렉션 알림의 등록을 취소합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This method cancels a garbage collection notification that was registered by using the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">이 메서드를 사용 하 여 등록 된 가비지 수집 알림의 취소는 <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">매개 변수 값에 대 한 후속 호출에 임계값을 조정 하기 전에이 메서드를 호출할 필요가 없습니다는 <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>The following example cancels a garbage collection registration.</source>
          <target state="translated">다음 예에서는 가비지 수집 등록을 취소합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This example is part of a larger example provided for the <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">이 예제는에 대해 제공 된 큰 예제의 일부는 <bpt id="p1">[</bpt>가비지 수집 알림<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>This member is not available when concurrent garbage collection is enabled.</source>
          <target state="translated">동시 가비지 컬렉션이 사용되는 경우 이 멤버를 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>See the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> runtime setting for information about how to disable concurrent garbage collection.</source>
          <target state="translated">동시 가비지 수집을 사용하지 않도록 설정하는 방법에 대한 자세한 내용은 <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> 런타임 설정을 참조하세요.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰 합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Forces garbage collection.</source>
          <target state="translated">가비지 컬렉션을 수행하도록 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.GC.Collect">
          <source>Forces an immediate garbage collection of all generations.</source>
          <target state="translated">모든 세대의 가비지 수집을 즉시 수행합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to try to reclaim all memory that is inaccessible.</source>
          <target state="translated">이 메서드를 사용 하 여 액세스할 수 있는 모든 메모리를 회수할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>It performs a blocking garbage collection of all generations.</source>
          <target state="translated">모든 세대의 차단 가비지 수집을 수행합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</source>
          <target state="translated">메모리에 있었던 시간에 관계 없이 모든 개체를 컬렉션에 대 한 것으로 간주 됩니다. 그러나 관리 코드에서 참조 되는 개체는 수집 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to force the system to try to reclaim the maximum amount of available memory.</source>
          <target state="translated">이 메서드를 사용 하 여 최대 사용 가능한 메모리 양을 회수할 수 시스템 강제 적용 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, you can compact the large object heap (LOH) by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method, as the following example illustrates.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>를 설정 하 여 큰 개체 힙 (LOH)을 압축할 수 있습니다는 <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> 속성을 <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> 호출 하기 전에 <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드를 다음 예제와 같이 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on all generations of memory.</source>
          <target state="translated">다음 예제에서는 사용 하는 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메모리의 모든 세대에서 수집을 수행 하는 메서드.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">코드의 사용 되지 않는 개체는 숫자를 생성 한 다음 호출에서 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드를 메모리에서 지웁니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">가비지를 수집할 가장 오래된 세대의 수입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>Forces an immediate garbage collection from generation 0 through a specified generation.</source>
          <target state="translated">0세대에서 지정된 세대까지 가비지 수집을 즉시 수행합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use this method to try to reclaim memory that is inaccessible.</source>
          <target state="translated">이 메서드를 사용 하 여 액세스할 수 있는 메모리를 회수할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">그러나이 메서드를 사용 하 여 보장 하지 않습니다 지정된 된 세대에 액세스할 수 없는 모든 메모리가 회수 됩니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</source>
          <target state="translated">가비지 수집기는 세대 번호를 가진 개체 수집 하지 않습니다 개체 에이징이 구현 된 경우 지정된 된 세대 보다 높습니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</source>
          <target state="translated">개체 에이징 구현 되지 않은 경우 가비지 수집기가 가비지 수집 중 모든 개체를 검토 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of the <ph id="ph2">`generation`</ph> parameter.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> 속성의 최대 유효 값을 확인 하 고 <ph id="ph2">`generation`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">가비지 수집기는 세대에 상관 없이 모든 개체를 검토 하려면, 매개 변수를 사용 하는이 메서드의 버전을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector reclaim objects based on a <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> setting, use the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">기반으로 하는 개체를 회수 하는 가비지 수집기는 <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> 설정을 사용 하 여는 <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on individual layers of memory.</source>
          <target state="translated">다음 예제에서는 사용 하는 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메모리의 각 계층에서 컬렉션을 수행 하는 메서드.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">코드의 사용 되지 않는 개체는 숫자를 생성 한 다음 호출에서 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드를 메모리에서 지웁니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph>가 잘못된 경우</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">가비지를 수집할 가장 오래된 세대의 수입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">이 가비지의 수집 강제 (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) 또는 최적화 (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>) 여부를 지정하는 열거형 값입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 값에 지정된 시간에 0세대에서 지정된 세대까지 가비지 수집을 수행합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">`mode`</ph> parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">`mode`</ph> 매개 변수를 수행할지 여부를 가비지 수집 즉시 또는 시간은 개체를 회수 하려면 최적의 지정 합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">이 메서드를 사용 하 여 지정된 된 세대에 액세스할 수 없는 모든 메모리가 회수 보장 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To adjust the intrusiveness of garbage collection during critical periods in your application, set the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> property.</source>
          <target state="translated">응용 프로그램에서 중요 한 기간 동안 가비지 수집의 대기를 조정 하려면 설정는 <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The garbage collector does not collect objects with a generation number higher than specified by the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">가비지 수집기에서 지정 된 것 보다 더 높은 세대 번호를 가진 개체를 수집 하지 않습니다는 <ph id="ph1">`generation`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of <ph id="ph2">`generation`</ph>.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> 속성의 최대 유효 값을 확인 하려면 <ph id="ph2">`generation`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">가비지 수집기는 세대에 상관 없이 모든 개체를 검토 하려면, 매개 변수를 사용 하는이 메서드의 버전을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector reclaim objects up to a specified generation of objects, use the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">개체의 지정된 된 세대까지 개체를 회수, 사용 하 여 가비지 수집기가 하는 <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>When you specify the maximum generation, all objects are collected.</source>
          <target state="translated">최대 생성을 지정 하면 개체를 모두 수집 됩니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The following example forces a garbage collection for generation 2 objects with the <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> setting.</source>
          <target state="translated">다음 예제에서는 사용 하 여 2 세대 개체에 대 한 가비지 수집을 강제로 <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> 설정 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph>가 잘못된 경우</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 값 중 하나가 아닙니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">가비지를 수집할 가장 오래된 세대의 수입니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">이 가비지의 수집 강제 (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) 또는 최적화 (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>) 여부를 지정하는 열거형 값입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated">차단 가비지 수집을 수행하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 가능한 경우 백그라운드 가비지 수집을 수행하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with a value specifying whether the collection should be blocking.</source>
          <target state="translated">수집이 차단되어야 할지 여부를 지정하는 값을 사용하여 <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 값으로 지정된 시간에 0세대에서 지정된 세대까지 가비지 수집을 강제로 실행합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The following table summarizes the interaction of the <ph id="ph1">`mode`</ph> and <ph id="ph2">`blocking`</ph> parameters:</source>
          <target state="translated">다음 표에서 요약의 상호 작용은 <ph id="ph1">`mode`</ph> 및 <ph id="ph2">`blocking`</ph> 매개 변수:</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`true`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph>가 <ph id="ph2">`true`</ph>인 경우</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph>가 <ph id="ph2">`false`</ph>인 경우</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> or <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection is performed as soon as possible.</source>
          <target state="translated">차단 컬렉션은 가능한 한 빨리 수행됩니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 0 or 1, the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method immediately triggers a blocking collection and returns when the collection is finished.</source>
          <target state="translated">백그라운드 컬렉션 진행 중인 경우 및 <ph id="ph1">`generation`</ph> 은 0 또는 1는 <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> 즉시 차단 컬렉션을 트리거하여 메서드와 완료 되는 컬렉션을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</source>
          <target state="translated">백그라운드 컬렉션 진행 중인 경우와 <ph id="ph1">`generation`</ph> 가 2 인 백그라운드 컬렉션이 완료 되 고 차단 2 세대 컬렉션을 트리거하여 다음 반환 될 때까지 메서드 대기 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection is performed as soon as possible.</source>
          <target state="translated">컬렉션은 가능한 한 빨리 수행됩니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> 메서드는 백그라운드 컬렉션을 요청하지만 이 작업이 항상 수행되지는 않으며 상황에 따라 차단 컬렉션이 계속 수행될 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">백그라운드 컬렉션이 이미 진행 중인 경우 메서드가 즉시 반환됩니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection may be performed, depending on the state of the garbage collector and the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">차단 컬렉션은 가비지 수집기의 상태와 <ph id="ph1">`generation`</ph> 매개 변수에 따라 수행될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">가비지 수집기는 최적의 성능을 제공하려고 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection may be performed, depending on the state of the garbage collector.</source>
          <target state="translated">가비지 수집기의 상태에 따라 컬렉션이 수행될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> 메서드는 백그라운드 컬렉션을 요청하지만 이 작업이 항상 수행되지는 않으며 상황에 따라 차단 컬렉션이 계속 수행될 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">가비지 수집기는 최적의 성능을 제공하려고 합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">백그라운드 컬렉션이 이미 진행 중인 경우 메서드가 즉시 반환됩니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a call to the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">호출 하는 경우는 <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> 전체 차단 가비지 수집을 수행 하는 메서드를 설정 하 여 큰 개체 힙 또한 압축할 수 있습니다는 <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> 속성을 <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> 호출 하기 전에 <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph>가 잘못된 경우</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>가 <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 값 중 하나가 아닙니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">가비지를 수집할 가장 오래된 세대의 수입니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">이 가비지의 수집 강제 (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) 또는 최적화 (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>) 여부를 지정하는 열거형 값입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated">차단 가비지 수집을 수행하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 가능한 경우 백그라운드 가비지 수집을 수행하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to compact the small object heap; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to sweep only.</source>
          <target state="translated">작은 개체 힙을 압축 하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>, 비우기만 하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with values that specify whether the collection should be blocking and compacting.</source>
          <target state="translated">수집이 차단되고 압축되어야 할지 여부를 지정하는 값을 사용하여 <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 값으로 지정된 시간에 0세대에서 지정된 세대까지 가비지 수집을 강제로 실행합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph>, the GC decides whether to perform a background or a blocking garbage collection.</source>
          <target state="translated">경우 <ph id="ph1">`blocking`</ph> 은 <ph id="ph2">`false`</ph>, GC 배경 또는 차단 가비지 컬렉션 수행 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, it performs a blocking garbage collection.</source>
          <target state="translated">경우 <ph id="ph1">`compacting`</ph> 은 <ph id="ph2">`true`</ph>, 차단 가비지 수집을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, the runtime compacts the small object heap (SOH).</source>
          <target state="translated">경우 <ph id="ph1">`compacting`</ph> 은 <ph id="ph2">`true`</ph>, 런타임에서 작은 개체 힙 (SOH)을 압축 합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The large object heap (LOH) is not compacted unless the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">큰 개체 힙 (LOH) 하지 않는 한 압축은 <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> 속성이로 설정 된 <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Note that this includes all blocking garbage collections, not just full blocking garbage collections.</source>
          <target state="translated">Note 모든 차단 가비지 컬렉션 되지 전체 차단 가비지 컬렉션에 있습니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</source>
          <target state="translated">호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> 메서드에 다음 코드 조각에서와 같이 관리 되는 힙 크기 가능한 가장 작은 줄일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">`true`</ph> for the <ph id="ph2">`compacting`</ph> argument guarantees a compacting, full blocking garbage collection.</source>
          <target state="translated">지정 <ph id="ph1">`true`</ph> 에 대 한는 <ph id="ph2">`compacting`</ph> 인수는 압축, 전체 차단 가비지 수집을 보장 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Setting the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> ensures that both the LOH and SOH are compacted.</source>
          <target state="translated">설정의 <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> 속성을 <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> LOH와 SOH 압축 되도록 보장 합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The generation of objects for which the garbage collection count is to be determined.</source>
          <target state="translated">가비지 수집 횟수를 확인할 개체의 세대입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Returns the number of times garbage collection has occurred for the specified generation of objects.</source>
          <target state="translated">지정된 세대의 개체에 대해 가비지 컬렉션이 수행된 횟수를 반환합니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The number of times garbage collection has occurred for the specified generation since the process was started.</source>
          <target state="translated">프로세스가 시작된 이후 지정된 세대에 대해 가비지 컬렉션이 수행된 횟수입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If you implement your own resource management, you might need to force garbage collection periodically by calling the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">사용자 고유의 리소스 관리를 구현 하는 경우 가비지 수집을 주기적으로 호출 하 여 적용 해야 할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</source>
          <target state="translated">이 작업은 비용이 많이 드는 작업 때문에 가비지 수집을 최근에 발생 했을 때 호출을 건너뛰어 성능을 개선할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Save the value returned by <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> immediately after calling <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>.</source>
          <target state="translated">반환 된 값을 저장 <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> 호출한 직후 <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The next time you need to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>, compare the current value returned by <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> to the saved value.</source>
          <target state="translated">호출 하면 다음에 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>에서 반환 된 현재 값 비교 <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> 저장 된 값으로.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If the two values are equal, no collection has occurred in the interim and it is reasonable to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> again.</source>
          <target state="translated">두 값이 같으면 컬렉션이 없으면 중간에 발생 하는 호출 하 상태일 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 다시 합니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>Ends the no GC region latency mode.</source>
          <target state="translated">비 GC 지역 대기 시간 모드를 종료합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> if the garbage collector is not in no GC region latency mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드가 throw는 <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> 가비지 수집기가 비 GC 지역 대기 시간 모드에 없는 경우.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>This occurs under any of the following conditions:</source>
          <target state="translated">다음 조건에서 발생합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method was not called previously.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드가 이전에 호출 되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method returned <ph id="ph2">`false`</ph>.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드 반환 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method threw an exception.</source>
          <target state="translated">에 대 한 호출에서 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드에서 예외가 발생 했습니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>You can prevent an exception for any of these reasons by using code such as the following:</source>
          <target state="translated">다음과 같은 코드를 사용 하 여 다음과 같은 이유로 인해에 대 한 예외를 방지할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The garbage collector is not in no GC region latency mode.</source>
          <target state="translated">가비지 수집기가 비 GC 지역 대기 시간 모드가 아닌 경우</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The no GC region latency mode was ended previously because a garbage collection was induced.</source>
          <target state="translated">가비지 수집이 발생하여 비 GC 지역 대기 시간 모드가 이전에 종료된 경우</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>A memory allocation exceeded the amount specified in the call to the <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> method.</source>
          <target state="translated">메모리 할당이 <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> 메서드 호출에서 지정된 크기를 초과한 경우</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the current generation number of an object.</source>
          <target state="translated">개체의 현재 세대 번호를 반환합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The object that generation information is retrieved for.</source>
          <target state="translated">세대 정보를 검색할 개체입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Returns the current generation number of the specified object.</source>
          <target state="translated">지정된 개체의 현재 세대 번호를 반환합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The current generation number of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph>의 현재 세대 번호입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Use this method to determine the age of an object, and then use that information with the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to force the garbage collector to collect objects in the same generation.</source>
          <target state="translated">이 메서드를 사용 하는 개체의 보존 기간을 결정 한 다음 해당 정보를 사용 하 여는 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드를 수집 하 여 가비지 수집기를 동일한 세대의 개체입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</source>
          <target state="translated">예를 들어 개체 그룹으로 생성 하 고 동시에 액세스할 수 없게 집합이 있는 경우에이 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of an object.</source>
          <target state="translated">다음 예제에서는 사용 하는 방법을 보여 줍니다는 <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> 메서드를 개체의 보존 기간을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</source>
          <target state="translated">이 예제에서는 메모리를 정리 하 고 사전 비교 콘솔에서 컬렉션 총 메모리를 게시 하는 가비지 수집을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>A <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph> that refers to the target object whose generation number is to be determined.</source>
          <target state="translated">세대 번호를 확인할 대상 개체를 참조하는 <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Returns the current generation number of the target of a specified weak reference.</source>
          <target state="translated">지정된 약한 참조의 대상의 현재 세대 번호를 반환합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The current generation number of the target of <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="wo" /&gt;</ph>의 대상의 현재 세대 번호입니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of a weak reference object.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> 약한 참조 개체의 보존 기간을 결정 하는 메서드.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Garbage collection has already been performed on <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated">가비지 수집이 <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>에서 이미 수행된 경우</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 메서드가 반환되기 전에 가비지 수집을 기다릴 수 있다는 것을 나타내려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>Retrieves the number of bytes currently thought to be allocated.</source>
          <target state="translated">현재 할당되었다고 여겨지는 바이트 수를 검색합니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</source>
          <target state="translated">매개 변수는 시스템에서 가비지를 수집하고 개체를 종료할 수 있도록 이 메서드가 반환되기 전에 잠시 동안 대기할 수 있는지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</source>
          <target state="translated">관리되는 메모리에 현재 할당된 가장 가까운 근사값의 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>If the <ph id="ph1">`forceFullCollection`</ph> parameter is <ph id="ph2">`true`</ph>, this method waits a short interval before returning while the system collects garbage and finalizes objects.</source>
          <target state="translated">경우는 <ph id="ph1">`forceFullCollection`</ph> 매개 변수는 <ph id="ph2">`true`</ph>,이 메서드는 시스템에서 가비지를 수집 하 고 개체를 종료할 때 짧은 간격으로 반환 하기 전에 대기 합니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</source>
          <target state="translated">간격의 기간이 완료 가비지 수집 주기의 수에 의해 결정 되는 내부적으로 지정 된 제한 및 주기 사이 복구 하는 메모리 양이 변경 되었습니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The garbage collector does not guarantee that all inaccessible memory is collected.</source>
          <target state="translated">가비지 수집기에서 액세스할 수 없는 메모리를 모두 수집 됨을 보장 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method to get and display the number of bytes currently allocated in managed memory.</source>
          <target state="translated">다음 예제에서는 사용 하는 방법을 <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> 메서드를 가져오고 관리 되는 메모리에 현재 할당 된 바이트 수를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object to reference.</source>
          <target state="translated">참조할 개체입니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</source>
          <target state="translated">지정된 개체를 참조하여 현재 루틴이 시작된 지점에서 이 메서드가 호출된 지점까지 가비지 컬렉션이 불가능하도록 합니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The purpose of the <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</source>
          <target state="translated">용도 <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> 방법은 서둘러 가비지 수집기가 회수 될 위험에 노출 하는 개체에 대 한 참조의 존재 여부를 확인 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</source>
          <target state="translated">이 발생할 수 있는 일반적인 시나리오는 관리 되는 코드 또는 데이터를 개체에 대 한 참조가 있지만 개체 사용 중인 Win32 Api, 관리 되지 않는 Dll 같은 비관리 코드 또는 COM.를 사용 하 여 메서드</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>This method references the <ph id="ph1">`obj`</ph> parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</source>
          <target state="translated">이 메서드가 참조는 <ph id="ph1">`obj`</ph> 매개 변수를 해당 개체까지 가비지 수집이 루틴의 시작 부분부터 실행 순서 대로 지점에이 메서드가 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>Code this method at the end, not the beginning, of the range of instructions where <ph id="ph1">`obj`</ph> must be available.</source>
          <target state="translated">이 메서드를 마치면 지침의 범위 시작이 아닌 코드 여기서 <ph id="ph1">`obj`</ph> 사용할 수 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> 메서드 아무런 작업도 수행 하 고 매개 변수로 전달 된 개체의 수명을 확장 이외의 부작용이 없습니다를 생성 합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The following code example creates an object at the beginning of its <ph id="ph1">`Main`</ph> method and does not refer to the object again until the end, when the <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is called.</source>
          <target state="translated">다음 코드 예제에서는의 시작 부분에서 개체를 만들고 해당 <ph id="ph1">`Main`</ph> 메서드 끝까지 다시 개체를 참조 하지 않습니다 때는 <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object persists for the 30-second duration of the <ph id="ph1">`Main`</ph> method, despite calls to the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> methods.</source>
          <target state="translated">개체는 30 초 동안 지속 되는 <ph id="ph1">`Main`</ph> 메서드 호출에도 불구 하 고는 <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.GC.MaxGeneration">
          <source>Gets the maximum number of generations that the system currently supports.</source>
          <target state="translated">시스템에서 현재 지원하는 가장 큰 세대 번호를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>A value that ranges from zero to the maximum number of supported generations.</source>
          <target state="translated">0에서 지원되는 가장 큰 세대 번호 사이의 값입니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</source>
          <target state="translated">생성 번호 또는 개체의 보존 기간에는 개체의 수명이의 구현에서 정의 된 상대 측정값입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property.</source>
          <target state="translated">가장 최근에 만든된 개체는 세대 0에에서이 고 가장 오래 된 개체를 반환한 생성을 보다 작거나 같은 세대에는 <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</source>
          <target state="translated">가비지 수집기가 새 메모리 오래 된 메모리 보다 가비지 수집을 수행할 수 있을 가능성이 있다고 가정 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property value can grow over time.</source>
          <target state="translated">따라서 메모리를 회수 될 때마다 세대 번호를 조정 하 여는 성능을 향상를 가비지 수집기와 <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> 속성 값은 시간에 따라 증가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>If object aging is implemented, the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property returns the maximum generation number used by the system; otherwise, this property returns zero.</source>
          <target state="translated">개체 에이징 구현 되는 경우는 <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> 속성 시스템에서 사용 하는 가장 큰 세대 번호를 반환 그렇지 않은 경우이 속성이 0을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</source>
          <target state="translated">다음 예제에서는 현재 사용 중에서 가장 큰 세대 번호를 표시 하려면 MaxGeneration 속성을 사용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>For this implementation, the value returned by the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property is guaranteed to remain constant for the lifetime of an executing application.</source>
          <target state="translated">이 구현에서 반환 되는 값은 <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> 속성이 실행 중인 응용 프로그램의 수명 동안 일정 하 게 유지 합니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property to determine the maximum value you can specify when calling the <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> method that takes a generation parameter.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> 호출할 때 지정할 수는 최대 값을 결정 하는 속성은 <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> 메서드 생성 매개 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</source>
          <target state="translated">2세대에 할당된 개체에 따라 알림을 발생시킬 시점을 지정하는 1에서 99 사이의 숫자입니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</source>
          <target state="translated">대형 개체 힙에 할당된 개체에 따라 알림을 발생시킬 시점을 지정하는 1에서 99 사이의 숫자입니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</source>
          <target state="translated">전체 가비지 컬렉션에 유리한 조건인 경우와 컬렉션이 완료된 경우에 가비지 컬렉션 알림이 발생하도록 지정합니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For each generation, the garbage collector sets a threshold for allocations into that generation.</source>
          <target state="translated">각 세대에 대해 가비지 수집기는 해당 세대에 할당에 대 한 임계값을 설정합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</source>
          <target state="translated">할당의 크기에서이 임계값을 초과 하면 해당 세대에 가비지 수집이 트리거됩니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</source>
          <target state="translated">에 대 한 다음 가비지 수집을 시도 합니다. 예를 들어 (즉, 20MB 1 세대 컬렉션 후에 유지 2 세대로 승격) 20 MB 이며 20MB 이상 세대 2의 임계값이 경우 1 세대 되지 않고 유지과 2 세대에 라는 메시지가 표시 됩니다, 2 세대 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</source>
          <target state="translated">마찬가지로, 큰 개체 힙 (LOH의)의 임계값 20MB 하며 응용 프로그램에서 할당 한 개 이상의 20MB 큰 개체, 다음 가비지 수집 (LOH gen2 가비지 컬렉션에만 수집 됩니다) 이후 2 세대 컬렉션으로 시도 됩니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> thresholds control how much in advance you are notified before a full garbage collection occurs.</source>
          <target state="translated"><ph id="ph1">`maxGenerationThreshold`</ph> 및 <ph id="ph2">`largeObjectHeapThreshold`</ph> 임계값 전체 가비지 수집이 발생 하기 전에 알림을 미리 어느 정도 제어 합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</source>
          <target state="translated">임계값이 클수록 간에 알림 및 다음 전체 가비지 수집이 발생할 수 있는 많은 할당입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method) when conditions are still favorable.</source>
          <target state="translated">런타임에서 전체 가비지 수집을 수행 하 고 사용 하 여 해당 컬렉션을 우회 하려고 할 때 알림을 받을 수 요청할 수 있는 공용 언어 런타임에서 전체 가비지 수집이 나쁜 영향을 응용 프로그램의 성능을 설정한 경우 직접 컬렉션을 실행 (사용 하는 <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드) 조건이 유리할 여전히 때.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</source>
          <target state="translated">가비지 수집 일정, 사용자가 직접 변경 하는 것 외에도 전체 GC 알림은 다음의 시나리오에서 유용 합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</source>
          <target state="translated">전체 가비지 수집의 접근 방식에 대 한 모니터링 하 고 (예를 들어 일부 캐시 항목 해제)에서 사용 중인 데이터 크기를 줄일 하나 도달 하 고 있음이 되었다는 메시지가 나타나면 합니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>As a result, when the garbage collection occurs, it is able to reclaim more memory.</source>
          <target state="translated">결과적으로, 가비지 수집이 발생 경우에 더 많은 메모리를 회수할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the completion of a full garbage collection so that you can collect some statistics.</source>
          <target state="translated">몇 가지 통계를 수집할 수 있도록 전체 가비지 수집의 완료에 대 한 모니터링 합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</source>
          <target state="translated">예를 들어 다음 사용 중인 데이터의 크기를 알 수 있도록 GC 완료 시 힙의 크기를 측정 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>(After a full GC, the heap is at its smallest size.)</source>
          <target state="translated">(전체 GC 후 힙에 가장 작은 크기로.)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For more information about what represents a full garbage collection, see <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>.</source>
          <target state="translated">전체 가비지 수집의 의미에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>가비지 수집 알림<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</source>
          <target state="translated">가비지 컬렉션 알림의 등록 하면 전체 가비지 수집이 임박 때와 완료 될 때를 알림을 받을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This pattern resembles how the operating system monitors for low memory notifications.</source>
          <target state="translated">이 패턴은 운영 체제 메모리 부족 알림을 모니터링 하는 방법 유사 합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Use the following guidelines for specifying the <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> parameters:</source>
          <target state="translated">다음 지침을 사용 하 여 지정 하는 데는 <ph id="ph1">`maxGenerationThreshold`</ph> 및 <ph id="ph2">`largeObjectHeapThreshold`</ph> 매개 변수:</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</source>
          <target state="translated">클수록 임계값 값을 더 할당 알림과 전체 가비지 수집이 사이의 발생 합니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</source>
          <target state="translated">임계값이 크면 근접 컬렉션에 대 한 확인 하기 위해 런타임에 대 한 더 많은 기회를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This increases the likelihood that you will be notified.</source>
          <target state="translated">이 알려 가능성이 커집니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</source>
          <target state="translated">그러나 런타임에 다음 수집을 실행 하기 전에 많은 할당 인해 때문에 임계값을 너무 높게 설정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</source>
          <target state="translated">사용자 컬렉션을 직접 실행할 높은 임계값을 사용 하 여 알림을 시, 하면 런타임 다음 수집에서 회수 되는 것 보다 적은 개체 회수 됩니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</source>
          <target state="translated">임계값 값이 작을수록, 알림과 전체 가비지 수집이 사이의 할당 적습니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</source>
          <target state="translated">다음 예제에는 가비지 수집 알림의 등록 하 고 가비지 수집 알림의 상태를 모니터링 하는 스레드를 시작 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부 <bpt id="p1">[</bpt>가비지 수집 알림<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> or <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> is not between 1 and 99.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph>가 1과 99 사이에 없습니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰 합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The amount of unmanaged memory that has been released.</source>
          <target state="translated">해제된 관리되지 않는 메모리의 양입니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</source>
          <target state="translated">관리되는 메모리가 해제되었고 가비지 컬렉션을 예약할 때 더 이상 고려할 필요가 없다고 런타임에 알립니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">가비지 수집을 예약 하는 시기를 결정할 때, 런타임에 고려 얼마나 많은 관리 되는 메모리를 할당 합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">관리 되는 작은 개체는 많은 양의 관리 되지 않는 메모리를 할당 하면 런타임에서 관리 되는 메모리만 고려 하 고 가비지 수집을 예약 하는 긴급도 따라서에서는 합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory, and the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method informs the runtime that the additional pressure has been released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 메서드 시스템 메모리의 추가 사용을 런타임에 알립니다 및 <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> 메서드 추가 사용이 해제 되었음을 런타임에 알립니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">가장 간단한 사용 패턴에 관리 되는 개체 생성자에 관리 되지 않는 메모리를 할당 및 해제는 <ph id="ph1">`Dispose`</ph> 또는 <ph id="ph2">`Finalize`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">호출의 <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 관리 되지 않는 메모리를 할당 한 후 메서드를 호출 하 고는 <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> 해제 한 후 메서드.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">여기서는 관리 되지 않는 메모리 할당 크게 변경 되는 관리 되는 개체의 수명 동안, 더 복잡 한 시나리오에서 호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> 런타임에 이러한 증분 변경 내용을 통신 하는 방법입니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">추가한 압력 양은 정확 하 게 제거 하는 확인 해야 합니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">이렇게 정의 하면 오랜 시간 동안 실행 되는 응용 프로그램에서 시스템의 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph>가 0보다 작거나 같은 경우</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">32비트 컴퓨터에서 <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">가비지 수집 우선 순위를 조작할 때 비관리 코드를 호출 하는 기능입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The object that a finalizer must be called for.</source>
          <target state="translated">종료자가 호출되어야 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Requests that the system call the finalizer for the specified object for which <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph> has previously been called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph>가 이전에 호출된 지정된 개체에 대해 시스템에서 종료자를 호출하도록 요청합니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method adds the <ph id="ph2">`obj`</ph> parameter to the list of objects that request finalization before the garbage collector frees the object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> 메서드 추가 <ph id="ph2">`obj`</ph> 가비지 수집기에서 개체를 정리 하기 전에 종료 되어야 하는 개체의 목록에 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">`obj`</ph> parameter must be the caller of this method.</source>
          <target state="translated"><ph id="ph1">`obj`</ph> 매개 변수는이 메서드의 호출자에 게 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method does not guarantee that the garbage collector will call an object's finalizer.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> 메서드는 가비지 수집기가 개체의 종료자를 호출 합니다 보증 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.</source>
          <target state="translated">기본적으로 종료자를 구현 하는 모든 개체 종료; 해야 하는 개체의 목록에 추가 그러나 개체 이미 종료 되었을 수 있습니다 또는 받는 사람 호출 하 여 종료를 비활성화는 <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>A finalizer can use this method to resurrect itself or an object that it references.</source>
          <target state="translated">종료자 부활 자신 또는 참조 하는 개체를이 방법을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</source>
          <target state="translated">다음 예제에서는 표준 메서드를 사용 하 여 개체를 두 번째로 마무리 하 가비지 수집 후 시간이 있습니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The object whose finalizer must not be executed.</source>
          <target state="translated">종료자가 실행되지 않아야 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Requests that the common language runtime not call the finalizer for the specified object.</source>
          <target state="translated">공용 언어 런타임에서 지정된 개체에 대해 종료자를 호출하지 않도록 요청합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>This method sets a bit in the object header of <ph id="ph1">`obj`</ph>, which the runtime checks when calling finalizers.</source>
          <target state="translated">이 메서드는 개체의 헤더에 약간 설정 <ph id="ph1">`obj`</ph>, 런타임 종료자를 호출 하는 경우 체크 인 합니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>A finalizer, which is represented by the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method, is used to release unmanaged resources before an object is garbage-collected.</source>
          <target state="translated">으로 표시 된 종료자는 <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> 메서드, 개체는 가비지 수집 되기 전에 관리 되지 않는 리소스를 해제 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>If <ph id="ph1">`obj`</ph> does not have a finalizer, the call to the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method has no effect.</source>
          <target state="translated">경우 <ph id="ph1">`obj`</ph> 종료자에 대 한 호출에는 없습니다는 <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> 메서드는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Objects that implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface can call this method from the object's <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation to prevent the garbage collector from calling <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> on an object that does not require it.</source>
          <target state="translated">구현 하는 개체는 <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> 인터페이스에서 개체의이 메서드를 호출할 수 <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> 호출에서 가비지 수집기를 방지 하기 위해 구현 <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> 필요 하지 않은 개체에 있습니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">종료자에서 이미 해제 된 관리 되지 않는 리소스를 해제 하지 않도록 하려면이 작업을 수행 하는 일반적으로 <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> 구현 합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method in a resource class to prevent a redundant garbage collection from being called.</source>
          <target state="translated">다음 예제에서는 사용 하는 방법을 <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> 메서드를 호출 하지 못하도록 중복 가비지 수집 되지 않도록 하려면 리소스 클래스에에서 있습니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> to free both managed resources (that is, objects that implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) and unmanaged resources.</source>
          <target state="translated">이 예제에서는 사용 된 <bpt id="p1">[</bpt>삭제 패턴<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> 관리 되는 리소스를 모두 해제 (즉, 구현 하는 개체 <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) 관리 되지 않는 리소스 및 합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Attempts to disallow garbage collection during the execution of a critical path.</source>
          <target state="translated">중요한 경로를 실행하는 동안에는 가비지 컬렉션이 허용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">에 대 한 호출을 중첩 시킬 수 없습니다는 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드를 호출 해야 합니다.는 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드는 런타임에서 현재 비 GC 지역 대기 시간 모드 경우.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">즉, 호출 하면 안 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 여러 번 (첫 번째 메서드 호출 후 후속 호출은 성공 하지 것입니다), 호출을 기대할 수 없습니다 및 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 해 서 첫 번째 호출에 성공 하려면 <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 성공 합니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">가비지 수집을 트리거하지 않고 할당할 메모리 양(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">임시 세그먼트 크기보다 작거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">임시 세그먼트 크기에 대한 자세한 내용은 <bpt id="p1">[</bpt>가비지 컬렉션 기본 사항<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> 문서에서 "임시 세대 및 세그먼트" 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</source>
          <target state="translated">지정된 양의 메모리를 사용할 수 있는 경우 중요한 경로를 실행하는 동안에는 가비지 수집이 허용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">런타임이 필요한 메모리 양을 커밋할 수 있고 가비지 수집기를 비 GC 지역 대기 시간 모드에서 사용할 수 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> 메서드는 앱 코드의 중요 한 영역에서 실행 하는 동안 가비지 수집을 허용 하지 않는 비 GC 지역 대기 시간 모드에는 가비지 수집기를 배치 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">런타임에서 처음 요청된 된 양의 메모리를 할당할 수 없는 경우 가비지 수집기가 추가 메모리를 확보 하기 위해 전체 차단 가비지 수집을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> bytes (it attempts to allocate <ph id="ph2">`totalSize`</ph> bytes for the small object heap and <ph id="ph3">`totalSize`</ph> bytes for the large object heap).</source>
          <target state="translated">필요한 크기의 2 실제로이 경우에 메모리를 할당할 수는 가비지 수집기가 비 GC 지역 대기 시간 모드 * <ph id="ph1">`totalSize`</ph> 바이트 (할당을 시도 <ph id="ph2">`totalSize`</ph> 작은 개체 힙 바이트 및 <ph id="ph3">`totalSize`</ph> 대형 개체 힙 바이트)입니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> 중요 한 경로에서 발생 하는 모든 메모리 할당을 처리할 수 있을 만큼 크기가 커야 합니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">대신 응용 프로그램의 실행은 할당 뿐만 아니라 응용 프로그램에의 한 할당이 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">에 대 한 호출을 중첩 시킬 수 없습니다는 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드를 호출 해야 합니다.는 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드는 런타임에서 현재 비 GC 지역 대기 시간 모드 경우.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">즉, 호출 하면 안 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 여러 번 (첫 번째 메서드 호출 후 후속 호출은 성공 하지 것입니다), 호출을 기대할 수 없습니다 및 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 해 서 첫 번째 호출에 성공 하려면 <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 성공 합니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">호출 하 여 비 GC 지역 대기 시간 모드를 종료는 <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph>가 임시 세그먼트 크기를 초과합니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">프로세스가 이미 비 GC 지역 대기 시간 모드에 있습니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">가비지 수집을 트리거하지 않고 할당할 메모리 양(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">임시 세그먼트 크기보다 작거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">임시 세그먼트 크기에 대한 자세한 내용은 <bpt id="p1">[</bpt>가비지 컬렉션 기본 사항<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> 문서에서 "임시 세대 및 세그먼트" 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> bytes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">가비지 수집기가 처음에 <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> 바이트를 할당할 수 없는 경우 전체 차단 가비지 수집을 생략하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않은 경우 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">지정된 양의 메모리를 사용할 수 있는 경우 중요한 경로를 실행하는 동안 가비지 수집이 허용되지 않고, 초기에 사용할 수 있는 메모리가 충분하지 않은 경우 가비지 수집기가 전체 차단 가비지 수집 수행 여부를 제어합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">런타임이 필요한 메모리 양을 커밋할 수 있고 가비지 수집기를 비 GC 지역 대기 시간 모드에서 사용할 수 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> 메서드는 앱 코드의 중요 한 영역에서 실행 하는 동안 가비지 수집을 허용 하지 않는 비 GC 지역 대기 시간 모드에는 가비지 수집기를 배치 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">런타임에서 처음 요청된 된 양의 메모리를 할당할 수 없는 경우와 <ph id="ph1">`disallowFullBlockingGC`</ph> 인수가 <ph id="ph2">`false`</ph>, 가비지 수집기 추가 메모리를 확보 하기 위해 전체 차단 가비지 컬렉션 수행; 그렇지 않으면 할당이 실패 하 고 메서드가 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> (it attempts to allocate <ph id="ph2">`totalSize`</ph> for the small object heap and <ph id="ph3">`totalSize`</ph> for the large object heap).</source>
          <target state="translated">필요한 실제로 2에이 경우에 메모리 양을 할당할 수 없는 경우 가비지 수집기가 비 GC 지역 대기 시간 모드를 입력 * <ph id="ph1">`totalSize`</ph> (할당을 시도 <ph id="ph2">`totalSize`</ph> 작은 개체 힙 용 및 <ph id="ph3">`totalSize`</ph> 큰 개체 힙 용).</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> 중요 한 경로에서 발생 하는 모든 메모리 할당을 처리할 수 있을 만큼 크기가 커야 합니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">대신 응용 프로그램의 실행은 할당 뿐만 아니라 응용 프로그램에의 한 할당이 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">설정 <ph id="ph1">`disallowFullBlockingGC`</ph> 를 <ph id="ph2">`true`</ph> 처음 사용 가능한 메모리가 부족 한 경우 컬렉션에 대 한 전체 차단 가비지를 방지 하기 위해 부하 분산 시나리오에에서 가장 유용한은: 시스템으로 요청을 수락할 준비가 반환 하는 경우 자체 보고 메서드와이 메서드를 호출할 수 있습니다 <ph id="ph3">`true`</ph>를 반환 하는 경우 다른 시스템에 요청을 리디렉션하는 부하 분산 장치가 있어야 하 고 <ph id="ph4">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">호출 하 여 요청을 처리 하지 않는 경우에 다음 전체 차단 가비지 수집을 수행할 수 있는 것은 <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">에 대 한 호출을 중첩 시킬 수 없습니다는 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드를 호출 해야 합니다.는 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드는 런타임에서 현재 비 GC 지역 대기 시간 모드 경우.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">즉, 호출 하면 안 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 여러 번 (첫 번째 메서드 호출 후 후속 호출은 성공 하지 것입니다), 호출을 기대할 수 없습니다 및 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 해 서 첫 번째 호출에 성공 하려면 <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 성공 합니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">호출 하 여 비 GC 지역 대기 시간 모드를 종료는 <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph>가 임시 세그먼트 크기를 초과합니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">프로세스가 이미 비 GC 지역 대기 시간 모드에 있습니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">가비지 수집을 트리거하지 않고 할당할 메모리 양(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept>는 임시 세그먼트 크기보다 작거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">임시 세그먼트 크기에 대한 자세한 내용은 <bpt id="p1">[</bpt>가비지 컬렉션 기본 사항<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> 문서에서 "임시 세대 및 세그먼트" 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated">큰 개체 힙(LOH) 할당용으로 사용하는 <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept>의 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</source>
          <target state="translated">큰 개체 힙 및 작은 개체 힙에 지정된 양의 메모리를 사용할 수 있는 경우 중요한 경로를 실행하는 동안에는 가비지 수집이 허용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">런타임이 필요한 메모리 양을 커밋할 수 있고 가비지 수집기를 비 GC 지역 대기 시간 모드에서 사용할 수 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> 메서드는 앱 코드의 중요 한 영역에서 실행 하는 동안 가비지 수집을 허용 하지 않는 비 GC 지역 대기 시간 모드에는 가비지 수집기를 배치 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">런타임에서 처음 요청된 된 양의 메모리를 할당할 수 없는 경우 가비지 수집기가 추가 메모리를 확보 하기 위해 전체 차단 가비지 수집을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">가비지 수집기가 비 GC 지역 대기 시간 모드를 할당할 수는 <ph id="ph1">`lohSize`</ph> LOH에 대 한 및 <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> 작은 개체 힙 (SOH)에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> LOH에 대 한 중요 한 경로에서 발생 하는 모든 메모리 할당을 처리할 수 있을 만큼 크기가 커야 하 고 <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> SOH에 대 한 중요 한 경로에서 발생 하는 모든 메모리 할당을 처리할 수 있을 만큼 크기가 커야 합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">대신 응용 프로그램의 실행은 할당 뿐만 아니라 응용 프로그램에의 한 할당이 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">에 대 한 호출을 중첩 시킬 수 없습니다는 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드를 호출 해야 합니다.는 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드는 런타임에서 현재 비 GC 지역 대기 시간 모드 경우.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">즉, 호출 하면 안 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 여러 번 (첫 번째 메서드 호출 후 후속 호출은 성공 하지 것입니다), 호출을 기대할 수 없습니다 및 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 해 서 첫 번째 호출에 성공 하려면 <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 성공 합니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">호출 하 여 비 GC 지역 대기 시간 모드를 종료는 <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph>가 임시 세그먼트 크기를 초과합니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">프로세스가 이미 비 GC 지역 대기 시간 모드에 있습니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">가비지 수집을 트리거하지 않고 할당할 메모리 양(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> – <bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept>는 임시 세그먼트 크기보다 작거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segement, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">임시 세그먼트 크기에 대한 자세한 내용은 <bpt id="p1">[</bpt>가비지 컬렉션 기본 사항<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> 문서에서 "임시 세대 및 세그먼트" 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated">큰 개체 힙(LOH) 할당용으로 사용하는 <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept>의 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">가비지 수집기가 처음에 작은 개체 힙(SOH) 및 LOH에서 지정된 메모리를 할당할 수 없는 경우 전체 차단 가비지 수집을 생략하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않은 경우 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">큰 개체 힙 및 작은 개체 힙에 지정된 양의 메모리를 사용할 수 있는 경우 중요한 경로를 실행하는 동안 가비지 수집이 허용되지 않고, 초기에 사용할 수 있는 메모리가 충분하지 않은 경우 가비지 수집기가 전체 차단 가비지 수집 수행 여부를 제어합니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">런타임이 필요한 메모리 양을 커밋할 수 있고 가비지 수집기를 비 GC 지역 대기 시간 모드에서 사용할 수 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> 메서드는 앱 코드의 중요 한 영역에서 실행 하는 동안 가비지 수집을 허용 하지 않는 비 GC 지역 대기 시간 모드에는 가비지 수집기를 배치 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">런타임에서 처음 요청된 된 양의 메모리를 할당할 수 없는 경우와 <ph id="ph1">`disallowFullBlockingGC`</ph> 인수가 <ph id="ph2">`false`</ph>, 가비지 수집기 추가 메모리를 확보 하기 위해 전체 차단 가비지 컬렉션 수행; 그렇지 않으면 할당이 실패 하 고 메서드가 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">가비지 수집기가 비 GC 지역 대기 시간 모드를 할당할 수는 <ph id="ph1">`lohSize`</ph> LOH에 대 한 및 <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> 작은 개체 힙 (SOH)에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> LOH에 대 한 중요 한 경로에서 발생 하는 모든 메모리 할당을 처리할 수 있을 만큼 크기가 커야 하 고 <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> SOH에 대 한 중요 한 경로에서 발생 하는 모든 메모리 할당을 처리할 수 있을 만큼 크기가 커야 합니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">대신 응용 프로그램의 실행은 할당 뿐만 아니라 응용 프로그램에의 한 할당이 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">설정 <ph id="ph1">`disallowFullBlockingGC`</ph> 를 <ph id="ph2">`true`</ph> 처음 사용 가능한 메모리가 부족 한 경우 컬렉션에 대 한 전체 차단 가비지를 방지 하기 위해 부하 분산 시나리오에에서 가장 유용한은: 시스템으로 요청을 수락할 준비가 반환 하는 경우 자체 보고 메서드와이 메서드를 호출할 수 있습니다 <ph id="ph3">`true`</ph>를 반환 하는 경우 다른 시스템에 요청을 리디렉션하는 부하 분산 장치가 있어야 하 고 <ph id="ph4">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">호출 하 여 요청을 처리 하지 않는 경우에 다음 전체 차단 가비지 수집을 수행할 수 있는 것은 <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">에 대 한 호출을 중첩 시킬 수 없습니다는 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 메서드를 호출 해야 합니다.는 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드는 런타임에서 현재 비 GC 지역 대기 시간 모드 경우.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">즉, 호출 하면 안 <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 여러 번 (첫 번째 메서드 호출 후 후속 호출은 성공 하지 것입니다), 호출을 기대할 수 없습니다 및 <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 해 서 첫 번째 호출에 성공 하려면 <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> 성공 합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">호출 하 여 비 GC 지역 대기 시간 모드를 종료는 <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph>가 임시 세그먼트 크기를 초과합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">프로세스가 이미 비 GC 지역 대기 시간 모드에 있습니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">공용 언어 런타임에 의한 전체 차단 가비지 컬렉션이 임박하고 있는지 여부를 확인하기 위한 등록된 알림의 상태를 반환합니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">공용 언어 런타임에 의한 전체 차단 가비지 컬렉션이 임박하고 있는지 여부를 확인하기 위한 등록된 알림의 상태를 반환합니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">등록된 가비지 컬렉션 알림의 상태입니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> 열거형을 사용 하 여 등록 된 현재 가비지 컬렉션 알림의 상태를 확인 하려면이 메서드에서 반환 되는 <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">사용할 수도 있습니다는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> 전체 가비지 컬렉션이 완료 되었는지 여부를 확인 하는 메서드.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">열거형 반환 하는 경우 <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, 다른 추가 개체에서 할당 되 고와 직접 컬렉션을 실행 하는 등 작업을 수행할 수 있습니다는 <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">Note 알림을 전체 가비지 수집이 발생 하는지, 조건에는 전체 가비지 수집을 편리 하 게 구성 된 임계값에 도달 했습니다 하을 보장 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">이 메서드를 가져올 가비지 컬렉션 알림이 무기한 대기 합니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">알림을 가져올 수 없는 경우 반환할 메서드에 대 한 제한 시간을 지정 하려는 경우 사용 하 여는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">제한 시간을 지정 하지 않고이 메서드를 호출 하는 경우 호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> 메서드 기본 설정 보다 오래 대기 중인 경우.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">이 메서드를 호출 하 여 따라야는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> 메서드를 전체 가비지 컬렉션이 완료 되었는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">확정 되지 않은 결과 하면이 메서드만 호출 합니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</source>
          <target state="translated">다음 예제에서는 한 전체 차단 가비지 수집이 임박 있는지 여부를 확인 하려면이 메서드를 사용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCApproachNotify`</ph> is called to perform actions in response to the approaching collection.</source>
          <target state="translated">알림의 상태 될 때마다 <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, 사용자 지정 메서드 <ph id="ph2">`OnFullGCApproachNotify`</ph> 근접 컬렉션에 대 한 응답으로 작업을 수행 하기 위해 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부 <bpt id="p1">[</bpt>가비지 수집 알림<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰 합니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">알림 상태를 가져올 때까지 기다릴 시간의 길이입니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">무한정 기다리려면 -1을 지정합니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">공용 언어 런타임에 의한 전체 차단 가비지 컬렉션이 임박하고 있는지 여부를 확인하기 위한 등록된 알림의 상태를 지정된 제한 시간 내에 반환합니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">등록된 가비지 컬렉션 알림의 상태입니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> 열거형을 사용 하 여 등록 된 현재 가비지 컬렉션 알림의 상태를 확인 하려면이 메서드에서 반환 되는 <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">사용할 수도 있습니다는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> 전체 가비지 컬렉션이 완료 되었는지 여부를 확인 하는 메서드.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">이 메서드가 반환 될 때마다 가비지 수집 알림 상태를 얻은 지정 된 값에 관계 없이 즉시 <ph id="ph1">`millisecondsTimeout`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">가비지 수집 알림 상태 하기 전에 가져오지 경우 <ph id="ph1">`millisecondsTimeout`</ph> 시간 초과,이 메서드가 반환 <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">열거형 반환 하는 경우 <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, 다른 추가 개체에서 할당 되 고와 직접 컬렉션을 실행 하는 등 작업을 수행할 수 있습니다는 <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">Note 알림을 전체 가비지 수집이 발생 하는지, 조건에는 전체 가비지 수집을 편리 하 게 구성 된 임계값에 도달 했습니다 하을 보장 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> 메서드에 시간 제한 기간이 경과할 때까지 기다리는 수 없습니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">이 메서드를 호출 하 여 따라야는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> 메서드를 전체 가비지 컬렉션이 완료 되었는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">확정 되지 않은 결과 하면이 메서드만 호출 합니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>는 음수가 아니거나 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 또는 -1보다 작거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰 합니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">공용 언어 런타임에 의한 전체 차단 가비지 컬렉션이 완료되었는지 여부를 확인하기 위한 등록된 알림의 상태를 반환합니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">공용 언어 런타임에 의한 전체 차단 가비지 컬렉션이 완료되었는지 여부를 확인하기 위한 등록된 알림의 상태를 반환합니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">등록된 가비지 컬렉션 알림의 상태입니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> 열거형을 사용 하 여 등록 된 현재 가비지 컬렉션 알림의 상태를 확인 하려면이 메서드에서 반환 되는 <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">사용할 수도 있습니다는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> 메서드는 전체 가비지 컬렉션이 임박 인지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">열거형이 반환 될 때 <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, 작업을 다시 시작 된 컬렉션 수를 얻는 등의 작업을 수행할 수 있습니다는 <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">이 메서드를 가져올 가비지 컬렉션 알림이 무기한 대기 합니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">알림을 가져올 수 없는 경우 반환할 메서드에 대 한 제한 시간을 지정 하려는 경우 사용 하 여는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">제한 시간을 지정 하지 않고이 메서드를 호출 하는 경우 호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> 메서드 기본 설정 보다 오래 대기 중인 경우.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">이 메서드 호출을 호출 하 여 앞에 있어야는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> 메서드를 전체 가비지 컬렉션이 완료 되었는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">이 메서드만 호출 확정 되지 않은 결과 생성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>The following example shows how to use this method to determine whether a full garbage collection has completed.</source>
          <target state="translated">다음 예에서는 전체 가비지 컬렉션이 완료 되었는지 여부를 확인 하려면이 메서드를 사용 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCCompletedNotify`</ph> is called to perform actions in response to the completed collection.</source>
          <target state="translated">알림의 상태 될 때마다 <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, 사용자 지정 메서드 <ph id="ph2">`OnFullGCCompletedNotify`</ph> 완료 된 컬렉션에 대 한 응답으로 작업을 수행 하기 위해 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부 <bpt id="p1">[</bpt>가비지 수집 알림<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> 항목입니다.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰 합니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">알림 상태를 가져올 때까지 기다릴 시간의 길이입니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">무한정 기다리려면 -1을 지정합니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</source>
          <target state="translated">공용 언어 런타임에 의한 전체 차단 가비지 컬렉션이 완료되었는지 여부를 확인하기 위한 등록된 알림의 상태를 지정된 제한 시간 내에 반환합니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">등록된 가비지 컬렉션 알림의 상태입니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> 열거형을 사용 하 여 등록 된 현재 가비지 컬렉션 알림의 상태를 확인 하려면이 메서드에서 반환 되는 <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">사용할 수도 있습니다는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> 메서드는 전체 가비지 컬렉션이 임박 인지 여부를 확인 합니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">이 메서드가 반환 될 때마다 가비지 수집 알림 상태를 얻은 지정 된 값에 관계 없이 즉시 <ph id="ph1">`millisecondsTimeout`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">가비지 수집 알림 상태 하기 전에 가져오지 경우 <ph id="ph1">`millisecondsTimeout`</ph> 시간 초과,이 메서드가 반환 <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">열거형이 반환 될 때 <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, 작업을 다시 시작 된 컬렉션 수를 얻는 등의 작업을 수행할 수 있습니다는 <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">호출할 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> 메서드에 시간 제한 기간이 경과할 때까지 기다리는 수 없습니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">이 메서드 호출을 호출 하 여 앞에 있어야는 <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> 메서드를 전체 가비지 컬렉션이 완료 되었는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">이 메서드만 호출 확정 되지 않은 결과 생성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph>는 음수가 아니거나 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 또는 -1보다 작거나 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰 합니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForPendingFinalizers">
          <source>Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</source>
          <target state="translated">종료자의 큐를 처리하는 스레드에서 해당 큐를 비울 때까지 현재 스레드를 일시 중단합니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</source>
          <target state="translated">가비지 수집기를 다시 사용할 수 있는 개체를 찾으면 개체의 종료 요청을 확인 하려면 각 개체를 검사 합니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>If an object implements a finalizer and has not disabled finalization by calling <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, the object is placed in a list of objects that are marked as ready for finalization.</source>
          <target state="translated">개체 종료자를 구현 하 고 종료를 호출 하 여 비활성화 되지 않은 경우 <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, 개체 종료 준비가 된 것으로 표시 된 개체의 목록에 배치 됩니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The garbage collector calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods for the objects in this list and removes the entries from the list.</source>
          <target state="translated">가비지 컬렉션이 <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 목록에서 항목을 제거 하 고이 목록에 있는 개체에 대 한 메서드.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>This method blocks until all finalizers have run to completion.</source>
          <target state="translated">모든 종료자 될 때까지이 메서드 차단 완료 될 때까지 실행 합니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</source>
          <target state="translated">종료 자가 실행 스레드를 지정 하지 않으므로이 메서드가 종료 되지는입니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>However, this thread can be interrupted by another thread while the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method is in progress.</source>
          <target state="translated">그러나 하는 동안 다른 스레드가이 스레드를 중단 될 수 있습니다는 <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> 메서드 진행 중입니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</source>
          <target state="translated">예를 들어 일정 시간 동안 대기 하 고이 스레드는 여전히 일시 중단 하는 경우 다음이 스레드를 중단 하는 다른 스레드를 시작할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method to suspend the current thread until finalization of all the collected objects is complete.</source>
          <target state="translated">다음 예제에서는 사용 하는 방법을 <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> 메서드 수집 된 모든 개체의 종료가 완료 될 때까지 현재 스레드를 일시 중단 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>