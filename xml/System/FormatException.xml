<Type Name="FormatException" FullName="System.FormatException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="041fd4b21ce035beb017a4f1a02285a70f983f8c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30729247" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FormatException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FormatException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.FormatException" />
  <TypeSignature Language="VB.NET" Value="Public Class FormatException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class FormatException : SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>인수의 형식이 올바르지 않거나 [합성 서식 문자열](~/docs/standard/base-types/composite-formatting.md)이 잘못 만들어진 경우 예외가 throw됩니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.FormatException> 다음 이유 중 하나에 대 한 예외를 throw 합니다.  
  
-   문자열을 다른 데이터 형식을 변환 하는 메서드 호출에서 문자열 필수 패턴에 맞지 않습니다. 일부 메서드를 호출할 때 일반적으로 발생는 <xref:System.Convert> 클래스 및 `Parse` 및 `ParseExact` 일부 형식의 메서드.  
  
     대부분의 경우에서 변환 하는 문자열을 파일에서 읽거나 사용자가 입력 하는 경우에 특히 사용할지는 `try/catch` 차단 하 고 처리는 <xref:System.FormatException> 변환이 실패 한 경우 예외입니다. 호출 하 여 변환 메서드를 호출을 바꿀 수도 있습니다는 `TryParse` 또는 `TryParseExact` 메서드를 사용할 수 있는 경우. 그러나 한 <xref:System.FormatException> 미리 정의 된 또는 하드 코드 된 문자열을 구문 분석 하려고 하는 경우 throw 되는 예외는 프로그램 오류를 나타냅니다. 이 경우 오류를 수정 대신 해야 예외를 처리 합니다.  
  
     문자열로 변환 하는 같은 형식에는 <xref:System> 네임 스페이스를 throw 할 수는 <xref:System.FormatException> 예외:  
  
    -   <xref:System.Boolean>. <xref:System.Boolean.Parse%28System.String%29?displayProperty=nameWithType> 및 <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> 방법에는 "True"를 "true" 되도록 변환 될 문자열, "False" 또는 "false" 필요 합니다. 다른 모든 값을 throw 한 <xref:System.FormatException> 예외입니다.  
  
    -   <xref:System.DateTime>와 <xref:System.DateTimeOffset>을 참조하세요. 모든 날짜 및 시간 데이터는 특정 문화권의 서식 지정 규칙에 따라 해석 됩니다: 현재 스레드 문화권 (또는 경우에 따라 현재 응용 프로그램 도메인 문화권), 고정 문화권 또는 지정 된 문화권. 호출 하는 경우는 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> 및 <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> 메서드, 날짜 및 시간 데이터 또한 준수 해야 *정확히* 하나 이상의 지정 된 패턴을 [표준 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 또는 [사용자 지정 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md) 메서드 호출에서 인수로 제공 되는 합니다. 예상 되는 culture 관련 패턴을 준수 하지 않는 경우는 <xref:System.FormatException> 예외가 throw 됩니다. 이 시스템에서 문화권별 형식으로 저장 하는 날짜 및 시간 데이터 수 구문 분석할 성공적으로 다른 시스템에서 의미 합니다.  
  
         날짜 및 시간 구문 분석 하는 방법에 대 한 자세한 내용은 참조 [구문 분석 하는 날짜 및 시간 문자열](~/docs/standard/base-types/parsing-datetime.md) 및 예외를 발생 시킨 메서드에 대 한 설명서입니다.  
  
    -   **GUIDs.** GUID의 문자열 표현을 32 자리 16 진수 (0-F)로 구성 되어야 하며 여 출력 되는 다섯 가지 형식 중 하나에 있어야는 <xref:System.Guid.ToString%2A?displayProperty=nameWithType> 메서드. 자세한 내용은 <xref:System.Guid.Parse%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
    -   **모든 부호 있는 정수, 부호 없는 정수 및 부동 소수점 형식을 비롯 한 숫자 형식입니다.** 구문 분석할 문자열 라틴어 숫자 0-9 구성 되어야 합니다. 양수 또는 음수 기호, 소수 구분 기호, 그룹 구분 기호 및 통화 기호 허용 될 수 있습니다. 문자를 다른를 포함 하는 문자열을 구문 분석 하 항상 throw 한 <xref:System.FormatException> 예외입니다.  
  
         모든 숫자 문자열을 특정 문화권의 서식 지정 규칙에 따라 해석 됩니다: 현재 스레드 문화권 (또는 경우에 따라 현재 응용 프로그램 도메인 문화권), 고정 문화권 또는 지정 된 문화권입니다. 결과적으로, 하나의 문화권의 규칙을 사용 하 여 구문 분석 되는 숫자 문자열의 다른 규칙을 사용 하는 경우 실패할 수 있습니다.  
  
         숫자 문자열 구문 분석 하는 방법에 대 한 자세한 내용은 참조 [숫자 문자열 구문 분석](~/docs/standard/base-types/parsing-numeric.md) 및 예외를 발생 시킨 특정 메서드에 대 한 설명서입니다.  
  
    -   **시간 간격입니다.** 고정 문화권을 구분 하지 않는 형식에서 또는 현재 스레드 문화권에 의해 (또는 경우에 따라 현재 응용 프로그램 도메인 문화권), 정의 된 문화권 구분 형식에서 문자열을 구문 분석할 수 여야 고정 문화권 또는 지정 된 문화권입니다. 문자열이 한 적절 한 형식이 나 최소, 일, 시간, if를에 없는 시간 간격의 분 구성 요소를 사용할 수 없는 경우 구문 분석 방법 throw 한 <xref:System.FormatException> 예외입니다. 자세한 내용은 참조에 대 한 설명서는 <xref:System.TimeSpan> 예외를 발생 시킨 메서드 구문 분석 합니다.  
  
-   형식이 구현 하는 <xref:System.IFormattable> 인터페이스를 지 원하는 개체를 문자열 표현으로 변환 되는 방법을 정의 하는 형식 문자열 및 잘못 된 형식 문자열에 사용 됩니다. 서식 지정 작업에서 가장 일반적입니다. 다음 예제에서는 "Q" 표준 형식 문자열은 숫자의 서식을 지정 하려면 복합 형식 문자열에 사용 됩니다. 그러나 "Q" 유효 하지 않거나 [표준 형식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md)합니다.  
  
     [!code-csharp[System.FormatException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable1.cs#7)]
     [!code-vb[System.FormatException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable1.vb#7)]  
  
     이 예외는 코딩 오류를 발생합니다. 이 오류를 해결 하려면 형식 문자열을 제거 하거나 올바른 대체 합니다. 다음 예제에서는 잘못 된 형식 문자열 "C" (currency) 형식 문자열 대체 하 여 오류를 해결 합니다.  
  
     [!code-csharp[System.FormatException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable2.cs#8)]
     [!code-vb[System.FormatException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable2.vb#8)]  
  
     A <xref:System.FormatException> 와 같은 메서드를 구문 분석 하 여 예외가 throw 될 수 있습니다 <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> 및 <xref:System.Guid.ParseExact%2A?displayProperty=nameWithType>, 문자열을 형식 문자열에 지정 된 패턴을 정확 하 게 따르는으로 구문 분석 해야 하는 합니다. 다음 예제에서는 "G" 표준 형식 문자열에 지정 된 패턴을 따르는 GUID의 문자열 표현을 예정입니다. 그러나는 <xref:System.Guid> 구조체의 구현의 <xref:System.IFormattable> "G" 형식 문자열을 지원 하지 않습니다.  
  
     [!code-csharp[System.FormatException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable3.cs#9)]
     [!code-vb[System.FormatException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable3.vb#9)]  
  
     이 예외는 또한 코딩 오류를 발생합니다. 이 문제를 해결 하려면 같은 정확한 형식으로 필요 하지 않은 구문 분석 메서드를 호출 <xref:System.DateTime.Parse%2A?displayProperty=nameWithType> 또는 <xref:System.Guid.Parse%2A?displayProperty=nameWithType>, 하거나 유효한 형식 문자열을 대체 합니다. 다음 예제에서는 호출 하 여 오류를 수정한는 <xref:System.Guid.Parse%2A?displayProperty=nameWithType> 메서드.  
  
     [!code-csharp[System.FormatException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable4.cs#10)]
     [!code-vb[System.FormatException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable4.vb#10)]  
  
-   하나 이상의의 형식 항목의 인덱스는 [합성 형식 문자열](~/docs/standard/base-types/composite-formatting.md) 개체 목록 또는 매개 변수 배열에 있는 항목의 인덱스 보다 큽니다. 다음 예제에서는 서식 문자열의 형식 항목의 가장 큰 인덱스는 3입니다. 개체 목록에 있는 항목의 인덱스가 0부터 시작 하기 때문에이 형식 문자열에는 4 개의 항목이 있어야 개체 목록이 필요 합니다. 대신,이 세 번만 `dat`, `temp`, 및 `scale`는 코드에서 발생 하므로 <xref:System.FormatException> 런타임 시 예외: 합니다.  
  
     [!code-csharp[System.FormatException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example1.cs#1)]
     [!code-vb[System.FormatException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example1.vb#1)]  
  
     이 경우에 <xref:System.FormatException> 예외 개발자 오류의 결과입니다. 이 수정 되지 않고 됩니다에서 처리 한 `try/catch` 개체 목록에서 각 항목 형식 항목의 인덱스에 해당 하는지 확인 하 여 블록입니다. 이 예제를 해결 하려면 참조 하는 두 번째 형식 항목의 인덱스를 변경는 `dat` 변수와 감소 씩 각 후속 형식 항목의 인덱스입니다.  
  
     [!code-csharp[System.FormatException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example2.cs#2)]
     [!code-vb[System.FormatException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example2.vb#2)]  
  
-   합성 형식 문자열 형식이 아닙니다. 이런 경우는 <xref:System.FormatException> 예외는 항상 개발자 오류의 결과입니다. 이 수정 되지 않고 됩니다에서 처리 한 `try/catch` 블록입니다.  
  
     다음 예제에서는 않습니다, 예외를 throw 하는 대로 문자열에 리터럴 중괄호를 포함 하려고 합니다.  
  
     [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
     [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
     복합 형식 문자열에 리터럴 중괄호를 포함 하는 데 권장 되는 방법 개체 목록에 포함할 형식 항목을 사용 하 여 결과 문자열에 삽입 하는 것입니다. 예를 들어 다음과 같이 이전 합성 형식 문자열을 수정할 수 있습니다.  
  
     [!code-csharp[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
     [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
     형식 문자열을 보시 겠어요 포함 되어 있는 경우에 예외가 throw 됩니다. 다음에 대 한 호출에서 <xref:System.String.Format%2A?displayProperty=nameWithType> 메서드 닫는 중괄호를 생략 하 고 여는 중괄호와 닫는 대괄호 쌍입니다.  
  
     [!code-csharp[System.FormatException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example3.cs#3)]
     [!code-vb[System.FormatException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example3.vb#3)]  
  
     이 오류를 해결 하려면 모든 중괄호와 닫는 중괄호 맞는지 확인 하십시오.  
  
     [!code-csharp[System.FormatException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example3.cs#4)]
     [!code-vb[System.FormatException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example3.vb#4)]  
  
-   개체 목록에 있는 합성 서식 지정 메서드에 강력한 형식의 매개 변수 배열로 제공한 및 <xref:System.FormatException> 예외 하나 이상의 형식 항목의 인덱스 개체 목록에서 인수 수를 초과 했음을 나타내는 합니다. 대신 컴파일러가 매개 변수 배열이 아니라 단일 인수도 배열 처리 배열 형식 간의 명시적 변환이 존재 하기 때문에 발생 합니다. 다음을 호출 하는 예를 들어는 <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 메서드가 throw는 <xref:System.FormatException> 예외를 형식 항목의 가장 높은 인덱스는 3 및 형식의 매개 변수 배열을 <xref:System.Int32> 에 4 개의 요소가 있습니다.  
  
     [!code-csharp[System.FormatException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/qa1.cs#5)]
     [!code-vb[System.FormatException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/qa1.vb#5)]  
  
     이 예외를 처리 하는 대신 해당 원인을 제거 해야 합니다. Visual Basic 또는 C# 아닙니다 개체 배열에 정수 배열로 변환할 수, 합성 서식 지정 메서드가 호출 하기 전에 사용자가 직접 변환을 수행 해야 합니다. 다음 예제에는 하나의 구현을 제공합니다.  
  
     [!code-csharp[System.FormatException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/qa2.cs#6)]
     [!code-vb[System.FormatException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/qa2.vb#6)]  
  
 <xref:System.FormatException> 0x80131537 값이 있는 HRESULT COR_E_FORMAT를 사용 합니다.  
  
 <xref:System.FormatException> 클래스에서 파생 <xref:System.Exception> 고유한 멤버가 추가 합니다. 인스턴스에 대 한 초기 속성 값 목록은 <xref:System.FormatException>, 참조는 <xref:System.FormatException.%23ctor%2A> 생성자입니다.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.FormatException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormatException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormatException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.FormatException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Exception.Message%2A> "형식이 잘못 되었습니다." 오류를 설명 하는 시스템 제공 메시지로 새 인스턴스의 속성 이 메시지는 현재 시스템 문화권을 고려합니다.  
  
 다음 표에서는 <xref:System.FormatException> 인스턴스의 초기 속성 값을 보여 줍니다.  
  
|속성|값|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 참조(Visual Basic의 경우 `Nothing`)|  
|<xref:System.Exception.Message%2A>|지역화된 오류 메시지 문자열입니다.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormatException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormatException(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">@FSHO2@오류를 설명하는 메시지입니다.</param>
        <summary>지정된 오류 메시지를 사용하여 <see cref="T:System.FormatException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Exception.Message%2A?displayProperty=nameWithType> 속성을 사용 하 여 새 예외는 `message` 매개 변수입니다. `message`의 내용은 사용자의 이해를 돕기 위한 것입니다. 이 생성자의 호출자는 이 문자열이 현재 시스템 문화권에 맞게 지역화되었는지 확인하는 데 필요합니다.  
  
 다음 표에서는 <xref:System.FormatException> 인스턴스의 초기 속성 값을 보여 줍니다.  
  
|속성|값|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 참조(Visual Basic의 경우 `Nothing`)|  
|<xref:System.Exception.Message%2A>|오류 메시지 문자열|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected FormatException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; FormatException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">serialize된 개체 데이터를 보유하는 개체입니다.</param>
        <param name="context">원본 또는 대상에 대한 컨텍스트 정보입니다.</param>
        <summary>serialize된 데이터를 사용하여 <see cref="T:System.FormatException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 deserialization을 수행하는 동안 호출되어 스트림을 통해 전송된 예외 개체를 다시 구성합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormatException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormatException(System::String ^ message, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">@FSHO2@예외 이유를 설명하는 오류 메시지입니다.</param>
        <param name="innerException">현재 예외의 원인인 예외입니다. <c>innerException</c> 매개 변수가 null 참조(Visual Basic에서는 <see langword="Nothing" />)가 아니면, 현재 예외는 내부 예외를 처리하는 <see langword="catch" /> 블록에서 발생한 것입니다.</param>
        <summary>지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <see cref="T:System.FormatException" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이전 예외의 직접적인 결과로 throw되는 예외의 <xref:System.Exception.InnerException%2A> 속성에는 이전 예외에 대한 참조가 들어 있어야 합니다. <xref:System.Exception.InnerException%2A> 속성은 생성자에 전달된 값과 같은 값을 반환하거나 `Nothing` 속성이 생성자에 내부 예외 값을 제공하지 않는 경우에는 null 참조(Visual Basic의 경우 <xref:System.Exception.InnerException%2A>)를 반환합니다.  
  
 다음 표에서는 <xref:System.FormatException> 인스턴스의 초기 속성 값을 보여 줍니다.  
  
|속성|값|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|내부 예외 참조|  
|<xref:System.Exception.Message%2A>|오류 메시지 문자열|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
  </Members>
</Type>