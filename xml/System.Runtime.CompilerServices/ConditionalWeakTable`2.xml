<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ConditionalWeakTable`2.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac575a1ca0bc007b584e93073f8cc318bd920092d8d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">75a1ca0bc007b584e93073f8cc318bd920092d8d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The reference type to which the field is attached.</source>
          <target state="translated">필드가 연결된 참조 형식입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The field's type.</source>
          <target state="translated">필드의 형식입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>This must be a reference type.</source>
          <target state="translated">참조 형식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Enables compilers to dynamically attach object fields to managed objects.</source>
          <target state="translated">컴파일러에서 관리되는 개체에 개체 필드를 동적으로 연결할 수 있도록 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class enables language compilers to attach arbitrary properties to managed objects at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 클래스를 사용 하면 언어 컴파일러에서 런타임 시 임의의 속성 관리 되는 개체에 연결 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 개체는 키로 표현 되는 관리 되는 개체를 값으로 표현 되는 연결 된 속성을 바인딩하는 사전입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The object's keys are the individual instances of the <ph id="ph1">`TKey`</ph> class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</source>
          <target state="translated">개체의 키가의 개별 인스턴스는 <ph id="ph1">`TKey`</ph> 클래스 속성이 연결 된 값은 해당 개체에 할당 된 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Keys must be unique; in other words, the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class supports one attached value per managed object.</source>
          <target state="translated">키는 고유 해야 합니다. 즉,는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 클래스는 관리 되는 개체당 하나의 연결 된 값을 지원 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Two keys are equal if passing them to the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">두 키가 같은지를 전달 하는 경우는 <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드 반환 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>You cannot control equality comparisons by overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> to explicitly set the hash code for a key.</source>
          <target state="translated">재정의 하 여 같음 비교를 제어할 수는 없습니다 <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 를 명시적으로 키에 대 한 해시 코드를 설정 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class does not use the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method to compute hash codes, and therefore does not invoke <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> overrides.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 클래스에서 사용 하지는 <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 계산할 해시 코드를 메서드와 따라서 호출 하지 않습니다 <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 재정의 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</source>
          <target state="translated">하지만 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 키/값 쌍의 컬렉션을 포함 하는 클래스, 것은 가장으로 간주 하는 사전 개체 보다는 테이블입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class differs from a dictionary in several ways:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 여러 가지 방법으로 사전에서와 다른 클래스:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It does not persist keys.</source>
          <target state="translated">키를 유지 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>That is, a key is not kept alive only because it is a member of the collection.</source>
          <target state="translated">즉, 키를 유지 되지 않는 컬렉션의 멤버 이기 때문입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It does not include all the methods (such as <ph id="ph1">`GetEnumerator`</ph> or <ph id="ph2">`Contains`</ph>) that a dictionary typically has.</source>
          <target state="translated">모든 메서드는 포함 되지 않습니다 (예: <ph id="ph1">`GetEnumerator`</ph> 또는 <ph id="ph2">`Contains`</ph>) 사전은 일반적으로 포함 하는 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It does not implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> interface.</source>
          <target state="translated">구현 하지 않습니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 클래스 컬렉션에 저장 된 키의 개체 수명 관리에 있는 다른 컬렉션 개체에서 달라 집니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</source>
          <target state="translated">일반적으로 개체 컬렉션으로 저장 된 경우 그 수명은 제거 됩니다 (및 개체에 추가 참조가 없는) 때까지 또는 컬렉션 개체 자체에서 제거 될 때까지 지속 됩니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>However, in the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</source>
          <target state="translated">그러나는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블에 키/값 쌍을 보장 하지는 키 유지 (예: 테이블에 있는 경우 한 개의 키, A, v 1 값이 있는 테이블에 저장 된 값에서 직접 액세스 될 수 있게 하는 경우에 추가 클래스 및 P2 A에 대 한 참조를 포함 하는 값을 사용 하 여 두 번째 키, B).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Instead, <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</source>
          <target state="translated">대신, <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 키에 다른 참조가 없는 테이블 밖으로 키/값 항목을 자동으로 제거 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The example provides an illustration.</source>
          <target state="translated">예제에서는 그림을 제공합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The following example illustrates that a key stored in the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table does not persist after references to it outside the table are destroyed.</source>
          <target state="translated">다음 예제에서는 키에 저장 되는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블 외부 참조를 삭제 한 후에 테이블 유지 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The example defines two classes: <ph id="ph1">`ManagedClass`</ph>, which represents the key in the table, and <ph id="ph2">`ClassData`</ph>, which represents the key's value.</source>
          <target state="translated">이 예제에서는 두 개의 클래스를 정의: <ph id="ph1">`ManagedClass`</ph>는 테이블의 키를 나타내는 및 <ph id="ph2">`ClassData`</ph>, 키의 값을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The example instantiates three objects of each type.</source>
          <target state="translated">이 예제에서는 각 유형의 세 가지 개체를 인스턴스화합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It also instantiates a <ph id="ph1">&lt;xref:System.WeakReference&gt;</ph> object that represents the second <ph id="ph2">`ManagedClass`</ph>, and then destroys the second <ph id="ph3">`ManagedClass`</ph> instance.</source>
          <target state="translated">또한 인스턴스화하는 <ph id="ph1">&lt;xref:System.WeakReference&gt;</ph> 나타내는 두 번째 개체입니다 <ph id="ph2">`ManagedClass`</ph>, 되 고 다음 두 번째 소멸 <ph id="ph3">`ManagedClass`</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The attempt to retrieve the second <ph id="ph1">`ManagedClass`</ph> object from the <ph id="ph2">&lt;xref:System.WeakReference.Target%2A&gt;</ph> property indicates that no references to the object remain.</source>
          <target state="translated">두 번째를 가져오려는 시도가 <ph id="ph1">`ManagedClass`</ph> 에서 개체는 <ph id="ph2">&lt;xref:System.WeakReference.Target%2A&gt;</ph> 속성 개체에 대 한 참조가 남아 있는지 나타냅니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Instances of the <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> class are thread safe.</source>
          <target state="translated">인스턴스는 <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> 클래스는 스레드로부터 안전 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>They do not require callers to do any additional locking.</source>
          <target state="translated">호출자에 게 추가 잠금을 작업을 수행 하는 필요 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A&gt;</ph> constructor instantiates an empty <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table; that is, the table contains no key/value pairs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A&gt;</ph> 생성자는 빈 인스턴스화합니다 <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블, 테이블 키/값 쌍을 포함 하는, 즉 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>You can add key/value pairs by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> method.</source>
          <target state="translated">호출 하 여 키/값 쌍을 추가할 수는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>, 또는 <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> object must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 개체 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method returns <ph id="ph2">`true`</ph>).</source>
          <target state="translated">키는 같은 개체를 참조 하는 경우 고유 하지 않습니다 (즉,에 인수로 전달 하는 경우는 <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드 반환 <ph id="ph2">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The key to add.</source>
          <target state="translated">추가할 키입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> represents the object to which the property is attached.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>키<ept id="p1">&lt;/c&gt;</ept>는 속성이 연결된 개체를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The key's property value.</source>
          <target state="translated">키의 속성 값입니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>Adds a key to the table.</source>
          <target state="translated">테이블에 키를 추가합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> object must be unique.</source>
          <target state="translated">모든 키에는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 개체 고유 해야 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method returns <ph id="ph2">`true`</ph>).</source>
          <target state="translated">키는 같은 개체를 참조 하는 경우 고유 하지 않습니다 (즉,에 인수로 전달 하는 경우는 <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> 메서드 반환 <ph id="ph2">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</source>
          <target state="translated">키가 추가 작업 하는 동안 가비지 수집을 기본 키/값 쌍 제거 되 고 예외가 throw 하지 않고 새로운 키/값 쌍 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`MainClass`</ph> 클래스 및 <ph id="ph2">`MainInfo`</ph> 클래스에 대 한 정보를 제공 하는 <ph id="ph3">`MainClass`</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> method to add a <ph id="ph2">`MainClass`</ph> object and its attached <ph id="ph3">`MainInfo`</ph> object to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">이 예에서는 다음 호출에서 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> 메서드를 추가 하려면는 <ph id="ph2">`MainClass`</ph> 개체 및 해당 연결 된 <ph id="ph3">`MainInfo`</ph> 개체를 <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The example also illustrates calls to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> methods to add key/value pairs to the table, and to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to retrieve the value of an existing key.</source>
          <target state="translated">예제에 대 한 호출 또한는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> 및 테이블에 키/값 쌍을 추가 하는 메서드는 <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> 기존 키의 값을 검색 하는 메서드.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> already exists.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>이(가) 이미 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> object.</source>
          <target state="translated">가비지 수집기에서 <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> 개체를 회수할 때 리소스가 해제되고 다른 정리 작업이 수행되도록 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A&gt;</ph> when the current object is ready to be finalized.</source>
          <target state="translated">가비지 컬렉션이 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A&gt;</ph> 현재 개체를 종료 될 경우.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The key to search for.</source>
          <target state="translated">검색할 키입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> represents the object to which the property is attached.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>키<ept id="p1">&lt;/c&gt;</ept>는 속성이 연결된 개체를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>Atomically searches for a specified key in the table and returns the corresponding value.</source>
          <target state="translated">테이블에서 지정된 키를 각각 검색하여 해당 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key.</source>
          <target state="translated">테이블에 키가 없는 경우 테이블의 값을 나타내는 클래스의 기본 생성자를 메서드가 호출하여 지정된 키에 바인딩된 값을 만듭니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The value that corresponds to <ph id="ph1">&lt;paramref name="key" /&gt;</ph>, if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the <ph id="ph3">&lt;paramref name="TValue" /&gt;</ph> generic type parameter.</source>
          <target state="translated">테이블에 이미 <ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 있으면 <ph id="ph2">&lt;paramref name="key" /&gt;</ph>에 해당하는 값이고, 그렇지 않으면 <ph id="ph3">&lt;paramref name="TValue" /&gt;</ph> 제네릭 형식 매개 변수에 의해 정의된 클래스의 기본 생성자가 만든 새 값입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If <ph id="ph1">`key`</ph> does not exist in the table, the method adds it, along with the object that is instantiated by calling the default constructor of the class defined by the <ph id="ph2">`TValue`</ph> generic type parameter.</source>
          <target state="translated">경우 <ph id="ph1">`key`</ph> 존재 하지 않는 테이블에 메서드 추가, 의해 정의 된 클래스의 기본 생성자를 호출 하 여 인스턴스화된 개체와 함께 <ph id="ph2">`TValue`</ph> 제네릭 형식 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If the <ph id="ph1">`TValue`</ph> class has no default constructor, a <ph id="ph2">&lt;xref:System.MissingMethodException&gt;</ph> is thrown.</source>
          <target state="translated">경우는 <ph id="ph1">`TValue`</ph> 클래스에 기본 생성자는 <ph id="ph2">&lt;xref:System.MissingMethodException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>This is the recommended method of retrieving an existing value or adding a new value to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table if the class of the table's value defines a default constructor.</source>
          <target state="translated">이 권장된 방법에 새 값을 추가 하거나 기존 값을 검색할입니다는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블의 값 클래스는 기본 생성자를 정의 하는 경우 테이블입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If it does not define a default constructor, you can instead call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> method, which relies on a callback-provided method to instantiate the object representing the table's value</source>
          <target state="translated">대신 호출 수를 기본 생성자를 정의 하지는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> 테이블의 값을 나타내는 개체를 인스턴스화하는 콜백 제공 된 메서드를 사용 하는 메서드</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method.</source>
          <target state="translated">키/값 쌍의 키가 테이블에서 찾을 수 없는 경우 호출을 추가 하지 않고 기존 키의 값을 검색 하는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`MainClass`</ph> 클래스 및 <ph id="ph2">`MainInfo`</ph> 클래스에 대 한 정보를 제공 하는 <ph id="ph3">`MainClass`</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> method to add a <ph id="ph2">`MainClass`</ph> object and its attached <ph id="ph3">`MainInfo`</ph> object to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">예제에서는 호출은 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> 를 추가 하려면 메서드는 <ph id="ph2">`MainClass`</ph> 개체 및 해당 연결 된 <ph id="ph3">`MainInfo`</ph> 개체를 <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The example also illustrates calls to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> methods to add key/value pairs to the table, and to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to retrieve the value of an existing key.</source>
          <target state="translated">예제에 대 한 호출 또한는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> 및 테이블에 키/값 쌍을 추가 하는 메서드는 <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> 기존 키의 값을 검색 하는 메서드.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MissingMemberException" /&gt;</ph>, instead.</source>
          <target state="translated"><bpt id="p1">[</bpt>Windows 스토어 앱용 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 또는 <bpt id="p2">[</bpt>이식 가능한 클래스 라이브러리<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>에서 대신 기본 클래스 예외 <ph id="ph1">&lt;see cref="T:System.MissingMemberException" /&gt;</ph>을 catch합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The class that represents the table's value does not define a default constructor.</source>
          <target state="translated">테이블 값을 나타내는 클래스가 기본 생성자를 정의하지 않는 경우</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The key to search for.</source>
          <target state="translated">검색할 키입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> represents the object to which the property is attached.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>키<ept id="p1">&lt;/c&gt;</ept>는 속성이 연결된 개체를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>A delegate to a method that can create a value for the given <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">지정된 <bpt id="p1">&lt;c&gt;</bpt>키<ept id="p1">&lt;/c&gt;</ept>에 대한 값을 만들 수 있는 메서드에 대한 대리자입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>It has a single parameter of type <bpt id="p1">&lt;c&gt;</bpt>TKey<ept id="p1">&lt;/c&gt;</ept>, and returns a value of type <bpt id="p2">&lt;c&gt;</bpt>TValue<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>TKey<ept id="p1">&lt;/c&gt;</ept> 형식의 단일 매개 변수가 있으며 <bpt id="p2">&lt;c&gt;</bpt>TValue<ept id="p2">&lt;/c&gt;</ept> 형식의 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Atomically searches for a specified key in the table and returns the corresponding value.</source>
          <target state="translated">테이블에서 지정된 키를 각각 검색하여 해당 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</source>
          <target state="translated">테이블에 키가 없는 경우 메서드가 콜백 메서드를 호출하여 지정된 키에 바인딩된 값을 만듭니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The value attached to <ph id="ph1">&lt;paramref name="key" /&gt;</ph>, if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> already exists in the table; otherwise, the new value returned by the <ph id="ph3">&lt;paramref name="createValueCallback" /&gt;</ph> delegate.</source>
          <target state="translated">테이블에 이미 <ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 있으면 <ph id="ph2">&lt;paramref name="key" /&gt;</ph>에 연결된 값이고, 그렇지 않으면 <ph id="ph3">&lt;paramref name="createValueCallback" /&gt;</ph> 대리자가 반환하는 새 값입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If <ph id="ph1">`key`</ph> does not exist in the table, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> invokes the method that is defined by the <ph id="ph3">`createValueCallback`</ph> parameter and passes it the key.</source>
          <target state="translated">경우 <ph id="ph1">`key`</ph> 는 테이블에 존재 하지 않는 <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> 에서 정의한 메서드를 호출 하는 <ph id="ph3">`createValueCallback`</ph> 매개 변수 키를 전달 하 고 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>A new value is bound to the key in the table and returned as a result.</source>
          <target state="translated">새 값을 테이블의 키에 바인딩되고이 결과로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Use this method only when the class that represents the table's value does not define a default constructor.</source>
          <target state="translated">테이블의 값을 나타내는 클래스를 기본 생성자를 정의 하지 않는 경우에이 방법을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If it does define a default constructor, use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> method instead.</source>
          <target state="translated">기본 생성자를 정의 사용 하 여는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> 메서드 대신 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method.</source>
          <target state="translated">키/값 쌍의 키가 테이블에서 찾을 수 없는 경우 호출을 추가 하지 않고 기존 키의 값을 검색 하는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If multiple threads try to create the same key, <ph id="ph1">`createValueCallback`</ph> may be invoked multiple times with the same key.</source>
          <target state="translated">여러 스레드에서 동일한 키를 만들려고 <ph id="ph1">`createValueCallback`</ph> 같은 키로 여러 번 호출 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Only one of these calls will succeed, and its returned value will be added to the table.</source>
          <target state="translated">이러한 호출 중 하나에만 성공 하 고 반환 된 값을 테이블에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Which thread succeeds in creating the value is indeterminate.</source>
          <target state="translated">스레드 값을 만드는 데 성공 결정 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>This rule permits the table to invoke <ph id="ph1">`createValueCallback`</ph> outside the internal table lock to prevent deadlocks.</source>
          <target state="translated">이 규칙은을 호출 하도록 허용 <ph id="ph1">`createValueCallback`</ph> 교착 상태를 방지 하기 위해 내부 테이블 잠금 외부입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`MainClass`</ph> 클래스 및 <ph id="ph2">`MainInfo`</ph> 클래스에 대 한 정보를 제공 하는 <ph id="ph3">`MainClass`</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>It also defines a static (<ph id="ph1">`Shared`</ph> in Visual Basic) <ph id="ph2">`CreateAttachedValue`</ph> method that can be assigned to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback&gt;</ph> delegate and passed to the <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> method.</source>
          <target state="translated">또한 정적 정의 (<ph id="ph1">`Shared`</ph> Visual Basic의) <ph id="ph2">`CreateAttachedValue`</ph> 에 지정할 수 있는 메서드는 <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback&gt;</ph> 대리자를 전달는 <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> method to add a <ph id="ph2">`MainClass`</ph> object and its attached <ph id="ph3">`MainInfo`</ph> object to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">예제에서는 호출은 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> 를 추가 하려면 메서드는 <ph id="ph2">`MainClass`</ph> 개체 및 해당 연결 된 <ph id="ph3">`MainInfo`</ph> 개체를 <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The example also illustrates calls to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> methods to add key/value pairs to the table, and to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to retrieve the value of an existing key.</source>
          <target state="translated">예제에 대 한 호출 또한는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> 및 테이블에 키/값 쌍을 추가 하는 메서드는 <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> 기존 키의 값을 검색 하는 메서드.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> or <ph id="ph2">&lt;paramref name="createValueCallback" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="createValueCallback" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>The key to remove.</source>
          <target state="translated">제거할 키입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>Removes a key and its value from the table.</source>
          <target state="translated">테이블에서 키와 해당 값을 제거합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the key is found and removed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">키를 찾아서 제거하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</source>
          <target state="translated">이 작업 동안 키가 가비지 수집을 메서드가 예외를 발생 시 키 지 않습니다 및 반환 값이 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>The key that represents an object with an attached property.</source>
          <target state="translated">연결된 속성이 있는 개체를 나타내는 키입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>When this method returns, contains the attached property value.</source>
          <target state="translated">이 메서드가 반환될 때 연결된 속성 값을 포함합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> is not found, <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> contains the default value.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>키<ept id="p1">&lt;/c&gt;</ept>를 찾을 수 없으면 <bpt id="p2">&lt;c&gt;</bpt>값<ept id="p2">&lt;/c&gt;</ept>에 기본값이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>Gets the value of the specified key.</source>
          <target state="translated">지정된 키의 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> is found; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="key" /&gt;</ph>가 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>If the key is garbage-collected during this operation, the method may return <ph id="ph1">`false`</ph> and set <ph id="ph2">`value`</ph> to the default value (as if the key were not present).</source>
          <target state="translated">메서드를 반환할 수 있습니다 하는 경우 키를 하는 가비지 수집 동안이 작업 <ph id="ph1">`false`</ph> 설정 <ph id="ph2">`value`</ph> 기본값으로 (경우 값의 키가 존재 하지 않는).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">다음 예제에서는 정의 <ph id="ph1">`MainClass`</ph> 클래스 및 <ph id="ph2">`MainInfo`</ph> 클래스에 대 한 정보를 제공 하는 <ph id="ph3">`MainClass`</ph> 인스턴스.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> methods to add key/value pairs to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">예제에서는 호출은 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> 키/값 쌍을 추가 하는 메서드는 <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> 테이블입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>In each case, the example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to confirm that the key/value pair has been added to the table.</source>
          <target state="translated">이 예에서는 호출 각각의 경우에는 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> 메서드를 키/값 쌍이 테이블에 추가 되었는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>