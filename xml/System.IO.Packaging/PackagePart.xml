<Type Name="PackagePart" FullName="System.IO.Packaging.PackagePart">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="154c70fa5276cdccac41f7e7f56b00b2e5fd1bb9" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33682761" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PackagePart" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PackagePart extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.PackagePart" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PackagePart" />
  <TypeSignature Language="C++ CLI" Value="public ref class PackagePart abstract" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.IO.Packaging.Package" />에 저장되는 파트에 대한 기본 클래스를 제공합니다.  이 클래스는 추상 클래스입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Packaging.PackagePart> 세 가지 기본 요소로 구성 됩니다.  
  
|액세스|설명|  
|------------|-----------------|  
|<xref:System.IO.Packaging.PackagePart.Uri%2A>|[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 부분의 합니다.|  
|<xref:System.IO.Packaging.PackagePart.ContentType%2A>|[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 스트림의 유형입니다.|  
|<xref:System.IO.Packaging.PackagePart.GetStream%2A>|파트의 콘텐츠 데이터 스트림입니다.|  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.IO.Packaging.PackagePart" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [WPF의 Pack URI](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
  
 [열기 패키징 Conventions 사양](http://go.microsoft.com/fwlink/?LinkID=71255)  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="package">파트의 부모 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="partUri">부모 <see cref="T:System.IO.Packaging.Package" /> 루트에 상대적인 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <summary>지정된 부모 <see cref="T:System.IO.Packaging.PackagePart" /> 및 파트 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]를 사용하여 <see cref="P:System.IO.Packaging.PackagePart.Package" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 유효 해야 <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 구성의 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을* 사양 및 [열려 패키징 규칙](http://go.microsoft.com/fwlink/?LinkID=71255) 사양입니다.  
  
 이 생성자를 사용 하 여 때는 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 부분의 즉시 인식 되지 않으며 설정할 나중 때 <xref:System.IO.Packaging.Package.CreatePart%2A> 라고 합니다.  
  
 기본적으로는 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 파트의 속성은 초기화 <xref:System.IO.Packaging.CompressionOption.NotCompressed>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="package" /> 또는 <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="package">파트의 부모 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="partUri">부모 <see cref="T:System.IO.Packaging.Package" /> 루트에 상대적인 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="contentType">파트 데이터 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식입니다.</param>
        <summary>지정된 부모 <see cref="T:System.IO.Packaging.PackagePart" />, 파트 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 및 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식을 사용하여 <see cref="P:System.IO.Packaging.PackagePart.Package" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 유효 해야 <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 구성의 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을* 사양 및 [열려 패키징 규칙](http://go.microsoft.com/fwlink/?LinkID=71255) 사양입니다.  
  
 기본적으로는 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 파트의 속성은 초기화 <xref:System.IO.Packaging.CompressionOption.NotCompressed>합니다.  
  
 `contentType` 이어야 합니다는 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식에 따라 구성의 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-HTTP*, 섹션 3.7 합니다.  다음 표에서 콘텐츠 예를 들어 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 에 사용 되는 형식 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] 문서.  
  
|설명|콘텐츠 형식|  
|-----------------|------------------|  
|글꼴|application/vnd.ms-opentype|  
|ICC 프로필|application/vnd.ms-color.iccprofile|  
|JPEG 이미지|/ jpeg 이미지|  
|애매 한 글꼴|application/vnd.ms-package.obfuscated-opentype|  
|PNG 이미지|이미지/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|TIFF 이미지|tiff image /|  
|Windows 미디어 사진 이미지|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="package" /> 또는 <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="package">파트의 부모 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="partUri">부모 <see cref="T:System.IO.Packaging.Package" /> 루트에 상대적인 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="contentType">파트 데이터 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식입니다.</param>
        <param name="compressionOption">파트 데이터 스트림의 압축 옵션입니다.</param>
        <summary>지정된 부모 <see cref="T:System.IO.Packaging.PackagePart" />, 파트 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식 및 <see cref="P:System.IO.Packaging.PackagePart.Package" />을 사용하여 <see cref="T:System.IO.Packaging.CompressionOption" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 유효 해야 <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 구성의 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을* 사양 및 [열려 패키징 규칙](http://go.microsoft.com/fwlink/?LinkID=71255) 사양입니다.  
  
 `contentType` 이어야 합니다는 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식에 따라 구성의 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-HTTP*, 섹션 3.7 합니다.  다음 표에서 콘텐츠 예를 들어 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 에 사용 되는 형식 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] 문서.  
  
|설명|콘텐츠 형식|  
|-----------------|------------------|  
|글꼴|application/vnd.ms-opentype|  
|ICC 프로필|application/vnd.ms-color.iccprofile|  
|JPEG 이미지|/ jpeg 이미지|  
|애매 한 글꼴|application/vnd.ms-package.obfuscated-opentype|  
|PNG 이미지|이미지/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|TIFF 이미지|tiff image /|  
|Windows 미디어 사진 이미지|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="package" /> 또는 <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="compressionOption" /> 값이 올바르지 않은 경우</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="CompressionOption">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.CompressionOption CompressionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Packaging.CompressionOption CompressionOption" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompressionOption As CompressionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::CompressionOption CompressionOption { System::IO::Packaging::CompressionOption get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.CompressionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파트 콘텐츠 스트림의 압축 옵션을 가져옵니다.</summary>
        <value>파트 콘텐츠 스트림의 압축 옵션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  생성자에 의해 설정 된 후의 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식을 가져옵니다.</summary>
        <value>파트에 대한 콘텐츠 데이터 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  생성자에 의해 설정 된 후의 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 변경할 수 없습니다.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 속성은 한 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식에 따라 구성의 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-HTTP*, 섹션 3.7 합니다.  다음 표에서 콘텐츠 예를 들어 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 에 사용 되는 형식 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] 문서.  
  
|설명|콘텐츠 형식|  
|-----------------|------------------|  
|글꼴|application/vnd.ms-opentype|  
|ICC 프로필|application/vnd.ms-color.iccprofile|  
|JPEG 이미지|/ jpeg 이미지|  
|애매 한 글꼴|application/vnd.ms-package.obfuscated-opentype|  
|PNG 이미지|이미지/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|TIFF 이미지|tiff image /|  
|Windows 미디어 사진 이미지|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)  
  
 또는  
  
 파생 클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> 메서드에서 반환한 문자열이 비어 있는 경우</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 <see cref="T:System.IO.Packaging.PackagePart" />와 지정된 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파트 수준 관계가이 일부 대상 파트 또는 리소스 간의 연결을 정의 합니다.  파트 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   간의 <xref:System.IO.Packaging.PackagePart> 대상 <xref:System.IO.Packaging.PackagePart> 내는 <xref:System.IO.Packaging.Package>합니다.  
  
-   간의 <xref:System.IO.Packaging.PackagePart> 패키지 외부의 대상 리소스입니다.  
  
 파트 관계 소스 파트 관계의 "소유자"로 간주 됩니다.  소스 파트를 삭제 하면 부분이 소유 하는 모든 관계도 삭제 됩니다.  대상 파트나 리소스 어떤 방식으로든에서 만들거나 관계 삭제 프로세스 물리적으로 변경 하지 않습니다.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> 메서드 소스 파트 또는 대상 파트 또는 리소스에 어떤 방식으로 물리적으로 변경 하지 않습니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 패키지 관계에 대 한 자세한 내용은 1.3의 섹션을 참조 하십시오.는 *열려 패키징 규칙 (OPC)* 사양에서 다운로드할 수 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 XPS에 대 한 자세한 내용은 문서에 대 한는 *Open XPS XML Paper Specification ()* 에서 다운로드할 수 [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">열거형 값 중 하나입니다. 예를 들어 대상 파트가 <see cref="F:System.IO.Packaging.TargetMode.Internal" /> 내부에 있으면 <see cref="T:System.IO.Packaging.Package" />이고, 대상이 <see cref="F:System.IO.Packaging.TargetMode.External" /> 외부의 리소스이면 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="relationshipType">관계의 역할입니다.</param>
        <summary>이 <see cref="T:System.IO.Packaging.PackagePart" />와 지정된 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계를 만듭니다.</summary>
        <returns>이 <see cref="T:System.IO.Packaging.PackagePart" />와 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파트 수준 관계가이 일부 대상 파트 또는 리소스 간의 연결을 정의 합니다.  파트 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   간의 <xref:System.IO.Packaging.PackagePart> 대상 <xref:System.IO.Packaging.PackagePart> 내는 <xref:System.IO.Packaging.Package>합니다.  
  
-   간의 <xref:System.IO.Packaging.PackagePart> 패키지 외부의 대상 리소스입니다.  
  
 파트 관계 소스 파트 관계의 "소유자"로 간주 됩니다.  소스 파트를 삭제 하면 부분이 소유 하는 모든 관계도 삭제 됩니다.  대상 파트나 리소스 어떤 방식으로든에서 만들거나 관계 삭제 프로세스 물리적으로 변경 하지 않습니다.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> 메서드 소스 파트 또는 대상 파트 또는 리소스에 어떤 방식으로 물리적으로 변경 하지 않습니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을* 사양입니다.  내부 상대 URI 수는 절대 경로일 수로 시작 하는 슬래시 ("/") 문자와 같은 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")로 기본 URI를 확인 합니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 에 따라 만든 상대 URI 또는 절대 두 수의 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을*사양입니다.  "http://www.microsoft.com/page2.xml"는 대상 외부 리소스 "page2.xml"를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"는는 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해를 참조 하는 상대 URI의 예시입니다.  
  
 `relationshipType` 있어야는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형식이 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을* 사양입니다.  다른 패키지 형식은 다른 파트 수준 관계 유형을 정의할 수 있습니다.  다음 표에 나와 파트 수준 `relationshipType` 준수 하는 문서에 대해 정의 된 Uri는 *Open XPS XML Paper Specification ()* 합니다.  
  
|XPS 문서 파트 수준 관계|관계 유형 URI|  
|-------------------------------------------|---------------------------|  
|디지털 서명 정의|[http://schemas.microsoft.com/xps/2005/06/signature-definitions](http://schemas.microsoft.com/xps/2005/06/signature-definitions)|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|필요한 리소스|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|제한 된 글꼴|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 패키지 관계에 대 한 자세한 내용은 1.3의 섹션을 참조 하십시오.는 *열려 패키징 규칙 (OPC)* 사양에서 다운로드할 수 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 XPS에 대 한 자세한 내용은 문서에 대 한는 *Open XPS XML Paper Specification ()* 에서 다운로드할 수 [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="targetMode" /> 매개 변수가 유효한 <see cref="T:System.IO.Packaging.TargetMode" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetUri" />로 식별된 파트가 관계인 경우. 관계의 대상은 다른 관계가 될 수 없습니다.  
  
 또는  
  
 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />로 지정되었지만 <paramref name="targetUri" />가 절대적인 외부 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 관계를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">열거형 값 중 하나입니다. 예를 들어 대상 파트가 <see cref="F:System.IO.Packaging.TargetMode.Internal" /> 내부에 있으면 <see cref="T:System.IO.Packaging.Package" />이고, 대상이 <see cref="F:System.IO.Packaging.TargetMode.External" /> 외부의 리소스이면 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="relationshipType">관계의 역할입니다.</param>
        <param name="id">관계의 고유 ID입니다.</param>
        <summary>이 <see cref="T:System.IO.Packaging.PackagePart" />와 지정된 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계를 만듭니다.</summary>
        <returns>이 <see cref="T:System.IO.Packaging.PackagePart" />와 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파트 수준 관계가이 일부 대상 파트 또는 리소스 간의 연결을 정의 합니다.  파트 수준 관계는 다음 두 형식 중 하나일 수 있습니다.  
  
-   간의 <xref:System.IO.Packaging.PackagePart> 대상 <xref:System.IO.Packaging.PackagePart> 내는 <xref:System.IO.Packaging.Package>합니다.  
  
-   간의 <xref:System.IO.Packaging.PackagePart> 패키지 외부의 대상 리소스입니다.  
  
 파트 관계 소스 파트 관계의 "소유자"로 간주 됩니다.  소스 파트를 삭제 하면 부분이 소유 하는 모든 관계도 삭제 됩니다.  대상 파트나 리소스 어떤 방식으로든에서 만들거나 관계 삭제 프로세스 물리적으로 변경 하지 않습니다.  
  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며에 설명 된 명명 규칙을 따라야는 *XML 스키마 2 부: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> 메서드 소스 파트 또는 대상 파트 또는 리소스에 어떤 방식으로 물리적으로 변경 하지 않습니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 이어야 합니다는 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을* 사양입니다.  내부 상대 URI 수는 절대 경로일 수로 시작 하는 슬래시 ("/") 문자와 같은 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")로 기본 URI를 확인 합니다.  
  
 경우 `targetMode` 로 지정 된 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 에 따라 만든 상대 URI 또는 절대 두 수의 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을*사양입니다.  "http://www.microsoft.com/page2.xml"는 대상 외부 리소스 "page2.xml"를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"는는 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해를 참조 하는 상대 URI의 예시입니다.  
  
 `relationshipType` 있어야는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형식이 [RFC 3986](http://tools.ietf.org/html/rfc3986) *식별자 URI (Uniform Resource) 일반 구문을* 사양입니다.  다른 패키지 형식은 다른 파트 수준 관계 유형을 정의할 수 있습니다.  다음 표에 나와 파트 수준 `relationshipType` 준수 하는 문서에 대해 정의 된 Uri는 *Open XPS XML Paper Specification ()* 합니다.  
  
|XPS 문서 파트 수준 관계|관계 유형 URI|  
|-------------------------------------------|---------------------------|  
|디지털 서명 정의|http://schemas.microsoft.com/xps/2005/06/signature-definitions|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|필요한 리소스|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|제한 된 글꼴|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 패키지 관계에 대 한 자세한 내용은 1.3의 섹션을 참조 하십시오.는 *열려 패키징 규칙 (OPC)* 사양에서 다운로드할 수 [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255)합니다.  
  
 XPS에 대 한 자세한 내용은 문서에 대 한는 *Open XPS XML Paper Specification ()* 에서 다운로드할 수 [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="targetMode" /> 매개 변수가 유효한 <see cref="T:System.IO.Packaging.TargetMode" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetUri" />로 식별된 파트가 관계인 경우. 관계의 대상은 다른 관계가 될 수 없습니다.  
  
 또는  
  
 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />로 지정되었지만 <paramref name="targetUri" />가 절대적인 외부 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 관계를 추가할 수 없습니다.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아닌 경우  
  
 또는  
  
 지정된 <paramref name="id" />의 파트가 이미 있는 경우</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">삭제할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 파트 수준 <see cref="T:System.IO.Packaging.PackageRelationship" />을 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며에 설명 된 명명 규칙을 따라야는 *XML 스키마 2 부: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 하는 경우 지정 된 `id` 와 일치 하지 않습니다는 <xref:System.IO.Packaging.PackageRelationship.Id%2A> 이 부분이 소유 하는 관계의 모든에 대해 어떠한 관계도 삭제 되 고 예외가 throw 되지 않습니다.  
  
 지정된 된 관계를 삭제할는 <xref:System.IO.Packaging.PackagePart.DeleteRelationship%2A> 이 파트 또는 대상 메서드가 실제로 변경 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 관계를 삭제할 수 없습니다.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetContentTypeCore">
      <MemberSignature Language="C#" Value="protected virtual string GetContentTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetContentTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContentTypeCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetContentTypeCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 파트 콘텐츠의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식을 반환합니다.</summary>
        <returns>파트 콘텐츠의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> 메서드는 가상 메서드이며는 <xref:System.IO.Packaging.PackagePart> 추상 기본 클래스입니다. 파생된 형식, 작성 시간에 콘텐츠 형식에 대 한 값 없습니다 제공 하는 경우에이 메서드를 구현 하거나 콘텐츠 형식 값은 nontrivial 또는 비용이 많이 드는 작업 합니다. 반환 값은 올바른 이어야 합니다 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식입니다.  
  
 파생된 클래스를 호출할 수 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> 초기화 하는 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 기본값에 파생된 클래스의 속성입니다.  후의 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 속성이 설정 되어이 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">파생 클래스는 <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> 메서드에 필요한 재정의 구현을 제공하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">반환할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />의 관계를 반환합니다.</summary>
        <returns>지정된 <paramref name="id" />와 일치하는 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며에 설명 된 명명 규칙을 따라야는 *XML 스키마 2 부: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 사용할 수는 <xref:System.IO.Packaging.PackagePart.RelationshipExists%2A> 메서드를 지정 된 관계를 확인 하려면 <xref:System.IO.Packaging.PackageRelationship.Id%2A> 이 부분이 소유 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)  
  
 또는  
  
 지정된 <paramref name="id" />의 관계가 패키지에 없는 경우</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 파트에서 소유한 모든 관계의 컬렉션을 반환합니다.</summary>
        <returns>이 파트에서 소유한 모든 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 컬렉션은 `null`있지만 부품 관계를 정의 하지 않는 경우 컬렉션 요소가 포함 될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">컬렉션에서 찾아서 반환할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />과 일치하는 관계의 컬렉션을 반환합니다.</summary>
        <returns>지정된 <paramref name="relationshipType" />과 일치하는 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 컬렉션은 `null`소비량이 적어지지만 관계가 없으면 지정 된 일치 하는 경우 컬렉션 요소가 포함 될 수 있습니다 `relationshipType` 파트에 대해 정의 된 합니다.  
  
 선행 또는 후행 공백은 `relationshipType` 문자열 자동으로 제거 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파트 콘텐츠 데이터 스트림을 반환합니다.</summary>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
 기본적으로는 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 하위 클래스는 추상 구현의 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 열고 파트 데이터 스트림의 ZIP 파일에서 반환 하는 클래스입니다.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파트 콘텐츠 데이터 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 데이터 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 콘텐츠 스트림을 엽니다 <xref:System.IO.FileMode> 의 <xref:System.IO.FileMode.OpenOrCreate> 및 <xref:System.IO.FileAccess> 부모와 동일 하 게 사용 권한을 <xref:System.IO.Packaging.Package>합니다.  
  
 오버 로드 <xref:System.IO.Packaging.PackagePart.GetStream%2A> 메서드를 사용 하면 특정을 설정할 수 있습니다 <xref:System.IO.FileMode>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">파생된 서브클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드에서 반환한 스트림 개체가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
 기본적으로는 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 하위 클래스는 추상 구현의 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 열고 파트 데이터 스트림의 ZIP 파일에서 반환 하는 클래스입니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">콘텐츠 스트림을 열 I/O 모드입니다.</param>
        <summary>지정된 I/O <see cref="T:System.IO.FileMode" />에서 열린 콘텐츠 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileAccess> 반환 된 콘텐츠 스트림의 권한은 부모 권한과 동일 <xref:System.IO.Packaging.Package>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 매개 변수가 유효한 <see cref="T:System.IO.FileMode" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> 매개 변수가 패키지 및 파트 스트림과 호환되지 않는 경우  
  
 또는  
  
 파생된 서브클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드에서 반환한 스트림 개체가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
 기본적으로는 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 하위 클래스는 추상 구현의 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 열고 파트 데이터 스트림의 ZIP 파일에서 반환 하는 클래스입니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">콘텐츠 스트림을 열 I/O 모드입니다.</param>
        <param name="access">콘텐츠 스트림을 열 때 사용하는 액세스 권한입니다.</param>
        <summary>지정된 <see cref="T:System.IO.FileMode" /> 및 <see cref="T:System.IO.FileAccess" />로 열린 파트 콘텐츠 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 스트림입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 매개 변수가 유효한 <see cref="T:System.IO.FileMode" /> 열거형 값이 아닌 경우  
  
 또는  
  
 <paramref name="access" /> 매개 변수가 유효한 <see cref="T:System.IO.FileAccess" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> 또는 <paramref name="access" />가 패키지 및 파트 스트림과 호환되지 않는 경우  
  
 또는  
  
 <paramref name="access" /> 매개 변수가 <see cref="F:System.IO.FileAccess.Read" />로 지정되었지만 <paramref name="mode" /> 매개 변수에서 쓰기 권한을 필요로 하는 경우.  <see cref="T:System.IO.FileMode" />, <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, 그리고 <see cref="F:System.IO.FileMode.Truncate" />의 <see cref="F:System.IO.FileMode.Append" /> 값에는 <see cref="F:System.IO.FileAccess.Write" /> 또는 <see cref="F:System.IO.FileAccess.ReadWrite" /> 액세스가 필요합니다.  
  
 또는  
  
 파생된 서브클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드에서 반환한 스트림 개체가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 방법을 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
 기본적으로는 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 하위 클래스는 추상 구현의 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 열고 파트 데이터 스트림의 ZIP 파일에서 반환 하는 클래스입니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStreamCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Stream GetStreamCore (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Stream GetStreamCore(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetStreamCore (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Stream ^ GetStreamCore(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">콘텐츠 스트림을 열 I/O 모드입니다.</param>
        <param name="access">콘텐츠 스트림을 열 때 사용하는 액세스 권한입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 <see cref="T:System.IO.FileMode" /> 및 <see cref="T:System.IO.FileAccess" />로 열린 파트 콘텐츠 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 데이터 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램을 호출 하지 않아야 <xref:System.IO.Packaging.PackagePart.GetStreamCore%2A> 를 직접은 <xref:System.IO.Packaging.PackagePart.GetStream%2A>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 확인 해야는 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 메서드를 호출 합니다.</para>
        </block>
        <block subset="none" type="usage">
          <para>파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드는 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 열고 파트 데이터 스트림의 반환 하는 메서드를 파생된 클래스에서 구현 하는 실제 형식에 기반 합니다.  
  
 기본적으로는 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 하위 클래스는 추상 구현의 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 동작에서 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 열고 파트 데이터 스트림의 ZIP 파일에서 반환 하는 클래스입니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.Package Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.Package Package" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::Package ^ Package { System::IO::Packaging::Package ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파트의 부모 <see cref="T:System.IO.Packaging.Package" />를 가져옵니다.</summary>
        <value>파트의 부모 패키지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Package%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.Package%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  부모 생성자에 의해 설정 된 후 <xref:System.IO.Packaging.PackagePart.Package%2A> 부분을 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">확인할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />의 관계를 이 파트가 소유하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          지정된 <paramref name="id" />의 관계를 이 파트가 소유하는 경우에는 <see langword="true" />이고 그렇지 않은 경우에는 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 유효한 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며에 설명 된 명명 규칙을 따라야는 *XML 스키마 2 부: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Uri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Uri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Uri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]를 가져옵니다.</summary>
        <value>[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 패키지 루트에 상대적인 부분의 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  생성자에 의해 설정 된 후의 <xref:System.IO.Packaging.PackagePart.Uri%2A> 파트의 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
 또는  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ComparePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>